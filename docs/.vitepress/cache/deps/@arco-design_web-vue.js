import {
  Comment,
  Fragment,
  Teleport,
  Transition,
  TransitionGroup,
  cloneVNode,
  computed,
  createApp,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createSlots,
  createStaticVNode,
  createTextVNode,
  createVNode,
  defineComponent,
  getCurrentInstance,
  guardReactiveProps,
  h,
  inject,
  isRef,
  isVNode,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  onBeforeUnmount,
  onDeactivated,
  onMounted,
  onUnmounted,
  onUpdated,
  openBlock,
  provide,
  reactive,
  readonly,
  ref,
  render,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDynamicComponent,
  toDisplayString,
  toRef,
  toRefs,
  vShow,
  watch,
  watchEffect,
  withCtx,
  withDirectives,
  withKeys,
  withModifiers
} from "./chunk-V634PGSD.js";
import {
  __commonJS,
  __toESM
} from "./chunk-UXIASGQL.js";

// node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS({
  "node_modules/dayjs/dayjs.min.js"(exports, module) {
    !function(t2, e2) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = e2() : "function" == typeof define && define.amd ? define(e2) : (t2 = "undefined" != typeof globalThis ? globalThis : t2 || self).dayjs = e2();
    }(exports, function() {
      "use strict";
      var t2 = 1e3, e2 = 6e4, n2 = 36e5, r2 = "millisecond", i2 = "second", s = "minute", u = "hour", a = "day", o = "week", c = "month", f = "quarter", h2 = "year", d = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
        var e3 = ["th", "st", "nd", "rd"], n3 = t3 % 100;
        return "[" + t3 + (e3[(n3 - 20) % 10] || e3[n3] || e3[0]) + "]";
      } }, m = function(t3, e3, n3) {
        var r3 = String(t3);
        return !r3 || r3.length >= e3 ? t3 : "" + Array(e3 + 1 - r3.length).join(n3) + t3;
      }, v = { s: m, z: function(t3) {
        var e3 = -t3.utcOffset(), n3 = Math.abs(e3), r3 = Math.floor(n3 / 60), i3 = n3 % 60;
        return (e3 <= 0 ? "+" : "-") + m(r3, 2, "0") + ":" + m(i3, 2, "0");
      }, m: function t3(e3, n3) {
        if (e3.date() < n3.date())
          return -t3(n3, e3);
        var r3 = 12 * (n3.year() - e3.year()) + (n3.month() - e3.month()), i3 = e3.clone().add(r3, c), s2 = n3 - i3 < 0, u2 = e3.clone().add(r3 + (s2 ? -1 : 1), c);
        return +(-(r3 + (n3 - i3) / (s2 ? i3 - u2 : u2 - i3)) || 0);
      }, a: function(t3) {
        return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
      }, p: function(t3) {
        return { M: c, y: h2, w: o, d: a, D: d, h: u, m: s, s: i2, ms: r2, Q: f }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t3) {
        return void 0 === t3;
      } }, g = "en", D = {};
      D[g] = M;
      var p = function(t3) {
        return t3 instanceof b;
      }, S = function t3(e3, n3, r3) {
        var i3;
        if (!e3)
          return g;
        if ("string" == typeof e3) {
          var s2 = e3.toLowerCase();
          D[s2] && (i3 = s2), n3 && (D[s2] = n3, i3 = s2);
          var u2 = e3.split("-");
          if (!i3 && u2.length > 1)
            return t3(u2[0]);
        } else {
          var a2 = e3.name;
          D[a2] = e3, i3 = a2;
        }
        return !r3 && i3 && (g = i3), i3 || !r3 && g;
      }, w = function(t3, e3) {
        if (p(t3))
          return t3.clone();
        var n3 = "object" == typeof e3 ? e3 : {};
        return n3.date = t3, n3.args = arguments, new b(n3);
      }, O = v;
      O.l = S, O.i = p, O.w = function(t3, e3) {
        return w(t3, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
      };
      var b = function() {
        function M2(t3) {
          this.$L = S(t3.locale, null, true), this.parse(t3);
        }
        var m2 = M2.prototype;
        return m2.parse = function(t3) {
          this.$d = function(t4) {
            var e3 = t4.date, n3 = t4.utc;
            if (null === e3)
              return /* @__PURE__ */ new Date(NaN);
            if (O.u(e3))
              return /* @__PURE__ */ new Date();
            if (e3 instanceof Date)
              return new Date(e3);
            if ("string" == typeof e3 && !/Z$/i.test(e3)) {
              var r3 = e3.match($);
              if (r3) {
                var i3 = r3[2] - 1 || 0, s2 = (r3[7] || "0").substring(0, 3);
                return n3 ? new Date(Date.UTC(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s2)) : new Date(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s2);
              }
            }
            return new Date(e3);
          }(t3), this.$x = t3.x || {}, this.init();
        }, m2.init = function() {
          var t3 = this.$d;
          this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
        }, m2.$utils = function() {
          return O;
        }, m2.isValid = function() {
          return !(this.$d.toString() === l);
        }, m2.isSame = function(t3, e3) {
          var n3 = w(t3);
          return this.startOf(e3) <= n3 && n3 <= this.endOf(e3);
        }, m2.isAfter = function(t3, e3) {
          return w(t3) < this.startOf(e3);
        }, m2.isBefore = function(t3, e3) {
          return this.endOf(e3) < w(t3);
        }, m2.$g = function(t3, e3, n3) {
          return O.u(t3) ? this[e3] : this.set(n3, t3);
        }, m2.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m2.valueOf = function() {
          return this.$d.getTime();
        }, m2.startOf = function(t3, e3) {
          var n3 = this, r3 = !!O.u(e3) || e3, f2 = O.p(t3), l2 = function(t4, e4) {
            var i3 = O.w(n3.$u ? Date.UTC(n3.$y, e4, t4) : new Date(n3.$y, e4, t4), n3);
            return r3 ? i3 : i3.endOf(a);
          }, $2 = function(t4, e4) {
            return O.w(n3.toDate()[t4].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n3);
          }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
          switch (f2) {
            case h2:
              return r3 ? l2(1, 0) : l2(31, 11);
            case c:
              return r3 ? l2(1, M3) : l2(0, M3 + 1);
            case o:
              var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
              return l2(r3 ? m3 - D2 : m3 + (6 - D2), M3);
            case a:
            case d:
              return $2(v2 + "Hours", 0);
            case u:
              return $2(v2 + "Minutes", 1);
            case s:
              return $2(v2 + "Seconds", 2);
            case i2:
              return $2(v2 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m2.endOf = function(t3) {
          return this.startOf(t3, false);
        }, m2.$set = function(t3, e3) {
          var n3, o2 = O.p(t3), f2 = "set" + (this.$u ? "UTC" : ""), l2 = (n3 = {}, n3[a] = f2 + "Date", n3[d] = f2 + "Date", n3[c] = f2 + "Month", n3[h2] = f2 + "FullYear", n3[u] = f2 + "Hours", n3[s] = f2 + "Minutes", n3[i2] = f2 + "Seconds", n3[r2] = f2 + "Milliseconds", n3)[o2], $2 = o2 === a ? this.$D + (e3 - this.$W) : e3;
          if (o2 === c || o2 === h2) {
            var y2 = this.clone().set(d, 1);
            y2.$d[l2]($2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
          } else
            l2 && this.$d[l2]($2);
          return this.init(), this;
        }, m2.set = function(t3, e3) {
          return this.clone().$set(t3, e3);
        }, m2.get = function(t3) {
          return this[O.p(t3)]();
        }, m2.add = function(r3, f2) {
          var d2, l2 = this;
          r3 = Number(r3);
          var $2 = O.p(f2), y2 = function(t3) {
            var e3 = w(l2);
            return O.w(e3.date(e3.date() + Math.round(t3 * r3)), l2);
          };
          if ($2 === c)
            return this.set(c, this.$M + r3);
          if ($2 === h2)
            return this.set(h2, this.$y + r3);
          if ($2 === a)
            return y2(1);
          if ($2 === o)
            return y2(7);
          var M3 = (d2 = {}, d2[s] = e2, d2[u] = n2, d2[i2] = t2, d2)[$2] || 1, m3 = this.$d.getTime() + r3 * M3;
          return O.w(m3, this);
        }, m2.subtract = function(t3, e3) {
          return this.add(-1 * t3, e3);
        }, m2.format = function(t3) {
          var e3 = this, n3 = this.$locale();
          if (!this.isValid())
            return n3.invalidDate || l;
          var r3 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i3 = O.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n3.weekdays, c2 = n3.months, f2 = n3.meridiem, h3 = function(t4, n4, i4, s3) {
            return t4 && (t4[n4] || t4(e3, r3)) || i4[n4].slice(0, s3);
          }, d2 = function(t4) {
            return O.s(s2 % 12 || 12, t4, "0");
          }, $2 = f2 || function(t4, e4, n4) {
            var r4 = t4 < 12 ? "AM" : "PM";
            return n4 ? r4.toLowerCase() : r4;
          };
          return r3.replace(y, function(t4, r4) {
            return r4 || function(t5) {
              switch (t5) {
                case "YY":
                  return String(e3.$y).slice(-2);
                case "YYYY":
                  return O.s(e3.$y, 4, "0");
                case "M":
                  return a2 + 1;
                case "MM":
                  return O.s(a2 + 1, 2, "0");
                case "MMM":
                  return h3(n3.monthsShort, a2, c2, 3);
                case "MMMM":
                  return h3(c2, a2);
                case "D":
                  return e3.$D;
                case "DD":
                  return O.s(e3.$D, 2, "0");
                case "d":
                  return String(e3.$W);
                case "dd":
                  return h3(n3.weekdaysMin, e3.$W, o2, 2);
                case "ddd":
                  return h3(n3.weekdaysShort, e3.$W, o2, 3);
                case "dddd":
                  return o2[e3.$W];
                case "H":
                  return String(s2);
                case "HH":
                  return O.s(s2, 2, "0");
                case "h":
                  return d2(1);
                case "hh":
                  return d2(2);
                case "a":
                  return $2(s2, u2, true);
                case "A":
                  return $2(s2, u2, false);
                case "m":
                  return String(u2);
                case "mm":
                  return O.s(u2, 2, "0");
                case "s":
                  return String(e3.$s);
                case "ss":
                  return O.s(e3.$s, 2, "0");
                case "SSS":
                  return O.s(e3.$ms, 3, "0");
                case "Z":
                  return i3;
              }
              return null;
            }(t4) || i3.replace(":", "");
          });
        }, m2.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m2.diff = function(r3, d2, l2) {
          var $2, y2 = this, M3 = O.p(d2), m3 = w(r3), v2 = (m3.utcOffset() - this.utcOffset()) * e2, g2 = this - m3, D2 = function() {
            return O.m(y2, m3);
          };
          switch (M3) {
            case h2:
              $2 = D2() / 12;
              break;
            case c:
              $2 = D2();
              break;
            case f:
              $2 = D2() / 3;
              break;
            case o:
              $2 = (g2 - v2) / 6048e5;
              break;
            case a:
              $2 = (g2 - v2) / 864e5;
              break;
            case u:
              $2 = g2 / n2;
              break;
            case s:
              $2 = g2 / e2;
              break;
            case i2:
              $2 = g2 / t2;
              break;
            default:
              $2 = g2;
          }
          return l2 ? $2 : O.a($2);
        }, m2.daysInMonth = function() {
          return this.endOf(c).$D;
        }, m2.$locale = function() {
          return D[this.$L];
        }, m2.locale = function(t3, e3) {
          if (!t3)
            return this.$L;
          var n3 = this.clone(), r3 = S(t3, e3, true);
          return r3 && (n3.$L = r3), n3;
        }, m2.clone = function() {
          return O.w(this.$d, this);
        }, m2.toDate = function() {
          return new Date(this.valueOf());
        }, m2.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m2.toISOString = function() {
          return this.$d.toISOString();
        }, m2.toString = function() {
          return this.$d.toUTCString();
        }, M2;
      }(), _ = b.prototype;
      return w.prototype = _, [["$ms", r2], ["$s", i2], ["$m", s], ["$H", u], ["$W", a], ["$M", c], ["$y", h2], ["$D", d]].forEach(function(t3) {
        _[t3[1]] = function(e3) {
          return this.$g(e3, t3[0], t3[1]);
        };
      }), w.extend = function(t3, e3) {
        return t3.$i || (t3(e3, b, w), t3.$i = true), w;
      }, w.locale = S, w.isDayjs = p, w.unix = function(t3) {
        return w(1e3 * t3);
      }, w.en = D[g], w.Ls = D, w.p = {}, w;
    });
  }
});

// node_modules/dayjs/plugin/customParseFormat.js
var require_customParseFormat = __commonJS({
  "node_modules/dayjs/plugin/customParseFormat.js"(exports, module) {
    !function(e2, t2) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = t2() : "function" == typeof define && define.amd ? define(t2) : (e2 = "undefined" != typeof globalThis ? globalThis : e2 || self).dayjs_plugin_customParseFormat = t2();
    }(exports, function() {
      "use strict";
      var e2 = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t2 = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n2 = /\d\d/, r2 = /\d\d?/, i2 = /\d*[^-_:/,()\s\d]+/, o = {}, s = function(e3) {
        return (e3 = +e3) + (e3 > 68 ? 1900 : 2e3);
      };
      var a = function(e3) {
        return function(t3) {
          this[e3] = +t3;
        };
      }, f = [/[+-]\d\d:?(\d\d)?|Z/, function(e3) {
        (this.zone || (this.zone = {})).offset = function(e4) {
          if (!e4)
            return 0;
          if ("Z" === e4)
            return 0;
          var t3 = e4.match(/([+-]|\d\d)/g), n3 = 60 * t3[1] + (+t3[2] || 0);
          return 0 === n3 ? 0 : "+" === t3[0] ? -n3 : n3;
        }(e3);
      }], h2 = function(e3) {
        var t3 = o[e3];
        return t3 && (t3.indexOf ? t3 : t3.s.concat(t3.f));
      }, u = function(e3, t3) {
        var n3, r3 = o.meridiem;
        if (r3) {
          for (var i3 = 1; i3 <= 24; i3 += 1)
            if (e3.indexOf(r3(i3, 0, t3)) > -1) {
              n3 = i3 > 12;
              break;
            }
        } else
          n3 = e3 === (t3 ? "pm" : "PM");
        return n3;
      }, d = { A: [i2, function(e3) {
        this.afternoon = u(e3, false);
      }], a: [i2, function(e3) {
        this.afternoon = u(e3, true);
      }], S: [/\d/, function(e3) {
        this.milliseconds = 100 * +e3;
      }], SS: [n2, function(e3) {
        this.milliseconds = 10 * +e3;
      }], SSS: [/\d{3}/, function(e3) {
        this.milliseconds = +e3;
      }], s: [r2, a("seconds")], ss: [r2, a("seconds")], m: [r2, a("minutes")], mm: [r2, a("minutes")], H: [r2, a("hours")], h: [r2, a("hours")], HH: [r2, a("hours")], hh: [r2, a("hours")], D: [r2, a("day")], DD: [n2, a("day")], Do: [i2, function(e3) {
        var t3 = o.ordinal, n3 = e3.match(/\d+/);
        if (this.day = n3[0], t3)
          for (var r3 = 1; r3 <= 31; r3 += 1)
            t3(r3).replace(/\[|\]/g, "") === e3 && (this.day = r3);
      }], M: [r2, a("month")], MM: [n2, a("month")], MMM: [i2, function(e3) {
        var t3 = h2("months"), n3 = (h2("monthsShort") || t3.map(function(e4) {
          return e4.slice(0, 3);
        })).indexOf(e3) + 1;
        if (n3 < 1)
          throw new Error();
        this.month = n3 % 12 || n3;
      }], MMMM: [i2, function(e3) {
        var t3 = h2("months").indexOf(e3) + 1;
        if (t3 < 1)
          throw new Error();
        this.month = t3 % 12 || t3;
      }], Y: [/[+-]?\d+/, a("year")], YY: [n2, function(e3) {
        this.year = s(e3);
      }], YYYY: [/\d{4}/, a("year")], Z: f, ZZ: f };
      function c(n3) {
        var r3, i3;
        r3 = n3, i3 = o && o.formats;
        for (var s2 = (n3 = r3.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t3, n4, r4) {
          var o2 = r4 && r4.toUpperCase();
          return n4 || i3[r4] || e2[r4] || i3[o2].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e3, t4, n5) {
            return t4 || n5.slice(1);
          });
        })).match(t2), a2 = s2.length, f2 = 0; f2 < a2; f2 += 1) {
          var h3 = s2[f2], u2 = d[h3], c2 = u2 && u2[0], l = u2 && u2[1];
          s2[f2] = l ? { regex: c2, parser: l } : h3.replace(/^\[|\]$/g, "");
        }
        return function(e3) {
          for (var t3 = {}, n4 = 0, r4 = 0; n4 < a2; n4 += 1) {
            var i4 = s2[n4];
            if ("string" == typeof i4)
              r4 += i4.length;
            else {
              var o2 = i4.regex, f3 = i4.parser, h4 = e3.slice(r4), u3 = o2.exec(h4)[0];
              f3.call(t3, u3), e3 = e3.replace(u3, "");
            }
          }
          return function(e4) {
            var t4 = e4.afternoon;
            if (void 0 !== t4) {
              var n5 = e4.hours;
              t4 ? n5 < 12 && (e4.hours += 12) : 12 === n5 && (e4.hours = 0), delete e4.afternoon;
            }
          }(t3), t3;
        };
      }
      return function(e3, t3, n3) {
        n3.p.customParseFormat = true, e3 && e3.parseTwoDigitYear && (s = e3.parseTwoDigitYear);
        var r3 = t3.prototype, i3 = r3.parse;
        r3.parse = function(e4) {
          var t4 = e4.date, r4 = e4.utc, s2 = e4.args;
          this.$u = r4;
          var a2 = s2[1];
          if ("string" == typeof a2) {
            var f2 = true === s2[2], h3 = true === s2[3], u2 = f2 || h3, d2 = s2[2];
            h3 && (d2 = s2[2]), o = this.$locale(), !f2 && d2 && (o = n3.Ls[d2]), this.$d = function(e5, t5, n4) {
              try {
                if (["x", "X"].indexOf(t5) > -1)
                  return new Date(("X" === t5 ? 1e3 : 1) * e5);
                var r5 = c(t5)(e5), i4 = r5.year, o2 = r5.month, s3 = r5.day, a3 = r5.hours, f3 = r5.minutes, h4 = r5.seconds, u3 = r5.milliseconds, d3 = r5.zone, l2 = /* @__PURE__ */ new Date(), m2 = s3 || (i4 || o2 ? 1 : l2.getDate()), M2 = i4 || l2.getFullYear(), Y = 0;
                i4 && !o2 || (Y = o2 > 0 ? o2 - 1 : l2.getMonth());
                var p = a3 || 0, v = f3 || 0, D = h4 || 0, g = u3 || 0;
                return d3 ? new Date(Date.UTC(M2, Y, m2, p, v, D, g + 60 * d3.offset * 1e3)) : n4 ? new Date(Date.UTC(M2, Y, m2, p, v, D, g)) : new Date(M2, Y, m2, p, v, D, g);
              } catch (e6) {
                return /* @__PURE__ */ new Date("");
              }
            }(t4, a2, r4), this.init(), d2 && true !== d2 && (this.$L = this.locale(d2).$L), u2 && t4 != this.format(a2) && (this.$d = /* @__PURE__ */ new Date("")), o = {};
          } else if (a2 instanceof Array)
            for (var l = a2.length, m = 1; m <= l; m += 1) {
              s2[1] = a2[m - 1];
              var M = n3.apply(this, s2);
              if (M.isValid()) {
                this.$d = M.$d, this.$L = M.$L, this.init();
                break;
              }
              m === l && (this.$d = /* @__PURE__ */ new Date(""));
            }
          else
            i3.call(this, e4);
        };
      };
    });
  }
});

// node_modules/dayjs/plugin/isBetween.js
var require_isBetween = __commonJS({
  "node_modules/dayjs/plugin/isBetween.js"(exports, module) {
    !function(e2, i2) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = i2() : "function" == typeof define && define.amd ? define(i2) : (e2 = "undefined" != typeof globalThis ? globalThis : e2 || self).dayjs_plugin_isBetween = i2();
    }(exports, function() {
      "use strict";
      return function(e2, i2, t2) {
        i2.prototype.isBetween = function(e3, i3, s, f) {
          var n2 = t2(e3), o = t2(i3), r2 = "(" === (f = f || "()")[0], u = ")" === f[1];
          return (r2 ? this.isAfter(n2, s) : !this.isBefore(n2, s)) && (u ? this.isBefore(o, s) : !this.isAfter(o, s)) || (r2 ? this.isBefore(n2, s) : !this.isAfter(n2, s)) && (u ? this.isAfter(o, s) : !this.isBefore(o, s));
        };
      };
    });
  }
});

// node_modules/dayjs/plugin/weekOfYear.js
var require_weekOfYear = __commonJS({
  "node_modules/dayjs/plugin/weekOfYear.js"(exports, module) {
    !function(e2, t2) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = t2() : "function" == typeof define && define.amd ? define(t2) : (e2 = "undefined" != typeof globalThis ? globalThis : e2 || self).dayjs_plugin_weekOfYear = t2();
    }(exports, function() {
      "use strict";
      var e2 = "week", t2 = "year";
      return function(i2, n2, r2) {
        var f = n2.prototype;
        f.week = function(i3) {
          if (void 0 === i3 && (i3 = null), null !== i3)
            return this.add(7 * (i3 - this.week()), "day");
          var n3 = this.$locale().yearStart || 1;
          if (11 === this.month() && this.date() > 25) {
            var f2 = r2(this).startOf(t2).add(1, t2).date(n3), s = r2(this).endOf(e2);
            if (f2.isBefore(s))
              return 1;
          }
          var a = r2(this).startOf(t2).date(n3).startOf(e2).subtract(1, "millisecond"), o = this.diff(a, e2, true);
          return o < 0 ? r2(this).startOf("week").week() : Math.ceil(o);
        }, f.weeks = function(e3) {
          return void 0 === e3 && (e3 = null), this.week(e3);
        };
      };
    });
  }
});

// node_modules/dayjs/plugin/advancedFormat.js
var require_advancedFormat = __commonJS({
  "node_modules/dayjs/plugin/advancedFormat.js"(exports, module) {
    !function(e2, t2) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = t2() : "function" == typeof define && define.amd ? define(t2) : (e2 = "undefined" != typeof globalThis ? globalThis : e2 || self).dayjs_plugin_advancedFormat = t2();
    }(exports, function() {
      "use strict";
      return function(e2, t2) {
        var r2 = t2.prototype, n2 = r2.format;
        r2.format = function(e3) {
          var t3 = this, r3 = this.$locale();
          if (!this.isValid())
            return n2.bind(this)(e3);
          var s = this.$utils(), a = (e3 || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(e4) {
            switch (e4) {
              case "Q":
                return Math.ceil((t3.$M + 1) / 3);
              case "Do":
                return r3.ordinal(t3.$D);
              case "gggg":
                return t3.weekYear();
              case "GGGG":
                return t3.isoWeekYear();
              case "wo":
                return r3.ordinal(t3.week(), "W");
              case "w":
              case "ww":
                return s.s(t3.week(), "w" === e4 ? 1 : 2, "0");
              case "W":
              case "WW":
                return s.s(t3.isoWeek(), "W" === e4 ? 1 : 2, "0");
              case "k":
              case "kk":
                return s.s(String(0 === t3.$H ? 24 : t3.$H), "k" === e4 ? 1 : 2, "0");
              case "X":
                return Math.floor(t3.$d.getTime() / 1e3);
              case "x":
                return t3.$d.getTime();
              case "z":
                return "[" + t3.offsetName() + "]";
              case "zzz":
                return "[" + t3.offsetName("long") + "]";
              default:
                return e4;
            }
          });
          return n2.bind(this)(a);
        };
      };
    });
  }
});

// node_modules/dayjs/plugin/weekYear.js
var require_weekYear = __commonJS({
  "node_modules/dayjs/plugin/weekYear.js"(exports, module) {
    !function(e2, t2) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = t2() : "function" == typeof define && define.amd ? define(t2) : (e2 = "undefined" != typeof globalThis ? globalThis : e2 || self).dayjs_plugin_weekYear = t2();
    }(exports, function() {
      "use strict";
      return function(e2, t2) {
        t2.prototype.weekYear = function() {
          var e3 = this.month(), t3 = this.week(), n2 = this.year();
          return 1 === t3 && 11 === e3 ? n2 + 1 : 0 === e3 && t3 >= 52 ? n2 - 1 : n2;
        };
      };
    });
  }
});

// node_modules/dayjs/plugin/quarterOfYear.js
var require_quarterOfYear = __commonJS({
  "node_modules/dayjs/plugin/quarterOfYear.js"(exports, module) {
    !function(t2, n2) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = n2() : "function" == typeof define && define.amd ? define(n2) : (t2 = "undefined" != typeof globalThis ? globalThis : t2 || self).dayjs_plugin_quarterOfYear = n2();
    }(exports, function() {
      "use strict";
      var t2 = "month", n2 = "quarter";
      return function(e2, i2) {
        var r2 = i2.prototype;
        r2.quarter = function(t3) {
          return this.$utils().u(t3) ? Math.ceil((this.month() + 1) / 3) : this.month(this.month() % 3 + 3 * (t3 - 1));
        };
        var s = r2.add;
        r2.add = function(e3, i3) {
          return e3 = Number(e3), this.$utils().p(i3) === n2 ? this.add(3 * e3, t2) : s.bind(this)(e3, i3);
        };
        var u = r2.startOf;
        r2.startOf = function(e3, i3) {
          var r3 = this.$utils(), s2 = !!r3.u(i3) || i3;
          if (r3.p(e3) === n2) {
            var o = this.quarter() - 1;
            return s2 ? this.month(3 * o).startOf(t2).startOf("day") : this.month(3 * o + 2).endOf(t2).endOf("day");
          }
          return u.bind(this)(e3, i3);
        };
      };
    });
  }
});

// node_modules/dayjs/locale/zh-cn.js
var require_zh_cn = __commonJS({
  "node_modules/dayjs/locale/zh-cn.js"(exports, module) {
    !function(e2, _) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = _(require_dayjs_min()) : "function" == typeof define && define.amd ? define(["dayjs"], _) : (e2 = "undefined" != typeof globalThis ? globalThis : e2 || self).dayjs_locale_zh_cn = _(e2.dayjs);
    }(exports, function(e2) {
      "use strict";
      function _(e3) {
        return e3 && "object" == typeof e3 && "default" in e3 ? e3 : { default: e3 };
      }
      var t2 = _(e2), d = { name: "zh-cn", weekdays: "星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"), weekdaysShort: "周日_周一_周二_周三_周四_周五_周六".split("_"), weekdaysMin: "日_一_二_三_四_五_六".split("_"), months: "一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"), monthsShort: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"), ordinal: function(e3, _2) {
        return "W" === _2 ? e3 + "周" : e3 + "日";
      }, weekStart: 1, yearStart: 4, formats: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY/MM/DD", LL: "YYYY年M月D日", LLL: "YYYY年M月D日Ah点mm分", LLLL: "YYYY年M月D日ddddAh点mm分", l: "YYYY/M/D", ll: "YYYY年M月D日", lll: "YYYY年M月D日 HH:mm", llll: "YYYY年M月D日dddd HH:mm" }, relativeTime: { future: "%s内", past: "%s前", s: "几秒", m: "1 分钟", mm: "%d 分钟", h: "1 小时", hh: "%d 小时", d: "1 天", dd: "%d 天", M: "1 个月", MM: "%d 个月", y: "1 年", yy: "%d 年" }, meridiem: function(e3, _2) {
        var t3 = 100 * e3 + _2;
        return t3 < 600 ? "凌晨" : t3 < 900 ? "早上" : t3 < 1100 ? "上午" : t3 < 1300 ? "中午" : t3 < 1800 ? "下午" : "晚上";
      } };
      return t2.default.locale(d, null, true), d;
    });
  }
});

// node_modules/@arco-design/web-vue/es/_utils/is.js
var opt = Object.prototype.toString;
function isArray(obj) {
  return opt.call(obj) === "[object Array]";
}
function isNull(obj) {
  return opt.call(obj) === "[object Null]";
}
function isBoolean(obj) {
  return opt.call(obj) === "[object Boolean]";
}
function isObject(obj) {
  return opt.call(obj) === "[object Object]";
}
var isPromise = (obj) => {
  return opt.call(obj) === "[object Promise]";
};
function isString(obj) {
  return opt.call(obj) === "[object String]";
}
function isNumber(obj) {
  return opt.call(obj) === "[object Number]" && obj === obj;
}
function isUndefined(obj) {
  return obj === void 0;
}
function isFunction(obj) {
  return typeof obj === "function";
}
function isEmptyObject(obj) {
  return isObject(obj) && Object.keys(obj).length === 0;
}
function isWindow(el) {
  return el === window;
}
var isComponentInstance = (value) => {
  return (value == null ? void 0 : value.$) !== void 0;
};
var isQuarter = (fromat) => {
  return /\[Q]Q/.test(fromat);
};
function isDayjs(time) {
  return isObject(time) && "$y" in time && "$M" in time && "$D" in time && "$d" in time && "$H" in time && "$m" in time && "$s" in time;
}

// node_modules/@arco-design/web-vue/es/config-provider/context.js
var configProviderInjectionKey = Symbol("ArcoConfigProvider");

// node_modules/@arco-design/web-vue/es/locale/lang/zh-cn.js
var calendarLang = {
  formatYear: "YYYY 年",
  formatMonth: "YYYY 年 MM 月",
  today: "今天",
  view: {
    month: "月",
    year: "年",
    week: "周",
    day: "日"
  },
  month: {
    long: {
      January: "一月",
      February: "二月",
      March: "三月",
      April: "四月",
      May: "五月",
      June: "六月",
      July: "七月",
      August: "八月",
      September: "九月",
      October: "十月",
      November: "十一月",
      December: "十二月"
    },
    short: {
      January: "一月",
      February: "二月",
      March: "三月",
      April: "四月",
      May: "五月",
      June: "六月",
      July: "七月",
      August: "八月",
      September: "九月",
      October: "十月",
      November: "十一月",
      December: "十二月"
    }
  },
  week: {
    long: {
      self: "周",
      monday: "周一",
      tuesday: "周二",
      wednesday: "周三",
      thursday: "周四",
      friday: "周五",
      saturday: "周六",
      sunday: "周日"
    },
    short: {
      self: "周",
      monday: "一",
      tuesday: "二",
      wednesday: "三",
      thursday: "四",
      friday: "五",
      saturday: "六",
      sunday: "日"
    }
  }
};
var lang = {
  locale: "zh-CN",
  empty: {
    description: "暂无数据"
  },
  drawer: {
    okText: "确定",
    cancelText: "取消"
  },
  popconfirm: {
    okText: "确定",
    cancelText: "取消"
  },
  modal: {
    okText: "确定",
    cancelText: "取消"
  },
  pagination: {
    goto: "前往",
    page: "页",
    countPerPage: "条/页",
    total: "共 {0} 条"
  },
  table: {
    okText: "确定",
    resetText: "重置"
  },
  upload: {
    start: "开始",
    cancel: "取消",
    delete: "删除",
    retry: "点击重试",
    buttonText: "点击上传",
    preview: "预览",
    drag: "点击或拖拽文件到此处上传",
    dragHover: "释放文件并开始上传",
    error: "上传失败"
  },
  datePicker: {
    view: calendarLang.view,
    month: calendarLang.month,
    week: calendarLang.week,
    placeholder: {
      date: "请选择日期",
      week: "请选择周",
      month: "请选择月份",
      year: "请选择年份",
      quarter: "请选择季度",
      time: "请选择时间"
    },
    rangePlaceholder: {
      date: ["开始日期", "结束日期"],
      week: ["开始周", "结束周"],
      month: ["开始月份", "结束月份"],
      year: ["开始年份", "结束年份"],
      quarter: ["开始季度", "结束季度"],
      time: ["开始时间", "结束时间"]
    },
    selectTime: "选择时间",
    today: "今天",
    now: "此刻",
    ok: "确定"
  },
  image: {
    loading: "加载中"
  },
  imagePreview: {
    fullScreen: "全屏",
    rotateRight: "向右旋转",
    rotateLeft: "向左旋转",
    zoomIn: "放大",
    zoomOut: "缩小",
    originalSize: "原始尺寸"
  },
  typography: {
    copied: "已复制",
    copy: "复制",
    expand: "展开",
    collapse: "折叠",
    edit: "编辑"
  }
};

// node_modules/@arco-design/web-vue/es/locale/index.js
var LOCALE = ref("zh-CN");
var I18N_MESSAGES = reactive({
  "zh-CN": lang
});
var addI18nMessages = (messages2, options) => {
  for (const key of Object.keys(messages2)) {
    if (!I18N_MESSAGES[key] || (options == null ? void 0 : options.overwrite)) {
      I18N_MESSAGES[key] = messages2[key];
    }
  }
};
var useLocale = (locale) => {
  if (!I18N_MESSAGES[locale]) {
    console.warn(`use ${locale} failed! Please add ${locale} first`);
    return;
  }
  LOCALE.value = locale;
};
var getLocale = () => {
  return LOCALE.value;
};
var useI18n = () => {
  const configProvider = inject(configProviderInjectionKey, void 0);
  const i18nMessage = computed(() => {
    var _a;
    return (_a = configProvider == null ? void 0 : configProvider.locale) != null ? _a : I18N_MESSAGES[LOCALE.value];
  });
  const locale = computed(() => i18nMessage.value.locale);
  const transform = (key, ...args) => {
    const keyArray = key.split(".");
    let temp = i18nMessage.value;
    for (const keyItem of keyArray) {
      if (!temp[keyItem]) {
        return key;
      }
      temp = temp[keyItem];
    }
    if (isString(temp)) {
      if (args.length > 0) {
        return temp.replace(/{(\d+)}/g, (sub, index3) => {
          var _a;
          return (_a = args[index3]) != null ? _a : sub;
        });
      }
      return temp;
    }
    return temp;
  };
  return {
    locale,
    t: transform
  };
};

// node_modules/@arco-design/web-vue/es/_utils/global-config.js
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var COMPONENT_PREFIX = "A";
var CLASS_PREFIX = "arco";
var GLOBAL_CONFIG_NAME = "$arco";
var getComponentPrefix = (options) => {
  var _a;
  return (_a = options == null ? void 0 : options.componentPrefix) != null ? _a : COMPONENT_PREFIX;
};
var setGlobalConfig = (app, options) => {
  var _a;
  if (options && options.classPrefix) {
    app.config.globalProperties[GLOBAL_CONFIG_NAME] = __spreadProps(__spreadValues({}, (_a = app.config.globalProperties[GLOBAL_CONFIG_NAME]) != null ? _a : {}), {
      classPrefix: options.classPrefix
    });
  }
};
var getPrefixCls = (componentName) => {
  var _a, _b, _c;
  const instance = getCurrentInstance();
  const configProvider = inject(configProviderInjectionKey, void 0);
  const prefix = (_c = (_b = configProvider == null ? void 0 : configProvider.prefixCls) != null ? _b : (_a = instance == null ? void 0 : instance.appContext.config.globalProperties[GLOBAL_CONFIG_NAME]) == null ? void 0 : _a.classPrefix) != null ? _c : CLASS_PREFIX;
  if (componentName) {
    return `${prefix}-${componentName}`;
  }
  return prefix;
};

// node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js
var MapShim = function() {
  if (typeof Map !== "undefined") {
    return Map;
  }
  function getIndex(arr, key) {
    var result = -1;
    arr.some(function(entry, index3) {
      if (entry[0] === key) {
        result = index3;
        return true;
      }
      return false;
    });
    return result;
  }
  return (
    /** @class */
    function() {
      function class_1() {
        this.__entries__ = [];
      }
      Object.defineProperty(class_1.prototype, "size", {
        /**
         * @returns {boolean}
         */
        get: function() {
          return this.__entries__.length;
        },
        enumerable: true,
        configurable: true
      });
      class_1.prototype.get = function(key) {
        var index3 = getIndex(this.__entries__, key);
        var entry = this.__entries__[index3];
        return entry && entry[1];
      };
      class_1.prototype.set = function(key, value) {
        var index3 = getIndex(this.__entries__, key);
        if (~index3) {
          this.__entries__[index3][1] = value;
        } else {
          this.__entries__.push([key, value]);
        }
      };
      class_1.prototype.delete = function(key) {
        var entries = this.__entries__;
        var index3 = getIndex(entries, key);
        if (~index3) {
          entries.splice(index3, 1);
        }
      };
      class_1.prototype.has = function(key) {
        return !!~getIndex(this.__entries__, key);
      };
      class_1.prototype.clear = function() {
        this.__entries__.splice(0);
      };
      class_1.prototype.forEach = function(callback, ctx) {
        if (ctx === void 0) {
          ctx = null;
        }
        for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
          var entry = _a[_i];
          callback.call(ctx, entry[1], entry[0]);
        }
      };
      return class_1;
    }()
  );
}();
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
var global$1 = function() {
  if (typeof global !== "undefined" && global.Math === Math) {
    return global;
  }
  if (typeof self !== "undefined" && self.Math === Math) {
    return self;
  }
  if (typeof window !== "undefined" && window.Math === Math) {
    return window;
  }
  return Function("return this")();
}();
var requestAnimationFrame$1 = function() {
  if (typeof requestAnimationFrame === "function") {
    return requestAnimationFrame.bind(global$1);
  }
  return function(callback) {
    return setTimeout(function() {
      return callback(Date.now());
    }, 1e3 / 60);
  };
}();
var trailingTimeout = 2;
function throttle(callback, delay) {
  var leadingCall = false, trailingCall = false, lastCallTime = 0;
  function resolvePending() {
    if (leadingCall) {
      leadingCall = false;
      callback();
    }
    if (trailingCall) {
      proxy();
    }
  }
  function timeoutCallback() {
    requestAnimationFrame$1(resolvePending);
  }
  function proxy() {
    var timeStamp = Date.now();
    if (leadingCall) {
      if (timeStamp - lastCallTime < trailingTimeout) {
        return;
      }
      trailingCall = true;
    } else {
      leadingCall = true;
      trailingCall = false;
      setTimeout(timeoutCallback, delay);
    }
    lastCallTime = timeStamp;
  }
  return proxy;
}
var REFRESH_DELAY = 20;
var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
var mutationObserverSupported = typeof MutationObserver !== "undefined";
var ResizeObserverController = (
  /** @class */
  function() {
    function ResizeObserverController2() {
      this.connected_ = false;
      this.mutationEventsAdded_ = false;
      this.mutationsObserver_ = null;
      this.observers_ = [];
      this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
      this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
    }
    ResizeObserverController2.prototype.addObserver = function(observer) {
      if (!~this.observers_.indexOf(observer)) {
        this.observers_.push(observer);
      }
      if (!this.connected_) {
        this.connect_();
      }
    };
    ResizeObserverController2.prototype.removeObserver = function(observer) {
      var observers2 = this.observers_;
      var index3 = observers2.indexOf(observer);
      if (~index3) {
        observers2.splice(index3, 1);
      }
      if (!observers2.length && this.connected_) {
        this.disconnect_();
      }
    };
    ResizeObserverController2.prototype.refresh = function() {
      var changesDetected = this.updateObservers_();
      if (changesDetected) {
        this.refresh();
      }
    };
    ResizeObserverController2.prototype.updateObservers_ = function() {
      var activeObservers = this.observers_.filter(function(observer) {
        return observer.gatherActive(), observer.hasActive();
      });
      activeObservers.forEach(function(observer) {
        return observer.broadcastActive();
      });
      return activeObservers.length > 0;
    };
    ResizeObserverController2.prototype.connect_ = function() {
      if (!isBrowser || this.connected_) {
        return;
      }
      document.addEventListener("transitionend", this.onTransitionEnd_);
      window.addEventListener("resize", this.refresh);
      if (mutationObserverSupported) {
        this.mutationsObserver_ = new MutationObserver(this.refresh);
        this.mutationsObserver_.observe(document, {
          attributes: true,
          childList: true,
          characterData: true,
          subtree: true
        });
      } else {
        document.addEventListener("DOMSubtreeModified", this.refresh);
        this.mutationEventsAdded_ = true;
      }
      this.connected_ = true;
    };
    ResizeObserverController2.prototype.disconnect_ = function() {
      if (!isBrowser || !this.connected_) {
        return;
      }
      document.removeEventListener("transitionend", this.onTransitionEnd_);
      window.removeEventListener("resize", this.refresh);
      if (this.mutationsObserver_) {
        this.mutationsObserver_.disconnect();
      }
      if (this.mutationEventsAdded_) {
        document.removeEventListener("DOMSubtreeModified", this.refresh);
      }
      this.mutationsObserver_ = null;
      this.mutationEventsAdded_ = false;
      this.connected_ = false;
    };
    ResizeObserverController2.prototype.onTransitionEnd_ = function(_a) {
      var _b = _a.propertyName, propertyName = _b === void 0 ? "" : _b;
      var isReflowProperty = transitionKeys.some(function(key) {
        return !!~propertyName.indexOf(key);
      });
      if (isReflowProperty) {
        this.refresh();
      }
    };
    ResizeObserverController2.getInstance = function() {
      if (!this.instance_) {
        this.instance_ = new ResizeObserverController2();
      }
      return this.instance_;
    };
    ResizeObserverController2.instance_ = null;
    return ResizeObserverController2;
  }()
);
var defineConfigurable = function(target3, props) {
  for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
    var key = _a[_i];
    Object.defineProperty(target3, key, {
      value: props[key],
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  return target3;
};
var getWindowOf = function(target3) {
  var ownerGlobal = target3 && target3.ownerDocument && target3.ownerDocument.defaultView;
  return ownerGlobal || global$1;
};
var emptyRect = createRectInit(0, 0, 0, 0);
function toFloat(value) {
  return parseFloat(value) || 0;
}
function getBordersSize(styles) {
  var positions = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    positions[_i - 1] = arguments[_i];
  }
  return positions.reduce(function(size, position) {
    var value = styles["border-" + position + "-width"];
    return size + toFloat(value);
  }, 0);
}
function getPaddings(styles) {
  var positions = ["top", "right", "bottom", "left"];
  var paddings = {};
  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
    var position = positions_1[_i];
    var value = styles["padding-" + position];
    paddings[position] = toFloat(value);
  }
  return paddings;
}
function getSVGContentRect(target3) {
  var bbox = target3.getBBox();
  return createRectInit(0, 0, bbox.width, bbox.height);
}
function getHTMLElementContentRect(target3) {
  var clientWidth = target3.clientWidth, clientHeight = target3.clientHeight;
  if (!clientWidth && !clientHeight) {
    return emptyRect;
  }
  var styles = getWindowOf(target3).getComputedStyle(target3);
  var paddings = getPaddings(styles);
  var horizPad = paddings.left + paddings.right;
  var vertPad = paddings.top + paddings.bottom;
  var width = toFloat(styles.width), height = toFloat(styles.height);
  if (styles.boxSizing === "border-box") {
    if (Math.round(width + horizPad) !== clientWidth) {
      width -= getBordersSize(styles, "left", "right") + horizPad;
    }
    if (Math.round(height + vertPad) !== clientHeight) {
      height -= getBordersSize(styles, "top", "bottom") + vertPad;
    }
  }
  if (!isDocumentElement(target3)) {
    var vertScrollbar = Math.round(width + horizPad) - clientWidth;
    var horizScrollbar = Math.round(height + vertPad) - clientHeight;
    if (Math.abs(vertScrollbar) !== 1) {
      width -= vertScrollbar;
    }
    if (Math.abs(horizScrollbar) !== 1) {
      height -= horizScrollbar;
    }
  }
  return createRectInit(paddings.left, paddings.top, width, height);
}
var isSVGGraphicsElement = function() {
  if (typeof SVGGraphicsElement !== "undefined") {
    return function(target3) {
      return target3 instanceof getWindowOf(target3).SVGGraphicsElement;
    };
  }
  return function(target3) {
    return target3 instanceof getWindowOf(target3).SVGElement && typeof target3.getBBox === "function";
  };
}();
function isDocumentElement(target3) {
  return target3 === getWindowOf(target3).document.documentElement;
}
function getContentRect(target3) {
  if (!isBrowser) {
    return emptyRect;
  }
  if (isSVGGraphicsElement(target3)) {
    return getSVGContentRect(target3);
  }
  return getHTMLElementContentRect(target3);
}
function createReadOnlyRect(_a) {
  var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
  var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
  var rect = Object.create(Constr.prototype);
  defineConfigurable(rect, {
    x,
    y,
    width,
    height,
    top: y,
    right: x + width,
    bottom: height + y,
    left: x
  });
  return rect;
}
function createRectInit(x, y, width, height) {
  return { x, y, width, height };
}
var ResizeObservation = (
  /** @class */
  function() {
    function ResizeObservation2(target3) {
      this.broadcastWidth = 0;
      this.broadcastHeight = 0;
      this.contentRect_ = createRectInit(0, 0, 0, 0);
      this.target = target3;
    }
    ResizeObservation2.prototype.isActive = function() {
      var rect = getContentRect(this.target);
      this.contentRect_ = rect;
      return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
    };
    ResizeObservation2.prototype.broadcastRect = function() {
      var rect = this.contentRect_;
      this.broadcastWidth = rect.width;
      this.broadcastHeight = rect.height;
      return rect;
    };
    return ResizeObservation2;
  }()
);
var ResizeObserverEntry = (
  /** @class */
  function() {
    function ResizeObserverEntry2(target3, rectInit) {
      var contentRect = createReadOnlyRect(rectInit);
      defineConfigurable(this, { target: target3, contentRect });
    }
    return ResizeObserverEntry2;
  }()
);
var ResizeObserverSPI = (
  /** @class */
  function() {
    function ResizeObserverSPI2(callback, controller, callbackCtx) {
      this.activeObservations_ = [];
      this.observations_ = new MapShim();
      if (typeof callback !== "function") {
        throw new TypeError("The callback provided as parameter 1 is not a function.");
      }
      this.callback_ = callback;
      this.controller_ = controller;
      this.callbackCtx_ = callbackCtx;
    }
    ResizeObserverSPI2.prototype.observe = function(target3) {
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      if (typeof Element === "undefined" || !(Element instanceof Object)) {
        return;
      }
      if (!(target3 instanceof getWindowOf(target3).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }
      var observations = this.observations_;
      if (observations.has(target3)) {
        return;
      }
      observations.set(target3, new ResizeObservation(target3));
      this.controller_.addObserver(this);
      this.controller_.refresh();
    };
    ResizeObserverSPI2.prototype.unobserve = function(target3) {
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      if (typeof Element === "undefined" || !(Element instanceof Object)) {
        return;
      }
      if (!(target3 instanceof getWindowOf(target3).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }
      var observations = this.observations_;
      if (!observations.has(target3)) {
        return;
      }
      observations.delete(target3);
      if (!observations.size) {
        this.controller_.removeObserver(this);
      }
    };
    ResizeObserverSPI2.prototype.disconnect = function() {
      this.clearActive();
      this.observations_.clear();
      this.controller_.removeObserver(this);
    };
    ResizeObserverSPI2.prototype.gatherActive = function() {
      var _this = this;
      this.clearActive();
      this.observations_.forEach(function(observation) {
        if (observation.isActive()) {
          _this.activeObservations_.push(observation);
        }
      });
    };
    ResizeObserverSPI2.prototype.broadcastActive = function() {
      if (!this.hasActive()) {
        return;
      }
      var ctx = this.callbackCtx_;
      var entries = this.activeObservations_.map(function(observation) {
        return new ResizeObserverEntry(observation.target, observation.broadcastRect());
      });
      this.callback_.call(ctx, entries, ctx);
      this.clearActive();
    };
    ResizeObserverSPI2.prototype.clearActive = function() {
      this.activeObservations_.splice(0);
    };
    ResizeObserverSPI2.prototype.hasActive = function() {
      return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI2;
  }()
);
var observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
var ResizeObserver = (
  /** @class */
  function() {
    function ResizeObserver4(callback) {
      if (!(this instanceof ResizeObserver4)) {
        throw new TypeError("Cannot call a class as a function.");
      }
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      var controller = ResizeObserverController.getInstance();
      var observer = new ResizeObserverSPI(callback, controller, this);
      observers.set(this, observer);
    }
    return ResizeObserver4;
  }()
);
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(method) {
  ResizeObserver.prototype[method] = function() {
    var _a;
    return (_a = observers.get(this))[method].apply(_a, arguments);
  };
});
var index = function() {
  if (typeof global$1.ResizeObserver !== "undefined") {
    return global$1.ResizeObserver;
  }
  return ResizeObserver;
}();
var ResizeObserver_es_default = index;

// node_modules/@arco-design/web-vue/es/_utils/vue-utils.js
var ShapeFlags;
(function(ShapeFlags2) {
  ShapeFlags2[ShapeFlags2["ELEMENT"] = 1] = "ELEMENT";
  ShapeFlags2[ShapeFlags2["FUNCTIONAL_COMPONENT"] = 2] = "FUNCTIONAL_COMPONENT";
  ShapeFlags2[ShapeFlags2["STATEFUL_COMPONENT"] = 4] = "STATEFUL_COMPONENT";
  ShapeFlags2[ShapeFlags2["COMPONENT"] = 6] = "COMPONENT";
  ShapeFlags2[ShapeFlags2["TEXT_CHILDREN"] = 8] = "TEXT_CHILDREN";
  ShapeFlags2[ShapeFlags2["ARRAY_CHILDREN"] = 16] = "ARRAY_CHILDREN";
  ShapeFlags2[ShapeFlags2["SLOTS_CHILDREN"] = 32] = "SLOTS_CHILDREN";
  ShapeFlags2[ShapeFlags2["TELEPORT"] = 64] = "TELEPORT";
  ShapeFlags2[ShapeFlags2["SUSPENSE"] = 128] = "SUSPENSE";
  ShapeFlags2[ShapeFlags2["COMPONENT_SHOULD_KEEP_ALIVE"] = 256] = "COMPONENT_SHOULD_KEEP_ALIVE";
  ShapeFlags2[ShapeFlags2["COMPONENT_KEPT_ALIVE"] = 512] = "COMPONENT_KEPT_ALIVE";
})(ShapeFlags || (ShapeFlags = {}));
var PatchFlags;
(function(PatchFlags2) {
  PatchFlags2[PatchFlags2["TEXT"] = 1] = "TEXT";
  PatchFlags2[PatchFlags2["CLASS"] = 2] = "CLASS";
  PatchFlags2[PatchFlags2["STYLE"] = 4] = "STYLE";
  PatchFlags2[PatchFlags2["PROPS"] = 8] = "PROPS";
  PatchFlags2[PatchFlags2["FULL_PROPS"] = 16] = "FULL_PROPS";
  PatchFlags2[PatchFlags2["HYDRATE_EVENTS"] = 32] = "HYDRATE_EVENTS";
  PatchFlags2[PatchFlags2["STABLE_FRAGMENT"] = 64] = "STABLE_FRAGMENT";
  PatchFlags2[PatchFlags2["KEYED_FRAGMENT"] = 128] = "KEYED_FRAGMENT";
  PatchFlags2[PatchFlags2["UNKEYED_FRAGMENT"] = 256] = "UNKEYED_FRAGMENT";
  PatchFlags2[PatchFlags2["NEED_PATCH"] = 512] = "NEED_PATCH";
  PatchFlags2[PatchFlags2["DYNAMIC_SLOTS"] = 1024] = "DYNAMIC_SLOTS";
  PatchFlags2[PatchFlags2["DEV_ROOT_FRAGMENT"] = 2048] = "DEV_ROOT_FRAGMENT";
  PatchFlags2[PatchFlags2["HOISTED"] = -1] = "HOISTED";
  PatchFlags2[PatchFlags2["BAIL"] = -2] = "BAIL";
})(PatchFlags || (PatchFlags = {}));
var isElement = (vn) => {
  return Boolean(vn && vn.shapeFlag & 1);
};
var isComponent = (vn, type) => {
  return Boolean(vn && vn.shapeFlag & 6);
};
var isTextChildren = (child, children) => {
  return Boolean(child && child.shapeFlag & 8);
};
var isArrayChildren = (vn, children) => {
  return Boolean(vn && vn.shapeFlag & 16);
};
var isSlotsChildren = (vn, children) => {
  return Boolean(vn && vn.shapeFlag & 32);
};
var getFirstComponent = (children) => {
  var _a, _b;
  if (!children) {
    return void 0;
  }
  for (const child of children) {
    if (isElement(child) || isComponent(child)) {
      return child;
    }
    if (isArrayChildren(child, child.children)) {
      const result = getFirstComponent(child.children);
      if (result)
        return result;
    } else if (isSlotsChildren(child, child.children)) {
      const children2 = (_b = (_a = child.children).default) == null ? void 0 : _b.call(_a);
      if (children2) {
        const result = getFirstComponent(children2);
        if (result)
          return result;
      }
    } else if (isArray(child)) {
      const result = getFirstComponent(child);
      if (result)
        return result;
    }
  }
  return void 0;
};
var isEmptyChildren = (children) => {
  if (!children) {
    return true;
  }
  for (const item of children) {
    if (item.children) {
      return false;
    }
  }
  return true;
};
var mergeFirstChild = (children, extraProps) => {
  if (children && children.length > 0) {
    for (let i2 = 0; i2 < children.length; i2++) {
      const child = children[i2];
      if (isElement(child) || isComponent(child)) {
        const props = isFunction(extraProps) ? extraProps(child) : extraProps;
        children[i2] = cloneVNode(child, props, true);
        return true;
      }
      const _children = getChildrenArray(child);
      if (_children && _children.length > 0) {
        const result = mergeFirstChild(_children, extraProps);
        if (result)
          return true;
      }
    }
  }
  return false;
};
var getChildrenArray = (vn) => {
  if (isArrayChildren(vn, vn.children)) {
    return vn.children;
  }
  if (isArray(vn)) {
    return vn;
  }
  return void 0;
};
var getFirstElementFromVNode = (vn) => {
  var _a, _b;
  if (isElement(vn)) {
    return vn.el;
  }
  if (isComponent(vn)) {
    if (((_a = vn.el) == null ? void 0 : _a.nodeType) === 1) {
      return vn.el;
    }
    if ((_b = vn.component) == null ? void 0 : _b.subTree) {
      const ele = getFirstElementFromVNode(vn.component.subTree);
      if (ele)
        return ele;
    }
  } else {
    const children = getChildrenArray(vn);
    return getFirstElementFromChildren(children);
  }
  return void 0;
};
var getFirstElementFromChildren = (children) => {
  if (children && children.length > 0) {
    for (const child of children) {
      const element = getFirstElementFromVNode(child);
      if (element)
        return element;
    }
  }
  return void 0;
};
var getAllElements = (children, includeText = false) => {
  var _a, _b;
  const results = [];
  for (const item of children != null ? children : []) {
    if (isElement(item) || isComponent(item) || includeText && isTextChildren(item, item.children)) {
      results.push(item);
    } else if (isArrayChildren(item, item.children)) {
      results.push(...getAllElements(item.children, includeText));
    } else if (isSlotsChildren(item, item.children)) {
      results.push(...getAllElements((_b = (_a = item.children).default) == null ? void 0 : _b.call(_a), includeText));
    } else if (isArray(item)) {
      results.push(...getAllElements(item, includeText));
    }
  }
  return results;
};
function unFragment(nodeList) {
  function loop(nodes) {
    const unFragmentNodeList = [];
    nodes.forEach((node) => {
      var _a, _b;
      if (isVNode(node) && node.type === Fragment) {
        if (isSlotsChildren(node, node.children)) {
          unFragmentNodeList.push(...loop(((_b = (_a = node.children).default) == null ? void 0 : _b.call(_a)) || []));
        } else if (isArrayChildren(node, node.children)) {
          unFragmentNodeList.push(...loop(node.children));
        } else if (isString(node.children)) {
          unFragmentNodeList.push(node.children);
        }
      } else {
        unFragmentNodeList.push(node);
      }
    });
    return unFragmentNodeList;
  }
  return loop(nodeList);
}
var getSlotFunction = (param) => {
  if (param) {
    if (isFunction(param))
      return param;
    return () => param;
  }
  return void 0;
};
var getComponentsFromVNode = (vn, name) => {
  var _a;
  const components2 = [];
  if (isComponent(vn, vn.type)) {
    if (vn.type.name === name) {
      if (vn.component) {
        components2.push(vn.component.uid);
      }
    } else if ((_a = vn.component) == null ? void 0 : _a.subTree) {
      components2.push(...getComponentsFromVNode(vn.component.subTree, name));
    }
  } else {
    const children = getChildrenArray(vn);
    if (children) {
      components2.push(...getComponentsFromChildren(children, name));
    }
  }
  return components2;
};
var getComponentsFromChildren = (children, name) => {
  const components2 = [];
  if (children && children.length > 0) {
    for (const child of children) {
      components2.push(...getComponentsFromVNode(child, name));
    }
  }
  return components2;
};

// node_modules/@arco-design/web-vue/es/_components/resize-observer.js
var ResizeObserver2 = defineComponent({
  name: "ResizeObserver",
  emits: [
    "resize"
  ],
  setup(props, {
    emit,
    slots
  }) {
    let resizeObserver;
    const componentRef = ref();
    const element = computed(() => isComponentInstance(componentRef.value) ? componentRef.value.$el : componentRef.value);
    const createResizeObserver = (target3) => {
      if (!target3)
        return;
      resizeObserver = new ResizeObserver_es_default((entries) => {
        const entry = entries[0];
        emit("resize", entry);
      });
      resizeObserver.observe(target3);
    };
    const destroyResizeObserver = () => {
      if (resizeObserver) {
        resizeObserver.disconnect();
        resizeObserver = null;
      }
    };
    watch(element, (_element) => {
      if (resizeObserver)
        destroyResizeObserver();
      if (_element)
        createResizeObserver(_element);
    });
    onMounted(() => {
      if (element.value) {
        createResizeObserver(element.value);
      }
    });
    onUnmounted(() => {
      destroyResizeObserver();
    });
    return () => {
      var _a, _b;
      const firstChild = getFirstComponent((_b = (_a = slots.default) == null ? void 0 : _a.call(slots)) != null ? _b : []);
      if (firstChild) {
        return cloneVNode(firstChild, {
          ref: componentRef
        }, true);
      }
      return null;
    };
  }
});

// node_modules/@arco-design/web-vue/es/_utils/raf.js
var target = typeof window === "undefined" ? global : window;
var raf = target.requestAnimationFrame;
var caf = target.cancelAnimationFrame;

// node_modules/@arco-design/web-vue/es/_utils/throttle-by-raf.js
function throttleByRaf(cb) {
  let timer = 0;
  const throttle2 = (...args) => {
    if (timer) {
      caf(timer);
    }
    timer = raf(() => {
      cb(...args);
      timer = 0;
    });
  };
  throttle2.cancel = () => {
    caf(timer);
    timer = 0;
  };
  return throttle2;
}

// node_modules/@arco-design/web-vue/es/_utils/dom.js
var NOOP = () => {
  return void 0;
};
var isServerRendering = (() => {
  try {
    return !(typeof window !== "undefined" && document !== void 0);
  } catch (e2) {
    return true;
  }
})();
var on = (() => {
  if (isServerRendering) {
    return NOOP;
  }
  return (element, event, handler, options = false) => {
    element.addEventListener(event, handler, options);
  };
})();
var off = (() => {
  if (isServerRendering) {
    return NOOP;
  }
  return (element, type, handler, options = false) => {
    element.removeEventListener(type, handler, options);
  };
})();
var contains = (root, ele) => {
  if (!root || !ele) {
    return false;
  }
  let node = ele;
  while (node) {
    if (node === root) {
      return true;
    }
    node = node.parentNode;
  }
  return false;
};
var getOverlay = (type) => {
  const popper = document.createElement("div");
  popper.setAttribute("class", `arco-overlay arco-overlay-${type}`);
  return popper;
};
var querySelector = (selectors, container2) => {
  var _a;
  if (isServerRendering) {
    return NOOP();
  }
  return (_a = (container2 != null ? container2 : document).querySelector(selectors)) != null ? _a : void 0;
};
var getElement = (target3, container2) => {
  if (isString(target3)) {
    const selector = target3[0] === "#" ? `[id='${target3.slice(1)}']` : target3;
    return querySelector(selector, container2);
  }
  return target3;
};
var getRelativeRect = (target3, relative) => {
  const targetRect = target3.getBoundingClientRect();
  const relativeRect = relative.getBoundingClientRect();
  return {
    top: targetRect.top - relativeRect.top,
    bottom: relativeRect.bottom - targetRect.bottom,
    left: targetRect.left - relativeRect.left,
    right: relativeRect.right - targetRect.right,
    width: targetRect.width,
    height: targetRect.height
  };
};
var isScroll = (element) => {
  return element.tagName === "BODY" ? document.documentElement.scrollHeight > window.innerHeight : element.scrollHeight > element.offsetHeight;
};
var getScrollBarWidth = (element) => {
  return element.tagName === "BODY" ? window.innerWidth - (document.documentElement.offsetWidth || document.body.offsetWidth) : element.offsetWidth - element.clientWidth;
};

// node_modules/@arco-design/web-vue/es/_virtual/plugin-vue_export-helper.js
var _export_sfc = (sfc, props) => {
  for (const [key, val] of props) {
    sfc[key] = val;
  }
  return sfc;
};

// node_modules/@arco-design/web-vue/es/affix/affix.js
var __defProp2 = Object.defineProperty;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp2.call(b, prop))
      __defNormalProp2(a, prop, b[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b)) {
      if (__propIsEnum2.call(b, prop))
        __defNormalProp2(a, prop, b[prop]);
    }
  return a;
};
function getTargetRect(target3) {
  return isWindow(target3) ? {
    top: 0,
    bottom: window.innerHeight
  } : target3.getBoundingClientRect();
}
var _sfc_main = defineComponent({
  name: "Affix",
  components: {
    ResizeObserver: ResizeObserver2
  },
  props: {
    offsetTop: {
      type: Number,
      default: 0
    },
    offsetBottom: {
      type: Number
    },
    target: {
      type: [String, Object, Function]
    },
    targetContainer: {
      type: [String, Object, Function]
    }
  },
  emits: {
    change: (fixed) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("affix");
    const { target: target3, targetContainer } = toRefs(props);
    const wrapperRef = ref();
    const targetRef = ref();
    const isFixed = ref(false);
    const placeholderStyles = ref({});
    const fixedStyles = ref({});
    const classNames = computed(() => ({ [prefixCls]: isFixed.value }));
    const updatePositionThrottle = throttleByRaf(() => {
      if (!wrapperRef.value || !targetRef.value)
        return;
      const { offsetTop, offsetBottom } = props;
      const offsetType = isUndefined(offsetBottom) ? "top" : "bottom";
      const wrapperRect = wrapperRef.value.getBoundingClientRect();
      const targetRect = getTargetRect(targetRef.value);
      let newIsFixed = false;
      let newFixedStyles = {};
      const newPlaceholderStyles = {
        width: `${wrapperRef.value.offsetWidth}px`,
        height: `${wrapperRef.value.offsetHeight}px`
      };
      if (offsetType === "top") {
        newIsFixed = wrapperRect.top - targetRect.top < (offsetTop || 0);
        newFixedStyles = newIsFixed ? {
          position: "fixed",
          top: `${targetRect.top + (offsetTop || 0)}px`
        } : {};
      } else {
        newIsFixed = targetRect.bottom - wrapperRect.bottom < (offsetBottom || 0);
        newFixedStyles = newIsFixed ? {
          position: "fixed",
          bottom: `${window.innerHeight - targetRect.bottom + (offsetBottom || 0)}px`
        } : {};
      }
      if (newIsFixed !== isFixed.value) {
        isFixed.value = newIsFixed;
        emit("change", newIsFixed);
      }
      placeholderStyles.value = newPlaceholderStyles;
      fixedStyles.value = __spreadValues2(__spreadValues2({}, newFixedStyles), newIsFixed ? newPlaceholderStyles : {});
    });
    onMounted(() => {
      watchEffect((onInvalidate) => {
        const element = target3 && target3.value !== window && getElement(target3.value) || window;
        targetRef.value = element;
        if (element) {
          on(element, "scroll", updatePositionThrottle);
          on(element, "resize", updatePositionThrottle);
          onInvalidate(() => {
            off(element, "scroll", updatePositionThrottle);
            off(element, "resize", updatePositionThrottle);
          });
        }
      });
      watchEffect((onInvalidate) => {
        if (!targetRef.value)
          return;
        const container2 = targetContainer && targetContainer.value !== window && getElement(targetContainer.value) || window;
        if (container2) {
          on(container2, "scroll", updatePositionThrottle);
          on(container2, "resize", updatePositionThrottle);
          onInvalidate(() => {
            off(container2, "scroll", updatePositionThrottle);
            off(container2, "resize", updatePositionThrottle);
          });
        }
      });
    });
    return {
      wrapperRef,
      isFixed,
      classNames,
      placeholderStyles,
      fixedStyles,
      updatePositionThrottle
    };
  },
  methods: {
    updatePosition() {
      this.updatePositionThrottle();
    }
  }
});
var _hoisted_1 = { ref: "wrapperRef" };
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ResizeObserver = resolveComponent("ResizeObserver");
  return openBlock(), createBlock(_component_ResizeObserver, { onResize: _ctx.updatePositionThrottle }, {
    default: withCtx(() => [
      createBaseVNode("div", _hoisted_1, [
        _ctx.isFixed ? (openBlock(), createElementBlock("div", {
          key: 0,
          style: normalizeStyle(_ctx.placeholderStyles)
        }, null, 4)) : createCommentVNode("v-if", true),
        createBaseVNode("div", {
          class: normalizeClass(_ctx.classNames),
          style: normalizeStyle(_ctx.fixedStyles)
        }, [
          createVNode(_component_ResizeObserver, { onResize: _ctx.updatePositionThrottle }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["onResize"])
        ], 6)
      ], 512)
    ]),
    _: 3
  }, 8, ["onResize"]);
}
var _Affix = _export_sfc(_sfc_main, [["render", _sfc_render]]);

// node_modules/@arco-design/web-vue/es/affix/index.js
var Affix = Object.assign(_Affix, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Affix.name, _Affix);
  }
});

// node_modules/@arco-design/web-vue/es/_components/icon-hover.js
var _sfc_main2 = defineComponent({
  name: "IconHover",
  props: {
    prefix: {
      type: String
    },
    size: {
      type: String,
      default: "medium"
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  setup() {
    const prefixCls = getPrefixCls("icon-hover");
    return {
      prefixCls
    };
  }
});
function _sfc_render2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", {
    class: normalizeClass([
      _ctx.prefixCls,
      {
        [`${_ctx.prefix}-icon-hover`]: _ctx.prefix,
        [`${_ctx.prefixCls}-size-${_ctx.size}`]: _ctx.size !== "medium",
        [`${_ctx.prefixCls}-disabled`]: _ctx.disabled
      }
    ])
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
var IconHover = _export_sfc(_sfc_main2, [["render", _sfc_render2]]);

// node_modules/@arco-design/web-vue/es/icon/icon-close/icon-close.js
var _sfc_main3 = defineComponent({
  name: "IconClose",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-close`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_12 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_2 = createBaseVNode("path", { d: "M9.857 9.858 24 24m0 0 14.142 14.142M24 24 38.142 9.858M24 24 9.857 38.142" }, null, -1);
var _hoisted_3 = [
  _hoisted_2
];
function _sfc_render3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_3, 14, _hoisted_12);
}
var _IconClose = _export_sfc(_sfc_main3, [["render", _sfc_render3]]);

// node_modules/@arco-design/web-vue/es/icon/icon-close/index.js
var IconClose = Object.assign(_IconClose, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconClose.name, _IconClose);
  }
});

// node_modules/@arco-design/web-vue/es/icon/icon-info-circle-fill/icon-info-circle-fill.js
var _sfc_main4 = defineComponent({
  name: "IconInfoCircleFill",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-info-circle-fill`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_13 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_22 = createBaseVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4 4 12.954 4 24s8.954 20 20 20Zm2-30a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-2Zm0 17h1a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1h-6a1 1 0 0 1-1-1v-2a1 1 0 0 1 1-1h1v-8a1 1 0 0 1-1-1v-2a1 1 0 0 1 1-1h3a1 1 0 0 1 1 1v11Z",
  fill: "currentColor",
  stroke: "none"
}, null, -1);
var _hoisted_32 = [
  _hoisted_22
];
function _sfc_render4(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_32, 14, _hoisted_13);
}
var _IconInfoCircleFill = _export_sfc(_sfc_main4, [["render", _sfc_render4]]);

// node_modules/@arco-design/web-vue/es/icon/icon-info-circle-fill/index.js
var IconInfoCircleFill = Object.assign(_IconInfoCircleFill, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconInfoCircleFill.name, _IconInfoCircleFill);
  }
});

// node_modules/@arco-design/web-vue/es/icon/icon-check-circle-fill/icon-check-circle-fill.js
var _sfc_main5 = defineComponent({
  name: "IconCheckCircleFill",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-check-circle-fill`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_14 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_23 = createBaseVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4 4 12.954 4 24s8.954 20 20 20Zm10.207-24.379a1 1 0 0 0 0-1.414l-1.414-1.414a1 1 0 0 0-1.414 0L22 26.172l-4.878-4.88a1 1 0 0 0-1.415 0l-1.414 1.415a1 1 0 0 0 0 1.414l7 7a1 1 0 0 0 1.414 0l11.5-11.5Z",
  fill: "currentColor",
  stroke: "none"
}, null, -1);
var _hoisted_33 = [
  _hoisted_23
];
function _sfc_render5(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_33, 14, _hoisted_14);
}
var _IconCheckCircleFill = _export_sfc(_sfc_main5, [["render", _sfc_render5]]);

// node_modules/@arco-design/web-vue/es/icon/icon-check-circle-fill/index.js
var IconCheckCircleFill = Object.assign(_IconCheckCircleFill, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconCheckCircleFill.name, _IconCheckCircleFill);
  }
});

// node_modules/@arco-design/web-vue/es/icon/icon-exclamation-circle-fill/icon-exclamation-circle-fill.js
var _sfc_main6 = defineComponent({
  name: "IconExclamationCircleFill",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-exclamation-circle-fill`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_15 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_24 = createBaseVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4 4 12.954 4 24s8.954 20 20 20Zm-2-11a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v2Zm4-18a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V15Z",
  fill: "currentColor",
  stroke: "none"
}, null, -1);
var _hoisted_34 = [
  _hoisted_24
];
function _sfc_render6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_34, 14, _hoisted_15);
}
var _IconExclamationCircleFill = _export_sfc(_sfc_main6, [["render", _sfc_render6]]);

// node_modules/@arco-design/web-vue/es/icon/icon-exclamation-circle-fill/index.js
var IconExclamationCircleFill = Object.assign(_IconExclamationCircleFill, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconExclamationCircleFill.name, _IconExclamationCircleFill);
  }
});

// node_modules/@arco-design/web-vue/es/icon/icon-close-circle-fill/icon-close-circle-fill.js
var _sfc_main7 = defineComponent({
  name: "IconCloseCircleFill",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-close-circle-fill`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_16 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_25 = createBaseVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4 4 12.954 4 24s8.954 20 20 20Zm4.955-27.771-4.95 4.95-4.95-4.95a1 1 0 0 0-1.414 0l-1.414 1.414a1 1 0 0 0 0 1.414l4.95 4.95-4.95 4.95a1 1 0 0 0 0 1.414l1.414 1.414a1 1 0 0 0 1.414 0l4.95-4.95 4.95 4.95a1 1 0 0 0 1.414 0l1.414-1.414a1 1 0 0 0 0-1.414l-4.95-4.95 4.95-4.95a1 1 0 0 0 0-1.414l-1.414-1.414a1 1 0 0 0-1.414 0Z",
  fill: "currentColor",
  stroke: "none"
}, null, -1);
var _hoisted_35 = [
  _hoisted_25
];
function _sfc_render7(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_35, 14, _hoisted_16);
}
var _IconCloseCircleFill = _export_sfc(_sfc_main7, [["render", _sfc_render7]]);

// node_modules/@arco-design/web-vue/es/icon/icon-close-circle-fill/index.js
var IconCloseCircleFill = Object.assign(_IconCloseCircleFill, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconCloseCircleFill.name, _IconCloseCircleFill);
  }
});

// node_modules/@arco-design/web-vue/es/alert/alert.js
var _sfc_main8 = defineComponent({
  name: "Alert",
  components: {
    IconHover,
    IconClose,
    IconInfoCircleFill,
    IconCheckCircleFill,
    IconExclamationCircleFill,
    IconCloseCircleFill
  },
  props: {
    type: {
      type: String,
      default: "info"
    },
    showIcon: {
      type: Boolean,
      default: true
    },
    closable: {
      type: Boolean,
      default: false
    },
    title: String,
    banner: {
      type: Boolean,
      default: false
    }
  },
  emits: {
    close: (ev) => true,
    afterClose: () => true
  },
  setup(props, { slots, emit }) {
    const prefixCls = getPrefixCls("alert");
    const visible = ref(true);
    const handleClose = (ev) => {
      visible.value = false;
      emit("close", ev);
    };
    const handleAfterLeave = () => {
      emit("afterClose");
    };
    const cls = computed(() => [
      prefixCls,
      `${prefixCls}-${props.type}`,
      {
        [`${prefixCls}-with-title`]: Boolean(props.title || slots.title),
        [`${prefixCls}-banner`]: props.banner
      }
    ]);
    return {
      prefixCls,
      cls,
      visible,
      handleClose,
      handleAfterLeave
    };
  }
});
function _sfc_render8(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_info_circle_fill = resolveComponent("icon-info-circle-fill");
  const _component_icon_check_circle_fill = resolveComponent("icon-check-circle-fill");
  const _component_icon_exclamation_circle_fill = resolveComponent("icon-exclamation-circle-fill");
  const _component_icon_close_circle_fill = resolveComponent("icon-close-circle-fill");
  const _component_icon_close = resolveComponent("icon-close");
  const _component_icon_hover = resolveComponent("icon-hover");
  return openBlock(), createBlock(Transition, {
    name: "zoom-in-top",
    onAfterLeave: _ctx.handleAfterLeave
  }, {
    default: withCtx(() => [
      _ctx.visible ? (openBlock(), createElementBlock("div", {
        key: 0,
        role: "alert",
        class: normalizeClass(_ctx.cls)
      }, [
        _ctx.showIcon && !(_ctx.type === "normal" && !_ctx.$slots.icon) ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(`${_ctx.prefixCls}-icon`)
        }, [
          renderSlot(_ctx.$slots, "icon", {}, () => [
            _ctx.type === "info" ? (openBlock(), createBlock(_component_icon_info_circle_fill, { key: 0 })) : _ctx.type === "success" ? (openBlock(), createBlock(_component_icon_check_circle_fill, { key: 1 })) : _ctx.type === "warning" ? (openBlock(), createBlock(_component_icon_exclamation_circle_fill, { key: 2 })) : _ctx.type === "error" ? (openBlock(), createBlock(_component_icon_close_circle_fill, { key: 3 })) : createCommentVNode("v-if", true)
          ])
        ], 2)) : createCommentVNode("v-if", true),
        createBaseVNode("div", {
          class: normalizeClass(`${_ctx.prefixCls}-body`)
        }, [
          _ctx.title || _ctx.$slots.title ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(`${_ctx.prefixCls}-title`)
          }, [
            renderSlot(_ctx.$slots, "title", {}, () => [
              createTextVNode(toDisplayString(_ctx.title), 1)
            ])
          ], 2)) : createCommentVNode("v-if", true),
          createBaseVNode("div", {
            class: normalizeClass(`${_ctx.prefixCls}-content`)
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 2)
        ], 2),
        _ctx.$slots.action ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass(`${_ctx.prefixCls}-action`)
        }, [
          renderSlot(_ctx.$slots, "action")
        ], 2)) : createCommentVNode("v-if", true),
        _ctx.closable ? (openBlock(), createElementBlock("div", {
          key: 2,
          tabindex: "-1",
          role: "button",
          "aria-label": "Close",
          class: normalizeClass(`${_ctx.prefixCls}-close-btn`),
          onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClose && _ctx.handleClose(...args))
        }, [
          renderSlot(_ctx.$slots, "close-element", {}, () => [
            createVNode(_component_icon_hover, null, {
              default: withCtx(() => [
                createVNode(_component_icon_close)
              ]),
              _: 1
            })
          ])
        ], 2)) : createCommentVNode("v-if", true)
      ], 2)) : createCommentVNode("v-if", true)
    ]),
    _: 3
  }, 8, ["onAfterLeave"]);
}
var _Alert = _export_sfc(_sfc_main8, [["render", _sfc_render8]]);

// node_modules/@arco-design/web-vue/es/alert/index.js
var Alert = Object.assign(_Alert, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Alert.name, _Alert);
  }
});

// node_modules/compute-scroll-into-view/dist/index.mjs
function t(t2) {
  return "object" == typeof t2 && null != t2 && 1 === t2.nodeType;
}
function e(t2, e2) {
  return (!e2 || "hidden" !== t2) && "visible" !== t2 && "clip" !== t2;
}
function n(t2, n2) {
  if (t2.clientHeight < t2.scrollHeight || t2.clientWidth < t2.scrollWidth) {
    var r2 = getComputedStyle(t2, null);
    return e(r2.overflowY, n2) || e(r2.overflowX, n2) || function(t3) {
      var e2 = function(t4) {
        if (!t4.ownerDocument || !t4.ownerDocument.defaultView)
          return null;
        try {
          return t4.ownerDocument.defaultView.frameElement;
        } catch (t5) {
          return null;
        }
      }(t3);
      return !!e2 && (e2.clientHeight < t3.scrollHeight || e2.clientWidth < t3.scrollWidth);
    }(t2);
  }
  return false;
}
function r(t2, e2, n2, r2, i2, o, l, d) {
  return o < t2 && l > e2 || o > t2 && l < e2 ? 0 : o <= t2 && d <= n2 || l >= e2 && d >= n2 ? o - t2 - r2 : l > e2 && d < n2 || o < t2 && d > n2 ? l - e2 + i2 : 0;
}
var i = function(e2, i2) {
  var o = window, l = i2.scrollMode, d = i2.block, f = i2.inline, h2 = i2.boundary, u = i2.skipOverflowHiddenElements, s = "function" == typeof h2 ? h2 : function(t2) {
    return t2 !== h2;
  };
  if (!t(e2))
    throw new TypeError("Invalid target");
  for (var a, c, g = document.scrollingElement || document.documentElement, p = [], m = e2; t(m) && s(m); ) {
    if ((m = null == (c = (a = m).parentElement) ? a.getRootNode().host || null : c) === g) {
      p.push(m);
      break;
    }
    null != m && m === document.body && n(m) && !n(document.documentElement) || null != m && n(m, u) && p.push(m);
  }
  for (var w = o.visualViewport ? o.visualViewport.width : innerWidth, v = o.visualViewport ? o.visualViewport.height : innerHeight, W = window.scrollX || pageXOffset, H = window.scrollY || pageYOffset, b = e2.getBoundingClientRect(), y = b.height, E = b.width, M = b.top, V = b.right, x = b.bottom, I = b.left, C = "start" === d || "nearest" === d ? M : "end" === d ? x : M + y / 2, R = "center" === f ? I + E / 2 : "end" === f ? V : I, T = [], k = 0; k < p.length; k++) {
    var B = p[k], D = B.getBoundingClientRect(), O = D.height, X = D.width, Y = D.top, L = D.right, S = D.bottom, j = D.left;
    if ("if-needed" === l && M >= 0 && I >= 0 && x <= v && V <= w && M >= Y && x <= S && I >= j && V <= L)
      return T;
    var N = getComputedStyle(B), q = parseInt(N.borderLeftWidth, 10), z = parseInt(N.borderTopWidth, 10), A = parseInt(N.borderRightWidth, 10), F = parseInt(N.borderBottomWidth, 10), G = 0, J = 0, K = "offsetWidth" in B ? B.offsetWidth - B.clientWidth - q - A : 0, P = "offsetHeight" in B ? B.offsetHeight - B.clientHeight - z - F : 0, Q = "offsetWidth" in B ? 0 === B.offsetWidth ? 0 : X / B.offsetWidth : 0, U = "offsetHeight" in B ? 0 === B.offsetHeight ? 0 : O / B.offsetHeight : 0;
    if (g === B)
      G = "start" === d ? C : "end" === d ? C - v : "nearest" === d ? r(H, H + v, v, z, F, H + C, H + C + y, y) : C - v / 2, J = "start" === f ? R : "center" === f ? R - w / 2 : "end" === f ? R - w : r(W, W + w, w, q, A, W + R, W + R + E, E), G = Math.max(0, G + H), J = Math.max(0, J + W);
    else {
      G = "start" === d ? C - Y - z : "end" === d ? C - S + F + P : "nearest" === d ? r(Y, S, O, z, F + P, C, C + y, y) : C - (Y + O / 2) + P / 2, J = "start" === f ? R - j - q : "center" === f ? R - (j + X / 2) + K / 2 : "end" === f ? R - L + A + K : r(j, L, X, q, A + K, R, R + E, E);
      var Z = B.scrollLeft, $ = B.scrollTop;
      C += $ - (G = Math.max(0, Math.min($ + G / U, B.scrollHeight - O / U + P))), R += Z - (J = Math.max(0, Math.min(Z + J / Q, B.scrollWidth - X / Q + K)));
    }
    T.push({ el: B, top: G, left: J });
  }
  return T;
};

// node_modules/b-tween/dist/b-tween.es.js
var easeInBy = function(power) {
  return function(t2) {
    return Math.pow(t2, power);
  };
};
var easeOutBy = function(power) {
  return function(t2) {
    return 1 - Math.abs(Math.pow(t2 - 1, power));
  };
};
var easeInOutBy = function(power) {
  return function(t2) {
    return t2 < 0.5 ? easeInBy(power)(t2 * 2) / 2 : easeOutBy(power)(t2 * 2 - 1) / 2 + 0.5;
  };
};
var linear = function(t2) {
  return t2;
};
var quadIn = easeInBy(2);
var quadOut = easeOutBy(2);
var quadInOut = easeInOutBy(2);
var cubicIn = easeInBy(3);
var cubicOut = easeOutBy(3);
var cubicInOut = easeInOutBy(3);
var quartIn = easeInBy(4);
var quartOut = easeOutBy(4);
var quartInOut = easeInOutBy(4);
var quintIn = easeInBy(5);
var quintOut = easeOutBy(5);
var quintInOut = easeInOutBy(5);
var sineIn = function(t2) {
  return 1 + Math.sin(Math.PI / 2 * t2 - Math.PI / 2);
};
var sineOut = function(t2) {
  return Math.sin(Math.PI / 2 * t2);
};
var sineInOut = function(t2) {
  return (1 + Math.sin(Math.PI * t2 - Math.PI / 2)) / 2;
};
var bounceOut = function(t2) {
  var s = 7.5625;
  var p = 2.75;
  if (t2 < 1 / p) {
    return s * t2 * t2;
  }
  if (t2 < 2 / p) {
    t2 -= 1.5 / p;
    return s * t2 * t2 + 0.75;
  }
  if (t2 < 2.5 / p) {
    t2 -= 2.25 / p;
    return s * t2 * t2 + 0.9375;
  }
  t2 -= 2.625 / p;
  return s * t2 * t2 + 0.984375;
};
var bounceIn = function(t2) {
  return 1 - bounceOut(1 - t2);
};
var bounceInOut = function(t2) {
  return t2 < 0.5 ? bounceIn(t2 * 2) * 0.5 : bounceOut(t2 * 2 - 1) * 0.5 + 0.5;
};
var easing = Object.freeze({
  linear,
  quadIn,
  quadOut,
  quadInOut,
  cubicIn,
  cubicOut,
  cubicInOut,
  quartIn,
  quartOut,
  quartInOut,
  quintIn,
  quintOut,
  quintInOut,
  sineIn,
  sineOut,
  sineInOut,
  bounceOut,
  bounceIn,
  bounceInOut
});
var Tween = function Tween2(settings) {
  var from = settings.from;
  var to = settings.to;
  var duration = settings.duration;
  var delay = settings.delay;
  var easing2 = settings.easing;
  var onStart = settings.onStart;
  var onUpdate = settings.onUpdate;
  var onFinish = settings.onFinish;
  for (var key in from) {
    if (to[key] === void 0) {
      to[key] = from[key];
    }
  }
  for (var key$1 in to) {
    if (from[key$1] === void 0) {
      from[key$1] = to[key$1];
    }
  }
  this.from = from;
  this.to = to;
  this.duration = duration || 500;
  this.delay = delay || 0;
  this.easing = easing2 || "linear";
  this.onStart = onStart;
  this.onUpdate = onUpdate || function() {
  };
  this.onFinish = onFinish;
  this.startTime = Date.now() + this.delay;
  this.started = false;
  this.finished = false;
  this.timer = null;
  this.keys = {};
};
Tween.prototype.update = function update() {
  this.time = Date.now();
  if (this.time < this.startTime) {
    return;
  }
  if (this.finished) {
    return;
  }
  if (this.elapsed === this.duration) {
    if (!this.finished) {
      this.finished = true;
      this.onFinish && this.onFinish(this.keys);
    }
    return;
  }
  this.elapsed = this.time - this.startTime;
  this.elapsed = this.elapsed > this.duration ? this.duration : this.elapsed;
  for (var key in this.to) {
    this.keys[key] = this.from[key] + (this.to[key] - this.from[key]) * easing[this.easing](this.elapsed / this.duration);
  }
  if (!this.started) {
    this.onStart && this.onStart(this.keys);
    this.started = true;
  }
  this.onUpdate(this.keys);
};
Tween.prototype.start = function start() {
  var this$1 = this;
  this.startTime = Date.now() + this.delay;
  var tick = function() {
    this$1.update();
    this$1.timer = requestAnimationFrame(tick);
    if (this$1.finished) {
      cancelAnimationFrame(this$1.timer);
      this$1.timer = null;
    }
  };
  tick();
};
Tween.prototype.stop = function stop() {
  cancelAnimationFrame(this.timer);
  this.timer = null;
};
var b_tween_es_default = Tween;

// node_modules/@arco-design/web-vue/es/anchor/utils.js
function slide(el, top, cb) {
  const tween = new b_tween_es_default({
    from: {
      scrollTop: el.scrollTop
    },
    to: {
      scrollTop: top
    },
    easing: "quartOut",
    duration: 300,
    onUpdate: (keys) => {
      el.scrollTop = keys.scrollTop;
    },
    onFinish: () => {
      if (isFunction(cb)) {
        cb();
      }
    }
  });
  tween.start();
}

// node_modules/@arco-design/web-vue/es/anchor/context.js
var anchorInjectionKey = Symbol("ArcoAnchor");

// node_modules/@arco-design/web-vue/es/anchor/anchor.js
var BOUNDARY_POSITIONS = ["start", "end", "center", "nearest"];
var _sfc_main9 = defineComponent({
  name: "Anchor",
  props: {
    boundary: {
      type: [Number, String],
      default: "start",
      validator: (value) => {
        return isNumber(value) || BOUNDARY_POSITIONS.includes(value);
      }
    },
    lineLess: {
      type: Boolean,
      default: false
    },
    scrollContainer: {
      type: [String, Object]
    },
    changeHash: {
      type: Boolean,
      default: true
    },
    smooth: {
      type: Boolean,
      default: true
    }
  },
  emits: {
    select: (hash, preHash) => true,
    change: (hash) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("anchor");
    const anchorRef = ref();
    const lineSliderRef = ref();
    const links = reactive({});
    const currentLink = ref("");
    const isScrolling = ref(false);
    const scrollContainerEle = ref();
    const containerEle = ref();
    const addLink = (hash, node) => {
      if (!hash)
        return;
      links[hash] = node;
    };
    const removeLink = (hash) => {
      delete links[hash];
    };
    const handleClick = (e2, hash) => {
      if (!props.changeHash) {
        e2.preventDefault();
      }
      if (hash) {
        scrollIntoView2(hash);
        handleAnchorChange(hash);
      }
      emit("select", hash, currentLink.value);
    };
    const scrollIntoView2 = (hash) => {
      try {
        const element = getElement(hash);
        if (!element)
          return;
        let block;
        let diff = 0;
        if (isNumber(props.boundary)) {
          block = "start";
          diff = props.boundary;
        } else {
          block = props.boundary;
        }
        const actions = i(element, { block });
        if (!actions.length)
          return;
        const { el, top } = actions[0];
        const targetTop = top - diff;
        slide(el, targetTop, () => {
          isScrolling.value = false;
        });
        isScrolling.value = true;
      } catch (e2) {
        console.error(e2);
      }
    };
    const handleScroll = throttleByRaf(() => {
      if (isScrolling.value)
        return;
      const element = getFirstInViewportEle();
      if (element && element.id) {
        const hash = `#${element.id}`;
        handleAnchorChange(hash);
      }
    });
    const handleAnchorChange = (hash) => {
      if (!links[hash] && anchorRef.value) {
        const element = getElement(`a[data-href='${hash}']`, anchorRef.value);
        if (!element)
          return;
        links[hash] = element;
      }
      if (hash !== currentLink.value) {
        currentLink.value = hash;
        nextTick(() => {
          emit("change", hash);
        });
      }
    };
    const getFirstInViewportEle = () => {
      if (!scrollContainerEle.value || !containerEle.value) {
        return void 0;
      }
      const boundary = isNumber(props.boundary) ? props.boundary : 0;
      const containerRect = containerEle.value.getBoundingClientRect();
      for (const hash of Object.keys(links)) {
        const element = getElement(hash);
        if (element) {
          const { top } = element.getBoundingClientRect();
          const offsetTop = isWindow(scrollContainerEle.value) ? top - boundary : top - containerRect.top - boundary;
          if (offsetTop >= 0 && offsetTop <= containerRect.height / 2) {
            return element;
          }
        }
      }
      return void 0;
    };
    watch(currentLink, () => {
      const link = links[currentLink.value];
      if (!props.lineLess && link && lineSliderRef.value) {
        lineSliderRef.value.style.top = `${link.offsetTop}px`;
      }
    });
    const bindScrollEvent = () => {
      if (scrollContainerEle.value) {
        on(scrollContainerEle.value, "scroll", handleScroll);
      }
    };
    const unbindScrollEvent = () => {
      if (scrollContainerEle.value) {
        off(scrollContainerEle.value, "scroll", handleScroll);
      }
    };
    const getContainer = () => {
      if (props.scrollContainer) {
        scrollContainerEle.value = isWindow(props.scrollContainer) ? window : getElement(props.scrollContainer);
        containerEle.value = isWindow(props.scrollContainer) ? document.documentElement : getElement(props.scrollContainer);
      } else {
        scrollContainerEle.value = window;
        containerEle.value = document.documentElement;
      }
    };
    onMounted(() => {
      getContainer();
      const hash = decodeURIComponent(window.location.hash);
      if (hash) {
        scrollIntoView2(hash);
        handleAnchorChange(hash);
      } else {
        handleScroll();
      }
      bindScrollEvent();
    });
    onBeforeUnmount(() => {
      unbindScrollEvent();
    });
    provide(anchorInjectionKey, reactive({
      currentLink,
      addLink,
      removeLink,
      handleClick
    }));
    const cls = computed(() => [
      prefixCls,
      {
        [`${prefixCls}-line-less`]: props.lineLess
      }
    ]);
    return {
      prefixCls,
      cls,
      anchorRef,
      lineSliderRef
    };
  }
});
function _sfc_render9(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    ref: "anchorRef",
    class: normalizeClass(_ctx.cls)
  }, [
    !_ctx.lineLess ? (openBlock(), createElementBlock("div", {
      key: 0,
      ref: "lineSliderRef",
      class: normalizeClass(`${_ctx.prefixCls}-line-slider`)
    }, null, 2)) : createCommentVNode("v-if", true),
    createBaseVNode("ul", {
      class: normalizeClass(`${_ctx.prefixCls}-list`)
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 2)
  ], 2);
}
var _Anchor = _export_sfc(_sfc_main9, [["render", _sfc_render9]]);

// node_modules/@arco-design/web-vue/es/anchor/anchor-link.js
var _sfc_main10 = defineComponent({
  name: "AnchorLink",
  props: {
    title: String,
    href: String
  },
  setup(props) {
    const prefixCls = getPrefixCls("anchor");
    const linkCls = `${prefixCls}-link`;
    const linkRef = ref();
    const context = inject(anchorInjectionKey, void 0);
    onMounted(() => {
      if (props.href && linkRef.value) {
        context == null ? void 0 : context.addLink(props.href, linkRef.value);
      }
    });
    const cls = computed(() => [
      `${linkCls}-item`,
      {
        [`${linkCls}-active`]: (context == null ? void 0 : context.currentLink) === props.href
      }
    ]);
    const handleClick = (e2) => context == null ? void 0 : context.handleClick(e2, props.href);
    return {
      prefixCls,
      linkCls,
      cls,
      linkRef,
      handleClick
    };
  }
});
var _hoisted_17 = ["href"];
function _sfc_render10(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("li", {
    ref: "linkRef",
    class: normalizeClass(_ctx.cls)
  }, [
    createBaseVNode("a", {
      class: normalizeClass(_ctx.linkCls),
      href: _ctx.href,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
    }, [
      renderSlot(_ctx.$slots, "default", {}, () => [
        createTextVNode(toDisplayString(_ctx.title), 1)
      ])
    ], 10, _hoisted_17),
    _ctx.$slots.sublist ? (openBlock(), createElementBlock("ul", {
      key: 0,
      class: normalizeClass(`${_ctx.prefixCls}-sublist`)
    }, [
      renderSlot(_ctx.$slots, "sublist")
    ], 2)) : createCommentVNode("v-if", true)
  ], 2);
}
var AnchorLink = _export_sfc(_sfc_main10, [["render", _sfc_render10]]);

// node_modules/@arco-design/web-vue/es/anchor/index.js
var Anchor = Object.assign(_Anchor, {
  Link: AnchorLink,
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Anchor.name, _Anchor);
    app.component(componentPrefix + AnchorLink.name, AnchorLink);
  }
});

// node_modules/@arco-design/web-vue/es/_utils/constant.js
var MESSAGE_TYPES = ["info", "success", "warning", "error"];
var INPUT_EVENTS = [
  "onFocus",
  "onFocusin",
  "onFocusout",
  "onBlur",
  "onChange",
  "onBeforeinput",
  "onInput",
  "onReset",
  "onSubmit",
  "onInvalid",
  "onKeydown",
  "onKeypress",
  "onKeyup",
  "onCopy",
  "onCut",
  "onPaste",
  "onCompositionstart",
  "onCompositionupdate",
  "onCompositionend",
  "onSelect",
  "autocomplete",
  "autofocus",
  "maxlength",
  "minlength",
  "name",
  "pattern",
  "readonly",
  "required"
];

// node_modules/@arco-design/web-vue/es/icon/icon-loading/icon-loading.js
var _sfc_main11 = defineComponent({
  name: "IconLoading",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-loading`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_18 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_26 = createBaseVNode("path", { d: "M42 24c0 9.941-8.059 18-18 18S6 33.941 6 24 14.059 6 24 6" }, null, -1);
var _hoisted_36 = [
  _hoisted_26
];
function _sfc_render11(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_36, 14, _hoisted_18);
}
var _IconLoading = _export_sfc(_sfc_main11, [["render", _sfc_render11]]);

// node_modules/@arco-design/web-vue/es/icon/icon-loading/index.js
var IconLoading = Object.assign(_IconLoading, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconLoading.name, _IconLoading);
  }
});

// node_modules/@arco-design/web-vue/es/_components/feedback-icon.js
var _sfc_main12 = defineComponent({
  name: "FeedbackIcon",
  components: {
    IconLoading,
    IconCheckCircleFill,
    IconExclamationCircleFill,
    IconCloseCircleFill
  },
  props: {
    type: {
      type: String
    }
  },
  setup(props) {
    const prefixCls = getPrefixCls("feedback-icon");
    const cls = computed(() => [
      prefixCls,
      `${prefixCls}-status-${props.type}`
    ]);
    return {
      cls
    };
  }
});
function _sfc_render12(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_loading = resolveComponent("icon-loading");
  const _component_icon_check_circle_fill = resolveComponent("icon-check-circle-fill");
  const _component_icon_exclamation_circle_fill = resolveComponent("icon-exclamation-circle-fill");
  const _component_icon_close_circle_fill = resolveComponent("icon-close-circle-fill");
  return openBlock(), createElementBlock("span", {
    class: normalizeClass(_ctx.cls)
  }, [
    _ctx.type === "validating" ? (openBlock(), createBlock(_component_icon_loading, { key: 0 })) : _ctx.type === "success" ? (openBlock(), createBlock(_component_icon_check_circle_fill, { key: 1 })) : _ctx.type === "warning" ? (openBlock(), createBlock(_component_icon_exclamation_circle_fill, { key: 2 })) : _ctx.type === "error" ? (openBlock(), createBlock(_component_icon_close_circle_fill, { key: 3 })) : createCommentVNode("v-if", true)
  ], 2);
}
var FeedbackIcon = _export_sfc(_sfc_main12, [["render", _sfc_render12]]);

// node_modules/@arco-design/web-vue/es/_utils/keycode.js
var Enter = {
  key: "Enter",
  code: "Enter"
};
var Backspace = {
  key: "Backspace",
  code: "Backspace"
};

// node_modules/@arco-design/web-vue/es/_utils/omit.js
var __defProp3 = Object.defineProperty;
var __getOwnPropSymbols3 = Object.getOwnPropertySymbols;
var __hasOwnProp3 = Object.prototype.hasOwnProperty;
var __propIsEnum3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp3 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues3 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp3.call(b, prop))
      __defNormalProp3(a, prop, b[prop]);
  if (__getOwnPropSymbols3)
    for (var prop of __getOwnPropSymbols3(b)) {
      if (__propIsEnum3.call(b, prop))
        __defNormalProp3(a, prop, b[prop]);
    }
  return a;
};
var omit = (object, path) => {
  const result = __spreadValues3({}, object);
  for (const item of path) {
    if (item in result) {
      delete result[item];
    }
  }
  return result;
};

// node_modules/@arco-design/web-vue/es/_utils/pick.js
function pick(obj, keys) {
  const clone = {};
  keys.forEach((key) => {
    const k = key;
    if (key in obj) {
      clone[k] = obj[k];
    }
  });
  return clone;
}

// node_modules/@arco-design/web-vue/es/form/context.js
var formItemInjectionKey = Symbol("ArcoFormItemContext");
var formInjectionKey = Symbol("ArcoFormContext");

// node_modules/@arco-design/web-vue/es/_hooks/use-form-item.js
var useFormItem = ({
  size,
  disabled,
  error,
  uninject
} = {}) => {
  const formItemCtx = !uninject ? inject(formItemInjectionKey, {}) : {};
  const mergedSize = computed(() => {
    var _a;
    return (_a = size == null ? void 0 : size.value) != null ? _a : formItemCtx.size;
  });
  const mergedDisabled = computed(() => (disabled == null ? void 0 : disabled.value) || formItemCtx.disabled);
  const mergedError = computed(() => (error == null ? void 0 : error.value) || formItemCtx.error);
  const feedback = toRef(formItemCtx, "feedback");
  const eventHandlers = toRef(formItemCtx, "eventHandlers");
  return {
    formItemCtx,
    mergedSize,
    mergedDisabled,
    mergedError,
    feedback,
    eventHandlers
  };
};

// node_modules/@arco-design/web-vue/es/_hooks/use-size.js
var useSize = (size, { defaultValue = "medium" } = {}) => {
  const configProviderCtx = inject(configProviderInjectionKey, void 0);
  const mergedSize = computed(() => {
    var _a, _b;
    return (_b = (_a = size == null ? void 0 : size.value) != null ? _a : configProviderCtx == null ? void 0 : configProviderCtx.size) != null ? _b : defaultValue;
  });
  return {
    mergedSize
  };
};

// node_modules/@arco-design/web-vue/es/_hooks/use-cursor.js
function useCursor(input) {
  const selectionRef = ref();
  function recordCursor() {
    if (!input.value)
      return;
    const { selectionStart, selectionEnd, value } = input.value;
    if (selectionStart == null || selectionEnd == null)
      return;
    const beforeTxt = value.slice(0, Math.max(0, selectionStart));
    const afterTxt = value.slice(Math.max(0, selectionEnd));
    selectionRef.value = {
      selectionStart,
      selectionEnd,
      value,
      beforeTxt,
      afterTxt
    };
  }
  function setCursor() {
    if (!input.value || !selectionRef.value)
      return;
    const { value } = input.value;
    const { beforeTxt, afterTxt, selectionStart } = selectionRef.value;
    if (!beforeTxt || !afterTxt || !selectionStart)
      return;
    let startPos = value.length;
    if (value.endsWith(afterTxt)) {
      startPos = value.length - afterTxt.length;
    } else if (value.startsWith(beforeTxt)) {
      startPos = beforeTxt.length;
    } else {
      const beforeLastChar = beforeTxt[selectionStart - 1];
      const newIndex = value.indexOf(beforeLastChar, selectionStart - 1);
      if (newIndex !== -1) {
        startPos = newIndex + 1;
      }
    }
    input.value.setSelectionRange(startPos, startPos);
  }
  return [recordCursor, setCursor];
}

// node_modules/@arco-design/web-vue/es/input/input.js
var __defProp4 = Object.defineProperty;
var __getOwnPropSymbols4 = Object.getOwnPropertySymbols;
var __hasOwnProp4 = Object.prototype.hasOwnProperty;
var __propIsEnum4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp4 = (obj, key, value) => key in obj ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues4 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp4.call(b, prop))
      __defNormalProp4(a, prop, b[prop]);
  if (__getOwnPropSymbols4)
    for (var prop of __getOwnPropSymbols4(b)) {
      if (__propIsEnum4.call(b, prop))
        __defNormalProp4(a, prop, b[prop]);
    }
  return a;
};
var _Input = defineComponent({
  name: "Input",
  inheritAttrs: false,
  props: {
    modelValue: String,
    defaultValue: {
      type: String,
      default: ""
    },
    size: {
      type: String
    },
    allowClear: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    readonly: {
      type: Boolean,
      default: false
    },
    error: {
      type: Boolean,
      default: false
    },
    placeholder: String,
    maxLength: {
      type: [Number, Object],
      default: 0
    },
    showWordLimit: {
      type: Boolean,
      default: false
    },
    wordLength: {
      type: Function
    },
    wordSlice: {
      type: Function
    },
    inputAttrs: {
      type: Object
    },
    type: {
      type: String,
      default: "text"
    }
  },
  emits: {
    "update:modelValue": (value) => true,
    "input": (value, ev) => true,
    "change": (value, ev) => true,
    "pressEnter": (ev) => true,
    "clear": (ev) => true,
    "focus": (ev) => true,
    "blur": (ev) => true
  },
  setup(props, {
    emit,
    slots,
    attrs
  }) {
    const {
      size,
      disabled,
      error,
      modelValue
    } = toRefs(props);
    const prefixCls = getPrefixCls("input");
    const inputRef = ref();
    const {
      mergedSize: _mergedSize,
      mergedDisabled,
      mergedError: _mergedError,
      feedback,
      eventHandlers
    } = useFormItem({
      size,
      disabled,
      error
    });
    const {
      mergedSize
    } = useSize(_mergedSize);
    const [recordCursor, setCursor] = useCursor(inputRef);
    const _value = ref(props.defaultValue);
    const computedValue = computed(() => {
      var _a;
      return (_a = props.modelValue) != null ? _a : _value.value;
    });
    watch(modelValue, (value) => {
      if (isUndefined(value) || isNull(value)) {
        _value.value = "";
      }
    });
    let preValue = computedValue.value;
    const focused = ref(false);
    const showClearBtn = computed(() => props.allowClear && !mergedDisabled.value && Boolean(computedValue.value));
    const isComposition = ref(false);
    const compositionValue = ref("");
    const getValueLength = (value) => {
      var _a;
      if (isFunction(props.wordLength)) {
        return props.wordLength(value);
      }
      return (_a = value.length) != null ? _a : 0;
    };
    const valueLength = computed(() => getValueLength(computedValue.value));
    const mergedError = computed(() => _mergedError.value || Boolean(isObject(props.maxLength) && props.maxLength.errorOnly && valueLength.value > maxLength.value));
    const maxLengthErrorOnly = computed(() => isObject(props.maxLength) && Boolean(props.maxLength.errorOnly));
    const maxLength = computed(() => {
      if (isObject(props.maxLength)) {
        return props.maxLength.length;
      }
      return props.maxLength;
    });
    const updateValue = (value) => {
      var _a, _b;
      if (maxLength.value && !maxLengthErrorOnly.value && getValueLength(value) > maxLength.value) {
        value = (_b = (_a = props.wordSlice) == null ? void 0 : _a.call(props, value, maxLength.value)) != null ? _b : value.slice(0, maxLength.value);
      }
      _value.value = value;
      emit("update:modelValue", value);
    };
    const handleMousedown = (e2) => {
      if (inputRef.value && e2.target !== inputRef.value) {
        e2.preventDefault();
        inputRef.value.focus();
      }
    };
    const emitChange = (value, ev) => {
      var _a, _b;
      if (value !== preValue) {
        preValue = value;
        emit("change", value, ev);
        (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onChange) == null ? void 0 : _b.call(_a, ev);
      }
    };
    const handleFocus = (ev) => {
      var _a, _b;
      focused.value = true;
      preValue = computedValue.value;
      emit("focus", ev);
      (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onFocus) == null ? void 0 : _b.call(_a, ev);
    };
    const handleBlur = (ev) => {
      var _a, _b;
      focused.value = false;
      emitChange(computedValue.value, ev);
      emit("blur", ev);
      (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onBlur) == null ? void 0 : _b.call(_a, ev);
    };
    const handleComposition = (e2) => {
      var _a, _b, _c;
      const {
        value,
        selectionStart,
        selectionEnd
      } = e2.target;
      if (e2.type === "compositionend") {
        isComposition.value = false;
        compositionValue.value = "";
        if (maxLength.value && !maxLengthErrorOnly.value && computedValue.value.length >= maxLength.value && getValueLength(value) > maxLength.value && selectionStart === selectionEnd) {
          keepControl();
          return;
        }
        updateValue(value);
        emit("input", value, e2);
        (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onInput) == null ? void 0 : _b.call(_a, e2);
        keepControl();
      } else {
        isComposition.value = true;
        compositionValue.value = computedValue.value + ((_c = e2.data) != null ? _c : "");
      }
    };
    const keepControl = () => {
      recordCursor();
      nextTick(() => {
        if (inputRef.value && computedValue.value !== inputRef.value.value) {
          inputRef.value.value = computedValue.value;
          setCursor();
        }
      });
    };
    const handleInput = (e2) => {
      var _a, _b;
      const {
        value
      } = e2.target;
      if (!isComposition.value) {
        if (maxLength.value && !maxLengthErrorOnly.value && (computedValue.value.length >= maxLength.value || getValueLength(value) > maxLength.value) && e2.inputType === "insertText") {
          keepControl();
          return;
        }
        updateValue(value);
        emit("input", value, e2);
        (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onInput) == null ? void 0 : _b.call(_a, e2);
        keepControl();
      }
    };
    const handleClear = (ev) => {
      updateValue("");
      emitChange("", ev);
      emit("clear", ev);
    };
    const handleKeyDown = (e2) => {
      const keyCode = e2.key || e2.code;
      if (!isComposition.value && keyCode === Enter.key) {
        emitChange(computedValue.value, e2);
        emit("pressEnter", e2);
      }
    };
    const outerCls = computed(() => [`${prefixCls}-outer`, `${prefixCls}-outer-size-${mergedSize.value}`, {
      [`${prefixCls}-outer-has-suffix`]: Boolean(slots.suffix),
      [`${prefixCls}-outer-disabled`]: mergedDisabled.value
    }]);
    const wrapperCls = computed(() => [`${prefixCls}-wrapper`, {
      [`${prefixCls}-error`]: mergedError.value,
      [`${prefixCls}-disabled`]: mergedDisabled.value,
      [`${prefixCls}-focus`]: focused.value
    }]);
    const cls = computed(() => [prefixCls, `${prefixCls}-size-${mergedSize.value}`]);
    const wrapperAttrs = computed(() => omit(attrs, INPUT_EVENTS));
    const inputAttrs = computed(() => pick(attrs, INPUT_EVENTS));
    const mergeInputAttrs = computed(() => {
      const attrs2 = __spreadValues4(__spreadValues4({}, inputAttrs.value), props.inputAttrs);
      if (mergedError.value) {
        attrs2["aria-invalid"] = true;
      }
      return attrs2;
    });
    const renderInput = (hasOuter) => {
      var _a;
      return createVNode("span", mergeProps({
        "class": wrapperCls.value,
        "onMousedown": handleMousedown
      }, !hasOuter ? wrapperAttrs.value : void 0), [slots.prefix && createVNode("span", {
        "class": `${prefixCls}-prefix`
      }, [slots.prefix()]), createVNode("input", mergeProps(mergeInputAttrs.value, {
        "ref": inputRef,
        "class": cls.value,
        "value": computedValue.value,
        "type": props.type,
        "placeholder": props.placeholder,
        "readonly": props.readonly,
        "disabled": mergedDisabled.value,
        "onInput": handleInput,
        "onKeydown": handleKeyDown,
        "onFocus": handleFocus,
        "onBlur": handleBlur,
        "onCompositionstart": handleComposition,
        "onCompositionupdate": handleComposition,
        "onCompositionend": handleComposition
      }), null), showClearBtn.value && createVNode(IconHover, {
        "prefix": prefixCls,
        "class": `${prefixCls}-clear-btn`,
        "onClick": handleClear
      }, {
        default: () => [createVNode(IconClose, null, null)]
      }), (slots.suffix || Boolean(props.maxLength) && props.showWordLimit || Boolean(feedback.value)) && createVNode("span", {
        "class": [`${prefixCls}-suffix`, {
          [`${prefixCls}-suffix-has-feedback`]: feedback.value
        }]
      }, [Boolean(props.maxLength) && props.showWordLimit && createVNode("span", {
        "class": `${prefixCls}-word-limit`
      }, [valueLength.value, createTextVNode("/"), maxLength.value]), (_a = slots.suffix) == null ? void 0 : _a.call(slots), Boolean(feedback.value) && createVNode(FeedbackIcon, {
        "type": feedback.value
      }, null)])]);
    };
    const render2 = () => {
      if (slots.prepend || slots.append) {
        return createVNode("span", mergeProps({
          "class": outerCls.value
        }, wrapperAttrs.value), [slots.prepend && createVNode("span", {
          "class": `${prefixCls}-prepend`
        }, [slots.prepend()]), renderInput(true), slots.append && createVNode("span", {
          "class": `${prefixCls}-append`
        }, [slots.append()])]);
      }
      return renderInput();
    };
    return {
      inputRef,
      render: render2
    };
  },
  methods: {
    focus() {
      var _a;
      (_a = this.inputRef) == null ? void 0 : _a.focus();
    },
    blur() {
      var _a;
      (_a = this.inputRef) == null ? void 0 : _a.blur();
    }
  },
  render() {
    return this.render();
  }
});

// node_modules/@arco-design/web-vue/es/icon/icon-search/icon-search.js
var _sfc_main13 = defineComponent({
  name: "IconSearch",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-search`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_19 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_27 = createBaseVNode("path", { d: "M33.072 33.071c6.248-6.248 6.248-16.379 0-22.627-6.249-6.249-16.38-6.249-22.628 0-6.248 6.248-6.248 16.379 0 22.627 6.248 6.248 16.38 6.248 22.628 0Zm0 0 8.485 8.485" }, null, -1);
var _hoisted_37 = [
  _hoisted_27
];
function _sfc_render13(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_37, 14, _hoisted_19);
}
var _IconSearch = _export_sfc(_sfc_main13, [["render", _sfc_render13]]);

// node_modules/@arco-design/web-vue/es/icon/icon-search/index.js
var IconSearch = Object.assign(_IconSearch, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconSearch.name, _IconSearch);
  }
});

// node_modules/@arco-design/web-vue/es/button/context.js
var buttonGroupInjectionKey = Symbol("ArcoButtonGroup");

// node_modules/@arco-design/web-vue/es/button/button.js
var _sfc_main14 = defineComponent({
  name: "Button",
  components: {
    IconLoading
  },
  props: {
    type: {
      type: String
    },
    shape: {
      type: String
    },
    status: {
      type: String
    },
    size: {
      type: String
    },
    long: {
      type: Boolean,
      default: false
    },
    loading: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean
    },
    htmlType: {
      type: String,
      default: "button"
    },
    href: String
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const { size, disabled } = toRefs(props);
    const prefixCls = getPrefixCls("btn");
    const groupContext = inject(buttonGroupInjectionKey, void 0);
    const _size = computed(() => {
      var _a;
      return (_a = size.value) != null ? _a : groupContext == null ? void 0 : groupContext.size;
    });
    const _disabled = computed(() => Boolean(disabled.value || (groupContext == null ? void 0 : groupContext.disabled)));
    const { mergedSize: _mergedSize, mergedDisabled } = useFormItem({
      size: _size,
      disabled: _disabled
    });
    const { mergedSize } = useSize(_mergedSize);
    const cls = computed(() => {
      var _a, _b, _c, _d, _e, _f;
      return [
        prefixCls,
        `${prefixCls}-${(_b = (_a = props.type) != null ? _a : groupContext == null ? void 0 : groupContext.type) != null ? _b : "secondary"}`,
        `${prefixCls}-shape-${(_d = (_c = props.shape) != null ? _c : groupContext == null ? void 0 : groupContext.shape) != null ? _d : "square"}`,
        `${prefixCls}-size-${mergedSize.value}`,
        `${prefixCls}-status-${(_f = (_e = props.status) != null ? _e : groupContext == null ? void 0 : groupContext.status) != null ? _f : "normal"}`,
        {
          [`${prefixCls}-long`]: props.long,
          [`${prefixCls}-loading`]: props.loading,
          [`${prefixCls}-disabled`]: mergedDisabled.value,
          [`${prefixCls}-link`]: isString(props.href)
        }
      ];
    });
    const handleClick = (ev) => {
      if (props.disabled || props.loading) {
        ev.preventDefault();
        return;
      }
      emit("click", ev);
    };
    return {
      prefixCls,
      cls,
      mergedDisabled,
      handleClick
    };
  }
});
var _hoisted_110 = ["href"];
var _hoisted_28 = ["type", "disabled"];
function _sfc_render14(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_loading = resolveComponent("icon-loading");
  return _ctx.href ? (openBlock(), createElementBlock("a", {
    key: 0,
    class: normalizeClass([
      _ctx.cls,
      { [`${_ctx.prefixCls}-only-icon`]: _ctx.$slots.icon && !_ctx.$slots.default }
    ]),
    href: _ctx.mergedDisabled || _ctx.loading ? void 0 : _ctx.href,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    _ctx.loading || _ctx.$slots.icon ? (openBlock(), createElementBlock("span", {
      key: 0,
      class: normalizeClass(`${_ctx.prefixCls}-icon`)
    }, [
      _ctx.loading ? (openBlock(), createBlock(_component_icon_loading, {
        key: 0,
        spin: "true"
      })) : renderSlot(_ctx.$slots, "icon", { key: 1 })
    ], 2)) : createCommentVNode("v-if", true),
    renderSlot(_ctx.$slots, "default")
  ], 10, _hoisted_110)) : (openBlock(), createElementBlock("button", {
    key: 1,
    class: normalizeClass([
      _ctx.cls,
      { [`${_ctx.prefixCls}-only-icon`]: _ctx.$slots.icon && !_ctx.$slots.default }
    ]),
    type: _ctx.htmlType,
    disabled: _ctx.mergedDisabled,
    onClick: _cache[1] || (_cache[1] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    _ctx.loading || _ctx.$slots.icon ? (openBlock(), createElementBlock("span", {
      key: 0,
      class: normalizeClass(`${_ctx.prefixCls}-icon`)
    }, [
      _ctx.loading ? (openBlock(), createBlock(_component_icon_loading, {
        key: 0,
        spin: true
      })) : renderSlot(_ctx.$slots, "icon", { key: 1 })
    ], 2)) : createCommentVNode("v-if", true),
    renderSlot(_ctx.$slots, "default")
  ], 10, _hoisted_28));
}
var _Button = _export_sfc(_sfc_main14, [["render", _sfc_render14]]);

// node_modules/@arco-design/web-vue/es/button/button-group.js
var _sfc_main15 = defineComponent({
  name: "ButtonGroup",
  props: {
    type: {
      type: String
    },
    status: {
      type: String
    },
    shape: {
      type: String
    },
    size: {
      type: String
    },
    disabled: {
      type: Boolean
    }
  },
  setup(props) {
    const { type, size, status, disabled, shape } = toRefs(props);
    const prefixCls = getPrefixCls("btn-group");
    provide(buttonGroupInjectionKey, reactive({
      type,
      size,
      shape,
      status,
      disabled
    }));
    return {
      prefixCls
    };
  }
});
function _sfc_render15(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.prefixCls)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
var ButtonGroup = _export_sfc(_sfc_main15, [["render", _sfc_render15]]);

// node_modules/@arco-design/web-vue/es/button/index.js
var Button = Object.assign(_Button, {
  Group: ButtonGroup,
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Button.name, _Button);
    app.component(componentPrefix + ButtonGroup.name, ButtonGroup);
  }
});

// node_modules/@arco-design/web-vue/es/input/input-search.js
var InputSearch = defineComponent({
  name: "InputSearch",
  props: {
    searchButton: {
      type: Boolean,
      default: false
    },
    loading: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    size: {
      type: String
    },
    buttonText: {
      type: String
    },
    buttonProps: {
      type: Object
    }
  },
  emits: {
    search: (value, ev) => true
  },
  setup(props, {
    emit,
    slots
  }) {
    const {
      size
    } = toRefs(props);
    const prefixCls = getPrefixCls("input-search");
    const {
      mergedSize
    } = useSize(size);
    const inputRef = ref();
    const handleClick = (e2) => {
      if (inputRef.value.inputRef) {
        emit("search", inputRef.value.inputRef.value, e2);
      }
    };
    const renderSuffix = () => {
      var _a;
      return createVNode(Fragment, null, [props.loading ? createVNode(IconLoading, null, null) : createVNode(IconHover, {
        "onClick": handleClick
      }, {
        default: () => [createVNode(IconSearch, null, null)]
      }), (_a = slots.suffix) == null ? void 0 : _a.call(slots)]);
    };
    const renderButton = () => {
      var _a;
      let _slots = {};
      if (props.buttonText || slots["button-default"] || slots["button-icon"]) {
        _slots = {
          default: (_a = slots["button-default"]) != null ? _a : props.buttonText ? () => props.buttonText : void 0,
          icon: slots["button-icon"]
        };
      } else {
        _slots = {
          icon: () => createVNode(IconSearch, null, null)
        };
      }
      return createVNode(Button, mergeProps({
        "type": "primary",
        "class": `${prefixCls}-btn`,
        "disabled": props.disabled,
        "size": mergedSize.value,
        "loading": props.loading
      }, props.buttonProps, {
        "onClick": handleClick
      }), _slots);
    };
    const render2 = () => createVNode(_Input, {
      "ref": inputRef,
      "class": prefixCls,
      "size": mergedSize.value,
      "disabled": props.disabled
    }, {
      prepend: slots.prepend,
      prefix: slots.prefix,
      suffix: props.searchButton ? slots.suffix : renderSuffix,
      append: props.searchButton ? renderButton : slots.append
    });
    return {
      inputRef,
      render: render2
    };
  },
  methods: {
    focus() {
      var _a;
      (_a = this.inputRef) == null ? void 0 : _a.focus();
    },
    blur() {
      var _a;
      (_a = this.inputRef) == null ? void 0 : _a.blur();
    }
  },
  render() {
    return this.render();
  }
});

// node_modules/@arco-design/web-vue/es/icon/icon-eye/icon-eye.js
var _sfc_main16 = defineComponent({
  name: "IconEye",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-eye`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_111 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_29 = createBaseVNode("path", {
  "clip-rule": "evenodd",
  d: "M24 37c6.627 0 12.627-4.333 18-13-5.373-8.667-11.373-13-18-13-6.627 0-12.627 4.333-18 13 5.373 8.667 11.373 13 18 13Z"
}, null, -1);
var _hoisted_38 = createBaseVNode("path", { d: "M29 24a5 5 0 1 1-10 0 5 5 0 0 1 10 0Z" }, null, -1);
var _hoisted_4 = [
  _hoisted_29,
  _hoisted_38
];
function _sfc_render16(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_4, 14, _hoisted_111);
}
var _IconEye = _export_sfc(_sfc_main16, [["render", _sfc_render16]]);

// node_modules/@arco-design/web-vue/es/icon/icon-eye/index.js
var IconEye = Object.assign(_IconEye, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconEye.name, _IconEye);
  }
});

// node_modules/@arco-design/web-vue/es/icon/icon-eye-invisible/icon-eye-invisible.js
var _sfc_main17 = defineComponent({
  name: "IconEyeInvisible",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-eye-invisible`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_112 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_210 = createBaseVNode("path", { d: "M14 14.5c-2.69 2-5.415 5.33-8 9.5 5.373 8.667 11.373 13 18 13 3.325 0 6.491-1.09 9.5-3.271M17.463 12.5C19 11 21.75 11 24 11c6.627 0 12.627 4.333 18 13-1.766 2.848-3.599 5.228-5.5 7.14" }, null, -1);
var _hoisted_39 = createBaseVNode("path", { d: "M29 24a5 5 0 1 1-10 0 5 5 0 0 1 10 0ZM6.852 7.103l34.294 34.294" }, null, -1);
var _hoisted_42 = [
  _hoisted_210,
  _hoisted_39
];
function _sfc_render17(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_42, 14, _hoisted_112);
}
var _IconEyeInvisible = _export_sfc(_sfc_main17, [["render", _sfc_render17]]);

// node_modules/@arco-design/web-vue/es/icon/icon-eye-invisible/index.js
var IconEyeInvisible = Object.assign(_IconEyeInvisible, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconEyeInvisible.name, _IconEyeInvisible);
  }
});

// node_modules/@arco-design/web-vue/es/input/input-password.js
var _sfc_main18 = defineComponent({
  name: "InputPassword",
  components: {
    IconEye,
    IconEyeInvisible,
    AIconHover: IconHover,
    AInput: _Input
  },
  props: {
    invisibleButton: {
      type: Boolean,
      default: true
    }
  },
  setup() {
    const inputRef = ref();
    const invisible = ref(true);
    const handleInvisible = () => {
      invisible.value = !invisible.value;
    };
    return {
      inputRef,
      invisible,
      handleInvisible
    };
  },
  methods: {
    focus() {
      var _a;
      (_a = this.inputRef) == null ? void 0 : _a.focus();
    },
    blur() {
      var _a;
      (_a = this.inputRef) == null ? void 0 : _a.blur();
    }
  }
});
function _sfc_render18(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_eye = resolveComponent("icon-eye");
  const _component_icon_eye_invisible = resolveComponent("icon-eye-invisible");
  const _component_a_icon_hover = resolveComponent("a-icon-hover");
  const _component_a_input = resolveComponent("a-input");
  return openBlock(), createBlock(_component_a_input, {
    ref: "inputRef",
    type: _ctx.invisible ? "password" : "text"
  }, createSlots({ _: 2 }, [
    _ctx.$slots.prepend ? {
      name: "prepend",
      fn: withCtx(() => [
        renderSlot(_ctx.$slots, "prepend")
      ])
    } : void 0,
    _ctx.$slots.prefix ? {
      name: "prefix",
      fn: withCtx(() => [
        renderSlot(_ctx.$slots, "prefix")
      ])
    } : void 0,
    _ctx.invisibleButton || _ctx.$slots.suffix ? {
      name: "suffix",
      fn: withCtx(() => [
        _ctx.invisibleButton ? (openBlock(), createBlock(_component_a_icon_hover, {
          key: 0,
          onClick: _ctx.handleInvisible,
          onMousedown: _cache[0] || (_cache[0] = withModifiers(() => {
          }, ["prevent"])),
          onMouseup: _cache[1] || (_cache[1] = withModifiers(() => {
          }, ["prevent"]))
        }, {
          default: withCtx(() => [
            !_ctx.invisible ? (openBlock(), createBlock(_component_icon_eye, { key: 0 })) : (openBlock(), createBlock(_component_icon_eye_invisible, { key: 1 }))
          ]),
          _: 1
        }, 8, ["onClick"])) : createCommentVNode("v-if", true),
        renderSlot(_ctx.$slots, "suffix")
      ])
    } : void 0,
    _ctx.$slots.append ? {
      name: "append",
      fn: withCtx(() => [
        renderSlot(_ctx.$slots, "append")
      ])
    } : void 0
  ]), 1032, ["type"]);
}
var InputPassword = _export_sfc(_sfc_main18, [["render", _sfc_render18]]);

// node_modules/@arco-design/web-vue/es/input/input-group.js
var _sfc_main19 = defineComponent({
  name: "InputGroup",
  setup() {
    const prefixCls = getPrefixCls("input-group");
    return {
      prefixCls
    };
  }
});
function _sfc_render19(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.prefixCls)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
var InputGroup = _export_sfc(_sfc_main19, [["render", _sfc_render19]]);

// node_modules/@arco-design/web-vue/es/input/index.js
var Input = Object.assign(_Input, {
  Search: InputSearch,
  Password: InputPassword,
  Group: InputGroup,
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Input.name, _Input);
    app.component(componentPrefix + InputGroup.name, InputGroup);
    app.component(componentPrefix + InputSearch.name, InputSearch);
    app.component(componentPrefix + InputPassword.name, InputPassword);
  }
});

// node_modules/@arco-design/web-vue/es/trigger/utils.js
var __defProp5 = Object.defineProperty;
var __getOwnPropSymbols5 = Object.getOwnPropertySymbols;
var __hasOwnProp5 = Object.prototype.hasOwnProperty;
var __propIsEnum5 = Object.prototype.propertyIsEnumerable;
var __defNormalProp5 = (obj, key, value) => key in obj ? __defProp5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues5 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp5.call(b, prop))
      __defNormalProp5(a, prop, b[prop]);
  if (__getOwnPropSymbols5)
    for (var prop of __getOwnPropSymbols5(b)) {
      if (__propIsEnum5.call(b, prop))
        __defNormalProp5(a, prop, b[prop]);
    }
  return a;
};
var getViewPortSize = () => {
  return {
    width: document.documentElement.clientWidth || window.innerWidth,
    height: document.documentElement.clientHeight || window.innerHeight
  };
};
var getElementScrollRect = (element, containerRect) => {
  var _a, _b;
  const rect = element.getBoundingClientRect();
  return {
    top: rect.top,
    bottom: rect.bottom,
    left: rect.left,
    right: rect.right,
    scrollTop: rect.top - containerRect.top,
    scrollBottom: rect.bottom - containerRect.top,
    scrollLeft: rect.left - containerRect.left,
    scrollRight: rect.right - containerRect.left,
    width: (_a = element.offsetWidth) != null ? _a : element.clientWidth,
    height: (_b = element.offsetHeight) != null ? _b : element.clientHeight
  };
};
var getBoundaryPosition = (position) => {
  switch (position) {
    case "top":
    case "tl":
    case "tr":
      return "top";
    case "bottom":
    case "bl":
    case "br":
      return "bottom";
    case "left":
    case "lt":
    case "lb":
      return "left";
    case "right":
    case "rt":
    case "rb":
      return "right";
    default:
      return "top";
  }
};
var changePosition = (position, direction) => {
  switch (direction) {
    case "top":
      switch (position) {
        case "bottom":
          return "top";
        case "bl":
          return "tl";
        case "br":
          return "tr";
        default:
          return position;
      }
    case "bottom":
      switch (position) {
        case "top":
          return "bottom";
        case "tl":
          return "bl";
        case "tr":
          return "br";
        default:
          return position;
      }
    case "left":
      switch (position) {
        case "right":
          return "left";
        case "rt":
          return "lt";
        case "rb":
          return "lb";
        default:
          return position;
      }
    case "right":
      switch (position) {
        case "left":
          return "right";
        case "lt":
          return "rt";
        case "lb":
          return "rb";
        default:
          return position;
      }
    default:
      return position;
  }
};
var getFitPosition = (position, popupPosition, {
  containerRect,
  triggerRect,
  popupRect,
  offset,
  translate
}) => {
  const direction = getBoundaryPosition(position);
  const viewPortSize = getViewPortSize();
  const viewPortBoundary = {
    top: containerRect.top + popupPosition.top,
    bottom: viewPortSize.height - (containerRect.top + popupPosition.top + popupRect.height),
    left: containerRect.left + popupPosition.left,
    right: viewPortSize.width - (containerRect.left + popupPosition.left + popupRect.width)
  };
  let finalPosition = position;
  if (direction === "top" && viewPortBoundary.top < 0) {
    if (triggerRect.top > popupRect.height) {
      popupPosition.top = -containerRect.top;
    } else {
      const fitPosition = getPopupOffset("bottom", triggerRect, popupRect, {
        offset,
        translate
      });
      if (viewPortSize.height - (containerRect.top + fitPosition.top + popupRect.height) > 0) {
        finalPosition = changePosition(position, "bottom");
        popupPosition.top = fitPosition.top;
      }
    }
  }
  if (direction === "bottom" && viewPortBoundary.bottom < 0) {
    if (viewPortSize.height - triggerRect.bottom > popupRect.height) {
      popupPosition.top = -containerRect.top + (viewPortSize.height - popupRect.height);
    } else {
      const fitPosition = getPopupOffset("top", triggerRect, popupRect, {
        offset,
        translate
      });
      if (containerRect.top + fitPosition.top > 0) {
        finalPosition = changePosition(position, "top");
        popupPosition.top = fitPosition.top;
      }
    }
  }
  if (direction === "left" && viewPortBoundary.left < 0) {
    if (triggerRect.left > popupRect.width) {
      popupPosition.left = -containerRect.left;
    } else {
      const fitPosition = getPopupOffset("right", triggerRect, popupRect, {
        offset,
        translate
      });
      if (viewPortSize.width - (containerRect.left + fitPosition.left + popupRect.width) > 0) {
        finalPosition = changePosition(position, "right");
        popupPosition.left = fitPosition.left;
      }
    }
  }
  if (direction === "right" && viewPortBoundary.right < 0) {
    if (viewPortSize.width - triggerRect.right > popupRect.width) {
      popupPosition.left = -containerRect.left + (viewPortSize.width - popupRect.width);
    } else {
      const fitPosition = getPopupOffset("left", triggerRect, popupRect, {
        offset,
        translate
      });
      if (containerRect.left + fitPosition.left > 0) {
        finalPosition = changePosition(position, "left");
        popupPosition.left = fitPosition.left;
      }
    }
  }
  if (direction === "top" || direction === "bottom") {
    if (viewPortBoundary.left < 0) {
      popupPosition.left = -containerRect.left;
    } else if (viewPortBoundary.right < 0) {
      popupPosition.left = -containerRect.left + (viewPortSize.width - popupRect.width);
    }
  }
  if (direction === "left" || direction === "right") {
    if (viewPortBoundary.top < 0) {
      popupPosition.top = -containerRect.top;
    } else if (viewPortBoundary.bottom < 0) {
      popupPosition.top = -containerRect.top + (viewPortSize.height - popupRect.height);
    }
  }
  return {
    popupPosition,
    position: finalPosition
  };
};
var getPopupOffset = (position, triggerRect, popupRect, {
  offset = 0,
  translate = [0, 0]
} = {}) => {
  var _a;
  const _translate = (_a = isArray(translate) ? translate : translate[position]) != null ? _a : [0, 0];
  switch (position) {
    case "top":
      return {
        left: triggerRect.scrollLeft + Math.round(triggerRect.width / 2) - Math.round(popupRect.width / 2) + _translate[0],
        top: triggerRect.scrollTop - popupRect.height - offset + _translate[1]
      };
    case "tl":
      return {
        left: triggerRect.scrollLeft + _translate[0],
        top: triggerRect.scrollTop - popupRect.height - offset + _translate[1]
      };
    case "tr":
      return {
        left: triggerRect.scrollRight - popupRect.width + _translate[0],
        top: triggerRect.scrollTop - popupRect.height - offset + _translate[1]
      };
    case "bottom":
      return {
        left: triggerRect.scrollLeft + Math.round(triggerRect.width / 2) - Math.round(popupRect.width / 2) + _translate[0],
        top: triggerRect.scrollBottom + offset + _translate[1]
      };
    case "bl":
      return {
        left: triggerRect.scrollLeft + _translate[0],
        top: triggerRect.scrollBottom + offset + _translate[1]
      };
    case "br":
      return {
        left: triggerRect.scrollRight - popupRect.width + _translate[0],
        top: triggerRect.scrollBottom + offset + _translate[1]
      };
    case "left":
      return {
        left: triggerRect.scrollLeft - popupRect.width - offset + _translate[0],
        top: triggerRect.scrollTop + Math.round(triggerRect.height / 2) - Math.round(popupRect.height / 2) + _translate[1]
      };
    case "lt":
      return {
        left: triggerRect.scrollLeft - popupRect.width - offset + _translate[0],
        top: triggerRect.scrollTop + _translate[1]
      };
    case "lb":
      return {
        left: triggerRect.scrollLeft - popupRect.width - offset + _translate[0],
        top: triggerRect.scrollBottom - popupRect.height + _translate[1]
      };
    case "right":
      return {
        left: triggerRect.scrollRight + offset + _translate[0],
        top: triggerRect.scrollTop + Math.round(triggerRect.height / 2) - Math.round(popupRect.height / 2) + _translate[1]
      };
    case "rt":
      return {
        left: triggerRect.scrollRight + offset + _translate[0],
        top: triggerRect.scrollTop + _translate[1]
      };
    case "rb":
      return {
        left: triggerRect.scrollRight + offset + _translate[0],
        top: triggerRect.scrollBottom - popupRect.height + _translate[1]
      };
    default:
      return {
        left: 0,
        top: 0
      };
  }
};
var getTransformOrigin = (position) => {
  let originX = "0";
  if (["top", "bottom"].includes(position)) {
    originX = "50%";
  } else if (["left", "lt", "lb", "tr", "br"].includes(position)) {
    originX = "100%";
  }
  let originY = "0";
  if (["left", "right"].includes(position)) {
    originY = "50%";
  } else if (["top", "tl", "tr", "lt", "rt"].includes(position)) {
    originY = "100%";
  }
  return `${originX} ${originY}`;
};
var getPopupStyle = (position, containerRect, triggerRect, popupRect, {
  offset = 0,
  translate = [0, 0],
  customStyle = {},
  autoFitPosition = false
} = {}) => {
  let finalPosition = position;
  let popupPosition = getPopupOffset(position, triggerRect, popupRect, {
    offset,
    translate
  });
  if (autoFitPosition) {
    const result = getFitPosition(position, popupPosition, {
      containerRect,
      popupRect,
      triggerRect,
      offset,
      translate
    });
    popupPosition = result.popupPosition;
    finalPosition = result.position;
  }
  const style = __spreadValues5({
    left: `${popupPosition.left}px`,
    top: `${popupPosition.top}px`
  }, customStyle);
  return {
    style,
    position: finalPosition
  };
};
var getArrowStyle = (position, triggerRect, popupRect, {
  customStyle = {}
}) => {
  if (["top", "tl", "tr", "bottom", "bl", "br"].includes(position)) {
    let offsetLeft = Math.abs(triggerRect.scrollLeft + triggerRect.width / 2 - popupRect.scrollLeft);
    if (offsetLeft > popupRect.width - 8) {
      if (triggerRect.width > popupRect.width) {
        offsetLeft = popupRect.width / 2;
      } else {
        offsetLeft = popupRect.width - 8;
      }
    }
    if (["top", "tl", "tr"].includes(position)) {
      return __spreadValues5({
        left: `${offsetLeft}px`,
        bottom: "0",
        transform: "translate(-50%,50%) rotate(45deg)"
      }, customStyle);
    }
    return __spreadValues5({
      left: `${offsetLeft}px`,
      top: "0",
      transform: "translate(-50%,-50%) rotate(45deg)"
    }, customStyle);
  }
  let offsetTop = Math.abs(triggerRect.scrollTop + triggerRect.height / 2 - popupRect.scrollTop);
  if (offsetTop > popupRect.height - 8) {
    if (triggerRect.height > popupRect.height) {
      offsetTop = popupRect.height / 2;
    } else {
      offsetTop = popupRect.height - 8;
    }
  }
  if (["left", "lt", "lb"].includes(position)) {
    return __spreadValues5({
      top: `${offsetTop}px`,
      right: "0",
      transform: "translate(50%,-50%) rotate(45deg)"
    }, customStyle);
  }
  return __spreadValues5({
    top: `${offsetTop}px`,
    left: "0",
    transform: "translate(-50%,-50%) rotate(45deg)"
  }, customStyle);
};
var isScrollElement = (element) => {
  return element.scrollHeight > element.offsetHeight || element.scrollWidth > element.offsetWidth;
};
var getScrollElements = (container2) => {
  var _a;
  const scrollElements = [];
  let element = container2;
  while (element && element !== document.documentElement) {
    if (isScrollElement(element)) {
      scrollElements.push(element);
    }
    element = (_a = element.parentElement) != null ? _a : void 0;
  }
  return scrollElements;
};

// node_modules/@arco-design/web-vue/es/_hooks/use-first-element.js
var useFirstElement = () => {
  const children = {};
  const firstElement = ref();
  const getFirstElement = () => {
    const element = getFirstElementFromChildren(children.value);
    if (element !== firstElement.value) {
      firstElement.value = element;
    }
  };
  onMounted(() => getFirstElement());
  onUpdated(() => getFirstElement());
  return {
    children,
    firstElement
  };
};

// node_modules/@arco-design/web-vue/es/_components/resize-observer-v2.js
var ResizeObserver3 = defineComponent({
  name: "ResizeObserver",
  props: {
    watchOnUpdated: Boolean
  },
  emits: [
    "resize"
  ],
  setup(props, { emit, slots }) {
    const { children, firstElement } = useFirstElement();
    let resizeObserver;
    const createResizeObserver = (target3) => {
      if (!target3)
        return;
      resizeObserver = new ResizeObserver_es_default((entries) => {
        const entry = entries[0];
        emit("resize", entry);
      });
      resizeObserver.observe(target3);
    };
    const destroyResizeObserver = () => {
      if (resizeObserver) {
        resizeObserver.disconnect();
        resizeObserver = null;
      }
    };
    watch(firstElement, (element) => {
      if (resizeObserver)
        destroyResizeObserver();
      if (element) {
        createResizeObserver(element);
      }
    });
    onBeforeUnmount(() => {
      if (resizeObserver)
        destroyResizeObserver();
    });
    return () => {
      var _a;
      children.value = (_a = slots.default) == null ? void 0 : _a.call(slots);
      return children.value;
    };
  }
});

// node_modules/@arco-design/web-vue/es/_hooks/use-pick-slots.js
function usePickSlots(slots, slotName) {
  const slot = ref(slots[slotName]);
  onUpdated(() => {
    const newSlot = slots[slotName];
    if (slot.value !== newSlot) {
      slot.value = newSlot;
    }
  });
  return slot;
}

// node_modules/@arco-design/web-vue/es/trigger/context.js
var triggerInjectionKey = Symbol("ArcoTrigger");

// node_modules/@arco-design/web-vue/es/_hooks/use-popup-manager.js
var POPUP_BASE_Z_INDEX = 1e3;
var MESSAGE_BASE_Z_INDEX = 5e3;
var Z_INDEX_STEP = 1;
var PopupManager = class {
  constructor() {
    this.popupStack = {
      popup: /* @__PURE__ */ new Set(),
      dialog: /* @__PURE__ */ new Set(),
      message: /* @__PURE__ */ new Set()
    };
    this.getNextZIndex = (type) => {
      const current = type === "message" ? Array.from(this.popupStack.message).pop() || MESSAGE_BASE_Z_INDEX : Array.from(this.popupStack.popup).pop() || POPUP_BASE_Z_INDEX;
      return current + Z_INDEX_STEP;
    };
    this.add = (type) => {
      const zIndex = this.getNextZIndex(type);
      this.popupStack[type].add(zIndex);
      if (type === "dialog") {
        this.popupStack.popup.add(zIndex);
      }
      return zIndex;
    };
    this.delete = (zIndex, type) => {
      this.popupStack[type].delete(zIndex);
      if (type === "dialog") {
        this.popupStack.popup.delete(zIndex);
      }
    };
    this.isLastDialog = (zIndex) => {
      if (this.popupStack.dialog.size > 1) {
        return zIndex === Array.from(this.popupStack.dialog).pop();
      }
      return true;
    };
  }
};
var popupManager = new PopupManager();
function usePopupManager(type, {
  visible,
  runOnMounted
} = {}) {
  const zIndex = ref(0);
  const open3 = () => {
    zIndex.value = popupManager.add(type);
  };
  const close = () => {
    popupManager.delete(zIndex.value, type);
  };
  const isLastDialog = () => {
    if (type === "dialog") {
      return popupManager.isLastDialog(zIndex.value);
    }
    return false;
  };
  watch(() => visible == null ? void 0 : visible.value, (visible2) => {
    if (visible2) {
      open3();
    } else {
      close();
    }
  }, {
    immediate: true
  });
  if (runOnMounted) {
    onMounted(() => {
      open3();
    });
    onBeforeUnmount(() => {
      close();
    });
  }
  return {
    zIndex: readonly(zIndex),
    open: open3,
    close,
    isLastDialog
  };
}

// node_modules/@arco-design/web-vue/es/_hooks/use-resize-observer.js
var useResizeObserver = ({
  elementRef,
  onResize
}) => {
  let resizeObserver;
  const createResizeObserver = () => {
    if (!elementRef.value)
      return;
    resizeObserver = new ResizeObserver_es_default((entries) => {
      const entry = entries[0];
      isFunction(onResize) && onResize(entry);
    });
    resizeObserver.observe(elementRef.value);
  };
  const destroyResizeObserver = () => {
    if (resizeObserver) {
      resizeObserver.disconnect();
      resizeObserver = null;
    }
  };
  return {
    createResizeObserver,
    destroyResizeObserver
  };
};

// node_modules/@arco-design/web-vue/es/_components/client-only.js
var ClientOnly = defineComponent({
  name: "ClientOnly",
  setup(_, {
    slots
  }) {
    const mounted = ref(false);
    onMounted(() => mounted.value = true);
    return () => {
      var _a;
      if (mounted.value) {
        return (_a = slots.default) == null ? void 0 : _a.call(slots);
      }
      return null;
    };
  }
});

// node_modules/@arco-design/web-vue/es/_hooks/use-teleport-container.js
var useTeleportContainer = ({
  popupContainer,
  visible,
  defaultContainer = "body",
  documentContainer
}) => {
  const teleportContainer = ref(popupContainer.value);
  const containerRef = ref();
  const getContainer = () => {
    const element = getElement(popupContainer.value);
    const _teleportContainer = element ? popupContainer.value : defaultContainer;
    const _containerElement = element != null ? element : documentContainer ? document.documentElement : getElement(defaultContainer);
    if (_teleportContainer !== teleportContainer.value) {
      teleportContainer.value = _teleportContainer;
    }
    if (_containerElement !== containerRef.value) {
      containerRef.value = _containerElement;
    }
  };
  onMounted(() => getContainer());
  watch(visible, (visible2) => {
    if (teleportContainer.value !== popupContainer.value && visible2) {
      getContainer();
    }
  });
  return {
    teleportContainer,
    containerRef
  };
};

// node_modules/@arco-design/web-vue/es/trigger/trigger.js
var __defProp6 = Object.defineProperty;
var __defProps2 = Object.defineProperties;
var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols6 = Object.getOwnPropertySymbols;
var __hasOwnProp6 = Object.prototype.hasOwnProperty;
var __propIsEnum6 = Object.prototype.propertyIsEnumerable;
var __defNormalProp6 = (obj, key, value) => key in obj ? __defProp6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues6 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp6.call(b, prop))
      __defNormalProp6(a, prop, b[prop]);
  if (__getOwnPropSymbols6)
    for (var prop of __getOwnPropSymbols6(b)) {
      if (__propIsEnum6.call(b, prop))
        __defNormalProp6(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps2 = (a, b) => __defProps2(a, __getOwnPropDescs2(b));
var TRIGGER_EVENTS = ["onClick", "onMouseenter", "onMouseleave", "onFocusin", "onFocusout", "onContextmenu"];
var _Trigger = defineComponent({
  name: "Trigger",
  inheritAttrs: false,
  props: {
    popupVisible: {
      type: Boolean,
      default: void 0
    },
    defaultPopupVisible: {
      type: Boolean,
      default: false
    },
    trigger: {
      type: [String, Array],
      default: "hover"
    },
    position: {
      type: String,
      default: "bottom"
    },
    disabled: {
      type: Boolean,
      default: false
    },
    popupOffset: {
      type: Number,
      default: 0
    },
    popupTranslate: {
      type: [Array, Object]
    },
    showArrow: {
      type: Boolean,
      default: false
    },
    alignPoint: {
      type: Boolean,
      default: false
    },
    popupHoverStay: {
      type: Boolean,
      default: true
    },
    blurToClose: {
      type: Boolean,
      default: true
    },
    clickToClose: {
      type: Boolean,
      default: true
    },
    clickOutsideToClose: {
      type: Boolean,
      default: true
    },
    unmountOnClose: {
      type: Boolean,
      default: true
    },
    contentClass: {
      type: [String, Array, Object]
    },
    contentStyle: {
      type: Object
    },
    arrowClass: {
      type: [String, Array, Object]
    },
    arrowStyle: {
      type: Object
    },
    popupStyle: {
      type: Object
    },
    animationName: {
      type: String,
      default: "fade-in"
    },
    duration: {
      type: [Number, Object]
    },
    mouseEnterDelay: {
      type: Number,
      default: 100
    },
    mouseLeaveDelay: {
      type: Number,
      default: 100
    },
    focusDelay: {
      type: Number,
      default: 0
    },
    autoFitPopupWidth: {
      type: Boolean,
      default: false
    },
    autoFitPopupMinWidth: {
      type: Boolean,
      default: false
    },
    autoFixPosition: {
      type: Boolean,
      default: true
    },
    popupContainer: {
      type: [String, Object]
    },
    updateAtScroll: {
      type: Boolean,
      default: false
    },
    autoFitTransformOrigin: {
      type: Boolean,
      default: false
    },
    hideEmpty: {
      type: Boolean,
      default: false
    },
    openedClass: {
      type: [String, Array, Object]
    },
    autoFitPosition: {
      type: Boolean,
      default: true
    },
    renderToBody: {
      type: Boolean,
      default: true
    },
    preventFocus: {
      type: Boolean,
      default: false
    }
  },
  emits: {
    "update:popupVisible": (visible) => true,
    "popupVisibleChange": (visible) => true,
    "show": () => true,
    "hide": () => true,
    "resize": () => true
  },
  setup(props, {
    emit,
    slots,
    attrs
  }) {
    const {
      popupContainer
    } = toRefs(props);
    const prefixCls = getPrefixCls("trigger");
    const popupAttrs = computed(() => omit(attrs, TRIGGER_EVENTS));
    const configCtx = inject(configProviderInjectionKey, void 0);
    const triggerMethods = computed(() => [].concat(props.trigger));
    const childrenRefs = /* @__PURE__ */ new Set();
    const triggerCtx = inject(triggerInjectionKey, void 0);
    const {
      children,
      firstElement
    } = useFirstElement();
    const popupRef = ref();
    const popupVisible = ref(props.defaultPopupVisible);
    const popupPosition = ref(props.position);
    const popupStyle = ref({});
    const transformStyle = ref({});
    const arrowStyle = ref({});
    const arrowRef = ref();
    const mousePosition = ref({
      top: 0,
      left: 0
    });
    const computedVisible = computed(() => {
      var _a;
      return (_a = props.popupVisible) != null ? _a : popupVisible.value;
    });
    const {
      teleportContainer,
      containerRef
    } = useTeleportContainer({
      popupContainer,
      visible: computedVisible,
      documentContainer: true
    });
    const {
      zIndex
    } = usePopupManager("popup", {
      visible: computedVisible
    });
    let delayTimer = 0;
    let outsideListener = false;
    const cleanDelayTimer = () => {
      if (delayTimer) {
        window.clearTimeout(delayTimer);
        delayTimer = 0;
      }
    };
    const updateMousePosition = (e2) => {
      if (props.alignPoint) {
        const {
          pageX,
          pageY
        } = e2;
        mousePosition.value = {
          top: pageY,
          left: pageX
        };
      }
    };
    const updatePopupStyle = () => {
      if (!firstElement.value || !popupRef.value || !containerRef.value) {
        return;
      }
      const containerRect = containerRef.value.getBoundingClientRect();
      const triggerRect = props.alignPoint ? {
        top: mousePosition.value.top,
        bottom: mousePosition.value.top,
        left: mousePosition.value.left,
        right: mousePosition.value.left,
        scrollTop: mousePosition.value.top,
        scrollBottom: mousePosition.value.top,
        scrollLeft: mousePosition.value.left,
        scrollRight: mousePosition.value.left,
        width: 0,
        height: 0
      } : getElementScrollRect(firstElement.value, containerRect);
      const getPopupRect = () => getElementScrollRect(popupRef.value, containerRect);
      const popupRect = getPopupRect();
      const {
        style,
        position
      } = getPopupStyle(props.position, containerRect, triggerRect, popupRect, {
        offset: props.popupOffset,
        translate: props.popupTranslate,
        customStyle: props.popupStyle,
        autoFitPosition: props.autoFitPosition
      });
      if (props.autoFitTransformOrigin) {
        transformStyle.value = {
          transformOrigin: getTransformOrigin(position)
        };
      }
      if (props.autoFitPopupMinWidth) {
        style.minWidth = `${triggerRect.width}px`;
      } else if (props.autoFitPopupWidth) {
        style.width = `${triggerRect.width}px`;
      }
      if (popupPosition.value !== position) {
        popupPosition.value = position;
      }
      popupStyle.value = style;
      if (props.showArrow) {
        nextTick(() => {
          arrowStyle.value = getArrowStyle(position, triggerRect, getPopupRect(), {
            customStyle: props.arrowStyle
          });
        });
      }
    };
    const changeVisible = (visible, delay) => {
      if (visible === computedVisible.value && delayTimer === 0) {
        return;
      }
      const update2 = () => {
        popupVisible.value = visible;
        emit("update:popupVisible", visible);
        emit("popupVisibleChange", visible);
        if (visible) {
          nextTick(() => {
            updatePopupStyle();
          });
        }
      };
      if (delay) {
        cleanDelayTimer();
        if (visible !== computedVisible.value) {
          delayTimer = window.setTimeout(update2, delay);
        }
      } else {
        update2();
      }
    };
    const handleClick = (e2) => {
      var _a;
      (_a = attrs.onClick) == null ? void 0 : _a.call(attrs, e2);
      if (props.disabled || computedVisible.value && !props.clickToClose) {
        return;
      }
      if (triggerMethods.value.includes("click")) {
        updateMousePosition(e2);
        changeVisible(!computedVisible.value);
      } else if (triggerMethods.value.includes("contextMenu") && computedVisible.value) {
        changeVisible(false);
      }
    };
    const handleMouseEnter = (e2) => {
      var _a;
      (_a = attrs.onMouseenter) == null ? void 0 : _a.call(attrs, e2);
      if (props.disabled || !triggerMethods.value.includes("hover")) {
        return;
      }
      updateMousePosition(e2);
      changeVisible(true, props.mouseEnterDelay);
    };
    const handleMouseEnterWithContext = (e2) => {
      triggerCtx == null ? void 0 : triggerCtx.onMouseenter(e2);
      handleMouseEnter(e2);
    };
    const handleMouseLeave = (e2) => {
      var _a;
      (_a = attrs.onMouseleave) == null ? void 0 : _a.call(attrs, e2);
      if (props.disabled || !triggerMethods.value.includes("hover")) {
        return;
      }
      changeVisible(false, props.mouseLeaveDelay);
    };
    const handleMouseLeaveWithContext = (e2) => {
      triggerCtx == null ? void 0 : triggerCtx.onMouseleave(e2);
      handleMouseLeave(e2);
    };
    const handleFocusin = (e2) => {
      var _a;
      (_a = attrs.onFocusin) == null ? void 0 : _a.call(attrs, e2);
      if (props.disabled || !triggerMethods.value.includes("focus")) {
        return;
      }
      changeVisible(true, props.focusDelay);
    };
    const handleFocusout = (e2) => {
      var _a;
      (_a = attrs.onFocusout) == null ? void 0 : _a.call(attrs, e2);
      if (props.disabled || !triggerMethods.value.includes("focus")) {
        return;
      }
      if (!props.blurToClose) {
        return;
      }
      changeVisible(false);
    };
    const handleContextmenu = (e2) => {
      var _a;
      (_a = attrs.onContextmenu) == null ? void 0 : _a.call(attrs, e2);
      if (props.disabled || !triggerMethods.value.includes("contextMenu") || computedVisible.value && !props.clickToClose) {
        return;
      }
      updateMousePosition(e2);
      changeVisible(!computedVisible.value);
      e2.preventDefault();
    };
    const addChildRef = (ref2) => {
      childrenRefs.add(ref2);
      triggerCtx == null ? void 0 : triggerCtx.addChildRef(ref2);
    };
    const removeChildRef = (ref2) => {
      childrenRefs.delete(ref2);
      triggerCtx == null ? void 0 : triggerCtx.removeChildRef(ref2);
    };
    provide(triggerInjectionKey, reactive({
      onMouseenter: handleMouseEnterWithContext,
      onMouseleave: handleMouseLeaveWithContext,
      addChildRef,
      removeChildRef
    }));
    const removeOutsideListener = () => {
      off(document.documentElement, "mousedown", handleOutsideClick);
      outsideListener = false;
    };
    const contentSlot = usePickSlots(slots, "content");
    const hidePopup = computed(() => {
      var _a;
      return props.hideEmpty && isEmptyChildren((_a = contentSlot.value) == null ? void 0 : _a.call(contentSlot));
    });
    const handleOutsideClick = (e2) => {
      var _a, _b, _c;
      if (((_a = firstElement.value) == null ? void 0 : _a.contains(e2.target)) || ((_b = popupRef.value) == null ? void 0 : _b.contains(e2.target))) {
        return;
      }
      for (const item of childrenRefs) {
        if ((_c = item.value) == null ? void 0 : _c.contains(e2.target)) {
          return;
        }
      }
      removeOutsideListener();
      changeVisible(false);
    };
    const handleScroll = throttleByRaf(() => {
      if (computedVisible.value) {
        updatePopupStyle();
      }
    });
    const handleResize = () => {
      if (computedVisible.value) {
        updatePopupStyle();
      }
    };
    const onTargetResize = () => {
      handleResize();
      emit("resize");
    };
    const handlePopupMouseDown = (e2) => {
      if (props.preventFocus) {
        e2.preventDefault();
      }
    };
    triggerCtx == null ? void 0 : triggerCtx.addChildRef(popupRef);
    const triggerCls = computed(() => {
      return computedVisible.value ? props.openedClass : void 0;
    });
    let scrollElements;
    watch(computedVisible, (value) => {
      if (props.clickOutsideToClose) {
        if (!value && outsideListener) {
          removeOutsideListener();
        } else if (value && !outsideListener) {
          on(document.documentElement, "mousedown", handleOutsideClick);
          outsideListener = true;
        }
      }
      if (props.updateAtScroll || (configCtx == null ? void 0 : configCtx.updateAtScroll)) {
        if (value) {
          scrollElements = getScrollElements(firstElement.value);
          for (const item of scrollElements) {
            item.addEventListener("scroll", handleScroll);
          }
        } else if (scrollElements) {
          for (const item of scrollElements) {
            item.removeEventListener("scroll", handleScroll);
          }
          scrollElements = void 0;
        }
      }
      if (value) {
        mounted.value = true;
      }
    });
    watch(() => [props.autoFitPopupWidth, props.autoFitPopupMinWidth], () => {
      if (computedVisible.value) {
        updatePopupStyle();
      }
    });
    const {
      createResizeObserver,
      destroyResizeObserver
    } = useResizeObserver({
      elementRef: containerRef,
      onResize: handleResize
    });
    onMounted(() => {
      createResizeObserver();
      if (computedVisible.value) {
        updatePopupStyle();
        if (props.clickOutsideToClose && !outsideListener) {
          on(document.documentElement, "mousedown", handleOutsideClick);
          outsideListener = true;
        }
        if (props.updateAtScroll || (configCtx == null ? void 0 : configCtx.updateAtScroll)) {
          scrollElements = getScrollElements(firstElement.value);
          for (const item of scrollElements) {
            item.addEventListener("scroll", handleScroll);
          }
        }
      }
    });
    onUpdated(() => {
      if (computedVisible.value) {
        updatePopupStyle();
      }
    });
    onDeactivated(() => {
      changeVisible(false);
    });
    onBeforeUnmount(() => {
      triggerCtx == null ? void 0 : triggerCtx.removeChildRef(popupRef);
      destroyResizeObserver();
      if (outsideListener) {
        removeOutsideListener();
      }
      if (scrollElements) {
        for (const item of scrollElements) {
          item.removeEventListener("scroll", handleScroll);
        }
        scrollElements = void 0;
      }
    });
    const mounted = ref(computedVisible.value);
    const isAnimation = ref(false);
    const onAnimationStart = () => {
      isAnimation.value = true;
    };
    const handleShow = () => {
      isAnimation.value = false;
      if (computedVisible.value) {
        emit("show");
      }
    };
    const handleHide = () => {
      isAnimation.value = false;
      if (!computedVisible.value) {
        mounted.value = false;
        emit("hide");
      }
    };
    return () => {
      var _a, _b;
      children.value = (_b = (_a = slots.default) == null ? void 0 : _a.call(slots)) != null ? _b : [];
      mergeFirstChild(children.value, {
        class: triggerCls.value,
        onClick: handleClick,
        onMouseenter: handleMouseEnter,
        onMouseleave: handleMouseLeave,
        onFocusin: handleFocusin,
        onFocusout: handleFocusout,
        onContextmenu: handleContextmenu
      });
      return createVNode(Fragment, null, [props.autoFixPosition ? createVNode(ResizeObserver3, {
        "onResize": onTargetResize
      }, {
        default: () => [children.value]
      }) : children.value, createVNode(ClientOnly, null, {
        default: () => [createVNode(Teleport, {
          "to": teleportContainer.value,
          "disabled": !props.renderToBody
        }, {
          default: () => [(!props.unmountOnClose || computedVisible.value || mounted.value) && !hidePopup.value && createVNode(ResizeObserver3, {
            "onResize": handleResize
          }, {
            default: () => [createVNode("div", mergeProps({
              "ref": popupRef,
              "class": [`${prefixCls}-popup`, `${prefixCls}-position-${popupPosition.value}`],
              "style": __spreadProps2(__spreadValues6({}, popupStyle.value), {
                zIndex: zIndex.value,
                pointerEvents: isAnimation.value ? "none" : "auto"
              }),
              "trigger-placement": popupPosition.value,
              "onMouseenter": handleMouseEnterWithContext,
              "onMouseleave": handleMouseLeaveWithContext,
              "onMousedown": handlePopupMouseDown
            }, popupAttrs.value), [createVNode(Transition, {
              "name": props.animationName,
              "duration": props.duration,
              "appear": true,
              "onBeforeEnter": onAnimationStart,
              "onAfterEnter": handleShow,
              "onBeforeLeave": onAnimationStart,
              "onAfterLeave": handleHide
            }, {
              default: () => {
                var _a2;
                return [withDirectives(createVNode("div", {
                  "class": `${prefixCls}-popup-wrapper`,
                  "style": transformStyle.value
                }, [createVNode("div", {
                  "class": [`${prefixCls}-content`, props.contentClass],
                  "style": props.contentStyle
                }, [(_a2 = slots.content) == null ? void 0 : _a2.call(slots)]), props.showArrow && createVNode("div", {
                  "ref": arrowRef,
                  "class": [`${prefixCls}-arrow`, props.arrowClass],
                  "style": arrowStyle.value
                }, null)]), [[vShow, computedVisible.value]])];
              }
            })])]
          })]
        })]
      })]);
    };
  }
});

// node_modules/@arco-design/web-vue/es/trigger/index.js
var Trigger = Object.assign(_Trigger, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Trigger.name, _Trigger);
  }
});

// node_modules/@arco-design/web-vue/es/icon/icon-empty/icon-empty.js
var _sfc_main20 = defineComponent({
  name: "IconEmpty",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-empty`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_113 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_211 = createBaseVNode("path", { d: "M24 5v6m7 1 4-4m-18 4-4-4m28.5 22H28s-1 3-4 3-4-3-4-3H6.5M40 41H8a2 2 0 0 1-2-2v-8.46a2 2 0 0 1 .272-1.007l6.15-10.54A2 2 0 0 1 14.148 18H33.85a2 2 0 0 1 1.728.992l6.149 10.541A2 2 0 0 1 42 30.541V39a2 2 0 0 1-2 2Z" }, null, -1);
var _hoisted_310 = [
  _hoisted_211
];
function _sfc_render20(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_310, 14, _hoisted_113);
}
var _IconEmpty = _export_sfc(_sfc_main20, [["render", _sfc_render20]]);

// node_modules/@arco-design/web-vue/es/icon/icon-empty/index.js
var IconEmpty = Object.assign(_IconEmpty, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconEmpty.name, _IconEmpty);
  }
});

// node_modules/@arco-design/web-vue/es/empty/empty.js
var Empty = defineComponent({
  name: "Empty",
  props: {
    description: String,
    imgSrc: String
  },
  setup(props, {
    slots
  }) {
    const prefixCls = getPrefixCls("empty");
    const {
      t: t2
    } = useI18n();
    const configCtx = inject(configProviderInjectionKey, void 0);
    return () => {
      var _a, _b, _c, _d;
      if ((configCtx == null ? void 0 : configCtx.slots.empty) && !(slots.image || props.imgSrc)) {
        return configCtx.slots.empty();
      }
      return createVNode("div", {
        "class": prefixCls
      }, [createVNode("div", {
        "class": `${prefixCls}-image`
      }, [(_b = (_a = slots.image) == null ? void 0 : _a.call(slots)) != null ? _b : props.imgSrc ? createVNode("img", {
        "src": props.imgSrc,
        "alt": props.description || "empty"
      }, null) : createVNode(IconEmpty, null, null)]), createVNode("div", {
        "class": `${prefixCls}-description`
      }, [(_d = (_c = slots.default) == null ? void 0 : _c.call(slots)) != null ? _d : props.description || t2("empty.description")])]);
    };
  }
});

// node_modules/@arco-design/web-vue/es/empty/index.js
var Empty2 = Object.assign(Empty, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + Empty.name, Empty);
  }
});

// node_modules/@arco-design/web-vue/es/spin/dot-loading.js
var DOT_NUMBER = 5;
var DotLoading = defineComponent({
  name: "DotLoading",
  props: {
    size: {
      type: Number
    }
  },
  setup(props) {
    const prefixCls = getPrefixCls("dot-loading");
    return () => {
      const style = props.size ? {
        width: `${props.size}px`,
        height: `${props.size}px`
      } : {};
      return createVNode("div", {
        "class": prefixCls,
        "style": {
          width: props.size ? `${props.size * 7}px` : void 0,
          height: props.size ? `${props.size}px` : void 0
        }
      }, [Array(DOT_NUMBER).fill(1).map((_, index3) => createVNode("div", {
        "class": `${prefixCls}-item`,
        "key": index3,
        "style": style
      }, null))]);
    };
  }
});

// node_modules/@arco-design/web-vue/es/spin/spin.js
var _Spin = defineComponent({
  name: "Spin",
  props: {
    size: {
      type: Number
    },
    loading: Boolean,
    dot: Boolean,
    tip: String
  },
  setup(props, {
    slots
  }) {
    const prefixCls = getPrefixCls("spin");
    const configCtx = inject(configProviderInjectionKey, void 0);
    const cls = computed(() => [prefixCls, {
      [`${prefixCls}-loading`]: props.loading,
      [`${prefixCls}-with-tip`]: props.tip && !slots.default
    }]);
    const renderIcon = () => {
      if (slots.icon) {
        const iconVNode = getFirstComponent(slots.icon());
        if (iconVNode) {
          return cloneVNode(iconVNode, {
            spin: true
          });
        }
      }
      if (slots.element) {
        return slots.element();
      }
      if (props.dot) {
        return createVNode(DotLoading, {
          "size": props.size
        }, null);
      }
      if (configCtx == null ? void 0 : configCtx.slots.loading) {
        return configCtx.slots.loading();
      }
      return createVNode(IconLoading, {
        "spin": true,
        "size": props.size
      }, null);
    };
    const renderSpinIcon = () => {
      const style = props.size ? {
        fontSize: `${props.size}px`
      } : void 0;
      return createVNode(Fragment, null, [createVNode("div", {
        "class": `${prefixCls}-icon`,
        "style": style
      }, [renderIcon()]), props.tip && createVNode("div", {
        "class": `${prefixCls}-tip`
      }, [props.tip])]);
    };
    return () => createVNode("div", {
      "class": cls.value
    }, [slots.default ? createVNode(Fragment, null, [slots.default(), props.loading && createVNode("div", {
      "class": `${prefixCls}-mask`
    }, [createVNode("div", {
      "class": `${prefixCls}-mask-icon`
    }, [renderSpinIcon()])])]) : renderSpinIcon()]);
  }
});

// node_modules/@arco-design/web-vue/es/spin/index.js
var Spin = Object.assign(_Spin, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Spin.name, _Spin);
  }
});

// node_modules/@arco-design/web-vue/es/scrollbar/thumb.js
var _sfc_main21 = defineComponent({
  name: "Thumb",
  props: {
    data: {
      type: Object
    },
    direction: {
      type: String,
      default: "horizontal"
    },
    alwaysShow: {
      type: Boolean,
      default: false
    },
    both: {
      type: Boolean,
      default: false
    }
  },
  emits: ["scroll"],
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("scrollbar");
    const visible = ref(false);
    const trackRef = ref();
    const thumbRef = ref();
    const thumbMap = computed(() => {
      if (props.direction === "horizontal") {
        return {
          size: "width",
          direction: "left",
          offset: "offsetWidth",
          client: "clientX"
        };
      }
      return {
        size: "height",
        direction: "top",
        offset: "offsetHeight",
        client: "clientY"
      };
    });
    const offset = ref(0);
    const isDragging = ref(false);
    const mouseOffset = ref(0);
    const thumbStyle = computed(() => {
      var _a, _b;
      return {
        [thumbMap.value.size]: `${(_b = (_a = props.data) == null ? void 0 : _a.thumbSize) != null ? _b : 0}px`,
        [thumbMap.value.direction]: `${offset.value}px`
      };
    });
    const handleThumbMouseDown = (ev) => {
      ev.preventDefault();
      if (thumbRef.value) {
        mouseOffset.value = ev[thumbMap.value.client] - thumbRef.value.getBoundingClientRect()[thumbMap.value.direction];
        isDragging.value = true;
        on(window, "mousemove", handleMouseMove);
        on(window, "mouseup", handleMouseUp);
        on(window, "contextmenu", handleMouseUp);
      }
    };
    const handleTrackClick = (ev) => {
      var _a, _b, _c, _d;
      ev.preventDefault();
      if (thumbRef.value) {
        const _offset = getLegalOffset(ev[thumbMap.value.client] > thumbRef.value.getBoundingClientRect()[thumbMap.value.direction] ? offset.value + ((_b = (_a = props.data) == null ? void 0 : _a.thumbSize) != null ? _b : 0) : offset.value - ((_d = (_c = props.data) == null ? void 0 : _c.thumbSize) != null ? _d : 0));
        if (_offset !== offset.value) {
          offset.value = _offset;
          emit("scroll", _offset);
        }
      }
    };
    const getLegalOffset = (offset2) => {
      if (offset2 < 0) {
        return 0;
      }
      if (props.data && offset2 > props.data.max) {
        return props.data.max;
      }
      return offset2;
    };
    const handleMouseMove = (ev) => {
      if (trackRef.value && thumbRef.value) {
        const _offset = getLegalOffset(ev[thumbMap.value.client] - trackRef.value.getBoundingClientRect()[thumbMap.value.direction] - mouseOffset.value);
        if (_offset !== offset.value) {
          offset.value = _offset;
          emit("scroll", _offset);
        }
      }
    };
    const handleMouseUp = () => {
      isDragging.value = false;
      off(window, "mousemove", handleMouseMove);
      off(window, "mouseup", handleMouseUp);
    };
    const setOffset = (_offset) => {
      if (!isDragging.value) {
        _offset = getLegalOffset(_offset);
        if (_offset !== offset.value) {
          offset.value = _offset;
        }
      }
    };
    const thumbCls = computed(() => [
      `${prefixCls}-thumb`,
      `${prefixCls}-thumb-direction-${props.direction}`,
      {
        [`${prefixCls}-thumb-dragging`]: isDragging.value
      }
    ]);
    return {
      visible,
      trackRef,
      thumbRef,
      prefixCls,
      thumbCls,
      thumbStyle,
      handleThumbMouseDown,
      handleTrackClick,
      setOffset
    };
  }
});
function _sfc_render21(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, null, {
    default: withCtx(() => [
      createBaseVNode("div", {
        ref: "trackRef",
        class: normalizeClass([
          `${_ctx.prefixCls}-track`,
          `${_ctx.prefixCls}-track-direction-${_ctx.direction}`
        ]),
        onMousedown: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.handleTrackClick && _ctx.handleTrackClick(...args), ["self"]))
      }, [
        createBaseVNode("div", {
          ref: "thumbRef",
          class: normalizeClass(_ctx.thumbCls),
          style: normalizeStyle(_ctx.thumbStyle),
          onMousedown: _cache[0] || (_cache[0] = (...args) => _ctx.handleThumbMouseDown && _ctx.handleThumbMouseDown(...args))
        }, [
          createBaseVNode("div", {
            class: normalizeClass(`${_ctx.prefixCls}-thumb-bar`)
          }, null, 2)
        ], 38)
      ], 34)
    ]),
    _: 1
  });
}
var Thumb = _export_sfc(_sfc_main21, [["render", _sfc_render21]]);

// node_modules/@arco-design/web-vue/es/scrollbar/scrollbar.js
var THUMB_MIN_SIZE = 20;
var TRACK_SIZE = 15;
var _sfc_main22 = defineComponent({
  name: "Scrollbar",
  components: {
    ResizeObserver: ResizeObserver3,
    Thumb
  },
  inheritAttrs: false,
  props: {
    type: {
      type: String,
      default: "embed"
    },
    outerClass: [String, Object, Array],
    outerStyle: {
      type: [String, Object, Array]
    },
    hide: {
      type: Boolean,
      default: false
    },
    disableHorizontal: {
      type: Boolean,
      default: false
    },
    disableVertical: {
      type: Boolean,
      default: false
    }
  },
  emits: {
    scroll: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("scrollbar");
    const containerRef = ref();
    const horizontalData = ref();
    const verticalData = ref();
    const horizontalThumbRef = ref();
    const verticalThumbRef = ref();
    const _hasHorizontalScrollbar = ref(false);
    const _hasVerticalScrollbar = ref(false);
    const hasHorizontalScrollbar = computed(() => _hasHorizontalScrollbar.value && !props.disableHorizontal);
    const hasVerticalScrollbar = computed(() => _hasVerticalScrollbar.value && !props.disableVertical);
    const isBoth = ref(false);
    const getContainerSize = () => {
      var _a, _b, _c, _d, _e, _f;
      if (containerRef.value) {
        const {
          clientWidth,
          clientHeight,
          offsetWidth,
          offsetHeight,
          scrollWidth,
          scrollHeight,
          scrollTop,
          scrollLeft
        } = containerRef.value;
        _hasHorizontalScrollbar.value = scrollWidth > clientWidth;
        _hasVerticalScrollbar.value = scrollHeight > clientHeight;
        isBoth.value = hasHorizontalScrollbar.value && hasVerticalScrollbar.value;
        const horizontalTrackWidth = props.type === "embed" && isBoth.value ? offsetWidth - TRACK_SIZE : offsetWidth;
        const verticalTrackHeight = props.type === "embed" && isBoth.value ? offsetHeight - TRACK_SIZE : offsetHeight;
        const horizontalThumbWidth = Math.round(horizontalTrackWidth / Math.min(scrollWidth / clientWidth, horizontalTrackWidth / THUMB_MIN_SIZE));
        const maxHorizontalOffset = horizontalTrackWidth - horizontalThumbWidth;
        const horizontalRatio = (scrollWidth - clientWidth) / maxHorizontalOffset;
        const verticalThumbHeight = Math.round(verticalTrackHeight / Math.min(scrollHeight / clientHeight, verticalTrackHeight / THUMB_MIN_SIZE));
        const maxVerticalOffset = verticalTrackHeight - verticalThumbHeight;
        const verticalRatio = (scrollHeight - clientHeight) / maxVerticalOffset;
        horizontalData.value = {
          ratio: horizontalRatio,
          thumbSize: horizontalThumbWidth,
          max: maxHorizontalOffset
        };
        verticalData.value = {
          ratio: verticalRatio,
          thumbSize: verticalThumbHeight,
          max: maxVerticalOffset
        };
        if (scrollTop > 0) {
          const verticalOffset = Math.round(scrollTop / ((_b = (_a = verticalData.value) == null ? void 0 : _a.ratio) != null ? _b : 1));
          (_c = verticalThumbRef.value) == null ? void 0 : _c.setOffset(verticalOffset);
        }
        if (scrollLeft > 0) {
          const horizontalOffset = Math.round(scrollLeft / ((_e = (_d = verticalData.value) == null ? void 0 : _d.ratio) != null ? _e : 1));
          (_f = horizontalThumbRef.value) == null ? void 0 : _f.setOffset(horizontalOffset);
        }
      }
    };
    onMounted(() => {
      getContainerSize();
    });
    const handleResize = () => {
      getContainerSize();
    };
    const handleScroll = (ev) => {
      var _a, _b, _c, _d, _e, _f;
      if (containerRef.value) {
        if (hasHorizontalScrollbar.value && !props.disableHorizontal) {
          const horizontalOffset = Math.round(containerRef.value.scrollLeft / ((_b = (_a = horizontalData.value) == null ? void 0 : _a.ratio) != null ? _b : 1));
          (_c = horizontalThumbRef.value) == null ? void 0 : _c.setOffset(horizontalOffset);
        }
        if (hasVerticalScrollbar.value && !props.disableVertical) {
          const verticalOffset = Math.round(containerRef.value.scrollTop / ((_e = (_d = verticalData.value) == null ? void 0 : _d.ratio) != null ? _e : 1));
          (_f = verticalThumbRef.value) == null ? void 0 : _f.setOffset(verticalOffset);
        }
      }
      emit("scroll", ev);
    };
    const handleHorizontalScroll = (offset) => {
      var _a, _b;
      if (containerRef.value) {
        containerRef.value.scrollTo({
          left: offset * ((_b = (_a = horizontalData.value) == null ? void 0 : _a.ratio) != null ? _b : 1)
        });
      }
    };
    const handleVerticalScroll = (offset) => {
      var _a, _b;
      if (containerRef.value) {
        containerRef.value.scrollTo({
          top: offset * ((_b = (_a = verticalData.value) == null ? void 0 : _a.ratio) != null ? _b : 1)
        });
      }
    };
    const style = computed(() => {
      const style2 = {};
      if (props.type === "track") {
        if (hasHorizontalScrollbar.value) {
          style2.paddingBottom = `${TRACK_SIZE}px`;
        }
        if (hasVerticalScrollbar.value) {
          style2.paddingRight = `${TRACK_SIZE}px`;
        }
      }
      return [style2, props.outerStyle];
    });
    const cls = computed(() => [
      `${prefixCls}`,
      `${prefixCls}-type-${props.type}`,
      {
        [`${prefixCls}-both`]: isBoth.value
      },
      props.outerClass
    ]);
    return {
      prefixCls,
      cls,
      style,
      containerRef,
      horizontalThumbRef,
      verticalThumbRef,
      horizontalData,
      verticalData,
      isBoth,
      hasHorizontalScrollbar,
      hasVerticalScrollbar,
      handleResize,
      handleScroll,
      handleHorizontalScroll,
      handleVerticalScroll
    };
  },
  methods: {
    scrollTo(options, y) {
      var _a, _b;
      if (isObject(options)) {
        (_a = this.$refs.containerRef) == null ? void 0 : _a.scrollTo(options);
      } else if (options || y) {
        (_b = this.$refs.containerRef) == null ? void 0 : _b.scrollTo(options, y);
      }
    },
    scrollTop(top) {
      var _a;
      (_a = this.$refs.containerRef) == null ? void 0 : _a.scrollTo({
        top
      });
    },
    scrollLeft(left) {
      var _a;
      (_a = this.$refs.containerRef) == null ? void 0 : _a.scrollTo({
        left
      });
    }
  }
});
function _sfc_render22(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ResizeObserver = resolveComponent("ResizeObserver");
  const _component_thumb = resolveComponent("thumb");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.style)
  }, [
    createVNode(_component_ResizeObserver, { onResize: _ctx.handleResize }, {
      default: withCtx(() => [
        createBaseVNode("div", mergeProps({
          ref: "containerRef",
          class: `${_ctx.prefixCls}-container`
        }, _ctx.$attrs, {
          onScroll: _cache[0] || (_cache[0] = (...args) => _ctx.handleScroll && _ctx.handleScroll(...args))
        }), [
          createVNode(_component_ResizeObserver, { onResize: _ctx.handleResize }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["onResize"])
        ], 16)
      ]),
      _: 3
    }, 8, ["onResize"]),
    !_ctx.hide && _ctx.hasHorizontalScrollbar ? (openBlock(), createBlock(_component_thumb, {
      key: 0,
      ref: "horizontalThumbRef",
      data: _ctx.horizontalData,
      direction: "horizontal",
      both: _ctx.isBoth,
      onScroll: _ctx.handleHorizontalScroll
    }, null, 8, ["data", "both", "onScroll"])) : createCommentVNode("v-if", true),
    !_ctx.hide && _ctx.hasVerticalScrollbar ? (openBlock(), createBlock(_component_thumb, {
      key: 1,
      ref: "verticalThumbRef",
      data: _ctx.verticalData,
      direction: "vertical",
      both: _ctx.isBoth,
      onScroll: _ctx.handleVerticalScroll
    }, null, 8, ["data", "both", "onScroll"])) : createCommentVNode("v-if", true)
  ], 6);
}
var _Scrollbar = _export_sfc(_sfc_main22, [["render", _sfc_render22]]);

// node_modules/@arco-design/web-vue/es/scrollbar/index.js
var Scrollbar = Object.assign(_Scrollbar, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Scrollbar.name, _Scrollbar);
  }
});

// node_modules/@arco-design/web-vue/es/_hooks/use-component-ref.js
var useComponentRef = (name) => {
  const componentRef = ref();
  const getElement2 = () => {
    if (isComponentInstance(componentRef.value)) {
      return componentRef.value.$refs[name];
    }
    return componentRef.value;
  };
  const elementRef = ref();
  onMounted(() => {
    elementRef.value = getElement2();
  });
  watch([componentRef], () => {
    elementRef.value = getElement2();
  });
  return {
    componentRef,
    elementRef
  };
};

// node_modules/@arco-design/web-vue/es/_hooks/use-scrollbar.js
var __defProp7 = Object.defineProperty;
var __getOwnPropSymbols7 = Object.getOwnPropertySymbols;
var __hasOwnProp7 = Object.prototype.hasOwnProperty;
var __propIsEnum7 = Object.prototype.propertyIsEnumerable;
var __defNormalProp7 = (obj, key, value) => key in obj ? __defProp7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues7 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp7.call(b, prop))
      __defNormalProp7(a, prop, b[prop]);
  if (__getOwnPropSymbols7)
    for (var prop of __getOwnPropSymbols7(b)) {
      if (__propIsEnum7.call(b, prop))
        __defNormalProp7(a, prop, b[prop]);
    }
  return a;
};
var useScrollbar = (scrollbar) => {
  const displayScrollbar = computed(() => Boolean(scrollbar.value));
  const scrollbarProps = computed(() => {
    if (!scrollbar.value)
      return void 0;
    return __spreadValues7({
      type: "embed"
    }, isBoolean(scrollbar.value) ? void 0 : scrollbar.value);
  });
  return {
    displayScrollbar,
    scrollbarProps
  };
};

// node_modules/@arco-design/web-vue/es/select/select-dropdown.js
var _sfc_main23 = defineComponent({
  name: "SelectDropdown",
  components: {
    ScrollbarComponent: Scrollbar,
    Empty: Empty2,
    Spin
  },
  props: {
    loading: Boolean,
    empty: Boolean,
    virtualList: Boolean,
    bottomOffset: {
      type: Number,
      default: 0
    },
    scrollbar: {
      type: [Boolean, Object],
      default: true
    },
    onScroll: {
      type: [Function, Array]
    },
    onReachBottom: {
      type: [Function, Array]
    }
  },
  emits: ["scroll", "reachBottom"],
  setup(props, { emit, slots }) {
    const { scrollbar } = toRefs(props);
    const prefixCls = getPrefixCls("select-dropdown");
    const { componentRef: wrapperComRef, elementRef: wrapperRef } = useComponentRef("containerRef");
    const { displayScrollbar, scrollbarProps } = useScrollbar(scrollbar);
    const handleScroll = (e2) => {
      const { scrollTop, scrollHeight, offsetHeight } = e2.target;
      const bottom = scrollHeight - (scrollTop + offsetHeight);
      if (bottom <= props.bottomOffset) {
        emit("reachBottom", e2);
      }
      emit("scroll", e2);
    };
    const cls = computed(() => [
      prefixCls,
      {
        [`${prefixCls}-has-header`]: Boolean(slots.header),
        [`${prefixCls}-has-footer`]: Boolean(slots.footer)
      }
    ]);
    return {
      prefixCls,
      cls,
      wrapperRef,
      wrapperComRef,
      handleScroll,
      displayScrollbar,
      scrollbarProps
    };
  }
});
function _sfc_render23(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_spin = resolveComponent("spin");
  const _component_empty = resolveComponent("empty");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.cls)
  }, [
    _ctx.loading ? (openBlock(), createBlock(_component_spin, {
      key: 0,
      class: normalizeClass(`${_ctx.prefixCls}-loading`)
    }, null, 8, ["class"])) : _ctx.empty ? (openBlock(), createElementBlock("div", {
      key: 1,
      class: normalizeClass(`${_ctx.prefixCls}-empty`)
    }, [
      renderSlot(_ctx.$slots, "empty", {}, () => [
        createVNode(_component_empty)
      ])
    ], 2)) : createCommentVNode("v-if", true),
    _ctx.$slots.header && !_ctx.empty ? (openBlock(), createElementBlock("div", {
      key: 2,
      class: normalizeClass(`${_ctx.prefixCls}-header`)
    }, [
      renderSlot(_ctx.$slots, "header")
    ], 2)) : createCommentVNode("v-if", true),
    _ctx.virtualList && !_ctx.loading && !_ctx.empty ? renderSlot(_ctx.$slots, "virtual-list", { key: 3 }) : createCommentVNode("v-if", true),
    !_ctx.virtualList ? withDirectives((openBlock(), createBlock(resolveDynamicComponent(_ctx.displayScrollbar ? "ScrollbarComponent" : "div"), mergeProps({
      key: 4,
      ref: "wrapperComRef",
      class: `${_ctx.prefixCls}-list-wrapper`
    }, _ctx.scrollbarProps, { onScroll: _ctx.handleScroll }), {
      default: withCtx(() => [
        createBaseVNode("ul", {
          class: normalizeClass(`${_ctx.prefixCls}-list`)
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 2)
      ]),
      _: 3
    }, 16, ["class", "onScroll"])), [
      [vShow, !_ctx.loading && !_ctx.empty]
    ]) : createCommentVNode("v-if", true),
    _ctx.$slots.footer && !_ctx.empty ? (openBlock(), createElementBlock("div", {
      key: 5,
      class: normalizeClass(`${_ctx.prefixCls}-footer`)
    }, [
      renderSlot(_ctx.$slots, "footer")
    ], 2)) : createCommentVNode("v-if", true)
  ], 2);
}
var SelectDropdown = _export_sfc(_sfc_main23, [["render", _sfc_render23]]);

// node_modules/@arco-design/web-vue/es/checkbox/icon-check.js
var IconCheck = defineComponent({
  name: "IconCheck",
  render() {
    return createVNode("svg", {
      "aria-hidden": "true",
      "focusable": "false",
      "viewBox": "0 0 1024 1024",
      "width": "200",
      "height": "200",
      "fill": "currentColor"
    }, [createVNode("path", {
      "d": "M877.44815445 206.10060629a64.72691371 64.72691371 0 0 0-95.14856334 4.01306852L380.73381888 685.46812814 235.22771741 533.48933518a64.72691371 64.72691371 0 0 0-92.43003222-1.03563036l-45.82665557 45.82665443a64.72691371 64.72691371 0 0 0-0.90617629 90.61767965l239.61903446 250.10479331a64.72691371 64.72691371 0 0 0 71.19960405 15.14609778 64.33855261 64.33855261 0 0 0 35.08198741-21.23042702l36.24707186-42.71976334 40.5190474-40.77795556-3.36579926-3.49525333 411.40426297-486.74638962a64.72691371 64.72691371 0 0 0-3.88361443-87.64024149l-45.3088404-45.43829334z",
      "p-id": "840"
    }, null)]);
  }
});

// node_modules/@arco-design/web-vue/es/checkbox/context.js
var checkboxGroupKey = Symbol("ArcoCheckboxGroup");

// node_modules/@arco-design/web-vue/es/checkbox/checkbox.js
var _Checkbox = defineComponent({
  name: "Checkbox",
  components: {
    IconCheck,
    IconHover
  },
  props: {
    modelValue: {
      type: [Boolean, Array],
      default: void 0
    },
    defaultChecked: {
      type: Boolean,
      default: false
    },
    value: {
      type: [String, Number]
    },
    disabled: {
      type: Boolean,
      default: false
    },
    indeterminate: {
      type: Boolean,
      default: false
    },
    uninjectGroupContext: {
      type: Boolean,
      default: false
    }
  },
  emits: {
    "update:modelValue": (value) => true,
    "change": (value, ev) => true
  },
  setup(props, {
    emit,
    slots
  }) {
    const {
      disabled,
      modelValue
    } = toRefs(props);
    const prefixCls = getPrefixCls("checkbox");
    const checkboxRef = ref();
    const checkboxGroupCtx = !props.uninjectGroupContext ? inject(checkboxGroupKey, void 0) : void 0;
    const isGroup = (checkboxGroupCtx == null ? void 0 : checkboxGroupCtx.name) === "ArcoCheckboxGroup";
    const {
      mergedDisabled: _mergedDisabled,
      eventHandlers
    } = useFormItem({
      disabled
    });
    const _checked = ref(props.defaultChecked);
    const computedValue = computed(() => {
      var _a;
      return isGroup ? checkboxGroupCtx == null ? void 0 : checkboxGroupCtx.computedValue : (_a = props.modelValue) != null ? _a : _checked.value;
    });
    const computedChecked = computed(() => {
      var _a;
      return isArray(computedValue.value) ? computedValue.value.includes((_a = props.value) != null ? _a : true) : computedValue.value;
    });
    const mergedDisabled = computed(() => (checkboxGroupCtx == null ? void 0 : checkboxGroupCtx.disabled) || (_mergedDisabled == null ? void 0 : _mergedDisabled.value) || !computedChecked.value && (checkboxGroupCtx == null ? void 0 : checkboxGroupCtx.isMaxed));
    const handleClick = (ev) => {
      ev.stopPropagation();
    };
    const handleChange = (e2) => {
      var _a, _b, _c, _d;
      const {
        checked
      } = e2.target;
      let newValue = checked;
      if (isArray(computedValue.value)) {
        const set = new Set(computedValue.value);
        if (checked) {
          set.add((_a = props.value) != null ? _a : true);
        } else {
          set.delete((_b = props.value) != null ? _b : true);
        }
        newValue = Array.from(set);
      }
      _checked.value = checked;
      if (isGroup && isArray(newValue)) {
        checkboxGroupCtx == null ? void 0 : checkboxGroupCtx.handleChange(newValue, e2);
      } else {
        emit("update:modelValue", newValue);
        emit("change", newValue, e2);
        (_d = (_c = eventHandlers.value) == null ? void 0 : _c.onChange) == null ? void 0 : _d.call(_c, e2);
      }
      nextTick(() => {
        if (checkboxRef.value && checkboxRef.value.checked !== computedChecked.value) {
          checkboxRef.value.checked = computedChecked.value;
        }
      });
    };
    const cls = computed(() => [prefixCls, {
      [`${prefixCls}-checked`]: computedChecked.value,
      [`${prefixCls}-indeterminate`]: props.indeterminate,
      [`${prefixCls}-disabled`]: mergedDisabled.value
    }]);
    const handleFocus = (ev) => {
      var _a, _b;
      (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onFocus) == null ? void 0 : _b.call(_a, ev);
    };
    const handleBlur = (ev) => {
      var _a, _b;
      (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onBlur) == null ? void 0 : _b.call(_a, ev);
    };
    watch(modelValue, (value) => {
      if (isUndefined(value) || isNull(value)) {
        _checked.value = false;
      }
    });
    watch(computedValue, (value) => {
      var _a;
      let checked;
      if (isArray(value)) {
        checked = value.includes((_a = props.value) != null ? _a : true);
      } else {
        checked = value;
      }
      if (_checked.value !== checked) {
        _checked.value = checked;
      }
      if (checkboxRef.value && checkboxRef.value.checked !== checked) {
        checkboxRef.value.checked = checked;
      }
    });
    return () => {
      var _a, _b, _c, _d;
      return createVNode("label", {
        "aria-disabled": mergedDisabled.value,
        "class": cls.value
      }, [createVNode("input", {
        "ref": checkboxRef,
        "type": "checkbox",
        "checked": computedChecked.value,
        "value": props.value,
        "class": `${prefixCls}-target`,
        "disabled": mergedDisabled.value,
        "onClick": handleClick,
        "onChange": handleChange,
        "onFocus": handleFocus,
        "onBlur": handleBlur
      }, null), (_d = (_c = (_b = slots.checkbox) != null ? _b : (_a = checkboxGroupCtx == null ? void 0 : checkboxGroupCtx.slots) == null ? void 0 : _a.checkbox) == null ? void 0 : _c({
        checked: computedChecked.value,
        disabled: mergedDisabled.value
      })) != null ? _d : createVNode(IconHover, {
        "class": `${prefixCls}-icon-hover`,
        "disabled": mergedDisabled.value || computedChecked.value
      }, {
        default: () => [createVNode("div", {
          "class": `${prefixCls}-icon`
        }, [computedChecked.value && createVNode(IconCheck, {
          "class": `${prefixCls}-icon-check`
        }, null)])]
      }), slots.default && createVNode("span", {
        "class": `${prefixCls}-label`
      }, [slots.default()])]);
    };
  }
});

// node_modules/@arco-design/web-vue/es/checkbox/checkbox-group.js
var CheckboxGroup = defineComponent({
  name: "CheckboxGroup",
  props: {
    modelValue: {
      type: Array,
      default: void 0
    },
    defaultValue: {
      type: Array,
      default: () => []
    },
    max: {
      type: Number
    },
    options: {
      type: Array
    },
    direction: {
      type: String,
      default: "horizontal"
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  emits: {
    "update:modelValue": (value) => true,
    "change": (value, ev) => true
  },
  setup(props, {
    emit,
    slots
  }) {
    const {
      disabled
    } = toRefs(props);
    const prefixCls = getPrefixCls("checkbox-group");
    const {
      mergedDisabled,
      eventHandlers
    } = useFormItem({
      disabled
    });
    const _value = ref(props.defaultValue);
    const computedValue = computed(() => isArray(props.modelValue) ? props.modelValue : _value.value);
    const isMaxed = computed(() => props.max === void 0 ? false : computedValue.value.length >= props.max);
    const options = computed(() => {
      var _a;
      return ((_a = props.options) != null ? _a : []).map((option) => {
        if (isString(option) || isNumber(option)) {
          return {
            label: option,
            value: option
          };
        }
        return option;
      });
    });
    const handleChange = (value, e2) => {
      var _a, _b;
      _value.value = value;
      emit("update:modelValue", value);
      emit("change", value, e2);
      (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onChange) == null ? void 0 : _b.call(_a, e2);
    };
    provide(checkboxGroupKey, reactive({
      name: "ArcoCheckboxGroup",
      computedValue,
      disabled: mergedDisabled,
      isMaxed,
      slots,
      handleChange
    }));
    const cls = computed(() => [prefixCls, `${prefixCls}-direction-${props.direction}`]);
    watch(() => props.modelValue, (curValue) => {
      if (isArray(curValue)) {
        _value.value = [...curValue];
      } else {
        _value.value = [];
      }
    });
    const renderOptions = () => {
      return options.value.map((option) => {
        const checked = computedValue.value.includes(option.value);
        return createVNode(_Checkbox, {
          "key": option.value,
          "value": option.value,
          "disabled": option.disabled || !checked && isMaxed.value,
          "indeterminate": option.indeterminate,
          "modelValue": checked
        }, {
          default: () => [slots.label ? slots.label({
            data: option
          }) : isFunction(option.label) ? option.label() : option.label]
        });
      });
    };
    return () => {
      var _a;
      return createVNode("span", {
        "class": cls.value
      }, [options.value.length > 0 ? renderOptions() : (_a = slots.default) == null ? void 0 : _a.call(slots)]);
    };
  }
});

// node_modules/@arco-design/web-vue/es/checkbox/index.js
var Checkbox = Object.assign(_Checkbox, {
  Group: CheckboxGroup,
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Checkbox.name, _Checkbox);
    app.component(componentPrefix + CheckboxGroup.name, CheckboxGroup);
  }
});

// node_modules/@arco-design/web-vue/es/select/context.js
var selectInjectionKey = Symbol("ArcoSelectContext");

// node_modules/@arco-design/web-vue/es/select/utils.js
var __defProp8 = Object.defineProperty;
var __defProps3 = Object.defineProperties;
var __getOwnPropDescs3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols8 = Object.getOwnPropertySymbols;
var __hasOwnProp8 = Object.prototype.hasOwnProperty;
var __propIsEnum8 = Object.prototype.propertyIsEnumerable;
var __defNormalProp8 = (obj, key, value) => key in obj ? __defProp8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues8 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp8.call(b, prop))
      __defNormalProp8(a, prop, b[prop]);
  if (__getOwnPropSymbols8)
    for (var prop of __getOwnPropSymbols8(b)) {
      if (__propIsEnum8.call(b, prop))
        __defNormalProp8(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps3 = (a, b) => __defProps3(a, __getOwnPropDescs3(b));
var isGroupOption = (option) => {
  return isObject(option) && "isGroup" in option;
};
var isGroupOptionInfo = (option) => {
  return isObject(option) && "isGroup" in option;
};
var getValueString = (value, valueKey = "value") => String(isObject(value) ? value[valueKey] : value);
var getKeyFromValue = (value, valueKey = "value") => {
  if (isObject(value)) {
    return `__arco__option__object__${value[valueKey]}`;
  }
  if (value || isNumber(value)) {
    return `__arco__option__${typeof value}-${value}`;
  }
  return "";
};
var createOptionInfo = (option, {
  valueKey,
  fieldNames,
  origin,
  index: index3 = -1
}) => {
  var _a;
  if (isObject(option)) {
    const value = option[fieldNames.value];
    return {
      raw: option,
      index: index3,
      key: getKeyFromValue(value, valueKey),
      origin,
      value,
      label: (_a = option[fieldNames.label]) != null ? _a : getValueString(value, valueKey),
      render: option[fieldNames.render],
      disabled: Boolean(option[fieldNames.disabled]),
      tagProps: option[fieldNames.tagProps]
    };
  }
  const raw = {
    value: option,
    label: String(option),
    disabled: false
  };
  return __spreadValues8({
    raw,
    index: index3,
    key: getKeyFromValue(option, valueKey),
    origin
  }, raw);
};
var getOptionInfos = (options, {
  valueKey,
  fieldNames,
  origin,
  optionInfoMap
}) => {
  var _a;
  const infos = [];
  for (const item of options) {
    if (isGroupOption(item)) {
      const options2 = getOptionInfos((_a = item.options) != null ? _a : [], {
        valueKey,
        fieldNames,
        origin,
        optionInfoMap
      });
      if (options2.length > 0) {
        infos.push(__spreadProps3(__spreadValues8({}, item), {
          key: `__arco__group__${item.label}`,
          options: options2
        }));
      }
    } else {
      const optionInfo = createOptionInfo(item, {
        valueKey,
        fieldNames,
        origin
      });
      infos.push(optionInfo);
      if (!optionInfoMap.get(optionInfo.key)) {
        optionInfoMap.set(optionInfo.key, optionInfo);
      }
    }
  }
  return infos;
};
var getValidOptions = (optionInfos, {
  inputValue,
  filterOption
}) => {
  const travel = (optionInfos2) => {
    var _a;
    const options = [];
    for (const item of optionInfos2) {
      if (isGroupOptionInfo(item)) {
        const _options = travel((_a = item.options) != null ? _a : []);
        if (_options.length > 0) {
          options.push(__spreadProps3(__spreadValues8({}, item), { options: _options }));
        }
      } else if (isValidOption(item, { inputValue, filterOption })) {
        options.push(item);
      }
    }
    return options;
  };
  return travel(optionInfos);
};
var isValidOption = (optionInfo, {
  inputValue,
  filterOption
}) => {
  if (isFunction(filterOption)) {
    return !inputValue || filterOption(inputValue, optionInfo.raw);
  }
  if (filterOption) {
    return optionInfo.label.toLowerCase().includes((inputValue != null ? inputValue : "").toLowerCase());
  }
  return true;
};

// node_modules/@arco-design/web-vue/es/_utils/is-equal.js
var isEqualObject = (obj, other) => {
  if (!obj || !other) {
    return false;
  }
  if (obj.length !== other.length) {
    return false;
  }
  for (const key of Object.keys(obj)) {
    const result = isEqual(obj[key], other[key]);
    if (!result)
      return false;
  }
  return true;
};
var isEqualArray = (arr, other) => {
  if (!arr || !other) {
    return false;
  }
  const { length } = arr;
  if (length !== other.length) {
    return false;
  }
  for (let i2 = 0; i2 < length; i2++) {
    const result = isEqual(arr[i2], other[i2]);
    if (!result)
      return false;
  }
  return true;
};
var isEqual = (a, b) => {
  const type = Object.prototype.toString.call(a);
  if (type !== Object.prototype.toString.call(b)) {
    return false;
  }
  if (type === "[object Object]") {
    return isEqualObject(a, b);
  }
  if (type === "[object Array]") {
    return isEqualArray(a, b);
  }
  if (type === "[object Function]") {
    if (a === b) {
      return true;
    }
    return a.toString() === b.toString();
  }
  return a === b;
};

// node_modules/@arco-design/web-vue/es/select/option.js
var _sfc_main24 = defineComponent({
  name: "Option",
  components: {
    Checkbox
  },
  props: {
    value: [String, Number, Object],
    label: String,
    disabled: Boolean,
    tagProps: {
      type: Object
    },
    extra: {
      type: Object
    },
    index: {
      type: Number
    },
    internal: Boolean
  },
  setup(props) {
    const { disabled, tagProps: _tagProps, index: index3 } = toRefs(props);
    const prefixCls = getPrefixCls("select-option");
    const selectCtx = inject(selectInjectionKey, void 0);
    const instance = getCurrentInstance();
    const itemRef = ref();
    const tagProps = ref(_tagProps.value);
    watch(_tagProps, (cur, pre) => {
      if (!isEqual(cur, pre)) {
        tagProps.value = cur;
      }
    });
    const textContent = ref("");
    const value = computed(() => {
      var _a, _b;
      return (_b = (_a = props.value) != null ? _a : props.label) != null ? _b : textContent.value;
    });
    const label = computed(() => {
      var _a;
      return (_a = props.label) != null ? _a : textContent.value;
    });
    const key = computed(() => getKeyFromValue(value.value, selectCtx == null ? void 0 : selectCtx.valueKey));
    const component = computed(() => {
      var _a;
      return (_a = selectCtx == null ? void 0 : selectCtx.component) != null ? _a : "li";
    });
    const setTextContent = () => {
      var _a;
      if (!props.label && itemRef.value) {
        const text = (_a = itemRef.value.textContent) != null ? _a : "";
        if (textContent.value !== text) {
          textContent.value = text;
        }
      }
    };
    onMounted(() => setTextContent());
    onUpdated(() => setTextContent());
    const isSelected = computed(() => {
      var _a;
      return (_a = selectCtx == null ? void 0 : selectCtx.valueKeys.includes(key.value)) != null ? _a : false;
    });
    const isActive = computed(() => (selectCtx == null ? void 0 : selectCtx.activeKey) === key.value);
    let isValid = ref(true);
    if (!props.internal) {
      const optionInfo = reactive({
        raw: {
          value,
          label,
          disabled,
          tagProps
        },
        ref: itemRef,
        index: index3,
        key,
        origin: "slot",
        value,
        label,
        disabled,
        tagProps
      });
      isValid = computed(() => isValidOption(optionInfo, {
        inputValue: selectCtx == null ? void 0 : selectCtx.inputValue,
        filterOption: selectCtx == null ? void 0 : selectCtx.filterOption
      }));
      if (instance) {
        selectCtx == null ? void 0 : selectCtx.addSlotOptionInfo(instance.uid, optionInfo);
      }
      onBeforeUnmount(() => {
        if (instance) {
          selectCtx == null ? void 0 : selectCtx.removeSlotOptionInfo(instance.uid);
        }
      });
    }
    const handleClick = (ev) => {
      if (!props.disabled) {
        selectCtx == null ? void 0 : selectCtx.onSelect(key.value, ev);
      }
    };
    const handleMouseEnter = () => {
      if (!props.disabled) {
        selectCtx == null ? void 0 : selectCtx.setActiveKey(key.value);
      }
    };
    const handleMouseLeave = () => {
      if (!props.disabled) {
        selectCtx == null ? void 0 : selectCtx.setActiveKey();
      }
    };
    const cls = computed(() => [
      prefixCls,
      {
        [`${prefixCls}-disabled`]: props.disabled,
        [`${prefixCls}-active`]: isActive.value,
        [`${prefixCls}-multiple`]: selectCtx == null ? void 0 : selectCtx.multiple
      }
    ]);
    return {
      prefixCls,
      cls,
      selectCtx,
      itemRef,
      component,
      isSelected,
      isValid,
      handleClick,
      handleMouseEnter,
      handleMouseLeave
    };
  }
});
function _sfc_render24(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_checkbox = resolveComponent("checkbox");
  return withDirectives((openBlock(), createBlock(resolveDynamicComponent(_ctx.component), {
    ref: "itemRef",
    class: normalizeClass([_ctx.cls, { [`${_ctx.prefixCls}-has-suffix`]: Boolean(_ctx.$slots.suffix) }]),
    onClick: _ctx.handleClick,
    onMouseenter: _ctx.handleMouseEnter,
    onMouseleave: _ctx.handleMouseLeave
  }, {
    default: withCtx(() => [
      _ctx.$slots.icon ? (openBlock(), createElementBlock("span", {
        key: 0,
        class: normalizeClass(`${_ctx.prefixCls}-icon`)
      }, [
        renderSlot(_ctx.$slots, "icon")
      ], 2)) : createCommentVNode("v-if", true),
      _ctx.selectCtx && _ctx.selectCtx.multiple ? (openBlock(), createBlock(_component_checkbox, {
        key: 1,
        class: normalizeClass(`${_ctx.prefixCls}-checkbox`),
        "model-value": _ctx.isSelected,
        disabled: _ctx.disabled,
        "uninject-group-context": ""
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createTextVNode(toDisplayString(_ctx.label), 1)
          ])
        ]),
        _: 3
      }, 8, ["class", "model-value", "disabled"])) : (openBlock(), createElementBlock("span", {
        key: 2,
        class: normalizeClass(`${_ctx.prefixCls}-content`)
      }, [
        renderSlot(_ctx.$slots, "default", {}, () => [
          createTextVNode(toDisplayString(_ctx.label), 1)
        ])
      ], 2)),
      _ctx.$slots.suffix ? (openBlock(), createElementBlock("span", {
        key: 3,
        class: normalizeClass(`${_ctx.prefixCls}-suffix`)
      }, [
        renderSlot(_ctx.$slots, "suffix")
      ], 2)) : createCommentVNode("v-if", true)
    ]),
    _: 3
  }, 8, ["class", "onClick", "onMouseenter", "onMouseleave"])), [
    [vShow, _ctx.isValid]
  ]);
}
var Option = _export_sfc(_sfc_main24, [["render", _sfc_render24]]);

// node_modules/@arco-design/web-vue/es/select/hooks/use-options.js
var __defProp9 = Object.defineProperty;
var __defProps4 = Object.defineProperties;
var __getOwnPropDescs4 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols9 = Object.getOwnPropertySymbols;
var __hasOwnProp9 = Object.prototype.hasOwnProperty;
var __propIsEnum9 = Object.prototype.propertyIsEnumerable;
var __defNormalProp9 = (obj, key, value) => key in obj ? __defProp9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues9 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp9.call(b, prop))
      __defNormalProp9(a, prop, b[prop]);
  if (__getOwnPropSymbols9)
    for (var prop of __getOwnPropSymbols9(b)) {
      if (__propIsEnum9.call(b, prop))
        __defNormalProp9(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps4 = (a, b) => __defProps4(a, __getOwnPropDescs4(b));
var DEFAULT_FIELD_NAMES = {
  value: "value",
  label: "label",
  disabled: "disabled",
  tagProps: "tagProps",
  render: "render"
};
var useOptions = ({
  options,
  extraOptions,
  inputValue,
  filterOption,
  showExtraOptions,
  valueKey,
  fieldNames
}) => {
  const mergedFieldNames = computed(() => __spreadValues9(__spreadValues9({}, DEFAULT_FIELD_NAMES), fieldNames == null ? void 0 : fieldNames.value));
  const slotOptionInfoMap = reactive(/* @__PURE__ */ new Map());
  const sortedSlotOptionInfos = ref([]);
  watch(slotOptionInfoMap, (slotOptionInfoMap2) => {
    sortedSlotOptionInfos.value = Array.from(slotOptionInfoMap2.values()).sort((a, b) => {
      if (isNumber(a.index) && isNumber(b.index)) {
        return a.index - b.index;
      }
      return 0;
    });
  }, { deep: true });
  const propOptionData = computed(() => {
    var _a, _b;
    const optionInfoMap2 = /* @__PURE__ */ new Map();
    const optionInfos = getOptionInfos((_a = options == null ? void 0 : options.value) != null ? _a : [], {
      valueKey: (_b = valueKey == null ? void 0 : valueKey.value) != null ? _b : "value",
      fieldNames: mergedFieldNames.value,
      origin: "options",
      optionInfoMap: optionInfoMap2
    });
    return {
      optionInfos,
      optionInfoMap: optionInfoMap2
    };
  });
  const extraOptionData = computed(() => {
    var _a, _b;
    const optionInfoMap2 = /* @__PURE__ */ new Map();
    const optionInfos = getOptionInfos((_a = extraOptions == null ? void 0 : extraOptions.value) != null ? _a : [], {
      valueKey: (_b = valueKey == null ? void 0 : valueKey.value) != null ? _b : "value",
      fieldNames: mergedFieldNames.value,
      origin: "extraOptions",
      optionInfoMap: optionInfoMap2
    });
    return {
      optionInfos,
      optionInfoMap: optionInfoMap2
    };
  });
  const optionInfoMap = reactive(/* @__PURE__ */ new Map());
  watch([
    slotOptionInfoMap,
    options != null ? options : ref([]),
    extraOptions != null ? extraOptions : ref([]),
    valueKey != null ? valueKey : ref("value")
  ], () => {
    optionInfoMap.clear();
    sortedSlotOptionInfos.value.forEach((info, index3) => {
      optionInfoMap.set(info.key, __spreadProps4(__spreadValues9({}, info), { index: index3 }));
    });
    propOptionData.value.optionInfoMap.forEach((info) => {
      if (!optionInfoMap.has(info.key)) {
        info.index = optionInfoMap.size;
        optionInfoMap.set(info.key, info);
      }
    });
    extraOptionData.value.optionInfoMap.forEach((info) => {
      if (!optionInfoMap.has(info.key)) {
        info.index = optionInfoMap.size;
        optionInfoMap.set(info.key, info);
      }
    });
  }, { immediate: true, deep: true });
  const validOptions = computed(() => {
    var _a;
    const options2 = getValidOptions(propOptionData.value.optionInfos, {
      inputValue: inputValue == null ? void 0 : inputValue.value,
      filterOption: filterOption == null ? void 0 : filterOption.value
    });
    if ((_a = showExtraOptions == null ? void 0 : showExtraOptions.value) != null ? _a : true) {
      options2.push(...getValidOptions(extraOptionData.value.optionInfos, {
        inputValue: inputValue == null ? void 0 : inputValue.value,
        filterOption: filterOption == null ? void 0 : filterOption.value
      }));
    }
    return options2;
  });
  const validOptionInfos = computed(() => Array.from(optionInfoMap.values()).filter((optionInfo) => {
    if (optionInfo.origin === "extraOptions" && (showExtraOptions == null ? void 0 : showExtraOptions.value) === false) {
      return false;
    }
    return isValidOption(optionInfo, {
      inputValue: inputValue == null ? void 0 : inputValue.value,
      filterOption: filterOption == null ? void 0 : filterOption.value
    });
  }));
  const enabledOptionKeys = computed(() => validOptionInfos.value.filter((optionInfo) => !optionInfo.disabled).map((info) => info.key));
  const getNextSlotOptionIndex = () => slotOptionInfoMap.size;
  const addSlotOptionInfo = (id, optionInfo) => {
    slotOptionInfoMap.set(id, optionInfo);
  };
  const removeSlotOptionInfo = (id) => {
    slotOptionInfoMap.delete(id);
  };
  return {
    validOptions,
    optionInfoMap,
    validOptionInfos,
    enabledOptionKeys,
    getNextSlotOptionIndex,
    addSlotOptionInfo,
    removeSlotOptionInfo
  };
};

// node_modules/@arco-design/web-vue/es/_utils/keyboard.js
var KEYBOARD_KEY = {
  ENTER: "Enter",
  ESC: "Escape",
  BACKSPACE: "Backspace",
  TAB: "Tab",
  SPACE: " ",
  ARROW_UP: "ArrowUp",
  ARROW_DOWN: "ArrowDown",
  ARROW_LEFT: "ArrowLeft",
  ARROW_RIGHT: "ArrowRight"
};
var stringifyCodeKey = (k) => {
  return JSON.stringify({
    key: k.key,
    ctrl: Boolean(k.ctrl),
    shift: Boolean(k.shift),
    alt: Boolean(k.alt),
    meta: Boolean(k.meta)
  });
};
var getKeyDownHandler = (codeKeyMap) => {
  const map = {};
  codeKeyMap.forEach((callback, codeKey) => {
    const _codeKey = isString(codeKey) ? { key: codeKey } : codeKey;
    map[stringifyCodeKey(_codeKey)] = callback;
  });
  return (event) => {
    const key = stringifyCodeKey({
      key: event.key,
      ctrl: event.ctrlKey,
      shift: event.shiftKey,
      alt: event.altKey,
      meta: event.metaKey
    });
    const callback = map[key];
    if (callback) {
      event.stopPropagation();
      callback(event);
    }
  };
};

// node_modules/@arco-design/web-vue/es/select/hooks/use-select.js
var useSelect = ({
  multiple,
  options,
  extraOptions,
  inputValue,
  filterOption,
  showExtraOptions,
  component,
  valueKey,
  fieldNames,
  loading,
  popupVisible,
  valueKeys,
  dropdownRef,
  optionRefs,
  virtualListRef,
  onSelect,
  onPopupVisibleChange,
  enterToOpen = true,
  defaultActiveFirstOption
}) => {
  const {
    validOptions,
    optionInfoMap,
    validOptionInfos,
    enabledOptionKeys,
    getNextSlotOptionIndex,
    addSlotOptionInfo,
    removeSlotOptionInfo
  } = useOptions({
    options,
    extraOptions,
    inputValue,
    filterOption,
    showExtraOptions,
    valueKey,
    fieldNames
  });
  const activeKey = ref();
  watch(enabledOptionKeys, (enabledKeys) => {
    if (!activeKey.value || !enabledKeys.includes(activeKey.value)) {
      activeKey.value = enabledKeys[0];
    }
  });
  const setActiveKey = (key) => {
    activeKey.value = key;
  };
  const getNextActiveKey = (direction) => {
    const _length = enabledOptionKeys.value.length;
    if (_length === 0) {
      return void 0;
    }
    if (!activeKey.value) {
      if (direction === "down") {
        return enabledOptionKeys.value[0];
      }
      return enabledOptionKeys.value[_length - 1];
    }
    const activeIndex = enabledOptionKeys.value.indexOf(activeKey.value);
    const nextIndex = (_length + activeIndex + (direction === "up" ? -1 : 1)) % _length;
    return enabledOptionKeys.value[nextIndex];
  };
  const scrollIntoView2 = (key) => {
    var _a, _b;
    if (virtualListRef == null ? void 0 : virtualListRef.value) {
      virtualListRef.value.scrollTo({ key });
    }
    const optionInfo = optionInfoMap.get(key);
    const wrapperEle = (_a = dropdownRef == null ? void 0 : dropdownRef.value) == null ? void 0 : _a.wrapperRef;
    const optionEle = (_b = optionRefs == null ? void 0 : optionRefs.value[key]) != null ? _b : optionInfo == null ? void 0 : optionInfo.ref;
    if (!wrapperEle || !optionEle) {
      return;
    }
    if (wrapperEle.scrollHeight === wrapperEle.offsetHeight) {
      return;
    }
    const optionRect = getRelativeRect(optionEle, wrapperEle);
    const wrapperScrollTop = wrapperEle.scrollTop;
    if (optionRect.top < 0) {
      wrapperEle.scrollTo(0, wrapperScrollTop + optionRect.top);
    } else if (optionRect.bottom < 0) {
      wrapperEle.scrollTo(0, wrapperScrollTop - optionRect.bottom);
    }
  };
  watch(popupVisible, (visible) => {
    var _a;
    if (visible) {
      const current = valueKeys.value[valueKeys.value.length - 1];
      let _activeKey = ((_a = defaultActiveFirstOption == null ? void 0 : defaultActiveFirstOption.value) != null ? _a : true) ? enabledOptionKeys.value[0] : void 0;
      if (enabledOptionKeys.value.includes(current)) {
        _activeKey = current;
      }
      if (_activeKey !== activeKey.value) {
        activeKey.value = _activeKey;
      }
      nextTick(() => {
        if (activeKey.value) {
          scrollIntoView2(activeKey.value);
        }
      });
    }
  });
  const handleKeyDown = getKeyDownHandler(/* @__PURE__ */ new Map([
    [
      KEYBOARD_KEY.ENTER,
      (e2) => {
        if (!(loading == null ? void 0 : loading.value)) {
          if (popupVisible.value) {
            if (activeKey.value) {
              onSelect(activeKey.value, e2);
              e2.preventDefault();
            }
          } else if (enterToOpen) {
            onPopupVisibleChange(true);
            e2.preventDefault();
          }
        }
      }
    ],
    [
      KEYBOARD_KEY.ESC,
      (e2) => {
        if (popupVisible.value) {
          onPopupVisibleChange(false);
          e2.preventDefault();
        }
      }
    ],
    [
      KEYBOARD_KEY.ARROW_DOWN,
      (e2) => {
        if (popupVisible.value) {
          const next = getNextActiveKey("down");
          if (next) {
            activeKey.value = next;
            scrollIntoView2(next);
          }
          e2.preventDefault();
        }
      }
    ],
    [
      KEYBOARD_KEY.ARROW_UP,
      (e2) => {
        if (popupVisible.value) {
          const next = getNextActiveKey("up");
          if (next) {
            activeKey.value = next;
            scrollIntoView2(next);
          }
          e2.preventDefault();
        }
      }
    ]
  ]));
  provide(selectInjectionKey, reactive({
    multiple,
    valueKey,
    inputValue,
    filterOption,
    component,
    valueKeys,
    activeKey,
    setActiveKey,
    onSelect,
    getNextSlotOptionIndex,
    addSlotOptionInfo,
    removeSlotOptionInfo
  }));
  return {
    validOptions,
    optionInfoMap,
    validOptionInfos,
    enabledOptionKeys,
    activeKey,
    setActiveKey,
    addSlotOptionInfo,
    removeSlotOptionInfo,
    getNextActiveKey,
    scrollIntoView: scrollIntoView2,
    handleKeyDown
  };
};

// node_modules/@arco-design/web-vue/es/auto-complete/auto-complete.js
var _AutoComplete = defineComponent({
  name: "AutoComplete",
  inheritAttrs: false,
  props: {
    modelValue: {
      type: String,
      default: void 0
    },
    defaultValue: {
      type: String,
      default: ""
    },
    disabled: {
      type: Boolean,
      default: false
    },
    data: {
      type: Array,
      default: () => []
    },
    popupContainer: {
      type: [String, Object]
    },
    strict: {
      type: Boolean,
      default: false
    },
    filterOption: {
      type: [Boolean, Function],
      default: true
    },
    triggerProps: {
      type: Object
    },
    allowClear: {
      type: Boolean,
      default: false
    }
  },
  emits: {
    "update:modelValue": (value) => true,
    "change": (value) => true,
    "search": (value) => true,
    "select": (value) => true,
    "clear": (ev) => true
  },
  setup(props, {
    emit,
    attrs,
    slots
  }) {
    const {
      modelValue
    } = toRefs(props);
    const prefixCls = getPrefixCls("auto-complete");
    const {
      mergedDisabled,
      eventHandlers
    } = useFormItem({
      disabled: toRef(props, "disabled")
    });
    const _value = ref(props.defaultValue);
    const inputRef = ref();
    const computedValue = computed(() => {
      var _a;
      return (_a = props.modelValue) != null ? _a : _value.value;
    });
    watch(modelValue, (value) => {
      if (isUndefined(value) || isNull(value)) {
        _value.value = "";
      }
    });
    const computedValueKeys = computed(() => computedValue.value ? [getKeyFromValue(computedValue.value)] : []);
    const {
      data
    } = toRefs(props);
    const dropdownRef = ref();
    const optionRefs = ref({});
    const _popupVisible = ref(false);
    const computedPopupVisible = computed(() => _popupVisible.value && validOptionInfos.value.length > 0);
    const handlePopupVisibleChange = (popupVisible) => {
      _popupVisible.value = popupVisible;
    };
    const strictFilterOption = (inputValue, option) => {
      var _a;
      return Boolean((_a = option.label) == null ? void 0 : _a.includes(inputValue));
    };
    const mergedFilterOption = computed(() => {
      if (isFunction(props.filterOption)) {
        return props.filterOption;
      }
      if (props.filterOption && props.strict) {
        return strictFilterOption;
      }
      return props.filterOption;
    });
    const handleChange = (value) => {
      var _a, _b;
      _value.value = value;
      emit("update:modelValue", value);
      emit("change", value);
      (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onChange) == null ? void 0 : _b.call(_a);
    };
    const handleClear = (ev) => {
      var _a, _b;
      _value.value = "";
      emit("update:modelValue", "");
      emit("change", "");
      (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onChange) == null ? void 0 : _b.call(_a);
      emit("clear", ev);
    };
    const handleSelect = (key, ev) => {
      var _a, _b;
      const value = (_a = optionInfoMap.get(key)) == null ? void 0 : _a.value;
      emit("select", value);
      handleChange(value);
      (_b = inputRef.value) == null ? void 0 : _b.blur();
    };
    const handleInputValueChange = (value) => {
      emit("search", value);
      handleChange(value);
    };
    const {
      validOptions,
      optionInfoMap,
      validOptionInfos,
      handleKeyDown
    } = useSelect({
      options: data,
      inputValue: computedValue,
      filterOption: mergedFilterOption,
      popupVisible: computedPopupVisible,
      valueKeys: computedValueKeys,
      dropdownRef,
      optionRefs,
      onSelect: handleSelect,
      onPopupVisibleChange: handlePopupVisibleChange
    });
    const getOptionContentFunc = (item) => {
      if (isFunction(slots.option) && item.value) {
        const optionInfo = optionInfoMap.get(item.key);
        const optionSlot = slots.option;
        return () => optionSlot({
          data: optionInfo
        });
      }
      return () => item.label;
    };
    const renderOption = (item) => {
      return createVNode(Option, {
        "ref": (ref2) => {
          if (ref2 == null ? void 0 : ref2.$el) {
            optionRefs.value[item.key] = ref2.$el;
          }
        },
        "key": item.key,
        "value": item.value,
        "disabled": item.disabled,
        "internal": true
      }, {
        default: getOptionContentFunc(item)
      });
    };
    const renderDropdown = () => {
      return createVNode(SelectDropdown, {
        "ref": dropdownRef,
        "class": `${prefixCls}-dropdown`
      }, {
        default: () => [validOptions.value.map((info) => renderOption(info))],
        footer: slots.footer
      });
    };
    const render2 = () => createVNode(Trigger, mergeProps({
      "trigger": "focus",
      "position": "bl",
      "animationName": "slide-dynamic-origin",
      "autoFitTransformOrigin": true,
      "popupVisible": computedPopupVisible.value,
      "clickToClose": false,
      "preventFocus": true,
      "popupOffset": 4,
      "disabled": mergedDisabled.value,
      "autoFitPopupWidth": true
    }, props.triggerProps, {
      "onPopupVisibleChange": handlePopupVisibleChange
    }), {
      default: () => [createVNode(Input, mergeProps({
        "ref": inputRef
      }, attrs, {
        "allowClear": props.allowClear,
        "modelValue": computedValue.value,
        "disabled": mergedDisabled.value,
        "onInput": handleInputValueChange,
        "onClear": handleClear,
        "onKeydown": handleKeyDown
      }), slots)],
      content: renderDropdown
    });
    return {
      inputRef,
      render: render2
    };
  },
  methods: {
    focus() {
      var _a;
      (_a = this.inputRef) == null ? void 0 : _a.focus();
    },
    blur() {
      var _a;
      (_a = this.inputRef) == null ? void 0 : _a.blur();
    }
  },
  render() {
    return this.render();
  }
});

// node_modules/@arco-design/web-vue/es/auto-complete/index.js
var AutoComplete = Object.assign(_AutoComplete, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _AutoComplete.name, _AutoComplete);
  }
});

// node_modules/@arco-design/web-vue/es/_hooks/use-index.js
var useIndex = ({
  itemRef,
  selector,
  index: index3,
  parentClassName
}) => {
  const _index = ref(-1);
  const computedIndex = computed(() => {
    var _a;
    return (_a = index3 == null ? void 0 : index3.value) != null ? _a : _index.value;
  });
  const parent = ref();
  const getParent = () => {
    var _a, _b, _c;
    let parent2 = (_b = (_a = itemRef.value) == null ? void 0 : _a.parentElement) != null ? _b : void 0;
    if (parentClassName) {
      while (parent2 && !parent2.className.includes(parentClassName)) {
        parent2 = (_c = parent2.parentElement) != null ? _c : void 0;
      }
    }
    return parent2;
  };
  const getIndex = () => {
    if (isUndefined(index3 == null ? void 0 : index3.value) && parent.value && itemRef.value) {
      const index22 = Array.from(parent.value.querySelectorAll(selector)).indexOf(itemRef.value);
      if (index22 !== _index.value) {
        _index.value = index22;
      }
    }
  };
  watch(itemRef, () => {
    if (itemRef.value && !parent.value) {
      parent.value = getParent();
    }
  });
  onMounted(() => {
    if (itemRef.value) {
      parent.value = getParent();
    }
    getIndex();
  });
  onUpdated(() => getIndex());
  return {
    computedIndex
  };
};

// node_modules/@arco-design/web-vue/es/avatar/context.js
var avatarGroupInjectionKey = Symbol("ArcoAvatarGroup");

// node_modules/@arco-design/web-vue/es/icon/icon-image-close/icon-image-close.js
var _sfc_main25 = defineComponent({
  name: "IconImageClose",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-image-close`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_114 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_212 = createStaticVNode('<path d="M41 26V9a2 2 0 0 0-2-2H9a2 2 0 0 0-2 2v30a2 2 0 0 0 2 2h17"></path><path d="m24 33 9-8.5V27s-2 1-3.5 2.5C27.841 31.159 27 33 27 33h-3Zm0 0-3.5-4.5L17 33h7Z"></path><path d="M20.5 28.5 17 33h7l-3.5-4.5ZM33 24.5 24 33h3s.841-1.841 2.5-3.5C31 28 33 27 33 27v-2.5Z" fill="currentColor" stroke="none"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M46 38a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-4.95-4.782 1.74 1.74-3.045 3.046 3.046 3.046-1.74 1.74-3.047-3.045-3.046 3.046-1.74-1.74 3.046-3.047-3.046-3.046 1.74-1.74 3.046 3.046 3.046-3.046Z" fill="currentColor" stroke="none"></path><path d="M17 15h-2v2h2v-2Z"></path>', 5);
var _hoisted_7 = [
  _hoisted_212
];
function _sfc_render25(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_7, 14, _hoisted_114);
}
var _IconImageClose = _export_sfc(_sfc_main25, [["render", _sfc_render25]]);

// node_modules/@arco-design/web-vue/es/icon/icon-image-close/index.js
var IconImageClose = Object.assign(_IconImageClose, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconImageClose.name, _IconImageClose);
  }
});

// node_modules/@arco-design/web-vue/es/avatar/avatar.js
var __defProp10 = Object.defineProperty;
var __getOwnPropSymbols10 = Object.getOwnPropertySymbols;
var __hasOwnProp10 = Object.prototype.hasOwnProperty;
var __propIsEnum10 = Object.prototype.propertyIsEnumerable;
var __defNormalProp10 = (obj, key, value) => key in obj ? __defProp10(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues10 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp10.call(b, prop))
      __defNormalProp10(a, prop, b[prop]);
  if (__getOwnPropSymbols10)
    for (var prop of __getOwnPropSymbols10(b)) {
      if (__propIsEnum10.call(b, prop))
        __defNormalProp10(a, prop, b[prop]);
    }
  return a;
};
var _sfc_main26 = defineComponent({
  name: "Avatar",
  components: {
    ResizeObserver: ResizeObserver3,
    IconImageClose,
    IconLoading
  },
  props: {
    shape: {
      type: String,
      default: "circle"
    },
    imageUrl: String,
    size: Number,
    autoFixFontSize: {
      type: Boolean,
      default: true
    },
    triggerType: {
      type: String,
      default: "button"
    },
    triggerIconStyle: {
      type: Object
    }
  },
  emits: {
    click: (ev) => true,
    error: () => true,
    load: () => true
  },
  setup(props, { slots, emit, attrs }) {
    const { shape, size, autoFixFontSize, triggerType, triggerIconStyle } = toRefs(props);
    const prefixCls = getPrefixCls("avatar");
    const groupCtx = inject(avatarGroupInjectionKey, void 0);
    const itemRef = ref();
    const wrapperRef = ref();
    const mergedShape = computed(() => {
      var _a;
      return (_a = groupCtx == null ? void 0 : groupCtx.shape) != null ? _a : shape.value;
    });
    const mergedSize = computed(() => {
      var _a;
      return (_a = groupCtx == null ? void 0 : groupCtx.size) != null ? _a : size.value;
    });
    const mergedAutoFixFontSize = computed(() => {
      var _a;
      return (_a = groupCtx == null ? void 0 : groupCtx.autoFixFontSize) != null ? _a : autoFixFontSize.value;
    });
    const isImage2 = ref(false);
    const hasError = ref(false);
    const shouldLoad = ref(true);
    const isLoaded = ref(false);
    const index3 = groupCtx ? useIndex({
      itemRef,
      selector: `.${prefixCls}`
    }).computedIndex : ref(-1);
    const outerStyle = computed(() => {
      var _a;
      const style = isNumber(mergedSize.value) ? {
        width: `${mergedSize.value}px`,
        height: `${mergedSize.value}px`,
        fontSize: `${mergedSize.value / 2}px`
      } : {};
      if (groupCtx) {
        style.zIndex = groupCtx.zIndexAscend ? index3.value + 1 : groupCtx.total - index3.value;
        style.marginLeft = index3.value !== 0 ? `-${((_a = mergedSize.value) != null ? _a : 40) / 4}px` : "0";
      }
      return style;
    });
    const computedTriggerIconStyle = useTriggerIconStyle({
      triggerIconStyle: triggerIconStyle == null ? void 0 : triggerIconStyle.value,
      inlineStyle: attrs.style,
      triggerType: triggerType.value
    });
    const autoFixFontSizeHandler = () => {
      if (!isImage2.value && !props.imageUrl) {
        nextTick(() => {
          var _a;
          if (!wrapperRef.value || !itemRef.value) {
            return;
          }
          const textWidth = wrapperRef.value.clientWidth;
          const avatarWidth = (_a = mergedSize.value) != null ? _a : itemRef.value.offsetWidth;
          const scale = avatarWidth / (textWidth + 8);
          if (avatarWidth && scale < 1) {
            wrapperRef.value.style.transform = `scale(${scale}) translateX(-50%)`;
          }
          shouldLoad.value = true;
        });
      }
    };
    onMounted(() => {
      var _a;
      if (((_a = wrapperRef.value) == null ? void 0 : _a.firstElementChild) && ["IMG", "PICTURE"].includes(wrapperRef.value.firstElementChild.tagName)) {
        isImage2.value = true;
      }
      if (mergedAutoFixFontSize.value) {
        autoFixFontSizeHandler();
      }
    });
    watch(size, () => {
      if (mergedAutoFixFontSize.value) {
        autoFixFontSizeHandler();
      }
    });
    const cls = computed(() => [
      prefixCls,
      `${prefixCls}-${mergedShape.value}`
    ]);
    const wrapperCls = computed(() => isImage2.value || props.imageUrl ? `${prefixCls}-image` : `${prefixCls}-text`);
    const onClick = (e2) => {
      emit("click", e2);
    };
    const handleResize = () => {
      if (mergedAutoFixFontSize.value) {
        autoFixFontSizeHandler();
      }
    };
    const handleImgLoad = () => {
      isLoaded.value = true;
      emit("load");
    };
    const handleImgError = () => {
      hasError.value = true;
      emit("error");
    };
    return {
      prefixCls,
      itemRef,
      cls,
      outerStyle,
      wrapperRef,
      wrapperCls,
      computedTriggerIconStyle,
      isImage: isImage2,
      shouldLoad,
      isLoaded,
      hasError,
      onClick,
      handleResize,
      handleImgLoad,
      handleImgError
    };
  }
});
var useTriggerIconStyle = ({
  triggerType,
  inlineStyle = {},
  triggerIconStyle = {}
}) => {
  let addon = {};
  if (triggerType === "button" && (!triggerIconStyle || triggerIconStyle && !triggerIconStyle.color) && inlineStyle && inlineStyle.backgroundColor) {
    addon = { color: inlineStyle.backgroundColor };
  }
  return __spreadValues10(__spreadValues10({}, triggerIconStyle), addon);
};
var _hoisted_115 = ["src"];
function _sfc_render26(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_IconImageClose = resolveComponent("IconImageClose");
  const _component_IconLoading = resolveComponent("IconLoading");
  const _component_resize_observer = resolveComponent("resize-observer");
  return openBlock(), createElementBlock("div", {
    ref: "itemRef",
    style: normalizeStyle(_ctx.outerStyle),
    class: normalizeClass([
      _ctx.cls,
      {
        [`${_ctx.prefixCls}-with-trigger-icon`]: Boolean(_ctx.$slots["trigger-icon"])
      }
    ]),
    onClick: _cache[2] || (_cache[2] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, [
    createVNode(_component_resize_observer, { onResize: _ctx.handleResize }, {
      default: withCtx(() => [
        createBaseVNode("span", {
          ref: "wrapperRef",
          class: normalizeClass(_ctx.wrapperCls)
        }, [
          _ctx.imageUrl ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            _ctx.hasError ? renderSlot(_ctx.$slots, "error", { key: 0 }, () => [
              createBaseVNode("div", {
                class: normalizeClass(`${_ctx.prefixCls}-image-icon`)
              }, [
                createVNode(_component_IconImageClose)
              ], 2)
            ]) : createCommentVNode("v-if", true),
            !(_ctx.hasError || !_ctx.shouldLoad) && !_ctx.isLoaded ? renderSlot(_ctx.$slots, "default", { key: 1 }, () => [
              createBaseVNode("div", {
                class: normalizeClass(`${_ctx.prefixCls}-image-icon`)
              }, [
                createVNode(_component_IconLoading)
              ], 2)
            ]) : createCommentVNode("v-if", true),
            !(_ctx.hasError || !_ctx.shouldLoad) ? (openBlock(), createElementBlock("img", {
              key: 2,
              src: _ctx.imageUrl,
              style: normalizeStyle({ width: _ctx.size + "px", height: _ctx.size + "px" }),
              alt: "avatar",
              onLoad: _cache[0] || (_cache[0] = (...args) => _ctx.handleImgLoad && _ctx.handleImgLoad(...args)),
              onError: _cache[1] || (_cache[1] = (...args) => _ctx.handleImgError && _ctx.handleImgError(...args))
            }, null, 44, _hoisted_115)) : createCommentVNode("v-if", true)
          ], 64)) : renderSlot(_ctx.$slots, "default", { key: 1 })
        ], 2)
      ]),
      _: 3
    }, 8, ["onResize"]),
    _ctx.$slots["trigger-icon"] ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(`${_ctx.prefixCls}-trigger-icon-${_ctx.triggerType}`),
      style: normalizeStyle(_ctx.computedTriggerIconStyle)
    }, [
      renderSlot(_ctx.$slots, "trigger-icon")
    ], 6)) : createCommentVNode("v-if", true)
  ], 6);
}
var _Avatar = _export_sfc(_sfc_main26, [["render", _sfc_render26]]);

// node_modules/@arco-design/web-vue/es/popover/popover.js
var _sfc_main27 = defineComponent({
  name: "Popover",
  components: {
    Trigger
  },
  props: {
    popupVisible: {
      type: Boolean,
      default: void 0
    },
    defaultPopupVisible: {
      type: Boolean,
      default: false
    },
    title: String,
    content: String,
    trigger: {
      type: [String, Array],
      default: "hover"
    },
    position: {
      type: String,
      default: "top"
    },
    contentClass: {
      type: [String, Array, Object]
    },
    contentStyle: {
      type: Object
    },
    arrowClass: {
      type: [String, Array, Object]
    },
    arrowStyle: {
      type: Object
    },
    popupContainer: {
      type: [String, Object]
    }
  },
  emits: {
    "update:popupVisible": (visible) => true,
    "popupVisibleChange": (visible) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("popover");
    const _popupVisible = ref(props.defaultPopupVisible);
    const computedPopupVisible = computed(() => {
      var _a;
      return (_a = props.popupVisible) != null ? _a : _popupVisible.value;
    });
    const handlePopupVisibleChange = (visible) => {
      _popupVisible.value = visible;
      emit("update:popupVisible", visible);
      emit("popupVisibleChange", visible);
    };
    const contentCls = computed(() => [
      `${prefixCls}-popup-content`,
      props.contentClass
    ]);
    const arrowCls = computed(() => [
      `${prefixCls}-popup-arrow`,
      props.arrowClass
    ]);
    return {
      prefixCls,
      computedPopupVisible,
      contentCls,
      arrowCls,
      handlePopupVisibleChange
    };
  }
});
function _sfc_render27(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_trigger = resolveComponent("trigger");
  return openBlock(), createBlock(_component_trigger, {
    class: normalizeClass(_ctx.prefixCls),
    trigger: _ctx.trigger,
    position: _ctx.position,
    "popup-visible": _ctx.computedPopupVisible,
    "popup-offset": 10,
    "content-class": _ctx.contentCls,
    "content-style": _ctx.contentStyle,
    "arrow-class": _ctx.arrowCls,
    "arrow-style": _ctx.arrowStyle,
    "show-arrow": "",
    "popup-container": _ctx.popupContainer,
    "animation-name": "zoom-in-fade-out",
    "auto-fit-transform-origin": "",
    onPopupVisibleChange: _ctx.handlePopupVisibleChange
  }, {
    content: withCtx(() => [
      createBaseVNode("div", {
        class: normalizeClass(`${_ctx.prefixCls}-title`)
      }, [
        renderSlot(_ctx.$slots, "title", {}, () => [
          createTextVNode(toDisplayString(_ctx.title), 1)
        ])
      ], 2),
      createBaseVNode("div", {
        class: normalizeClass(`${_ctx.prefixCls}-content`)
      }, [
        renderSlot(_ctx.$slots, "content", {}, () => [
          createTextVNode(toDisplayString(_ctx.content), 1)
        ])
      ], 2)
    ]),
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 8, ["class", "trigger", "position", "popup-visible", "content-class", "content-style", "arrow-class", "arrow-style", "popup-container", "onPopupVisibleChange"]);
}
var _Popover = _export_sfc(_sfc_main27, [["render", _sfc_render27]]);

// node_modules/@arco-design/web-vue/es/popover/index.js
var Popover = Object.assign(_Popover, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Popover.name, _Popover);
  }
});

// node_modules/@arco-design/web-vue/es/avatar/avatar-group.js
var AvatarGroup = defineComponent({
  name: "AvatarGroup",
  props: {
    shape: {
      type: String,
      default: "circle"
    },
    size: Number,
    autoFixFontSize: {
      type: Boolean,
      default: true
    },
    maxCount: {
      type: Number,
      default: 0
    },
    zIndexAscend: {
      type: Boolean,
      default: false
    },
    maxStyle: {
      type: Object
    },
    maxPopoverTriggerProps: {
      type: Object
    }
  },
  setup(props, {
    slots
  }) {
    const {
      shape,
      size,
      autoFixFontSize,
      zIndexAscend
    } = toRefs(props);
    const prefixCls = getPrefixCls("avatar-group");
    const total = ref(0);
    provide(avatarGroupInjectionKey, reactive({
      shape,
      size,
      autoFixFontSize,
      zIndexAscend,
      total
    }));
    return () => {
      var _a, _b;
      const children = getAllElements((_b = (_a = slots.default) == null ? void 0 : _a.call(slots)) != null ? _b : []);
      const avatarsToRender = props.maxCount > 0 ? children.slice(0, props.maxCount) : children;
      const avatarsInPopover = props.maxCount > 0 ? children.slice(props.maxCount) : [];
      if (total.value !== avatarsToRender.length) {
        total.value = avatarsToRender.length;
      }
      return createVNode("div", {
        "class": prefixCls
      }, [avatarsToRender, avatarsInPopover.length > 0 && createVNode(Popover, props.maxPopoverTriggerProps, {
        default: () => [createVNode(_Avatar, {
          "class": `${prefixCls}-max-count-avatar`,
          "style": props.maxStyle
        }, {
          default: () => [createTextVNode("+"), avatarsInPopover.length]
        })],
        content: () => createVNode("div", null, [avatarsInPopover])
      })]);
    };
  }
});

// node_modules/@arco-design/web-vue/es/avatar/index.js
var Avatar = Object.assign(_Avatar, {
  Group: AvatarGroup,
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Avatar.name, _Avatar);
    app.component(componentPrefix + AvatarGroup.name, AvatarGroup);
  }
});

// node_modules/@arco-design/web-vue/es/icon/icon-to-top/icon-to-top.js
var _sfc_main28 = defineComponent({
  name: "IconToTop",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-to-top`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_116 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_213 = createBaseVNode("path", { d: "M43 7H5M24 20v23M24 13.96 30.453 21H17.546L24 13.96Zm.736-.804Z" }, null, -1);
var _hoisted_311 = createBaseVNode("path", {
  d: "m24 14-6 7h12l-6-7Z",
  fill: "currentColor",
  stroke: "none"
}, null, -1);
var _hoisted_43 = [
  _hoisted_213,
  _hoisted_311
];
function _sfc_render28(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_43, 14, _hoisted_116);
}
var _IconToTop = _export_sfc(_sfc_main28, [["render", _sfc_render28]]);

// node_modules/@arco-design/web-vue/es/icon/icon-to-top/index.js
var IconToTop = Object.assign(_IconToTop, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconToTop.name, _IconToTop);
  }
});

// node_modules/@arco-design/web-vue/es/back-top/back-top.js
var _sfc_main29 = defineComponent({
  name: "BackTop",
  components: {
    IconToTop
  },
  props: {
    visibleHeight: {
      type: Number,
      default: 200
    },
    targetContainer: {
      type: [String, Object]
    },
    easing: {
      type: String,
      default: "quartOut"
    },
    duration: {
      type: Number,
      default: 200
    }
  },
  setup(props) {
    const prefixCls = getPrefixCls("back-top");
    const visible = ref(false);
    const target3 = ref();
    const isWindow2 = !props.targetContainer;
    const scrollHandler = throttleByRaf(() => {
      if (target3.value) {
        const { visibleHeight } = props;
        const { scrollTop } = target3.value;
        visible.value = scrollTop >= visibleHeight;
      }
    });
    const getContainer = (container2) => {
      if (isString(container2)) {
        return document.querySelector(container2);
      }
      return container2;
    };
    onMounted(() => {
      target3.value = isWindow2 ? document == null ? void 0 : document.documentElement : getContainer(props.targetContainer);
      if (target3.value) {
        on(isWindow2 ? window : target3.value, "scroll", scrollHandler);
        scrollHandler();
      }
    });
    onUnmounted(() => {
      scrollHandler.cancel();
      if (target3.value) {
        off(isWindow2 ? window : target3.value, "scroll", scrollHandler);
      }
    });
    const scrollToTop = () => {
      if (target3.value) {
        const { scrollTop } = target3.value;
        const tween = new b_tween_es_default({
          from: { scrollTop },
          to: { scrollTop: 0 },
          easing: props.easing,
          duration: props.duration,
          onUpdate: (keys) => {
            if (target3.value) {
              target3.value.scrollTop = keys.scrollTop;
            }
          }
        });
        tween.start();
      }
    };
    return {
      prefixCls,
      visible,
      scrollToTop
    };
  }
});
function _sfc_render29(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_to_top = resolveComponent("icon-to-top");
  return openBlock(), createBlock(Transition, { name: "fade-in" }, {
    default: withCtx(() => [
      _ctx.visible ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(_ctx.prefixCls),
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.scrollToTop && _ctx.scrollToTop(...args))
      }, [
        renderSlot(_ctx.$slots, "default", {}, () => [
          createBaseVNode("button", {
            class: normalizeClass(`${_ctx.prefixCls}-btn`)
          }, [
            createVNode(_component_icon_to_top)
          ], 2)
        ])
      ], 2)) : createCommentVNode("v-if", true)
    ]),
    _: 3
  });
}
var _BackTop = _export_sfc(_sfc_main29, [["render", _sfc_render29]]);

// node_modules/@arco-design/web-vue/es/back-top/index.js
var BackTop = Object.assign(_BackTop, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _BackTop.name, _BackTop);
  }
});

// node_modules/@arco-design/web-vue/es/badge/badge.js
var __defProp11 = Object.defineProperty;
var __getOwnPropSymbols11 = Object.getOwnPropertySymbols;
var __hasOwnProp11 = Object.prototype.hasOwnProperty;
var __propIsEnum11 = Object.prototype.propertyIsEnumerable;
var __defNormalProp11 = (obj, key, value) => key in obj ? __defProp11(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues11 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp11.call(b, prop))
      __defNormalProp11(a, prop, b[prop]);
  if (__getOwnPropSymbols11)
    for (var prop of __getOwnPropSymbols11(b)) {
      if (__propIsEnum11.call(b, prop))
        __defNormalProp11(a, prop, b[prop]);
    }
  return a;
};
var COLORS = ["red", "orangered", "orange", "gold", "lime", "green", "cyan", "arcoblue", "purple", "pinkpurple", "magenta", "gray"];
var BADGE_STATUSES = ["normal", "processing", "success", "warning", "danger"];
var _Badge = defineComponent({
  name: "Badge",
  props: {
    text: {
      type: String
    },
    dot: {
      type: Boolean
    },
    dotStyle: {
      type: Object
    },
    maxCount: {
      type: Number,
      default: 99
    },
    offset: {
      type: Array,
      default: () => []
    },
    color: {
      type: String
    },
    status: {
      type: String,
      validator: (value) => {
        return BADGE_STATUSES.includes(value);
      }
    },
    count: {
      type: Number
    }
  },
  setup(props, {
    slots
  }) {
    const {
      status,
      color,
      dotStyle,
      offset,
      text,
      dot,
      maxCount,
      count
    } = toRefs(props);
    const prefixCls = getPrefixCls("badge");
    const wrapperClassName = useWrapperClass(prefixCls, status == null ? void 0 : status.value, slots == null ? void 0 : slots.default);
    const computedStyleRef = computed(() => {
      const computedDotStyle = __spreadValues11({}, (dotStyle == null ? void 0 : dotStyle.value) || {});
      const [leftOffset, topOffset] = (offset == null ? void 0 : offset.value) || [];
      if (leftOffset) {
        computedDotStyle.marginRight = `${-leftOffset}px`;
      }
      if (topOffset) {
        computedDotStyle.marginTop = `${topOffset}px`;
      }
      const computedColorStyle = !(color == null ? void 0 : color.value) || COLORS.includes(color == null ? void 0 : color.value) ? {} : {
        backgroundColor: color.value
      };
      const mergedStyle = __spreadValues11(__spreadValues11({}, computedColorStyle), computedDotStyle);
      return {
        mergedStyle,
        computedDotStyle,
        computedColorStyle
      };
    });
    const getDot = () => {
      const textValue = text == null ? void 0 : text.value;
      const colorValue = color == null ? void 0 : color.value;
      const statusValue = status == null ? void 0 : status.value;
      const dotValue = dot == null ? void 0 : dot.value;
      const countValue = Number(count == null ? void 0 : count.value);
      const hasCount = (count == null ? void 0 : count.value) != null;
      const {
        computedDotStyle,
        mergedStyle
      } = computedStyleRef.value;
      if (slots.content) {
        return createVNode("span", {
          "class": `${prefixCls}-custom-dot`,
          "style": computedDotStyle
        }, [slots.content()]);
      }
      if (textValue && !colorValue && !statusValue) {
        return createVNode("span", {
          "class": `${prefixCls}-text`,
          "style": computedDotStyle
        }, [textValue]);
      }
      if (statusValue || colorValue && !hasCount) {
        return createVNode("span", {
          "class": `${prefixCls}-status-wrapper`
        }, [createVNode("span", {
          "class": [`${prefixCls}-status-dot`, {
            [`${prefixCls}-status-${statusValue}`]: statusValue,
            [`${prefixCls}-color-${colorValue}`]: colorValue
          }],
          "style": mergedStyle
        }, null), textValue && createVNode("span", {
          "class": `${prefixCls}-status-text`
        }, [textValue])]);
      }
      if ((dotValue || colorValue) && countValue > 0) {
        return createVNode("span", {
          "class": [`${prefixCls}-dot`, {
            [`${prefixCls}-color-${colorValue}`]: colorValue
          }],
          "style": mergedStyle
        }, null);
      }
      if (countValue === 0) {
        return null;
      }
      return createVNode("span", {
        "class": `${prefixCls}-number`,
        "style": mergedStyle
      }, [createVNode("span", null, [maxCount.value && countValue > maxCount.value ? `${maxCount.value}+` : countValue])]);
    };
    return () => {
      return createVNode("span", {
        "class": wrapperClassName.value
      }, [slots.default && slots.default(), getDot()]);
    };
  }
});
var useWrapperClass = (prefixCls, status, children) => {
  return computed(() => [prefixCls, {
    [`${prefixCls}-status`]: status,
    [`${prefixCls}-no-children`]: !children
  }]);
};

// node_modules/@arco-design/web-vue/es/badge/index.js
var Badge = Object.assign(_Badge, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Badge.name, _Badge);
  }
});

// node_modules/@arco-design/web-vue/es/breadcrumb/context.js
var breadcrumbInjectKey = Symbol("ArcoBreadcrumb");

// node_modules/@arco-design/web-vue/es/icon/icon-more/icon-more.js
var _sfc_main30 = defineComponent({
  name: "IconMore",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-more`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_117 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_214 = createBaseVNode("path", {
  d: "M38 25v-2h2v2h-2ZM23 25v-2h2v2h-2ZM8 25v-2h2v2H8Z",
  fill: "currentColor",
  stroke: "none"
}, null, -1);
var _hoisted_312 = createBaseVNode("path", { d: "M38 25v-2h2v2h-2ZM23 25v-2h2v2h-2ZM8 25v-2h2v2H8Z" }, null, -1);
var _hoisted_44 = [
  _hoisted_214,
  _hoisted_312
];
function _sfc_render30(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_44, 14, _hoisted_117);
}
var _IconMore = _export_sfc(_sfc_main30, [["render", _sfc_render30]]);

// node_modules/@arco-design/web-vue/es/icon/icon-more/index.js
var IconMore = Object.assign(_IconMore, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconMore.name, _IconMore);
  }
});

// node_modules/@arco-design/web-vue/es/icon/icon-down/icon-down.js
var _sfc_main31 = defineComponent({
  name: "IconDown",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-down`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_118 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_215 = createBaseVNode("path", { d: "M39.6 17.443 24.043 33 8.487 17.443" }, null, -1);
var _hoisted_313 = [
  _hoisted_215
];
function _sfc_render31(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_313, 14, _hoisted_118);
}
var _IconDown = _export_sfc(_sfc_main31, [["render", _sfc_render31]]);

// node_modules/@arco-design/web-vue/es/icon/icon-down/index.js
var IconDown = Object.assign(_IconDown, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconDown.name, _IconDown);
  }
});

// node_modules/@arco-design/web-vue/es/icon/icon-oblique-line/icon-oblique-line.js
var _sfc_main32 = defineComponent({
  name: "IconObliqueLine",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-oblique-line`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_119 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_216 = createBaseVNode("path", { d: "M29.506 6.502 18.493 41.498" }, null, -1);
var _hoisted_314 = [
  _hoisted_216
];
function _sfc_render32(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_314, 14, _hoisted_119);
}
var _IconObliqueLine = _export_sfc(_sfc_main32, [["render", _sfc_render32]]);

// node_modules/@arco-design/web-vue/es/icon/icon-oblique-line/index.js
var IconObliqueLine = Object.assign(_IconObliqueLine, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconObliqueLine.name, _IconObliqueLine);
  }
});

// node_modules/@arco-design/web-vue/es/dropdown/context.js
var dropdownInjectionKey = Symbol("ArcoDropdown");

// node_modules/@arco-design/web-vue/es/dropdown/dropdown-panel.js
var _sfc_main33 = defineComponent({
  name: "DropdownPanel",
  components: {
    Scrollbar,
    Empty: Empty2
  },
  props: {
    loading: {
      type: Boolean,
      default: false
    },
    isEmpty: {
      type: Boolean,
      default: false
    },
    bottomOffset: {
      type: Number,
      default: 0
    },
    onScroll: {
      type: [Function, Array]
    },
    onReachBottom: {
      type: [Function, Array]
    }
  },
  emits: ["scroll", "reachBottom"],
  setup(props, { emit, slots }) {
    const prefixCls = getPrefixCls("dropdown");
    const dropdownCtx = inject(dropdownInjectionKey, {});
    const wrapperRef = ref();
    const handleScroll = (e2) => {
      const { scrollTop, scrollHeight, offsetHeight } = e2.target;
      const bottom = scrollHeight - (scrollTop + offsetHeight);
      if (bottom <= props.bottomOffset) {
        emit("reachBottom", e2);
      }
      emit("scroll", e2);
    };
    const style = computed(() => {
      if (isNumber(dropdownCtx.popupMaxHeight)) {
        return {
          maxHeight: `${dropdownCtx.popupMaxHeight}px`
        };
      }
      if (!dropdownCtx.popupMaxHeight) {
        return {
          maxHeight: "none",
          overflowY: "hidden"
        };
      }
      return void 0;
    });
    const cls = computed(() => [
      prefixCls,
      {
        [`${prefixCls}-has-footer`]: Boolean(slots.footer)
      }
    ]);
    return {
      prefixCls,
      cls,
      style,
      wrapperRef,
      handleScroll
    };
  }
});
function _sfc_render33(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_empty = resolveComponent("empty");
  const _component_Scrollbar = resolveComponent("Scrollbar");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.cls)
  }, [
    _ctx.isEmpty ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(`${_ctx.prefixCls}-empty`)
    }, [
      renderSlot(_ctx.$slots, "empty", {}, () => [
        createVNode(_component_empty)
      ])
    ], 2)) : createCommentVNode("v-if", true),
    createVNode(_component_Scrollbar, {
      ref: "wrapperRef",
      class: normalizeClass(`${_ctx.prefixCls}-list-wrapper`),
      style: normalizeStyle(_ctx.style),
      onScroll: _ctx.handleScroll
    }, {
      default: withCtx(() => [
        createBaseVNode("ul", {
          class: normalizeClass(`${_ctx.prefixCls}-list`)
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 2)
      ]),
      _: 3
    }, 8, ["class", "style", "onScroll"]),
    _ctx.$slots.footer && !_ctx.isEmpty ? (openBlock(), createElementBlock("div", {
      key: 1,
      class: normalizeClass(`${_ctx.prefixCls}-footer`)
    }, [
      renderSlot(_ctx.$slots, "footer")
    ], 2)) : createCommentVNode("v-if", true)
  ], 2);
}
var DropdownPanel = _export_sfc(_sfc_main33, [["render", _sfc_render33]]);

// node_modules/@arco-design/web-vue/es/_hooks/use-trigger.js
var useTrigger = ({
  popupVisible,
  defaultPopupVisible,
  emit
}) => {
  var _a;
  const _popupVisible = ref((_a = defaultPopupVisible == null ? void 0 : defaultPopupVisible.value) != null ? _a : false);
  const computedPopupVisible = computed(() => {
    var _a2;
    return (_a2 = popupVisible == null ? void 0 : popupVisible.value) != null ? _a2 : _popupVisible.value;
  });
  const handlePopupVisibleChange = (visible) => {
    if (visible !== computedPopupVisible.value) {
      _popupVisible.value = visible;
      emit("update:popupVisible", visible);
      emit("popupVisibleChange", visible);
    }
  };
  watch(computedPopupVisible, (visible) => {
    if (_popupVisible.value !== visible) {
      _popupVisible.value = visible;
    }
  });
  return {
    computedPopupVisible,
    handlePopupVisibleChange
  };
};

// node_modules/@arco-design/web-vue/es/dropdown/dropdown.js
var _sfc_main34 = defineComponent({
  name: "Dropdown",
  components: {
    Trigger,
    DropdownPanel
  },
  props: {
    popupVisible: {
      type: Boolean,
      default: void 0
    },
    defaultPopupVisible: {
      type: Boolean,
      default: false
    },
    trigger: {
      type: [String, Array],
      default: "click"
    },
    position: {
      type: String,
      default: "bottom"
    },
    popupContainer: {
      type: [String, Object]
    },
    popupMaxHeight: {
      type: [Boolean, Number],
      default: true
    },
    hideOnSelect: {
      type: Boolean,
      default: true
    }
  },
  emits: {
    "update:popupVisible": (visible) => true,
    "popupVisibleChange": (visible) => true,
    "select": (value, ev) => true
  },
  setup(props, { emit }) {
    const { defaultPopupVisible, popupVisible, popupMaxHeight } = toRefs(props);
    const prefixCls = getPrefixCls("dropdown");
    const { computedPopupVisible, handlePopupVisibleChange } = useTrigger({
      defaultPopupVisible,
      popupVisible,
      emit
    });
    const handleOptionClick = (value, ev) => {
      emit("select", value, ev);
      props.hideOnSelect && handlePopupVisibleChange(false);
    };
    provide(dropdownInjectionKey, reactive({
      popupMaxHeight,
      onOptionClick: handleOptionClick
    }));
    return {
      prefixCls,
      computedPopupVisible,
      handlePopupVisibleChange
    };
  }
});
function _sfc_render34(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_DropdownPanel = resolveComponent("DropdownPanel");
  const _component_Trigger = resolveComponent("Trigger");
  return openBlock(), createBlock(_component_Trigger, {
    "popup-visible": _ctx.computedPopupVisible,
    "animation-name": "slide-dynamic-origin",
    "auto-fit-transform-origin": "",
    trigger: _ctx.trigger,
    position: _ctx.position,
    "popup-offset": 4,
    "popup-container": _ctx.popupContainer,
    "opened-class": `${_ctx.prefixCls}-open`,
    onPopupVisibleChange: _ctx.handlePopupVisibleChange
  }, {
    content: withCtx(() => [
      createVNode(_component_DropdownPanel, null, createSlots({
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "content")
        ]),
        _: 2
      }, [
        _ctx.$slots.footer ? {
          name: "footer",
          fn: withCtx(() => [
            renderSlot(_ctx.$slots, "footer")
          ])
        } : void 0
      ]), 1024)
    ]),
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 8, ["popup-visible", "trigger", "position", "popup-container", "opened-class", "onPopupVisibleChange"]);
}
var _Dropdown = _export_sfc(_sfc_main34, [["render", _sfc_render34]]);

// node_modules/@arco-design/web-vue/es/dropdown/dropdown-option.js
var _sfc_main35 = defineComponent({
  name: "Doption",
  props: {
    value: {
      type: [String, Number, Object]
    },
    disabled: {
      type: Boolean,
      default: false
    },
    active: Boolean,
    uninjectContext: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("dropdown-option");
    const liRef = ref();
    const computedValue = computed(() => {
      var _a, _b, _c;
      return (_c = (_b = props.value) != null ? _b : (_a = liRef.value) == null ? void 0 : _a.textContent) != null ? _c : void 0;
    });
    const dropdownCtx = !props.uninjectContext ? inject(dropdownInjectionKey, void 0) : void 0;
    const handleClick = (ev) => {
      if (!props.disabled) {
        emit("click", ev);
        dropdownCtx == null ? void 0 : dropdownCtx.onOptionClick(computedValue.value, ev);
      }
    };
    const cls = computed(() => [
      prefixCls,
      {
        [`${prefixCls}-disabled`]: props.disabled,
        [`${prefixCls}-active`]: props.active
      }
    ]);
    return {
      prefixCls,
      cls,
      liRef,
      handleClick
    };
  }
});
function _sfc_render35(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("li", {
    ref: "liRef",
    class: normalizeClass([_ctx.cls, { [`${_ctx.prefixCls}-has-suffix`]: Boolean(_ctx.$slots.suffix) }]),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    _ctx.$slots.icon ? (openBlock(), createElementBlock("span", {
      key: 0,
      class: normalizeClass(`${_ctx.prefixCls}-icon`)
    }, [
      renderSlot(_ctx.$slots, "icon")
    ], 2)) : createCommentVNode("v-if", true),
    createBaseVNode("span", {
      class: normalizeClass(`${_ctx.prefixCls}-content`)
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 2),
    _ctx.$slots.suffix ? (openBlock(), createElementBlock("span", {
      key: 1,
      class: normalizeClass(`${_ctx.prefixCls}-suffix`)
    }, [
      renderSlot(_ctx.$slots, "suffix")
    ], 2)) : createCommentVNode("v-if", true)
  ], 2);
}
var Doption = _export_sfc(_sfc_main35, [["render", _sfc_render35]]);

// node_modules/@arco-design/web-vue/es/dropdown/dropdown-group.js
var _sfc_main36 = defineComponent({
  name: "Dgroup",
  props: {
    title: String
  },
  setup() {
    const prefixCls = getPrefixCls("dropdown-group");
    return {
      prefixCls
    };
  }
});
function _sfc_render36(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(Fragment, null, [
    createBaseVNode("li", {
      class: normalizeClass(`${_ctx.prefixCls}-title`)
    }, [
      renderSlot(_ctx.$slots, "title", {}, () => [
        createTextVNode(toDisplayString(_ctx.title), 1)
      ])
    ], 2),
    renderSlot(_ctx.$slots, "default")
  ], 64);
}
var Dgroup = _export_sfc(_sfc_main36, [["render", _sfc_render36]]);

// node_modules/@arco-design/web-vue/es/icon/icon-right/icon-right.js
var _sfc_main37 = defineComponent({
  name: "IconRight",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-right`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_120 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_217 = createBaseVNode("path", { d: "m16 39.513 15.556-15.557L16 8.4" }, null, -1);
var _hoisted_315 = [
  _hoisted_217
];
function _sfc_render37(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_315, 14, _hoisted_120);
}
var _IconRight = _export_sfc(_sfc_main37, [["render", _sfc_render37]]);

// node_modules/@arco-design/web-vue/es/icon/icon-right/index.js
var IconRight = Object.assign(_IconRight, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconRight.name, _IconRight);
  }
});

// node_modules/@arco-design/web-vue/es/dropdown/dropdown-submenu.js
var _sfc_main38 = defineComponent({
  name: "Dsubmenu",
  components: {
    Trigger,
    DropdownPanel,
    DropdownOption: Doption,
    IconRight
  },
  props: {
    value: {
      type: [String, Number]
    },
    disabled: {
      type: Boolean,
      default: false
    },
    trigger: {
      type: [String, Array],
      default: "click"
    },
    position: {
      type: String,
      default: "rt"
    },
    popupVisible: {
      type: Boolean,
      default: void 0
    },
    defaultPopupVisible: {
      type: Boolean,
      default: false
    },
    optionProps: {
      type: Object
    }
  },
  emits: {
    "update:popupVisible": (visible) => true,
    "popupVisibleChange": (visible) => true
  },
  setup(props, { emit }) {
    const { defaultPopupVisible, popupVisible } = toRefs(props);
    const prefixCls = getPrefixCls("dropdown");
    const { computedPopupVisible, handlePopupVisibleChange } = useTrigger({
      defaultPopupVisible,
      popupVisible,
      emit
    });
    return {
      prefixCls,
      computedPopupVisible,
      handlePopupVisibleChange
    };
  }
});
function _sfc_render38(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_IconRight = resolveComponent("IconRight");
  const _component_dropdown_option = resolveComponent("dropdown-option");
  const _component_dropdown_panel = resolveComponent("dropdown-panel");
  const _component_Trigger = resolveComponent("Trigger");
  return openBlock(), createBlock(_component_Trigger, {
    "popup-visible": _ctx.computedPopupVisible,
    trigger: _ctx.trigger,
    position: _ctx.position,
    disabled: _ctx.disabled,
    "popup-offset": 4,
    onPopupVisibleChange: _ctx.handlePopupVisibleChange
  }, {
    content: withCtx(() => [
      createVNode(_component_dropdown_panel, {
        class: normalizeClass(`${_ctx.prefixCls}-submenu`)
      }, createSlots({
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "content")
        ]),
        _: 2
      }, [
        _ctx.$slots.footer ? {
          name: "footer",
          fn: withCtx(() => [
            renderSlot(_ctx.$slots, "footer")
          ])
        } : void 0
      ]), 1032, ["class"])
    ]),
    default: withCtx(() => [
      createVNode(_component_dropdown_option, mergeProps(_ctx.optionProps, {
        active: _ctx.computedPopupVisible,
        "uninject-context": ""
      }), createSlots({
        suffix: withCtx(() => [
          renderSlot(_ctx.$slots, "suffix", {}, () => [
            createVNode(_component_IconRight)
          ])
        ]),
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 2
      }, [
        _ctx.$slots.icon ? {
          name: "icon",
          fn: withCtx(() => [
            renderSlot(_ctx.$slots, "icon")
          ])
        } : void 0
      ]), 1040, ["active"])
    ]),
    _: 3
  }, 8, ["popup-visible", "trigger", "position", "disabled", "onPopupVisibleChange"]);
}
var Dsubmenu = _export_sfc(_sfc_main38, [["render", _sfc_render38]]);

// node_modules/@arco-design/web-vue/es/dropdown/dropdown-button.js
var _sfc_main39 = defineComponent({
  name: "DropdownButton",
  components: {
    IconMore,
    Button,
    ButtonGroup,
    Dropdown: _Dropdown
  },
  props: {
    popupVisible: {
      type: Boolean,
      default: void 0
    },
    defaultPopupVisible: {
      type: Boolean,
      default: false
    },
    trigger: {
      type: [String, Array],
      default: "click"
    },
    position: {
      type: String,
      default: "br"
    },
    popupContainer: {
      type: [String, Object]
    },
    disabled: {
      type: Boolean,
      default: false
    },
    type: {
      type: String
    },
    size: {
      type: String
    },
    buttonProps: {
      type: Object
    },
    hideOnSelect: {
      type: Boolean,
      default: true
    }
  },
  emits: {
    "update:popupVisible": (visible) => true,
    "popupVisibleChange": (visible) => true,
    "click": (ev) => true,
    "select": (value, ev) => true
  },
  setup(props, { emit }) {
    const { defaultPopupVisible, popupVisible } = toRefs(props);
    const prefixCls = getPrefixCls("dropdown");
    const { computedPopupVisible, handlePopupVisibleChange } = useTrigger({
      defaultPopupVisible,
      popupVisible,
      emit
    });
    const handleClick = (ev) => {
      emit("click", ev);
    };
    const handleSelect = (value, ev) => {
      emit("select", value, ev);
    };
    return {
      prefixCls,
      computedPopupVisible,
      handleClick,
      handleSelect,
      handlePopupVisibleChange
    };
  }
});
function _sfc_render39(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Button = resolveComponent("Button");
  const _component_IconMore = resolveComponent("IconMore");
  const _component_Dropdown = resolveComponent("Dropdown");
  const _component_ButtonGroup = resolveComponent("ButtonGroup");
  return openBlock(), createBlock(_component_ButtonGroup, null, {
    default: withCtx(() => [
      createVNode(_component_Button, mergeProps({
        size: _ctx.size,
        type: _ctx.type,
        disabled: _ctx.disabled
      }, _ctx.buttonProps, { onClick: _ctx.handleClick }), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["size", "type", "disabled", "onClick"]),
      createVNode(_component_Dropdown, {
        "popup-visible": _ctx.computedPopupVisible,
        trigger: _ctx.trigger,
        position: _ctx.position,
        "popup-container": _ctx.popupContainer,
        "hide-on-select": _ctx.hideOnSelect,
        onSelect: _ctx.handleSelect,
        onPopupVisibleChange: _ctx.handlePopupVisibleChange
      }, {
        content: withCtx(() => [
          renderSlot(_ctx.$slots, "content")
        ]),
        default: withCtx(() => [
          createVNode(_component_Button, {
            size: _ctx.size,
            type: _ctx.type,
            disabled: _ctx.disabled
          }, {
            icon: withCtx(() => [
              renderSlot(_ctx.$slots, "icon", { popupVisible: _ctx.computedPopupVisible }, () => [
                createVNode(_component_IconMore)
              ])
            ]),
            _: 3
          }, 8, ["size", "type", "disabled"])
        ]),
        _: 3
      }, 8, ["popup-visible", "trigger", "position", "popup-container", "hide-on-select", "onSelect", "onPopupVisibleChange"])
    ]),
    _: 3
  });
}
var DropdownButton = _export_sfc(_sfc_main39, [["render", _sfc_render39]]);

// node_modules/@arco-design/web-vue/es/dropdown/index.js
var Dropdown = Object.assign(_Dropdown, {
  Option: Doption,
  Group: Dgroup,
  Submenu: Dsubmenu,
  Button: DropdownButton,
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Dropdown.name, _Dropdown);
    app.component(componentPrefix + Doption.name, Doption);
    app.component(componentPrefix + Dgroup.name, Dgroup);
    app.component(componentPrefix + Dsubmenu.name, Dsubmenu);
    app.component(componentPrefix + DropdownButton.name, DropdownButton);
  }
});

// node_modules/@arco-design/web-vue/es/breadcrumb/breadcrumb-item.js
var BreadcrumbItem = defineComponent({
  name: "BreadcrumbItem",
  inheritAttrs: false,
  props: {
    separator: {
      type: [String, Number]
    },
    droplist: {
      type: Array
    },
    dropdownProps: {
      type: Object
    },
    index: {
      type: Number,
      default: 0
    }
  },
  setup(props, {
    slots,
    attrs
  }) {
    const prefixCls = getPrefixCls("breadcrumb-item");
    const breadcrumbCtx = inject(breadcrumbInjectKey, void 0);
    const dropdownVisible = ref(false);
    const show = computed(() => {
      if (breadcrumbCtx && breadcrumbCtx.needHide) {
        if (props.index > 1 && props.index <= breadcrumbCtx.total - breadcrumbCtx.maxCount) {
          return false;
        }
      }
      return true;
    });
    const displayMore = computed(() => {
      if (breadcrumbCtx && breadcrumbCtx.needHide) {
        return props.index === 1;
      }
      return false;
    });
    const showSeparator = computed(() => breadcrumbCtx ? props.index < breadcrumbCtx.total - 1 : true);
    const handleVisibleChange = (visible) => {
      dropdownVisible.value = visible;
    };
    const separatorRender = () => {
      var _a, _b, _c, _d, _e, _f, _g;
      if (!showSeparator.value)
        return null;
      const separatorElement = (_g = (_f = (_e = (_b = (_a = slots.separator) == null ? void 0 : _a.call(slots)) != null ? _b : props.separator) != null ? _e : (_d = breadcrumbCtx == null ? void 0 : (_c = breadcrumbCtx.slots).separator) == null ? void 0 : _d.call(_c)) != null ? _f : breadcrumbCtx == null ? void 0 : breadcrumbCtx.separator) != null ? _g : createVNode(IconObliqueLine, null, null);
      return createVNode("div", {
        "aria-hidden": "true",
        "class": `${prefixCls}-separator`
      }, [separatorElement]);
    };
    const renderItem = () => {
      var _a, _b, _c, _d;
      return createVNode("div", mergeProps({
        "role": "listitem",
        "class": [prefixCls, {
          [`${prefixCls}-with-dropdown`]: props.droplist || slots.droplist
        }]
      }, displayMore.value ? {
        "aria-label": "ellipses of breadcrumb items"
      } : void 0, attrs), [displayMore.value ? (_c = (_b = breadcrumbCtx == null ? void 0 : (_a = breadcrumbCtx.slots)["more-icon"]) == null ? void 0 : _b.call(_a)) != null ? _c : createVNode(IconMore, null, null) : (_d = slots.default) == null ? void 0 : _d.call(slots), (props.droplist || slots.droplist) && createVNode("span", {
        "aria-hidden": true,
        "class": [`${prefixCls}-dropdown-icon`, {
          [`${prefixCls}-dropdown-icon-active`]: dropdownVisible.value
        }]
      }, [createVNode(IconDown, null, null)])]);
    };
    const renderDropdownContent = () => {
      var _a, _b, _c;
      return (_c = (_a = slots.droplist) == null ? void 0 : _a.call(slots)) != null ? _c : (_b = props.droplist) == null ? void 0 : _b.map((item) => createVNode(Doption, {
        "value": item.path
      }, {
        default: () => [item.label]
      }));
    };
    const renderDropdown = () => {
      return createVNode(Dropdown, mergeProps({
        "popupVisible": dropdownVisible.value,
        "onPopupVisibleChange": handleVisibleChange
      }, props.dropdownProps), {
        default: () => [renderItem()],
        content: renderDropdownContent
      });
    };
    return () => {
      if (show.value) {
        return createVNode(Fragment, null, [slots.droplist || props.droplist ? renderDropdown() : renderItem(), separatorRender()]);
      }
      return null;
    };
  }
});

// node_modules/@arco-design/web-vue/es/breadcrumb/breadcrumb.js
var _Breadcrumb = defineComponent({
  name: "Breadcrumb",
  props: {
    maxCount: {
      type: Number,
      default: 0
    },
    routes: {
      type: Array
    },
    separator: {
      type: [String, Number]
    },
    customUrl: {
      type: Function
    }
  },
  setup(props, {
    slots
  }) {
    const {
      maxCount,
      separator,
      routes
    } = toRefs(props);
    const prefixCls = getPrefixCls("breadcrumb");
    const total = ref(0);
    const needHide = computed(() => maxCount.value > 0 && total.value > maxCount.value + 1);
    provide(breadcrumbInjectKey, reactive({
      total,
      maxCount,
      separator,
      needHide,
      slots
    }));
    const defaultItemRender = (route, routes2, paths) => {
      var _a, _b;
      if (routes2.indexOf(route) === routes2.length - 1) {
        return createVNode("span", null, [route.label]);
      }
      const href = (_b = (_a = props.customUrl) == null ? void 0 : _a.call(props, paths)) != null ? _b : `#/${paths.join("/").replace(/^\//, "")}`;
      return createVNode("a", {
        "href": href
      }, [route.label]);
    };
    const renderByRoutes = () => {
      var _a;
      if (!((_a = routes.value) == null ? void 0 : _a.length))
        return null;
      if (total.value !== routes.value.length) {
        total.value = routes.value.length;
      }
      const paths = [];
      return routes.value.map((route, idx, origin) => {
        paths.push((route.path || "").replace(/^\//, ""));
        const currentPaths = [...paths];
        return createVNode(BreadcrumbItem, {
          "key": route.path || route.label,
          "index": idx,
          "droplist": route.children
        }, {
          default: () => {
            var _a2, _b;
            return [(_b = (_a2 = slots["item-render"]) == null ? void 0 : _a2.call(slots, {
              route,
              routes: origin,
              paths: currentPaths
            })) != null ? _b : defaultItemRender(route, origin, currentPaths)];
          }
        });
      });
    };
    const renderByChildren = () => {
      var _a, _b;
      const children = getAllElements((_b = (_a = slots.default) == null ? void 0 : _a.call(slots)) != null ? _b : []);
      if (total.value !== children.length) {
        total.value = children.length;
      }
      return children.map((child, index3) => {
        var _a2;
        child.props = mergeProps((_a2 = child.props) != null ? _a2 : {}, {
          index: index3
        });
        return child;
      });
    };
    return () => {
      return createVNode("div", {
        "role": "list",
        "class": prefixCls
      }, [slots.default ? renderByChildren() : renderByRoutes()]);
    };
  }
});

// node_modules/@arco-design/web-vue/es/breadcrumb/index.js
var Breadcrumb = Object.assign(_Breadcrumb, {
  Item: BreadcrumbItem,
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Breadcrumb.name, _Breadcrumb);
    app.component(componentPrefix + BreadcrumbItem.name, BreadcrumbItem);
  }
});

// node_modules/@arco-design/web-vue/es/card/context.js
var cardInjectionKey = Symbol("ArcoCard");

// node_modules/@arco-design/web-vue/es/card/card.js
var _Card = defineComponent({
  name: "Card",
  components: {
    Spin
  },
  props: {
    bordered: {
      type: Boolean,
      default: true
    },
    loading: {
      type: Boolean,
      default: false
    },
    hoverable: {
      type: Boolean,
      default: false
    },
    size: {
      type: String
    },
    headerStyle: {
      type: Object,
      default: () => ({})
    },
    bodyStyle: {
      type: Object,
      default: () => ({})
    },
    title: {
      type: String
    },
    extra: {
      type: String
    }
  },
  setup(props, {
    slots
  }) {
    const prefixCls = getPrefixCls("card");
    const {
      size
    } = toRefs(props);
    const {
      mergedSize: _mergedSize
    } = useSize(size);
    const mergedSize = computed(() => {
      if (_mergedSize.value === "small" || _mergedSize.value === "mini") {
        return "small";
      }
      return "medium";
    });
    const renderActions = (vns) => {
      const actions = getAllElements(vns);
      return createVNode("div", {
        "class": `${prefixCls}-actions`
      }, [createVNode("div", {
        "class": `${prefixCls}-actions-right`
      }, [actions.map((action, index3) => createVNode("span", {
        "key": `action-${index3}`,
        "class": `${prefixCls}-actions-item`
      }, [action]))])]);
    };
    const cardContext = reactive({
      hasMeta: false,
      hasGrid: false,
      slots,
      renderActions
    });
    provide(cardInjectionKey, cardContext);
    const cls = computed(() => [prefixCls, `${prefixCls}-size-${mergedSize.value}`, {
      [`${prefixCls}-loading`]: props.loading,
      [`${prefixCls}-bordered`]: props.bordered,
      [`${prefixCls}-hoverable`]: props.hoverable,
      [`${prefixCls}-contain-grid`]: cardContext.hasGrid
    }]);
    return () => {
      var _a, _b, _c, _d, _e, _f, _g;
      const hasTitle = Boolean((_a = slots.title) != null ? _a : props.title);
      const hasExtra = Boolean((_b = slots.extra) != null ? _b : props.extra);
      return createVNode("div", {
        "class": cls.value
      }, [(hasTitle || hasExtra) && createVNode("div", {
        "class": [`${prefixCls}-header`, {
          [`${prefixCls}-header-no-title`]: !hasTitle
        }],
        "style": props.headerStyle
      }, [hasTitle && createVNode("div", {
        "class": `${prefixCls}-header-title`
      }, [(_d = (_c = slots.title) == null ? void 0 : _c.call(slots)) != null ? _d : props.title]), hasExtra && createVNode("div", {
        "class": `${prefixCls}-header-extra`
      }, [(_f = (_e = slots.extra) == null ? void 0 : _e.call(slots)) != null ? _f : props.extra])]), slots.cover && createVNode("div", {
        "class": `${prefixCls}-cover`
      }, [slots.cover()]), createVNode("div", {
        "class": `${prefixCls}-body`,
        "style": props.bodyStyle
      }, [props.loading ? createVNode(Spin, null, null) : (_g = slots.default) == null ? void 0 : _g.call(slots), slots.actions && !cardContext.hasMeta && renderActions(slots.actions())])]);
    };
  }
});

// node_modules/@arco-design/web-vue/es/card/card-meta.js
var CardMeta = defineComponent({
  name: "CardMeta",
  props: {
    title: {
      type: String
    },
    description: {
      type: String
    }
  },
  setup(props, {
    slots
  }) {
    const prefixCls = getPrefixCls("card-meta");
    const context = inject(cardInjectionKey);
    onMounted(() => {
      if (context) {
        context.hasMeta = true;
      }
    });
    return () => {
      var _a, _b, _c, _d, _e, _f;
      const hasTitle = Boolean((_a = slots.title) != null ? _a : props.title);
      const hasDesc = Boolean((_b = slots.description) != null ? _b : props.description);
      return createVNode("div", {
        "class": prefixCls
      }, [(hasTitle || hasDesc) && createVNode("div", {
        "class": `${prefixCls}-content`
      }, [hasTitle && createVNode("div", {
        "class": `${prefixCls}-title`
      }, [(_d = (_c = slots.title) == null ? void 0 : _c.call(slots)) != null ? _d : props.title]), hasDesc && createVNode("div", {
        "class": `${prefixCls}-description`
      }, [(_f = (_e = slots.description) == null ? void 0 : _e.call(slots)) != null ? _f : props.description])]), (slots.avatar || (context == null ? void 0 : context.slots.actions)) && createVNode("div", {
        "class": [`${prefixCls}-footer `, {
          [`${prefixCls}-footer-only-actions`]: !slots.avatar
        }]
      }, [slots.avatar && createVNode("div", {
        "class": `${prefixCls}-avatar`
      }, [slots.avatar()]), context && context.slots.actions && context.renderActions(context.slots.actions())])]);
    };
  }
});

// node_modules/@arco-design/web-vue/es/card/card-grid.js
var _sfc_main40 = defineComponent({
  name: "CardGrid",
  props: {
    hoverable: {
      type: Boolean,
      default: false
    }
  },
  setup(props) {
    const prefixCls = getPrefixCls("card-grid");
    const context = inject(cardInjectionKey);
    onMounted(() => {
      if (context) {
        context.hasGrid = true;
      }
    });
    const cls = computed(() => {
      return [
        prefixCls,
        {
          [`${prefixCls}-hoverable`]: props.hoverable
        }
      ];
    });
    return {
      cls
    };
  }
});
function _sfc_render40(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.cls)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
var CardGrid = _export_sfc(_sfc_main40, [["render", _sfc_render40]]);

// node_modules/@arco-design/web-vue/es/card/index.js
var Card = Object.assign(_Card, {
  Meta: CardMeta,
  Grid: CardGrid,
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Card.name, _Card);
    app.component(componentPrefix + CardMeta.name, CardMeta);
    app.component(componentPrefix + CardGrid.name, CardGrid);
  }
});

// node_modules/@arco-design/web-vue/es/carousel/carousel-indicator.js
var _sfc_main41 = defineComponent({
  name: "Indicator",
  props: {
    count: {
      type: Number,
      default: 2
    },
    activeIndex: {
      type: Number,
      default: 0
    },
    type: {
      type: String,
      default: "line"
    },
    position: {
      type: String,
      default: "bottom"
    },
    trigger: {
      type: String,
      default: "click"
    }
  },
  emits: ["select"],
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("carousel-indicator");
    const onClick = (event) => {
      var _a;
      event.preventDefault();
      if (props.type === "slider") {
        const x = event.offsetX;
        const width = event.currentTarget.clientWidth;
        if (event.target === event.currentTarget) {
          const index3 = Math.floor(x / width * props.count);
          index3 !== props.activeIndex && emit("select", index3);
        }
      } else {
        const index3 = Number.parseInt((_a = event.target.getAttribute("data-index")) != null ? _a : "", 10);
        if (!Number.isNaN(index3) && index3 !== props.activeIndex) {
          emit("select", index3);
        }
      }
    };
    const eventHandlers = computed(() => {
      return props.trigger === "click" ? { onClick } : { onMouseover: onClick };
    });
    const cls = computed(() => [
      `${prefixCls}`,
      `${prefixCls}-${props.type}`,
      `${prefixCls}-${props.position}`
    ]);
    const sliderStyle = computed(() => {
      const step = 100 / props.count;
      return { width: `${step}%`, left: `${props.activeIndex * step}%` };
    });
    return {
      prefixCls,
      eventHandlers,
      cls,
      sliderStyle
    };
  }
});
var _hoisted_121 = ["data-index"];
function _sfc_render41(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({ class: _ctx.cls }, _ctx.eventHandlers), [
    _ctx.type === "slider" ? (openBlock(), createElementBlock("span", {
      key: 0,
      style: normalizeStyle(_ctx.sliderStyle),
      class: normalizeClass([`${_ctx.prefixCls}-item`, `${_ctx.prefixCls}-item-active`])
    }, null, 6)) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(Array(_ctx.count), (_, index3) => {
      return openBlock(), createElementBlock("span", {
        key: index3,
        "data-index": index3,
        class: normalizeClass([
          `${_ctx.prefixCls}-item`,
          { [`${_ctx.prefixCls}-item-active`]: index3 === _ctx.activeIndex }
        ])
      }, null, 10, _hoisted_121);
    }), 128))
  ], 16);
}
var CarouselIndicator = _export_sfc(_sfc_main41, [["render", _sfc_render41]]);

// node_modules/@arco-design/web-vue/es/icon/icon-up/icon-up.js
var _sfc_main42 = defineComponent({
  name: "IconUp",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-up`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_122 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_218 = createBaseVNode("path", { d: "M39.6 30.557 24.043 15 8.487 30.557" }, null, -1);
var _hoisted_316 = [
  _hoisted_218
];
function _sfc_render42(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_316, 14, _hoisted_122);
}
var _IconUp = _export_sfc(_sfc_main42, [["render", _sfc_render42]]);

// node_modules/@arco-design/web-vue/es/icon/icon-up/index.js
var IconUp = Object.assign(_IconUp, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconUp.name, _IconUp);
  }
});

// node_modules/@arco-design/web-vue/es/icon/icon-left/icon-left.js
var _sfc_main43 = defineComponent({
  name: "IconLeft",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-left`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_123 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_219 = createBaseVNode("path", { d: "M32 8.4 16.444 23.956 32 39.513" }, null, -1);
var _hoisted_317 = [
  _hoisted_219
];
function _sfc_render43(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_317, 14, _hoisted_123);
}
var _IconLeft = _export_sfc(_sfc_main43, [["render", _sfc_render43]]);

// node_modules/@arco-design/web-vue/es/icon/icon-left/index.js
var IconLeft = Object.assign(_IconLeft, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconLeft.name, _IconLeft);
  }
});

// node_modules/@arco-design/web-vue/es/carousel/carousel-arrow.js
var _sfc_main44 = defineComponent({
  name: "Arrow",
  components: {
    IconUp,
    IconDown,
    IconLeft,
    IconRight
  },
  props: {
    direction: {
      type: String,
      default: "horizontal"
    },
    showArrow: {
      type: String,
      default: "always"
    }
  },
  emits: ["previousClick", "nextClick"],
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("carousel");
    const onPreviousClick = (ev) => {
      emit("previousClick", ev);
    };
    const onNextClick = (ev) => {
      emit("nextClick", ev);
    };
    const cls = computed(() => [
      `${prefixCls}-arrow`,
      {
        [`${prefixCls}-arrow-hover`]: props.showArrow === "hover"
      }
    ]);
    return {
      prefixCls,
      cls,
      onPreviousClick,
      onNextClick
    };
  }
});
function _sfc_render44(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_IconLeft = resolveComponent("IconLeft");
  const _component_IconUp = resolveComponent("IconUp");
  const _component_IconRight = resolveComponent("IconRight");
  const _component_IconDown = resolveComponent("IconDown");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.cls)
  }, [
    createBaseVNode("div", {
      class: normalizeClass(`${_ctx.prefixCls}-arrow-${_ctx.direction === "vertical" ? "top" : "left"}`),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onPreviousClick && _ctx.onPreviousClick(...args))
    }, [
      _ctx.direction === "horizontal" ? (openBlock(), createBlock(_component_IconLeft, { key: 0 })) : (openBlock(), createBlock(_component_IconUp, { key: 1 }))
    ], 2),
    createBaseVNode("div", {
      class: normalizeClass(`${_ctx.prefixCls}-arrow-${_ctx.direction === "vertical" ? "bottom" : "right"}`),
      onClick: _cache[1] || (_cache[1] = (...args) => _ctx.onNextClick && _ctx.onNextClick(...args))
    }, [
      _ctx.direction === "horizontal" ? (openBlock(), createBlock(_component_IconRight, { key: 0 })) : (openBlock(), createBlock(_component_IconDown, { key: 1 }))
    ], 2)
  ], 2);
}
var CarouselArrow = _export_sfc(_sfc_main44, [["render", _sfc_render44]]);

// node_modules/@arco-design/web-vue/es/carousel/context.js
var carouselInjectionKey = Symbol("ArcoCarousel");

// node_modules/@arco-design/web-vue/es/_hooks/use-children-components.js
var useChildrenComponents = (name) => {
  const children = {};
  const components2 = ref([]);
  const getComponents = () => {
    if (children.value) {
      const _components = getComponentsFromChildren(children.value, name);
      if (_components.length !== components2.value.length || _components.toString() !== components2.value.toString()) {
        components2.value = _components;
      }
    }
  };
  onMounted(() => getComponents());
  onUpdated(() => getComponents());
  return {
    children,
    components: components2
  };
};

// node_modules/@arco-design/web-vue/es/carousel/carousel.js
var __defProp12 = Object.defineProperty;
var __getOwnPropSymbols12 = Object.getOwnPropertySymbols;
var __hasOwnProp12 = Object.prototype.hasOwnProperty;
var __propIsEnum12 = Object.prototype.propertyIsEnumerable;
var __defNormalProp12 = (obj, key, value) => key in obj ? __defProp12(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues12 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp12.call(b, prop))
      __defNormalProp12(a, prop, b[prop]);
  if (__getOwnPropSymbols12)
    for (var prop of __getOwnPropSymbols12(b)) {
      if (__propIsEnum12.call(b, prop))
        __defNormalProp12(a, prop, b[prop]);
    }
  return a;
};
var DEFAULT_AUTO_PLAY = {
  interval: 3e3,
  hoverToPause: true
};
function getValidIndex(i2, length) {
  const indexNumber = +i2;
  return typeof indexNumber === "number" && !Number.isNaN(indexNumber) ? (indexNumber + length) % length : i2;
}
var _Carousel = defineComponent({
  name: "Carousel",
  props: {
    current: {
      type: Number
    },
    defaultCurrent: {
      type: Number,
      default: 1
    },
    autoPlay: {
      type: [Boolean, Object],
      default: false
    },
    moveSpeed: {
      type: Number,
      default: 500
    },
    animationName: {
      type: String,
      default: "slide"
    },
    trigger: {
      type: String,
      default: "click"
    },
    direction: {
      type: String,
      default: "horizontal"
    },
    showArrow: {
      type: String,
      default: "always"
    },
    arrowClass: {
      type: String,
      default: ""
    },
    indicatorType: {
      type: String,
      default: "dot"
    },
    indicatorPosition: {
      type: String,
      default: "bottom"
    },
    indicatorClass: {
      type: String,
      default: ""
    },
    transitionTimingFunction: {
      type: String,
      default: "cubic-bezier(0.34, 0.69, 0.1, 1)"
    }
  },
  emits: {
    "update:current": (index3) => true,
    "change": (index3, prevIndex, isManual) => true
  },
  setup(props, {
    emit,
    slots
  }) {
    const {
      current,
      animationName,
      moveSpeed,
      transitionTimingFunction
    } = toRefs(props);
    const prefixCls = getPrefixCls("carousel");
    const isPause = ref(false);
    const previousIndex = ref();
    const slideDirection = ref();
    const computedAutoPlay = computed(() => {
      if (isObject(props.autoPlay)) {
        return __spreadValues12(__spreadValues12({}, DEFAULT_AUTO_PLAY), props.autoPlay);
      }
      return props.autoPlay ? DEFAULT_AUTO_PLAY : {};
    });
    let intervalTimer = 0;
    let animationTimer = 0;
    const {
      children,
      components: components2
    } = useChildrenComponents("CarouselItem");
    const _index = ref(props.defaultCurrent - 1);
    const mergedIndexes = computed(() => {
      const childrenLength = components2.value.length;
      const mergedIndex = isNumber(current.value) ? getValidIndex(current.value - 1, childrenLength) : _index.value;
      const prevIndex = getValidIndex(mergedIndex - 1, childrenLength);
      const nextIndex = getValidIndex(mergedIndex + 1, childrenLength);
      return {
        mergedIndex,
        mergedPrevIndex: prevIndex,
        mergedNextIndex: nextIndex
      };
    });
    const carouselContext = reactive({
      items: components2,
      slideTo,
      mergedIndexes,
      previousIndex,
      animationName,
      slideDirection,
      transitionTimingFunction,
      moveSpeed
    });
    provide(carouselInjectionKey, carouselContext);
    const clearTimer = () => {
      if (intervalTimer) {
        window.clearInterval(intervalTimer);
      }
    };
    watchEffect(() => {
      var _a;
      const {
        interval
      } = computedAutoPlay.value || {};
      const {
        mergedNextIndex
      } = mergedIndexes.value;
      const shouldInterval = ((_a = components2.value) == null ? void 0 : _a.length) > 1 && !isPause.value && Boolean(interval);
      clearTimer();
      if (shouldInterval) {
        intervalTimer = window.setInterval(() => {
          slideTo({
            targetIndex: mergedNextIndex
          });
        }, interval);
      }
    });
    onBeforeUnmount(() => {
      clearTimer();
    });
    function slideTo({
      targetIndex,
      isNegative = false,
      isManual = false
    }) {
      if (!animationTimer && targetIndex !== mergedIndexes.value.mergedIndex) {
        previousIndex.value = _index.value;
        _index.value = targetIndex;
        slideDirection.value = isNegative ? "negative" : "positive";
        animationTimer = window.setTimeout(() => {
          animationTimer = 0;
        }, moveSpeed.value);
        emit("update:current", _index.value + 1);
        emit("change", _index.value + 1, previousIndex.value + 1, isManual);
      }
    }
    const onPreviousClick = () => slideTo({
      targetIndex: mergedIndexes.value.mergedPrevIndex,
      isNegative: true,
      isManual: true
    });
    const onNextClick = () => slideTo({
      targetIndex: mergedIndexes.value.mergedNextIndex,
      isManual: true
    });
    const onSelect = (index3) => slideTo({
      targetIndex: index3,
      isNegative: index3 < mergedIndexes.value.mergedIndex,
      isManual: true
    });
    const eventHandlers = computed(() => {
      return computedAutoPlay.value.hoverToPause ? {
        onMouseenter: () => {
          isPause.value = true;
        },
        onMouseleave: () => {
          isPause.value = false;
        }
      } : {};
    });
    const hasIndicator = computed(() => {
      return props.indicatorType !== "never" && components2.value.length > 1;
    });
    const hasArrow = computed(() => {
      return props.showArrow !== "never" && components2.value.length > 1;
    });
    const cls = computed(() => {
      return [prefixCls, `${prefixCls}-indicator-position-${props.indicatorPosition}`];
    });
    const contentCls = computed(() => {
      return [`${prefixCls}-${props.animationName}`, `${prefixCls}-${props.direction}`, {
        [`${prefixCls}-negative`]: slideDirection.value === "negative"
      }];
    });
    const indicatorCls = computed(() => {
      return [`${prefixCls}-indicator-wrapper`, `${prefixCls}-indicator-wrapper-${props.indicatorPosition}`];
    });
    return () => {
      var _a;
      children.value = (_a = slots.default) == null ? void 0 : _a.call(slots);
      return createVNode("div", mergeProps({
        "class": cls.value
      }, eventHandlers.value), [createVNode("div", {
        "class": contentCls.value
      }, [children.value]), hasIndicator.value && createVNode("div", {
        "class": indicatorCls.value
      }, [createVNode(CarouselIndicator, {
        "class": props.indicatorClass,
        "type": props.indicatorType,
        "count": components2.value.length,
        "activeIndex": mergedIndexes.value.mergedIndex,
        "position": props.indicatorPosition,
        "trigger": props.trigger,
        "onSelect": onSelect
      }, null)]), hasArrow.value && createVNode(CarouselArrow, {
        "class": props.arrowClass,
        "direction": props.direction,
        "showArrow": props.showArrow,
        "onPreviousClick": onPreviousClick,
        "onNextClick": onNextClick
      }, null)]);
    };
  }
});

// node_modules/@arco-design/web-vue/es/carousel/carousel-item.js
var _sfc_main45 = defineComponent({
  name: "CarouselItem",
  setup() {
    const prefixCls = getPrefixCls("carousel-item");
    const instance = getCurrentInstance();
    const context = inject(carouselInjectionKey, {});
    const index3 = computed(() => {
      var _a, _b, _c;
      return (_c = (_b = context.items) == null ? void 0 : _b.indexOf((_a = instance == null ? void 0 : instance.uid) != null ? _a : -1)) != null ? _c : -1;
    });
    const isCurrent = computed(() => {
      var _a;
      return ((_a = context.mergedIndexes) == null ? void 0 : _a.mergedIndex) === index3.value;
    });
    const cls = computed(() => {
      const { previousIndex, animationName, slideDirection, mergedIndexes } = context;
      return {
        [`${prefixCls}-prev`]: index3.value === (mergedIndexes == null ? void 0 : mergedIndexes.mergedPrevIndex),
        [`${prefixCls}-next`]: index3.value === (mergedIndexes == null ? void 0 : mergedIndexes.mergedNextIndex),
        [`${prefixCls}-current`]: isCurrent.value,
        [`${prefixCls}-slide-in`]: animationName === "slide" && slideDirection && isCurrent.value,
        [`${prefixCls}-slide-out`]: animationName === "slide" && slideDirection && index3.value === previousIndex
      };
    });
    const animationStyle = computed(() => {
      const { transitionTimingFunction, moveSpeed } = context;
      return {
        transitionTimingFunction,
        transitionDuration: `${moveSpeed}ms`,
        animationTimingFunction: transitionTimingFunction,
        animationDuration: `${moveSpeed}ms`
      };
    });
    return {
      cls,
      animationStyle,
      isCurrent
    };
  }
});
var _hoisted_124 = ["aria-hidden"];
function _sfc_render45(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    "aria-hidden": !_ctx.isCurrent,
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.animationStyle)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 14, _hoisted_124);
}
var CarouselItem = _export_sfc(_sfc_main45, [["render", _sfc_render45]]);

// node_modules/@arco-design/web-vue/es/carousel/index.js
var Carousel = Object.assign(_Carousel, {
  Item: CarouselItem,
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Carousel.name, _Carousel);
    app.component(componentPrefix + CarouselItem.name, CarouselItem);
  }
});

// node_modules/@arco-design/web-vue/es/cascader/utils.js
var getOptionInfos2 = (options, {
  optionMap,
  leafOptionMap,
  leafOptionSet,
  leafOptionValueMap,
  totalLevel: innerLevel,
  checkStrictly,
  enabledLazyLoad,
  lazyLoadOptions,
  valueKey,
  fieldNames
}) => {
  let totalLevel = 0;
  const travelOptions = (options2, parent, level) => {
    var _a;
    const parentPath = (_a = parent == null ? void 0 : parent.path) != null ? _a : [];
    totalLevel = Math.max(totalLevel, level != null ? level : 1);
    return options2.map((item, index3) => {
      var _a2;
      const value = item[fieldNames.value];
      const data = {
        raw: item,
        value,
        label: (_a2 = item[fieldNames.label]) != null ? _a2 : String(value),
        disabled: Boolean(item[fieldNames.disabled]),
        selectionDisabled: false,
        render: item[fieldNames.render],
        tagProps: item[fieldNames.tagProps],
        isLeaf: item[fieldNames.isLeaf],
        level: parentPath.length,
        index: index3,
        key: "",
        valueKey: String(isObject(value) ? value[valueKey.value] : value),
        parent,
        path: [],
        pathValue: []
      };
      const path = parentPath.concat(data);
      const pathValue = [];
      const key = path.map((item2) => {
        pathValue.push(item2.value);
        return item2.valueKey;
      }).join("-");
      data.path = path;
      data.pathValue = pathValue;
      data.key = key;
      if (item[fieldNames.children]) {
        data.isLeaf = false;
        data.children = travelOptions(item[fieldNames.children], data, (level != null ? level : 1) + 1);
      } else if (enabledLazyLoad && !data.isLeaf) {
        data.isLeaf = false;
        if (lazyLoadOptions[key]) {
          data.children = travelOptions(lazyLoadOptions[key], data, (level != null ? level : 1) + 1);
        }
      } else {
        data.isLeaf = true;
      }
      if (data.children && !data.disabled) {
        data.totalLeafOptions = data.children.reduce((pre, item2) => {
          if (isNumber(item2.totalLeafOptions)) {
            return pre + item2.totalLeafOptions;
          }
          if (item2.disabled || item2.selectionDisabled) {
            return pre;
          }
          return pre + (item2.isLeaf ? 1 : 0);
        }, 0);
        if (data.totalLeafOptions === 0 && !checkStrictly.value) {
          data.selectionDisabled = true;
        }
      }
      optionMap.set(data.key, data);
      if (data.isLeaf || checkStrictly.value) {
        leafOptionSet.add(data);
        leafOptionMap.set(data.key, data);
        if (!leafOptionValueMap.has(data.valueKey)) {
          leafOptionValueMap.set(data.valueKey, data.key);
        }
      }
      return data;
    });
  };
  const result = travelOptions(options);
  innerLevel.value = totalLevel;
  return result;
};
var getCheckedStatus = (option, valueMap) => {
  var _a, _b;
  let checked = false;
  let indeterminate = false;
  if (option.isLeaf) {
    if (valueMap == null ? void 0 : valueMap.has(option.key)) {
      checked = true;
    }
  } else {
    const reg = new RegExp(`^${option.key}(-|$)`);
    const checkedLeafOptionNumber = Array.from((_a = valueMap == null ? void 0 : valueMap.keys()) != null ? _a : []).reduce((pre, key) => {
      if (reg.test(key)) {
        return pre + 1;
      }
      return pre;
    }, 0);
    if (checkedLeafOptionNumber > 0 && checkedLeafOptionNumber >= ((_b = option.totalLeafOptions) != null ? _b : 1)) {
      checked = true;
    } else if (checkedLeafOptionNumber > 0) {
      indeterminate = true;
    }
  }
  return {
    checked,
    indeterminate
  };
};
var getLeafOptionKeys = (option) => {
  const keys = [];
  if (option.isLeaf) {
    keys.push(option.key);
  } else if (option.children) {
    for (const item of option.children) {
      keys.push(...getLeafOptionKeys(item));
    }
  }
  return keys;
};
var getLeafOptionInfos = (option) => {
  const infos = [];
  if (option.disabled || option.selectionDisabled) {
    return infos;
  }
  if (option.isLeaf) {
    infos.push(option);
  } else if (option.children) {
    for (const item of option.children) {
      infos.push(...getLeafOptionInfos(item));
    }
  }
  return infos;
};
var getValueKey = (value, {
  valueKey,
  leafOptionValueMap
}) => {
  var _a;
  if (isArray(value)) {
    return value.map((item) => {
      if (isObject(item))
        return item[valueKey];
      return item;
    }).join("-");
  }
  const _value = isObject(value) ? value[valueKey] : value;
  return (_a = leafOptionValueMap.get(String(_value))) != null ? _a : String(_value);
};
var getValidValues = (value, { multiple, pathMode }) => {
  if (!isArray(value)) {
    return isUndefined(value) || isNull(value) || value === "" ? [] : [value];
  }
  if (pathMode && !multiple && value.length > 0 && !isArray(value[0])) {
    return [value];
  }
  return value;
};
var getOptionLabel = (option) => {
  return option.path.map((item) => item.label).join(" / ");
};

// node_modules/@arco-design/web-vue/es/_hooks/use-input.js
var useInput = ({
  defaultValue,
  modelValue,
  emit,
  eventName = "input",
  updateEventName = "update:modelValue",
  eventHandlers
}) => {
  var _a;
  const inputRef = ref();
  const _value = ref((_a = defaultValue == null ? void 0 : defaultValue.value) != null ? _a : "");
  const _focused = ref(false);
  const isComposition = ref(false);
  const compositionValue = ref("");
  let initialValue;
  const computedValue = computed(() => {
    var _a2;
    return (_a2 = modelValue == null ? void 0 : modelValue.value) != null ? _a2 : _value.value;
  });
  const updateValue = (value, ev) => {
    _value.value = value;
    emit(updateEventName, value);
    emit(eventName, value, ev);
  };
  const handleInput = (ev) => {
    const { value } = ev.target;
    if (!isComposition.value) {
      updateValue(value, ev);
      nextTick(() => {
        if (inputRef.value && computedValue.value !== inputRef.value.value) {
          inputRef.value.value = computedValue.value;
        }
      });
    }
  };
  const handleChange = (ev) => {
    if (eventName === "input" && computedValue.value !== initialValue) {
      initialValue = computedValue.value;
      emit("change", computedValue.value, ev);
    }
  };
  const handleComposition = (ev) => {
    var _a2;
    const { value } = ev.target;
    if (ev.type === "compositionend") {
      isComposition.value = false;
      compositionValue.value = "";
      updateValue(value, ev);
      nextTick(() => {
        if (inputRef.value && computedValue.value !== inputRef.value.value) {
          inputRef.value.value = computedValue.value;
        }
      });
    } else {
      isComposition.value = true;
      compositionValue.value = computedValue.value + ((_a2 = ev.data) != null ? _a2 : "");
    }
  };
  const handleFocus = (ev) => {
    var _a2, _b;
    _focused.value = true;
    initialValue = computedValue.value;
    emit("focus", ev);
    (_b = (_a2 = eventHandlers == null ? void 0 : eventHandlers.value) == null ? void 0 : _a2.onFocus) == null ? void 0 : _b.call(_a2, ev);
  };
  const handleBlur = (ev) => {
    var _a2, _b;
    _focused.value = false;
    emit("blur", ev);
    (_b = (_a2 = eventHandlers == null ? void 0 : eventHandlers.value) == null ? void 0 : _a2.onBlur) == null ? void 0 : _b.call(_a2, ev);
    handleChange(ev);
  };
  const handleKeyDown = (ev) => {
    const keyCode = ev.key || ev.code;
    if (!isComposition.value && keyCode === Enter.key) {
      emit("pressEnter", ev);
      handleChange(ev);
    }
  };
  const handleMousedown = (ev) => {
    if (inputRef.value && ev.target !== inputRef.value) {
      ev.preventDefault();
      inputRef.value.focus();
    }
  };
  watch(computedValue, (value) => {
    if (inputRef.value && value !== inputRef.value.value) {
      inputRef.value.value = value;
    }
  });
  return {
    inputRef,
    _value,
    _focused,
    isComposition,
    compositionValue,
    computedValue,
    handleInput,
    handleComposition,
    handleFocus,
    handleBlur,
    handleKeyDown,
    handleMousedown
  };
};

// node_modules/@arco-design/web-vue/es/_components/input-label/input-label.js
var InputLabel = defineComponent({
  name: "InputLabel",
  inheritAttrs: false,
  props: {
    modelValue: Object,
    inputValue: {
      type: String,
      default: ""
    },
    enabledInput: Boolean,
    formatLabel: Function,
    placeholder: String,
    retainInputValue: Boolean,
    disabled: Boolean,
    baseCls: String,
    size: String,
    error: Boolean,
    focused: Boolean,
    uninjectFormItemContext: Boolean
  },
  emits: ["update:inputValue", "inputValueChange", "focus", "blur"],
  setup(props, {
    attrs,
    emit,
    slots
  }) {
    var _a;
    const {
      size,
      disabled,
      error,
      inputValue,
      uninjectFormItemContext
    } = toRefs(props);
    const prefixCls = (_a = props.baseCls) != null ? _a : getPrefixCls("input-label");
    const {
      mergedSize: _mergedSize,
      mergedDisabled,
      mergedError,
      eventHandlers
    } = useFormItem({
      size,
      disabled,
      error,
      uninject: uninjectFormItemContext == null ? void 0 : uninjectFormItemContext.value
    });
    const {
      mergedSize
    } = useSize(_mergedSize);
    const {
      inputRef,
      _focused,
      computedValue: computedInputValue,
      handleInput,
      handleComposition,
      handleFocus,
      handleBlur,
      handleMousedown
    } = useInput({
      modelValue: inputValue,
      emit,
      eventName: "inputValueChange",
      updateEventName: "update:inputValue",
      eventHandlers
    });
    const mergedFocused = computed(() => {
      var _a2;
      return (_a2 = props.focused) != null ? _a2 : _focused.value;
    });
    const showInput = computed(() => props.enabledInput && _focused.value || !props.modelValue);
    const mergedPlaceholder = computed(() => {
      if (props.enabledInput && props.modelValue) {
        return props.modelValue.label;
      }
      return props.placeholder;
    });
    const renderLabel = () => {
      var _a2, _b, _c, _d, _e;
      if (props.modelValue) {
        return (_e = (_c = (_a2 = slots.default) == null ? void 0 : _a2.call(slots, {
          data: props.modelValue
        })) != null ? _c : (_b = props.formatLabel) == null ? void 0 : _b.call(props, props.modelValue)) != null ? _e : (_d = props.modelValue) == null ? void 0 : _d.label;
      }
      return null;
    };
    const cls = computed(() => [prefixCls, `${prefixCls}-size-${mergedSize.value}`, {
      [`${prefixCls}-search`]: props.enabledInput,
      [`${prefixCls}-focus`]: mergedFocused.value,
      [`${prefixCls}-disabled`]: mergedDisabled.value,
      [`${prefixCls}-error`]: mergedError.value
    }]);
    const wrapperAttrs = computed(() => omit(attrs, INPUT_EVENTS));
    const inputAttrs = computed(() => pick(attrs, INPUT_EVENTS));
    const render2 = () => createVNode("span", mergeProps(wrapperAttrs.value, {
      "class": cls.value,
      "onMousedown": handleMousedown
    }), [slots.prefix && createVNode("span", {
      "class": `${prefixCls}-prefix`
    }, [slots.prefix()]), createVNode("input", mergeProps(inputAttrs.value, {
      "ref": inputRef,
      "class": [`${prefixCls}-input`, {
        [`${prefixCls}-input-hidden`]: !showInput.value
      }],
      "value": computedInputValue.value,
      "readonly": !props.enabledInput,
      "placeholder": mergedPlaceholder.value,
      "disabled": mergedDisabled.value,
      "onInput": handleInput,
      "onFocus": handleFocus,
      "onBlur": handleBlur,
      "onCompositionstart": handleComposition,
      "onCompositionupdate": handleComposition,
      "onCompositionend": handleComposition
    }), null), createVNode("span", {
      "class": [`${prefixCls}-value`, {
        [`${prefixCls}-value-hidden`]: showInput.value
      }]
    }, [renderLabel()]), slots.suffix && createVNode("span", {
      "class": `${prefixCls}-suffix`
    }, [slots.suffix()])]);
    return {
      inputRef,
      render: render2
    };
  },
  methods: {
    focus() {
      var _a;
      (_a = this.inputRef) == null ? void 0 : _a.focus();
    },
    blur() {
      var _a;
      (_a = this.inputRef) == null ? void 0 : _a.blur();
    }
  },
  render() {
    return this.render();
  }
});

// node_modules/@arco-design/web-vue/es/input-tag/utils.js
var __defProp13 = Object.defineProperty;
var __getOwnPropSymbols13 = Object.getOwnPropertySymbols;
var __hasOwnProp13 = Object.prototype.hasOwnProperty;
var __propIsEnum13 = Object.prototype.propertyIsEnumerable;
var __defNormalProp13 = (obj, key, value) => key in obj ? __defProp13(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues13 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp13.call(b, prop))
      __defNormalProp13(a, prop, b[prop]);
  if (__getOwnPropSymbols13)
    for (var prop of __getOwnPropSymbols13(b)) {
      if (__propIsEnum13.call(b, prop))
        __defNormalProp13(a, prop, b[prop]);
    }
  return a;
};
var getValueData = (value, fieldNames) => {
  const result = [];
  for (const item of value) {
    if (isObject(item)) {
      result.push({
        raw: item,
        value: item[fieldNames.value],
        label: item[fieldNames.label],
        closable: item[fieldNames.closable],
        tagProps: item[fieldNames.tagProps]
      });
    } else if (value || isNumber(value)) {
      const raw = {
        value: item,
        label: String(item),
        closable: true
      };
      result.push(__spreadValues13({
        raw
      }, raw));
    }
  }
  return result;
};

// node_modules/@arco-design/web-vue/es/tag/interface.js
var TAG_COLORS = [
  "red",
  "orangered",
  "orange",
  "gold",
  "lime",
  "green",
  "cyan",
  "blue",
  "arcoblue",
  "purple",
  "pinkpurple",
  "magenta",
  "gray"
];

// node_modules/@arco-design/web-vue/es/tag/tag.js
var _sfc_main46 = defineComponent({
  name: "Tag",
  components: {
    IconHover,
    IconClose,
    IconLoading
  },
  props: {
    color: {
      type: String
    },
    size: {
      type: String
    },
    bordered: {
      type: Boolean,
      default: false
    },
    visible: {
      type: Boolean,
      default: void 0
    },
    defaultVisible: {
      type: Boolean,
      default: true
    },
    loading: {
      type: Boolean,
      default: false
    },
    closable: {
      type: Boolean,
      default: false
    },
    checkable: {
      type: Boolean,
      default: false
    },
    checked: {
      type: Boolean,
      default: void 0
    },
    defaultChecked: {
      type: Boolean,
      default: true
    }
  },
  emits: {
    "update:visible": (visible) => true,
    "update:checked": (checked) => true,
    "close": (ev) => true,
    "check": (checked, ev) => true
  },
  setup(props, { emit }) {
    const { size } = toRefs(props);
    const prefixCls = getPrefixCls("tag");
    const isBuiltInColor = computed(() => props.color && TAG_COLORS.includes(props.color));
    const isCustomColor = computed(() => props.color && !TAG_COLORS.includes(props.color));
    const _visible = ref(props.defaultVisible);
    const _checked = ref(props.defaultChecked);
    const computedVisible = computed(() => {
      var _a;
      return (_a = props.visible) != null ? _a : _visible.value;
    });
    const computedChecked = computed(() => {
      var _a;
      return props.checkable ? (_a = props.checked) != null ? _a : _checked.value : true;
    });
    const { mergedSize: _mergedSize } = useSize(size);
    const mergedSize = computed(() => {
      if (_mergedSize.value === "mini") {
        return "small";
      }
      return _mergedSize.value;
    });
    const handleClose = (ev) => {
      _visible.value = false;
      emit("update:visible", false);
      emit("close", ev);
    };
    const handleClick = (ev) => {
      if (props.checkable) {
        const newChecked = !computedChecked.value;
        _checked.value = newChecked;
        emit("update:checked", newChecked);
        emit("check", newChecked, ev);
      }
    };
    const cls = computed(() => [
      prefixCls,
      `${prefixCls}-size-${mergedSize.value}`,
      {
        [`${prefixCls}-loading`]: props.loading,
        [`${prefixCls}-hide`]: !computedVisible.value,
        [`${prefixCls}-${props.color}`]: isBuiltInColor.value,
        [`${prefixCls}-bordered`]: props.bordered,
        [`${prefixCls}-checkable`]: props.checkable,
        [`${prefixCls}-checked`]: computedChecked.value,
        [`${prefixCls}-custom-color`]: isCustomColor.value
      }
    ]);
    const style = computed(() => {
      if (isCustomColor.value) {
        return {
          backgroundColor: props.color
        };
      }
      return void 0;
    });
    return {
      prefixCls,
      cls,
      style,
      computedVisible,
      computedChecked,
      handleClick,
      handleClose
    };
  }
});
function _sfc_render46(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_close = resolveComponent("icon-close");
  const _component_icon_hover = resolveComponent("icon-hover");
  const _component_icon_loading = resolveComponent("icon-loading");
  return _ctx.computedVisible ? (openBlock(), createElementBlock("span", {
    key: 0,
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.style),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    _ctx.$slots.icon ? (openBlock(), createElementBlock("span", {
      key: 0,
      class: normalizeClass(`${_ctx.prefixCls}-icon`)
    }, [
      renderSlot(_ctx.$slots, "icon")
    ], 2)) : createCommentVNode("v-if", true),
    renderSlot(_ctx.$slots, "default"),
    _ctx.closable ? (openBlock(), createBlock(_component_icon_hover, {
      key: 1,
      role: "button",
      "aria-label": "Close",
      prefix: _ctx.prefixCls,
      class: normalizeClass(`${_ctx.prefixCls}-close-btn`),
      onClick: withModifiers(_ctx.handleClose, ["stop"])
    }, {
      default: withCtx(() => [
        renderSlot(_ctx.$slots, "close-icon", {}, () => [
          createVNode(_component_icon_close)
        ])
      ]),
      _: 3
    }, 8, ["prefix", "class", "onClick"])) : createCommentVNode("v-if", true),
    _ctx.loading ? (openBlock(), createElementBlock("span", {
      key: 2,
      class: normalizeClass(`${_ctx.prefixCls}-loading-icon`)
    }, [
      createVNode(_component_icon_loading)
    ], 2)) : createCommentVNode("v-if", true)
  ], 6)) : createCommentVNode("v-if", true);
}
var _Tag = _export_sfc(_sfc_main46, [["render", _sfc_render46]]);

// node_modules/@arco-design/web-vue/es/tag/index.js
var Tag = Object.assign(_Tag, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Tag.name, _Tag);
  }
});

// node_modules/@arco-design/web-vue/es/input-tag/input-tag.js
var __defProp14 = Object.defineProperty;
var __getOwnPropSymbols14 = Object.getOwnPropertySymbols;
var __hasOwnProp14 = Object.prototype.hasOwnProperty;
var __propIsEnum14 = Object.prototype.propertyIsEnumerable;
var __defNormalProp14 = (obj, key, value) => key in obj ? __defProp14(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues14 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp14.call(b, prop))
      __defNormalProp14(a, prop, b[prop]);
  if (__getOwnPropSymbols14)
    for (var prop of __getOwnPropSymbols14(b)) {
      if (__propIsEnum14.call(b, prop))
        __defNormalProp14(a, prop, b[prop]);
    }
  return a;
};
var DEFAULT_FIELD_NAMES2 = {
  value: "value",
  label: "label",
  closable: "closable",
  tagProps: "tagProps"
};
var _InputTag = defineComponent({
  name: "InputTag",
  inheritAttrs: false,
  props: {
    modelValue: {
      type: Array
    },
    defaultValue: {
      type: Array,
      default: () => []
    },
    inputValue: String,
    defaultInputValue: {
      type: String,
      default: ""
    },
    placeholder: String,
    disabled: {
      type: Boolean,
      default: false
    },
    error: {
      type: Boolean,
      default: false
    },
    readonly: {
      type: Boolean,
      default: false
    },
    allowClear: {
      type: Boolean,
      default: false
    },
    size: {
      type: String
    },
    maxTagCount: {
      type: Number,
      default: 0
    },
    retainInputValue: {
      type: [Boolean, Object],
      default: false
    },
    formatTag: {
      type: Function
    },
    uniqueValue: {
      type: Boolean,
      default: false
    },
    fieldNames: {
      type: Object
    },
    baseCls: String,
    focused: Boolean,
    disabledInput: Boolean,
    uninjectFormItemContext: Boolean
  },
  emits: {
    "update:modelValue": (value) => true,
    "update:inputValue": (inputValue) => true,
    "change": (value, ev) => true,
    "inputValueChange": (inputValue, ev) => true,
    "pressEnter": (inputValue, ev) => true,
    "remove": (removed, ev) => true,
    "clear": (ev) => true,
    "focus": (ev) => true,
    "blur": (ev) => true
  },
  setup(props, {
    emit,
    slots,
    attrs
  }) {
    const {
      size,
      disabled,
      error,
      uninjectFormItemContext,
      modelValue
    } = toRefs(props);
    const prefixCls = props.baseCls || getPrefixCls("input-tag");
    const inputRef = ref();
    const mirrorRef = ref();
    const {
      mergedSize: _mergedSize,
      mergedDisabled,
      mergedError,
      feedback,
      eventHandlers
    } = useFormItem({
      size,
      disabled,
      error,
      uninject: uninjectFormItemContext == null ? void 0 : uninjectFormItemContext.value
    });
    const {
      mergedSize
    } = useSize(_mergedSize);
    const mergedFieldNames = computed(() => __spreadValues14(__spreadValues14({}, DEFAULT_FIELD_NAMES2), props.fieldNames));
    const _focused = ref(false);
    const _value = ref(props.defaultValue);
    const _inputValue = ref(props.defaultInputValue);
    const isComposition = ref(false);
    const compositionValue = ref("");
    const retainInputValue = computed(() => {
      if (isObject(props.retainInputValue)) {
        return __spreadValues14({
          create: false,
          blur: false
        }, props.retainInputValue);
      }
      return {
        create: props.retainInputValue,
        blur: props.retainInputValue
      };
    });
    const inputStyle = reactive({
      width: "12px"
    });
    const mergedFocused = computed(() => props.focused || _focused.value);
    const updateInputValue = (value, ev) => {
      _inputValue.value = value;
      emit("update:inputValue", value);
      emit("inputValueChange", value, ev);
    };
    const handleComposition = (ev) => {
      var _a;
      const {
        value
      } = ev.target;
      if (ev.type === "compositionend") {
        isComposition.value = false;
        compositionValue.value = "";
        updateInputValue(value, ev);
        nextTick(() => {
          if (inputRef.value && computedInputValue.value !== inputRef.value.value) {
            inputRef.value.value = computedInputValue.value;
          }
        });
      } else {
        isComposition.value = true;
        compositionValue.value = computedInputValue.value + ((_a = ev.data) != null ? _a : "");
      }
    };
    const computedValue = computed(() => {
      var _a;
      return (_a = props.modelValue) != null ? _a : _value.value;
    });
    const computedInputValue = computed(() => {
      var _a;
      return (_a = props.inputValue) != null ? _a : _inputValue.value;
    });
    watch(modelValue, (value) => {
      if (isUndefined(value) || isNull(value)) {
        _value.value = [];
      }
    });
    const handleMousedown = (e2) => {
      if (inputRef.value && e2.target !== inputRef.value) {
        e2.preventDefault();
        inputRef.value.focus();
      }
    };
    const handleInput = (ev) => {
      const {
        value
      } = ev.target;
      if (!isComposition.value) {
        updateInputValue(value, ev);
        nextTick(() => {
          if (inputRef.value && computedInputValue.value !== inputRef.value.value) {
            inputRef.value.value = computedInputValue.value;
          }
        });
      }
    };
    const valueData = computed(() => getValueData(computedValue.value, mergedFieldNames.value));
    const tags = computed(() => {
      if (props.maxTagCount > 0) {
        const invisibleTags = valueData.value.length - props.maxTagCount;
        if (invisibleTags > 0) {
          const result = valueData.value.slice(0, props.maxTagCount);
          const raw = {
            value: "__arco__more",
            label: `+${invisibleTags}...`,
            closable: false
          };
          result.push(__spreadValues14({
            raw
          }, raw));
          return result;
        }
      }
      return valueData.value;
    });
    const updateValue = (value, ev) => {
      var _a, _b;
      _value.value = value;
      emit("update:modelValue", value);
      emit("change", value, ev);
      (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onChange) == null ? void 0 : _b.call(_a, ev);
    };
    const handleRemove = (value, index3, e2) => {
      var _a;
      const newValue = (_a = computedValue.value) == null ? void 0 : _a.filter((_, i2) => i2 !== index3);
      updateValue(newValue, e2);
      emit("remove", value, e2);
    };
    const handleClear = (e2) => {
      const newValue = [];
      updateValue(newValue, e2);
      emit("clear", e2);
    };
    const showClearBtn = computed(() => !mergedDisabled.value && !props.readonly && props.allowClear && Boolean(computedValue.value.length));
    const handlePressEnter = (e2) => {
      var _a;
      if (computedInputValue.value) {
        e2.preventDefault();
        if (props.uniqueValue && ((_a = computedValue.value) == null ? void 0 : _a.includes(computedInputValue.value))) {
          emit("pressEnter", computedInputValue.value, e2);
          return;
        }
        const newValue = computedValue.value.concat(computedInputValue.value);
        updateValue(newValue, e2);
        emit("pressEnter", computedInputValue.value, e2);
        if (!retainInputValue.value.create) {
          updateInputValue("", e2);
        }
      }
    };
    const handleFocus = (ev) => {
      var _a, _b;
      _focused.value = true;
      emit("focus", ev);
      (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onFocus) == null ? void 0 : _b.call(_a, ev);
    };
    const handleBlur = (ev) => {
      var _a, _b;
      _focused.value = false;
      if (!retainInputValue.value.blur && computedInputValue.value) {
        updateInputValue("", ev);
      }
      emit("blur", ev);
      (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onBlur) == null ? void 0 : _b.call(_a, ev);
    };
    const getLastClosableIndex = () => {
      for (let i2 = valueData.value.length - 1; i2 >= 0; i2--) {
        if (valueData.value[i2].closable) {
          return i2;
        }
      }
      return -1;
    };
    const handleKeyDown = (e2) => {
      const keyCode = e2.key || e2.code;
      if (!isComposition.value && computedInputValue.value && keyCode === Enter.key) {
        handlePressEnter(e2);
      }
      if (!isComposition.value && tags.value.length > 0 && !computedInputValue.value && keyCode === Backspace.key) {
        const lastIndex = getLastClosableIndex();
        if (lastIndex >= 0) {
          handleRemove(valueData.value[lastIndex].value, lastIndex, e2);
        }
      }
    };
    const setInputWidth = (width) => {
      if (width > 12) {
        inputStyle.width = `${width}px`;
      } else {
        inputStyle.width = "12px";
      }
    };
    onMounted(() => {
      if (mirrorRef.value) {
        setInputWidth(mirrorRef.value.offsetWidth);
      }
    });
    const handleResize = () => {
      if (mirrorRef.value) {
        setInputWidth(mirrorRef.value.offsetWidth);
      }
    };
    watch(computedInputValue, (value) => {
      if (inputRef.value && !isComposition.value && value !== inputRef.value.value) {
        inputRef.value.value = value;
      }
    });
    const cls = computed(() => [prefixCls, `${prefixCls}-size-${mergedSize.value}`, {
      [`${prefixCls}-disabled`]: mergedDisabled.value,
      [`${prefixCls}-disabled-input`]: props.disabledInput,
      [`${prefixCls}-error`]: mergedError.value,
      [`${prefixCls}-focus`]: mergedFocused.value,
      [`${prefixCls}-readonly`]: props.readonly,
      [`${prefixCls}-has-tag`]: tags.value.length > 0,
      [`${prefixCls}-has-prefix`]: Boolean(slots.prefix),
      [`${prefixCls}-has-suffix`]: Boolean(slots.suffix) || showClearBtn.value || feedback.value,
      [`${prefixCls}-has-placeholder`]: !computedValue.value.length
    }]);
    const wrapperAttrs = computed(() => omit(attrs, INPUT_EVENTS));
    const inputAttrs = computed(() => pick(attrs, INPUT_EVENTS));
    const render2 = () => {
      var _a;
      return createVNode("span", mergeProps({
        "class": cls.value,
        "onMousedown": handleMousedown
      }, wrapperAttrs.value), [createVNode(ResizeObserver2, {
        "onResize": handleResize
      }, {
        default: () => [createVNode("span", {
          "ref": mirrorRef,
          "class": `${prefixCls}-mirror`
        }, [tags.value.length > 0 ? compositionValue.value || computedInputValue.value : compositionValue.value || computedInputValue.value || props.placeholder])]
      }), slots.prefix && createVNode("span", {
        "class": `${prefixCls}-prefix`
      }, [slots.prefix()]), createVNode(TransitionGroup, {
        "tag": "span",
        "name": "input-tag-zoom",
        "class": `${prefixCls}-inner`
      }, {
        default: () => [tags.value.map((item, index3) => createVNode(Tag, mergeProps({
          "key": `tag-${item.value}`,
          "class": `${prefixCls}-tag`,
          "closable": !mergedDisabled.value && !props.readonly && item.closable,
          "visible": true
        }, item.tagProps, {
          "onClose": (ev) => handleRemove(item.value, index3, ev)
        }), {
          default: () => {
            var _a2, _b, _c, _d;
            return [(_d = (_c = (_a2 = slots.tag) == null ? void 0 : _a2.call(slots, {
              data: item.raw
            })) != null ? _c : (_b = props.formatTag) == null ? void 0 : _b.call(props, item.raw)) != null ? _d : item.label];
          }
        })), createVNode("input", mergeProps(inputAttrs.value, {
          "ref": inputRef,
          "key": "input-tag-input",
          "class": `${prefixCls}-input`,
          "style": inputStyle,
          "placeholder": tags.value.length === 0 ? props.placeholder : void 0,
          "disabled": mergedDisabled.value,
          "readonly": props.readonly || props.disabledInput,
          "onInput": handleInput,
          "onKeydown": handleKeyDown,
          "onFocus": handleFocus,
          "onBlur": handleBlur,
          "onCompositionstart": handleComposition,
          "onCompositionupdate": handleComposition,
          "onCompositionend": handleComposition
        }), null)]
      }), showClearBtn.value && createVNode(IconHover, {
        "class": `${prefixCls}-clear-btn`,
        "onClick": handleClear,
        "onMousedown": (e2) => e2.stopPropagation()
      }, {
        default: () => [createVNode(IconClose, null, null)]
      }), (slots.suffix || Boolean(feedback.value)) && createVNode("span", {
        "class": `${prefixCls}-suffix`
      }, [(_a = slots.suffix) == null ? void 0 : _a.call(slots), Boolean(feedback.value) && createVNode(FeedbackIcon, {
        "type": feedback.value
      }, null)])]);
    };
    return {
      inputRef,
      render: render2
    };
  },
  methods: {
    focus() {
      var _a;
      (_a = this.inputRef) == null ? void 0 : _a.focus();
    },
    blur() {
      var _a;
      (_a = this.inputRef) == null ? void 0 : _a.blur();
    }
  },
  render() {
    return this.render();
  }
});

// node_modules/@arco-design/web-vue/es/input-tag/index.js
var InputTag = Object.assign(_InputTag, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _InputTag.name, _InputTag);
  }
});

// node_modules/@arco-design/web-vue/es/_components/select-view/select-view.js
var SelectView = defineComponent({
  name: "SelectView",
  props: {
    modelValue: {
      type: Array,
      required: true
    },
    inputValue: String,
    placeholder: String,
    disabled: {
      type: Boolean,
      default: false
    },
    error: {
      type: Boolean,
      default: false
    },
    loading: {
      type: Boolean,
      default: false
    },
    opened: {
      type: Boolean,
      default: false
    },
    size: {
      type: String
    },
    bordered: {
      type: Boolean,
      default: true
    },
    multiple: {
      type: Boolean,
      default: false
    },
    allowClear: {
      type: Boolean,
      default: false
    },
    allowCreate: {
      type: Boolean,
      default: false
    },
    allowSearch: {
      type: Boolean,
      default: (props) => isArray(props.modelValue)
    },
    maxTagCount: {
      type: Number,
      default: 0
    },
    retainInputValue: {
      type: Boolean,
      default: false
    }
  },
  emits: ["remove", "clear", "focus", "blur"],
  setup(props, {
    emit,
    slots
  }) {
    const {
      size,
      disabled,
      error
    } = toRefs(props);
    const prefixCls = getPrefixCls("select-view");
    const {
      feedback,
      eventHandlers,
      mergedDisabled,
      mergedSize: _mergedSize,
      mergedError
    } = useFormItem({
      size,
      disabled,
      error
    });
    const {
      mergedSize
    } = useSize(_mergedSize);
    const {
      opened
    } = toRefs(props);
    const componentRef = ref();
    const inputRef = computed(() => {
      var _a;
      return (_a = componentRef.value) == null ? void 0 : _a.inputRef;
    });
    const isEmptyValue2 = computed(() => props.modelValue.length === 0);
    const enabledInput = computed(() => props.allowSearch || props.allowCreate);
    const showClearBtn = computed(() => props.allowClear && !props.disabled && !isEmptyValue2.value);
    const handleFocus = (ev) => {
      var _a, _b;
      emit("focus", ev);
      (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onFocus) == null ? void 0 : _b.call(_a, ev);
    };
    const handleBlur = (ev) => {
      var _a, _b;
      emit("blur", ev);
      (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onBlur) == null ? void 0 : _b.call(_a, ev);
    };
    const handleRemove = (tag) => {
      emit("remove", tag);
    };
    const handleClear = (ev) => {
      emit("clear", ev);
    };
    const renderIcon = () => {
      var _a, _b, _c, _d;
      if (props.loading) {
        return (_b = (_a = slots["loading-icon"]) == null ? void 0 : _a.call(slots)) != null ? _b : createVNode(IconLoading, null, null);
      }
      if (props.allowSearch && props.opened) {
        return (_d = (_c = slots["search-icon"]) == null ? void 0 : _c.call(slots)) != null ? _d : createVNode(IconSearch, null, null);
      }
      if (slots["arrow-icon"]) {
        return slots["arrow-icon"]();
      }
      return createVNode(IconDown, {
        "class": `${prefixCls}-arrow-icon`
      }, null);
    };
    const renderSuffix = () => createVNode(Fragment, null, [showClearBtn.value && createVNode(IconHover, {
      "class": `${prefixCls}-clear-btn`,
      "onClick": handleClear,
      "onMousedown": (ev) => ev.stopPropagation()
    }, {
      default: () => [createVNode(IconClose, null, null)]
    }), createVNode("span", {
      "class": `${prefixCls}-icon`
    }, [renderIcon()]), Boolean(feedback.value) && createVNode(FeedbackIcon, {
      "type": feedback.value
    }, null)]);
    watch(opened, (opened2) => {
      if (!opened2 && inputRef.value && inputRef.value.isSameNode(document.activeElement)) {
        inputRef.value.blur();
      }
    });
    const cls = computed(() => [`${prefixCls}-${props.multiple ? "multiple" : "single"}`, {
      [`${prefixCls}-opened`]: props.opened,
      [`${prefixCls}-borderless`]: !props.bordered
    }]);
    const render2 = () => {
      if (props.multiple) {
        return createVNode(InputTag, {
          "ref": componentRef,
          "baseCls": prefixCls,
          "class": cls.value,
          "modelValue": props.modelValue,
          "inputValue": props.inputValue,
          "focused": props.opened,
          "placeholder": props.placeholder,
          "disabled": mergedDisabled.value,
          "size": mergedSize.value,
          "error": mergedError.value,
          "maxTagCount": props.maxTagCount,
          "disabledInput": !props.allowSearch && !props.allowCreate,
          "retainInputValue": true,
          "uninjectFormItemContext": true,
          "onRemove": handleRemove,
          "onFocus": handleFocus,
          "onBlur": handleBlur
        }, {
          prefix: slots.prefix,
          suffix: renderSuffix,
          tag: slots.label
        });
      }
      return createVNode(InputLabel, {
        "ref": componentRef,
        "baseCls": prefixCls,
        "class": cls.value,
        "modelValue": props.modelValue[0],
        "inputValue": props.inputValue,
        "focused": props.opened,
        "placeholder": props.placeholder,
        "disabled": mergedDisabled.value,
        "size": mergedSize.value,
        "error": mergedError.value,
        "enabledInput": enabledInput.value,
        "uninjectFormItemContext": true,
        "onFocus": handleFocus,
        "onBlur": handleBlur
      }, {
        default: slots.label,
        prefix: slots.prefix,
        suffix: renderSuffix
      });
    };
    return {
      inputRef,
      handleFocus,
      handleBlur,
      render: render2
    };
  },
  methods: {
    focus() {
      if (this.inputRef) {
        this.inputRef.focus();
      }
    },
    blur() {
      if (this.inputRef) {
        this.inputRef.blur();
      }
    }
  },
  render() {
    return this.render();
  }
});

// node_modules/@arco-design/web-vue/es/radio/context.js
var radioGroupKey = Symbol("RadioGroup");

// node_modules/@arco-design/web-vue/es/radio/radio.js
var _Radio = defineComponent({
  name: "Radio",
  components: {
    IconHover
  },
  props: {
    modelValue: {
      type: [String, Number, Boolean],
      default: void 0
    },
    defaultChecked: {
      type: Boolean,
      default: false
    },
    value: {
      type: [String, Number, Boolean],
      default: true
    },
    type: {
      type: String,
      default: "radio"
    },
    disabled: {
      type: Boolean,
      default: false
    },
    uninjectGroupContext: {
      type: Boolean,
      default: false
    }
  },
  emits: {
    "update:modelValue": (value) => true,
    "change": (value, ev) => true
  },
  setup(props, {
    emit,
    slots
  }) {
    const prefixCls = getPrefixCls("radio");
    const {
      modelValue
    } = toRefs(props);
    const radioGroupCtx = !props.uninjectGroupContext ? inject(radioGroupKey, void 0) : void 0;
    const {
      mergedDisabled: _mergedDisabled,
      eventHandlers
    } = useFormItem({
      disabled: toRef(props, "disabled")
    });
    const inputRef = ref(null);
    const _checked = ref(props.defaultChecked);
    const isGroup = computed(() => (radioGroupCtx == null ? void 0 : radioGroupCtx.name) === "ArcoRadioGroup");
    const mergedType = computed(() => {
      var _a;
      return (_a = radioGroupCtx == null ? void 0 : radioGroupCtx.type) != null ? _a : props.type;
    });
    const mergedDisabled = computed(() => (radioGroupCtx == null ? void 0 : radioGroupCtx.disabled) || _mergedDisabled.value);
    const computedChecked = computed(() => {
      var _a, _b;
      if (isGroup.value) {
        return (radioGroupCtx == null ? void 0 : radioGroupCtx.value) === ((_a = props.value) != null ? _a : true);
      }
      if (!isUndefined(props.modelValue)) {
        return props.modelValue === ((_b = props.value) != null ? _b : true);
      }
      return _checked.value;
    });
    watch(modelValue, (value) => {
      if (isUndefined(value) || isNull(value)) {
        _checked.value = false;
      }
    });
    watch(computedChecked, (curValue, preValue) => {
      if (curValue !== preValue) {
        _checked.value = curValue;
        if (inputRef.value) {
          inputRef.value.checked = curValue;
        }
      }
    });
    const handleFocus = (ev) => {
      var _a, _b;
      (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onFocus) == null ? void 0 : _b.call(_a, ev);
    };
    const handleBlur = (ev) => {
      var _a, _b;
      (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onBlur) == null ? void 0 : _b.call(_a, ev);
    };
    const handleClick = (ev) => {
      ev.stopPropagation();
    };
    const handleChange = (e2) => {
      var _a, _b, _c, _d, _e;
      _checked.value = true;
      if (isGroup.value) {
        radioGroupCtx == null ? void 0 : radioGroupCtx.handleChange((_a = props.value) != null ? _a : true, e2);
      } else {
        emit("update:modelValue", (_b = props.value) != null ? _b : true);
        emit("change", (_c = props.value) != null ? _c : true, e2);
        (_e = (_d = eventHandlers.value) == null ? void 0 : _d.onChange) == null ? void 0 : _e.call(_d, e2);
      }
      nextTick(() => {
        if (inputRef.value && inputRef.value.checked !== computedChecked.value) {
          inputRef.value.checked = computedChecked.value;
        }
      });
    };
    const cls = computed(() => [`${mergedType.value === "button" ? `${prefixCls}-button` : prefixCls}`, {
      [`${prefixCls}-checked`]: computedChecked.value,
      [`${prefixCls}-disabled`]: mergedDisabled.value
    }]);
    const defaultRadio = () => createVNode(Fragment, null, [createVNode(resolveComponent("icon-hover"), {
      "class": `${prefixCls}-icon-hover`,
      "disabled": mergedDisabled.value || computedChecked.value
    }, {
      default: () => [createVNode("span", {
        "class": `${prefixCls}-icon`
      }, null)]
    }), slots.default && createVNode("span", {
      "class": `${prefixCls}-label`
    }, [slots.default()])]);
    return () => {
      var _a, _b, _c, _d;
      return createVNode("label", {
        "class": cls.value
      }, [createVNode("input", {
        "ref": inputRef,
        "type": "radio",
        "checked": computedChecked.value,
        "value": props.value,
        "class": `${prefixCls}-target`,
        "disabled": mergedDisabled.value,
        "onClick": handleClick,
        "onChange": handleChange,
        "onFocus": handleFocus,
        "onBlur": handleBlur
      }, null), mergedType.value === "radio" ? (_d = (_c = (_b = slots.radio) != null ? _b : (_a = radioGroupCtx == null ? void 0 : radioGroupCtx.slots) == null ? void 0 : _a.radio) == null ? void 0 : _c({
        checked: computedChecked.value,
        disabled: mergedDisabled.value
      })) != null ? _d : defaultRadio() : createVNode("span", {
        "class": `${prefixCls}-button-content`
      }, [slots.default && slots.default()])]);
    };
  }
});

// node_modules/@arco-design/web-vue/es/radio/radio-group.js
var RadioGroup = defineComponent({
  name: "RadioGroup",
  props: {
    modelValue: {
      type: [String, Number, Boolean],
      default: void 0
    },
    defaultValue: {
      type: [String, Number, Boolean],
      default: ""
    },
    type: {
      type: String,
      default: "radio"
    },
    size: {
      type: String
    },
    options: {
      type: Array
    },
    direction: {
      type: String,
      default: "horizontal"
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  emits: {
    "update:modelValue": (value) => true,
    "change": (value, ev) => true
  },
  setup(props, {
    emit,
    slots
  }) {
    const prefixCls = getPrefixCls("radio-group");
    const {
      size,
      type,
      disabled,
      modelValue
    } = toRefs(props);
    const {
      mergedDisabled,
      mergedSize,
      eventHandlers
    } = useFormItem({
      size,
      disabled
    });
    const _value = ref(props.defaultValue);
    const computedValue = computed(() => {
      var _a;
      return (_a = props.modelValue) != null ? _a : _value.value;
    });
    const options = computed(() => {
      var _a;
      return ((_a = props.options) != null ? _a : []).map((option) => {
        if (isString(option) || isNumber(option)) {
          return {
            label: option,
            value: option
          };
        }
        return option;
      });
    });
    const handleChange = (value, e2) => {
      var _a, _b;
      _value.value = value;
      emit("update:modelValue", value);
      emit("change", value, e2);
      (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onChange) == null ? void 0 : _b.call(_a, e2);
    };
    provide(radioGroupKey, reactive({
      name: "ArcoRadioGroup",
      value: computedValue,
      size: mergedSize,
      type,
      disabled: mergedDisabled,
      slots,
      handleChange
    }));
    watch(computedValue, (cur) => {
      if (_value.value !== cur) {
        _value.value = cur;
      }
    });
    watch(modelValue, (val) => {
      if (isUndefined(val) || isNull(val)) {
        _value.value = "";
      }
    });
    const cls = computed(() => [`${prefixCls}${props.type === "button" ? "-button" : ""}`, `${prefixCls}-size-${mergedSize.value}`, `${prefixCls}-direction-${props.direction}`, {
      [`${prefixCls}-disabled`]: mergedDisabled.value
    }]);
    const renderOptions = () => {
      return options.value.map((option) => createVNode(_Radio, {
        "key": option.value,
        "value": option.value,
        "disabled": option.disabled,
        "modelValue": computedValue.value === option.value
      }, {
        default: () => [slots.label ? slots.label({
          data: option
        }) : isFunction(option.label) ? option.label() : option.label]
      }));
    };
    return () => {
      var _a;
      return createVNode("span", {
        "class": cls.value
      }, [options.value.length > 0 ? renderOptions() : (_a = slots.default) == null ? void 0 : _a.call(slots)]);
    };
  }
});

// node_modules/@arco-design/web-vue/es/radio/index.js
var Radio = Object.assign(_Radio, {
  Group: RadioGroup,
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Radio.name, _Radio);
    app.component(componentPrefix + RadioGroup.name, RadioGroup);
  }
});

// node_modules/@arco-design/web-vue/es/cascader/context.js
var cascaderInjectionKey = Symbol("ArcoCascader");

// node_modules/@arco-design/web-vue/es/cascader/cascader-option.js
var CascaderOption = defineComponent({
  name: "CascaderOption",
  props: {
    option: {
      type: Object,
      required: true
    },
    active: Boolean,
    multiple: Boolean,
    checkStrictly: Boolean,
    searchOption: Boolean,
    pathLabel: Boolean
  },
  setup(props) {
    const prefixCls = getPrefixCls("cascader-option");
    const cascaderCtx = inject(cascaderInjectionKey, {});
    const isLoading = ref(false);
    const events = {};
    const handlePathChange = (ev) => {
      var _a;
      if (isFunction(cascaderCtx.loadMore) && !props.option.isLeaf) {
        const {
          isLeaf,
          children,
          key
        } = props.option;
        if (!isLeaf && !children) {
          isLoading.value = true;
          new Promise((resolve) => {
            var _a2;
            (_a2 = cascaderCtx.loadMore) == null ? void 0 : _a2.call(cascaderCtx, props.option.raw, resolve);
          }).then((children2) => {
            var _a2;
            isLoading.value = false;
            if (children2) {
              (_a2 = cascaderCtx.addLazyLoadOptions) == null ? void 0 : _a2.call(cascaderCtx, children2, key);
            }
          });
        }
      }
      (_a = cascaderCtx.setSelectedPath) == null ? void 0 : _a.call(cascaderCtx, props.option.key);
    };
    if (!props.option.disabled) {
      events.onMouseenter = [() => {
        var _a;
        return (_a = cascaderCtx.setActiveKey) == null ? void 0 : _a.call(cascaderCtx, props.option.key);
      }];
      events.onMouseleave = () => {
        var _a;
        return (_a = cascaderCtx.setActiveKey) == null ? void 0 : _a.call(cascaderCtx);
      };
      events.onClick = [];
      if (cascaderCtx.expandTrigger === "hover") {
        events.onMouseenter.push((ev) => handlePathChange());
      } else {
        events.onClick.push((ev) => handlePathChange());
      }
      if (props.option.isLeaf && !props.multiple) {
        events.onClick.push((ev) => {
          var _a;
          handlePathChange();
          (_a = cascaderCtx.onClickOption) == null ? void 0 : _a.call(cascaderCtx, props.option);
        });
      }
    }
    const cls = computed(() => [prefixCls, {
      [`${prefixCls}-active`]: props.active,
      [`${prefixCls}-disabled`]: props.option.disabled
    }]);
    const checkedStatus = computed(() => {
      var _a;
      if (props.checkStrictly) {
        return {
          checked: (_a = cascaderCtx.valueMap) == null ? void 0 : _a.has(props.option.key),
          indeterminate: false
        };
      }
      return getCheckedStatus(props.option, cascaderCtx.valueMap);
    });
    const renderLabelContent = () => {
      var _a, _b, _c;
      if (props.pathLabel) {
        return (_b = (_a = cascaderCtx == null ? void 0 : cascaderCtx.formatLabel) == null ? void 0 : _a.call(cascaderCtx, props.option.path.map((item) => item.raw))) != null ? _b : getOptionLabel(props.option);
      }
      if ((_c = cascaderCtx.slots) == null ? void 0 : _c.option) {
        return cascaderCtx.slots.option({
          data: props.option
        });
      }
      if (isFunction(props.option.render)) {
        return props.option.render();
      }
      return props.option.label;
    };
    const renderIcon = () => {
      if (isLoading.value) {
        return createVNode(IconLoading, null, null);
      }
      if (!props.searchOption && !props.option.isLeaf) {
        return createVNode(IconRight, null, null);
      }
      return null;
    };
    return () => {
      var _a;
      return createVNode("li", mergeProps({
        "tabindex": "0",
        "role": "menuitem",
        "aria-disabled": props.option.disabled,
        "aria-haspopup": !props.option.isLeaf,
        "aria-expanded": !props.option.isLeaf && props.active,
        "title": props.option.label,
        "class": cls.value
      }, events), [props.multiple && createVNode(Checkbox, {
        "modelValue": checkedStatus.value.checked,
        "indeterminate": checkedStatus.value.indeterminate,
        "disabled": props.option.disabled || props.option.selectionDisabled,
        "uninjectGroupContext": true,
        "onChange": (value, ev) => {
          var _a2;
          ev.stopPropagation();
          handlePathChange();
          (_a2 = cascaderCtx.onClickOption) == null ? void 0 : _a2.call(cascaderCtx, props.option, !checkedStatus.value.checked);
        },
        "onClick": (ev) => ev.stopPropagation()
      }, null), props.checkStrictly && !props.multiple && createVNode(Radio, {
        "modelValue": (_a = cascaderCtx.valueMap) == null ? void 0 : _a.has(props.option.key),
        "disabled": props.option.disabled,
        "uninjectGroupContext": true,
        "onChange": (value, ev) => {
          var _a2;
          ev.stopPropagation();
          handlePathChange();
          (_a2 = cascaderCtx.onClickOption) == null ? void 0 : _a2.call(cascaderCtx, props.option, true);
        },
        "onClick": (ev) => ev.stopPropagation()
      }, null), createVNode("div", {
        "class": `${prefixCls}-label`
      }, [renderLabelContent(), renderIcon()])]);
    };
  }
});

// node_modules/@arco-design/web-vue/es/cascader/base-cascader-panel.js
function _isSlot(s) {
  return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
var BaseCascaderPanel = defineComponent({
  name: "BaseCascaderPanel",
  props: {
    displayColumns: {
      type: Array,
      required: true
    },
    selectedPath: {
      type: Array,
      required: true
    },
    activeKey: String,
    totalLevel: {
      type: Number,
      required: true
    },
    multiple: Boolean,
    checkStrictly: Boolean,
    loading: Boolean,
    dropdown: Boolean
  },
  setup(props, {
    slots
  }) {
    const prefixCls = getPrefixCls("cascader");
    const renderEmpty = () => {
      var _a, _b;
      return (_b = (_a = slots.empty) == null ? void 0 : _a.call(slots)) != null ? _b : createVNode(Empty2, null, null);
    };
    const renderColumn = (column, level = 0) => {
      return createVNode("div", {
        "class": `${prefixCls}-panel-column`,
        "key": `column-${level}`,
        "style": {
          zIndex: props.totalLevel - level
        }
      }, [createVNode(Scrollbar, {
        "class": `${prefixCls}-column-content`
      }, {
        default: () => [column.length === 0 ? createVNode("div", {
          "class": `${prefixCls}-list-empty`
        }, [renderEmpty()]) : createVNode("ul", {
          "role": "menu",
          "class": [`${prefixCls}-list`, {
            [`${prefixCls}-list-multiple`]: Boolean(props == null ? void 0 : props.multiple),
            [`${prefixCls}-list-strictly`]: Boolean(props == null ? void 0 : props.checkStrictly)
          }]
        }, [column.map((item) => {
          return createVNode(CascaderOption, {
            "key": item.key,
            "option": item,
            "active": props.selectedPath.includes(item.key) || item.key === props.activeKey,
            "multiple": props.multiple,
            "checkStrictly": props.checkStrictly
          }, null);
        })])]
      })]);
    };
    const renderContent = () => {
      if (props.loading) {
        return createVNode("div", {
          "key": "panel-column-loading",
          "class": [`${prefixCls}-panel-column`, `${prefixCls}-panel-column-loading`]
        }, [createVNode(Spin, null, null)]);
      }
      if (props.displayColumns.length === 0) {
        return createVNode("div", {
          "key": "panel-column-empty",
          "class": `${prefixCls}-panel-column`
        }, [createVNode("div", {
          "class": `${prefixCls}-list-empty`
        }, [renderEmpty()])]);
      }
      return props.displayColumns.map((column, index3) => renderColumn(column, index3));
    };
    return () => {
      let _slot;
      return createVNode(TransitionGroup, {
        "tag": "div",
        "name": "cascader-slide",
        "class": [`${prefixCls}-panel`, {
          [`${prefixCls}-dropdown-panel`]: props.dropdown
        }]
      }, _isSlot(_slot = renderContent()) ? _slot : {
        default: () => [_slot]
      });
    };
  }
});

// node_modules/@arco-design/web-vue/es/cascader/cascader-search-panel.js
function _isSlot2(s) {
  return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
var CascaderSearchPanel = defineComponent({
  name: "CascaderSearchPanel",
  props: {
    options: {
      type: Array,
      required: true
    },
    loading: Boolean,
    activeKey: String,
    multiple: Boolean,
    checkStrictly: Boolean,
    pathLabel: Boolean
  },
  setup(props, {
    slots
  }) {
    const prefixCls = getPrefixCls("cascader");
    const renderContent = () => {
      var _a, _b;
      if (props.loading) {
        return createVNode(Spin, null, null);
      }
      if (props.options.length === 0) {
        return createVNode("div", {
          "class": `${prefixCls}-list-empty`
        }, [(_b = (_a = slots.empty) == null ? void 0 : _a.call(slots)) != null ? _b : createVNode(Empty2, null, null)]);
      }
      return createVNode("ul", {
        "role": "menu",
        "class": [`${prefixCls}-list`, `${prefixCls}-search-list`, {
          [`${prefixCls}-list-multiple`]: props.multiple
        }]
      }, [props.options.map((item) => createVNode(CascaderOption, {
        "key": item.key,
        "class": `${prefixCls}-search-option`,
        "option": item,
        "active": item.key === props.activeKey,
        "multiple": props.multiple,
        "checkStrictly": props.checkStrictly,
        "pathLabel": props.pathLabel,
        "searchOption": true
      }, null))]);
    };
    return () => {
      let _slot;
      return createVNode(Scrollbar, {
        "class": [`${prefixCls}-panel`, `${prefixCls}-search-panel`]
      }, _isSlot2(_slot = renderContent()) ? _slot : {
        default: () => [_slot]
      });
    };
  }
});

// node_modules/@arco-design/web-vue/es/cascader/hooks/use-selected-path.js
var useSelectedPath = (options, {
  optionMap,
  filteredLeafOptions,
  showSearchPanel,
  expandChild
}) => {
  const activeKey = ref();
  const activeOption = computed(() => {
    if (activeKey.value)
      return optionMap.get(activeKey.value);
    return void 0;
  });
  const selectedPath = ref([]);
  const displayColumns = computed(() => {
    const columns = [options.value];
    for (const key of selectedPath.value) {
      const option = optionMap.get(key);
      if (option == null ? void 0 : option.children) {
        columns.push(option.children);
      }
    }
    return columns;
  });
  const setSelectedPath = (key) => {
    var _a;
    const option = getTargetOption(key);
    selectedPath.value = (_a = option == null ? void 0 : option.path.map((item) => item.key)) != null ? _a : [];
  };
  const setActiveKey = (key) => {
    activeKey.value = key;
  };
  const enabledOptions = computed(() => {
    var _a;
    if (showSearchPanel == null ? void 0 : showSearchPanel.value) {
      return filteredLeafOptions.value.filter((item) => !item.disabled);
    }
    if (activeOption.value && activeOption.value.parent) {
      return (_a = activeOption.value.parent.children) == null ? void 0 : _a.filter((item) => !item.disabled);
    }
    return options.value.filter((item) => !item.disabled);
  });
  const getTargetOption = (key) => {
    let target3 = key ? optionMap.get(key) : void 0;
    if (expandChild.value) {
      while (target3 && target3.children && target3.children.length > 0) {
        target3 = target3.children[0];
      }
    }
    return target3;
  };
  const getNextActiveNode = (direction) => {
    var _a, _b, _c, _d, _e, _f, _g;
    const _length = (_b = (_a = enabledOptions.value) == null ? void 0 : _a.length) != null ? _b : 0;
    if (activeKey.value) {
      const enabledIndex = (_d = (_c = enabledOptions.value) == null ? void 0 : _c.findIndex((item) => item.key === activeKey.value)) != null ? _d : 0;
      if (direction === "next") {
        return (_e = enabledOptions.value) == null ? void 0 : _e[(_length + enabledIndex + 1) % _length];
      }
      return (_f = enabledOptions.value) == null ? void 0 : _f[(_length + enabledIndex - 1) % _length];
    }
    return (_g = enabledOptions.value) == null ? void 0 : _g[0];
  };
  return {
    activeKey,
    activeOption,
    selectedPath,
    displayColumns,
    setActiveKey,
    setSelectedPath,
    getNextActiveNode
  };
};

// node_modules/@arco-design/web-vue/es/_utils/debounce.js
var target2 = typeof window === "undefined" ? global : window;
function debounce(callback, delay) {
  let timer = 0;
  return (...args) => {
    if (timer) {
      target2.clearTimeout(timer);
    }
    timer = target2.setTimeout(() => {
      timer = 0;
      callback(...args);
    }, delay);
  };
}

// node_modules/@arco-design/web-vue/es/cascader/cascader.js
var __defProp15 = Object.defineProperty;
var __getOwnPropSymbols15 = Object.getOwnPropertySymbols;
var __hasOwnProp15 = Object.prototype.hasOwnProperty;
var __propIsEnum15 = Object.prototype.propertyIsEnumerable;
var __defNormalProp15 = (obj, key, value) => key in obj ? __defProp15(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues15 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp15.call(b, prop))
      __defNormalProp15(a, prop, b[prop]);
  if (__getOwnPropSymbols15)
    for (var prop of __getOwnPropSymbols15(b)) {
      if (__propIsEnum15.call(b, prop))
        __defNormalProp15(a, prop, b[prop]);
    }
  return a;
};
var _sfc_main47 = defineComponent({
  name: "Cascader",
  components: {
    Trigger,
    SelectView,
    BaseCascaderPanel,
    CascaderSearchPanel
  },
  inheritAttrs: false,
  props: {
    pathMode: {
      type: Boolean,
      default: false
    },
    multiple: {
      type: Boolean,
      default: false
    },
    modelValue: {
      type: [String, Number, Object, Array]
    },
    defaultValue: {
      type: [String, Number, Object, Array],
      default: (props) => props.multiple ? [] : props.pathMode ? void 0 : ""
    },
    options: {
      type: Array,
      default: () => []
    },
    disabled: {
      type: Boolean,
      default: false
    },
    error: {
      type: Boolean,
      default: false
    },
    size: {
      type: String
    },
    allowSearch: {
      type: Boolean,
      default: (props) => Boolean(props.multiple)
    },
    allowClear: {
      type: Boolean,
      default: false
    },
    inputValue: {
      type: String,
      default: void 0
    },
    defaultInputValue: {
      type: String,
      default: ""
    },
    popupVisible: {
      type: Boolean,
      default: void 0
    },
    expandTrigger: {
      type: String,
      default: "click"
    },
    defaultPopupVisible: {
      type: Boolean,
      default: false
    },
    placeholder: String,
    filterOption: {
      type: Function
    },
    popupContainer: {
      type: [String, Object]
    },
    maxTagCount: {
      type: Number,
      default: 0
    },
    formatLabel: {
      type: Function
    },
    triggerProps: {
      type: Object
    },
    checkStrictly: {
      type: Boolean,
      default: false
    },
    loadMore: {
      type: Function
    },
    loading: {
      type: Boolean,
      default: false
    },
    searchOptionOnlyLabel: {
      type: Boolean,
      default: false
    },
    searchDelay: {
      type: Number,
      default: 500
    },
    fieldNames: {
      type: Object
    },
    valueKey: {
      type: String,
      default: "value"
    },
    fallback: {
      type: [Boolean, Function],
      default: true
    },
    expandChild: {
      type: Boolean,
      default: false
    }
  },
  emits: {
    "update:modelValue": (value) => true,
    "update:popupVisible": (visible) => true,
    "change": (value) => true,
    "inputValueChange": (value) => true,
    "clear": () => true,
    "search": (value) => true,
    "popupVisibleChange": (visible) => true,
    "focus": (ev) => true,
    "blur": (ev) => true
  },
  setup(props, { emit, slots }) {
    const {
      options,
      checkStrictly,
      loadMore,
      formatLabel,
      modelValue,
      disabled,
      valueKey,
      expandTrigger,
      expandChild
    } = toRefs(props);
    const _value = ref(props.defaultValue);
    const _inputValue = ref(props.defaultInputValue);
    const _popupVisible = ref(props.defaultPopupVisible);
    const { mergedDisabled, eventHandlers } = useFormItem({ disabled });
    watch(modelValue, (value) => {
      if (isUndefined(value) || isNull(value)) {
        _value.value = props.multiple ? [] : void 0;
      }
    });
    const optionInfos = ref([]);
    const totalLevel = ref(1);
    const optionMap = reactive(/* @__PURE__ */ new Map());
    const leafOptionMap = reactive(/* @__PURE__ */ new Map());
    const leafOptionValueMap = reactive(/* @__PURE__ */ new Map());
    const leafOptionSet = reactive(/* @__PURE__ */ new Set());
    const lazyLoadOptions = reactive({});
    const addLazyLoadOptions = (children, key) => {
      lazyLoadOptions[key] = children;
    };
    const DEFAULT_FIELD_NAMES4 = {
      value: "value",
      label: "label",
      disabled: "disabled",
      children: "children",
      tagProps: "tagProps",
      render: "render",
      isLeaf: "isLeaf"
    };
    const mergedFieldNames = computed(() => __spreadValues15(__spreadValues15({}, DEFAULT_FIELD_NAMES4), props.fieldNames));
    watch([options, lazyLoadOptions, mergedFieldNames], ([_options, _lazyLoadOptions, _fieldNames]) => {
      optionMap.clear();
      leafOptionMap.clear();
      leafOptionValueMap.clear();
      leafOptionSet.clear();
      optionInfos.value = getOptionInfos2(_options != null ? _options : [], {
        enabledLazyLoad: Boolean(props.loadMore),
        lazyLoadOptions,
        optionMap,
        leafOptionSet,
        leafOptionMap,
        leafOptionValueMap,
        totalLevel,
        checkStrictly,
        valueKey,
        fieldNames: _fieldNames
      });
    }, {
      immediate: true,
      deep: true
    });
    const computedValueMap = computed(() => {
      var _a;
      const values = getValidValues((_a = props.modelValue) != null ? _a : _value.value, {
        multiple: props.multiple,
        pathMode: props.pathMode
      });
      return new Map(values.map((value) => [
        getValueKey(value, {
          valueKey: props.valueKey,
          leafOptionValueMap
        }),
        value
      ]));
    });
    const computedInputValue = computed(() => {
      var _a;
      return (_a = props.inputValue) != null ? _a : _inputValue.value;
    });
    const computedPopupVisible = computed(() => {
      var _a;
      return (_a = props.popupVisible) != null ? _a : _popupVisible.value;
    });
    const filteredLeafOptions = computed(() => {
      const options2 = props.checkStrictly ? Array.from(optionMap.values()) : Array.from(leafOptionSet);
      return options2.filter((item) => {
        var _a, _b, _c, _d;
        return (_d = (_a = props.filterOption) == null ? void 0 : _a.call(props, computedInputValue.value, item.raw)) != null ? _d : (_c = item.label) == null ? void 0 : _c.toLocaleLowerCase().includes((_b = computedInputValue.value) == null ? void 0 : _b.toLocaleLowerCase());
      });
    });
    const updateValue = (values) => {
      var _a, _b, _c;
      const value = props.multiple ? values : (_a = values[0]) != null ? _a : "";
      if (values.length === 0) {
        setSelectedPath();
        setActiveKey();
      }
      _value.value = value;
      emit("update:modelValue", value);
      emit("change", value);
      (_c = (_b = eventHandlers.value) == null ? void 0 : _b.onChange) == null ? void 0 : _c.call(_b);
    };
    const handlePopupVisibleChange = (visible) => {
      if (computedPopupVisible.value !== visible) {
        _popupVisible.value = visible;
        emit("popupVisibleChange", visible);
      }
    };
    const handleRemove = (key) => {
      if (props.multiple) {
        const option = leafOptionMap.get(key);
        if (option) {
          selectMultiple(option, false);
        } else {
          const values = [];
          computedValueMap.value.forEach((value, _key) => {
            if (_key !== key) {
              values.push(value);
            }
          });
          updateValue(values);
        }
      }
    };
    const selectSingle = (option) => {
      updateValue([props.pathMode ? option.pathValue : option.value]);
      handlePopupVisibleChange(false);
    };
    const selectMultiple = (option, checked) => {
      if (checked) {
        const leafOptionInfos = props.checkStrictly ? [option] : getLeafOptionInfos(option);
        updateValue([
          ...computedValueMap.value.values(),
          ...leafOptionInfos.filter((item) => !computedValueMap.value.has(item.key)).map((item) => {
            return props.pathMode ? item.pathValue : item.value;
          })
        ]);
      } else {
        const leafOptionKeys = props.checkStrictly ? [option.key] : getLeafOptionKeys(option);
        const values = [];
        computedValueMap.value.forEach((value, key) => {
          if (!leafOptionKeys.includes(key)) {
            values.push(value);
          }
        });
        updateValue(values);
      }
      handleInputValueChange("", "optionChecked");
    };
    const handleClickOption = (option, checked) => {
      if (props.multiple) {
        selectMultiple(option, checked != null ? checked : true);
      } else {
        selectSingle(option);
      }
    };
    const handleSearch = debounce((value) => {
      emit("search", value);
    }, props.searchDelay);
    const handleInputValueChange = (value, reason) => {
      if (value !== computedInputValue.value) {
        if (reason === "manual" && !computedPopupVisible.value) {
          _popupVisible.value = true;
          emit("popupVisibleChange", true);
        }
        _inputValue.value = value;
        emit("inputValueChange", value);
        if (props.allowSearch) {
          handleSearch(value);
        }
      }
    };
    watch(computedPopupVisible, (value) => {
      if (value) {
        if (computedValueMap.value.size > 0) {
          const keys = Array.from(computedValueMap.value.keys());
          const lastKey = keys[keys.length - 1];
          const option = leafOptionMap.get(lastKey);
          if (option && option.key !== activeKey.value) {
            setSelectedPath(option.key);
            setActiveKey(option.key);
          }
        }
      } else {
        if (computedValueMap.value.size === 0) {
          setSelectedPath();
          setActiveKey();
        }
        handleInputValueChange("", "optionListHide");
      }
    });
    const handleClear = (e2) => {
      e2.stopPropagation();
      if (props.multiple) {
        const newValues = [];
        computedValueMap.value.forEach((value, key) => {
          const option = leafOptionMap.get(key);
          if (option == null ? void 0 : option.disabled) {
            newValues.push(props.pathMode ? option.pathValue : option.value);
          }
        });
        updateValue(newValues);
      } else {
        updateValue([]);
      }
      handleInputValueChange("", "manual");
      emit("clear");
    };
    const showSearchPanel = computed(() => props.allowSearch && computedInputValue.value.length > 0);
    const handleFocus = (e2) => {
      emit("focus", e2);
    };
    const handleBlur = (e2) => {
      emit("blur", e2);
    };
    const {
      activeKey,
      activeOption,
      selectedPath,
      displayColumns,
      setActiveKey,
      setSelectedPath,
      getNextActiveNode
    } = useSelectedPath(optionInfos, {
      optionMap,
      filteredLeafOptions,
      showSearchPanel,
      expandChild
    });
    provide(cascaderInjectionKey, reactive({
      onClickOption: handleClickOption,
      setActiveKey,
      setSelectedPath,
      loadMore,
      expandTrigger,
      addLazyLoadOptions,
      formatLabel,
      slots,
      valueMap: computedValueMap
    }));
    const handleKeyDown = getKeyDownHandler(/* @__PURE__ */ new Map([
      [
        KEYBOARD_KEY.ENTER,
        (ev) => {
          if (computedPopupVisible.value) {
            if (activeOption.value) {
              let checked;
              if (props.checkStrictly || activeOption.value.isLeaf) {
                checked = !computedValueMap.value.has(activeOption.value.key);
              } else {
                checked = !getCheckedStatus(activeOption.value, computedValueMap.value).checked;
              }
              setSelectedPath(activeOption.value.key);
              handleClickOption(activeOption.value, checked);
            }
          } else {
            handlePopupVisibleChange(true);
          }
        }
      ],
      [
        KEYBOARD_KEY.ESC,
        (ev) => {
          handlePopupVisibleChange(false);
        }
      ],
      [
        KEYBOARD_KEY.ARROW_DOWN,
        (ev) => {
          ev.preventDefault();
          const activeNode = getNextActiveNode("next");
          setActiveKey(activeNode == null ? void 0 : activeNode.key);
        }
      ],
      [
        KEYBOARD_KEY.ARROW_UP,
        (ev) => {
          ev.preventDefault();
          const activeNode = getNextActiveNode("preview");
          setActiveKey(activeNode == null ? void 0 : activeNode.key);
        }
      ],
      [
        KEYBOARD_KEY.ARROW_RIGHT,
        (ev) => {
          var _a, _b;
          if (!showSearchPanel.value) {
            ev.preventDefault();
            if ((_a = activeOption.value) == null ? void 0 : _a.children) {
              setSelectedPath(activeOption.value.key);
              setActiveKey((_b = activeOption.value.children[0]) == null ? void 0 : _b.key);
            }
          }
        }
      ],
      [
        KEYBOARD_KEY.ARROW_LEFT,
        (ev) => {
          var _a;
          if (!showSearchPanel.value) {
            ev.preventDefault();
            if ((_a = activeOption.value) == null ? void 0 : _a.parent) {
              setSelectedPath(activeOption.value.parent.key);
              setActiveKey(activeOption.value.parent.key);
            }
          }
        }
      ]
    ]));
    const selectViewValue = computed(() => {
      const result = [];
      computedValueMap.value.forEach((value, key) => {
        var _a, _b;
        const option = leafOptionMap.get(key);
        if (option) {
          result.push({
            value: key,
            label: (_b = (_a = props.formatLabel) == null ? void 0 : _a.call(props, option.path.map((item) => item.raw))) != null ? _b : getOptionLabel(option),
            closable: !option.disabled,
            tagProps: option.tagProps
          });
        } else if (props.fallback) {
          const label = isFunction(props.fallback) ? props.fallback(value) : isArray(value) ? value.join(" / ") : String(value);
          result.push({
            value: key,
            label,
            closable: true
          });
        }
      });
      return result;
    });
    return {
      optionInfos,
      filteredLeafOptions,
      selectedPath,
      activeKey,
      displayColumns,
      computedInputValue,
      computedPopupVisible,
      handleClear,
      selectViewValue,
      handleInputValueChange,
      showSearchPanel,
      handlePopupVisibleChange,
      handleFocus,
      handleBlur,
      handleRemove,
      mergedDisabled,
      handleKeyDown,
      totalLevel
    };
  }
});
function _sfc_render47(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_select_view = resolveComponent("select-view");
  const _component_cascader_search_panel = resolveComponent("cascader-search-panel");
  const _component_base_cascader_panel = resolveComponent("base-cascader-panel");
  const _component_trigger = resolveComponent("trigger");
  return openBlock(), createBlock(_component_trigger, mergeProps(_ctx.triggerProps, {
    trigger: "click",
    "animation-name": "slide-dynamic-origin",
    "auto-fit-transform-origin": "",
    "popup-visible": _ctx.computedPopupVisible,
    position: "bl",
    disabled: _ctx.mergedDisabled,
    "popup-offset": 4,
    "auto-fit-popup-width": _ctx.showSearchPanel,
    "popup-container": _ctx.popupContainer,
    "prevent-focus": true,
    "click-to-close": !_ctx.allowSearch,
    onPopupVisibleChange: _ctx.handlePopupVisibleChange
  }), {
    content: withCtx(() => [
      _ctx.showSearchPanel ? (openBlock(), createBlock(_component_cascader_search_panel, {
        key: 0,
        options: _ctx.filteredLeafOptions,
        "active-key": _ctx.activeKey,
        multiple: _ctx.multiple,
        "check-strictly": _ctx.checkStrictly,
        loading: _ctx.loading,
        "path-label": !_ctx.searchOptionOnlyLabel
      }, createSlots({ _: 2 }, [
        _ctx.$slots.empty ? {
          name: "empty",
          fn: withCtx(() => [
            renderSlot(_ctx.$slots, "empty")
          ])
        } : void 0
      ]), 1032, ["options", "active-key", "multiple", "check-strictly", "loading", "path-label"])) : (openBlock(), createBlock(_component_base_cascader_panel, {
        key: 1,
        "display-columns": _ctx.displayColumns,
        "selected-path": _ctx.selectedPath,
        "active-key": _ctx.activeKey,
        multiple: _ctx.multiple,
        "total-level": _ctx.totalLevel,
        "check-strictly": _ctx.checkStrictly,
        loading: _ctx.loading,
        dropdown: ""
      }, createSlots({ _: 2 }, [
        _ctx.$slots.empty ? {
          name: "empty",
          fn: withCtx(() => [
            renderSlot(_ctx.$slots, "empty")
          ])
        } : void 0
      ]), 1032, ["display-columns", "selected-path", "active-key", "multiple", "total-level", "check-strictly", "loading"]))
    ]),
    default: withCtx(() => [
      createVNode(_component_select_view, mergeProps({
        "model-value": _ctx.selectViewValue,
        "input-value": _ctx.computedInputValue,
        disabled: _ctx.mergedDisabled,
        error: _ctx.error,
        multiple: _ctx.multiple,
        "allow-clear": _ctx.allowClear,
        "allow-search": _ctx.allowSearch,
        size: _ctx.size,
        opened: _ctx.computedPopupVisible,
        placeholder: _ctx.placeholder,
        loading: _ctx.loading,
        "max-tag-count": _ctx.maxTagCount
      }, _ctx.$attrs, {
        onInputValueChange: _ctx.handleInputValueChange,
        onClear: _ctx.handleClear,
        onFocus: _ctx.handleFocus,
        onBlur: _ctx.handleBlur,
        onRemove: _ctx.handleRemove,
        onKeydown: _ctx.handleKeyDown
      }), createSlots({ _: 2 }, [
        _ctx.$slots.label ? {
          name: "label",
          fn: withCtx((data) => [
            renderSlot(_ctx.$slots, "label", normalizeProps(guardReactiveProps(data)))
          ])
        } : void 0,
        _ctx.$slots.prefix ? {
          name: "prefix",
          fn: withCtx(() => [
            renderSlot(_ctx.$slots, "prefix")
          ])
        } : void 0,
        _ctx.$slots["arrow-icon"] ? {
          name: "arrow-icon",
          fn: withCtx(() => [
            renderSlot(_ctx.$slots, "arrow-icon")
          ])
        } : void 0,
        _ctx.$slots["loading-icon"] ? {
          name: "loading-icon",
          fn: withCtx(() => [
            renderSlot(_ctx.$slots, "loading-icon")
          ])
        } : void 0,
        _ctx.$slots["search-icon"] ? {
          name: "search-icon",
          fn: withCtx(() => [
            renderSlot(_ctx.$slots, "search-icon")
          ])
        } : void 0
      ]), 1040, ["model-value", "input-value", "disabled", "error", "multiple", "allow-clear", "allow-search", "size", "opened", "placeholder", "loading", "max-tag-count", "onInputValueChange", "onClear", "onFocus", "onBlur", "onRemove", "onKeydown"])
    ]),
    _: 3
  }, 16, ["popup-visible", "disabled", "auto-fit-popup-width", "popup-container", "click-to-close", "onPopupVisibleChange"]);
}
var _Cascader = _export_sfc(_sfc_main47, [["render", _sfc_render47]]);

// node_modules/@arco-design/web-vue/es/cascader/cascader-panel.js
var __defProp16 = Object.defineProperty;
var __getOwnPropSymbols16 = Object.getOwnPropertySymbols;
var __hasOwnProp16 = Object.prototype.hasOwnProperty;
var __propIsEnum16 = Object.prototype.propertyIsEnumerable;
var __defNormalProp16 = (obj, key, value) => key in obj ? __defProp16(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues16 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp16.call(b, prop))
      __defNormalProp16(a, prop, b[prop]);
  if (__getOwnPropSymbols16)
    for (var prop of __getOwnPropSymbols16(b)) {
      if (__propIsEnum16.call(b, prop))
        __defNormalProp16(a, prop, b[prop]);
    }
  return a;
};
var _sfc_main48 = defineComponent({
  name: "CascaderPanel",
  components: {
    BaseCascaderPanel
  },
  props: {
    pathMode: {
      type: Boolean,
      default: false
    },
    multiple: {
      type: Boolean,
      default: false
    },
    modelValue: {
      type: [String, Number, Array]
    },
    defaultValue: {
      type: [String, Number, Array],
      default: (props) => props.multiple ? [] : props.pathMode ? void 0 : ""
    },
    options: {
      type: Array,
      default: () => []
    },
    expandTrigger: {
      type: String,
      default: "click"
    },
    checkStrictly: {
      type: Boolean,
      default: false
    },
    loadMore: {
      type: Function
    },
    fieldNames: {
      type: Object
    },
    valueKey: {
      type: String,
      default: "value"
    },
    expandChild: {
      type: Boolean,
      default: false
    }
  },
  emits: {
    "update:modelValue": (value) => true,
    "change": (value) => true
  },
  setup(props, { emit, slots }) {
    const {
      options,
      checkStrictly,
      loadMore,
      modelValue,
      valueKey,
      expandChild,
      expandTrigger
    } = toRefs(props);
    const _value = ref(props.defaultValue);
    watch(modelValue, (value) => {
      if (isUndefined(value) || isNull(value)) {
        _value.value = props.multiple ? [] : void 0;
      }
    });
    const optionInfos = ref([]);
    const totalLevel = ref(1);
    const optionMap = reactive(/* @__PURE__ */ new Map());
    const leafOptionMap = reactive(/* @__PURE__ */ new Map());
    const leafOptionValueMap = reactive(/* @__PURE__ */ new Map());
    const leafOptionSet = reactive(/* @__PURE__ */ new Set());
    const lazyLoadOptions = reactive({});
    const addLazyLoadOptions = (children, key) => {
      lazyLoadOptions[key] = children;
    };
    const DEFAULT_FIELD_NAMES4 = {
      value: "value",
      label: "label",
      disabled: "disabled",
      children: "children",
      tagProps: "tagProps",
      render: "render",
      isLeaf: "isLeaf"
    };
    const mergedFieldNames = computed(() => __spreadValues16(__spreadValues16({}, DEFAULT_FIELD_NAMES4), props.fieldNames));
    watch([options, lazyLoadOptions, mergedFieldNames], ([_options, _lazyLoadOptions, _fieldNames]) => {
      optionMap.clear();
      leafOptionMap.clear();
      leafOptionValueMap.clear();
      leafOptionSet.clear();
      optionInfos.value = getOptionInfos2(_options != null ? _options : [], {
        enabledLazyLoad: Boolean(props.loadMore),
        lazyLoadOptions: _lazyLoadOptions,
        optionMap,
        leafOptionSet,
        leafOptionMap,
        leafOptionValueMap,
        totalLevel,
        checkStrictly,
        fieldNames: _fieldNames,
        valueKey
      });
    }, {
      immediate: true
    });
    const computedValueMap = computed(() => {
      var _a;
      const values = getValidValues((_a = props.modelValue) != null ? _a : _value.value, {
        multiple: props.multiple,
        pathMode: props.pathMode
      });
      return new Map(values.map((value) => [
        getValueKey(value, {
          valueKey: props.valueKey,
          leafOptionValueMap
        }),
        value
      ]));
    });
    const filteredLeafOptions = computed(() => props.checkStrictly ? Array.from(optionMap.values()) : Array.from(leafOptionSet));
    const updateValue = (values) => {
      var _a;
      const value = props.multiple ? values : (_a = values[0]) != null ? _a : "";
      if (values.length === 0) {
        setSelectedPath();
        setActiveKey();
      }
      _value.value = value;
      emit("update:modelValue", value);
      emit("change", value);
    };
    const selectSingle = (option) => {
      updateValue([props.pathMode ? option.pathValue : option.value]);
    };
    const selectMultiple = (option, checked) => {
      if (checked) {
        const leafOptionInfos = props.checkStrictly ? [option] : getLeafOptionInfos(option);
        updateValue([
          ...computedValueMap.value.values(),
          ...leafOptionInfos.filter((item) => !computedValueMap.value.has(item.key)).map((item) => {
            return props.pathMode ? item.pathValue : item.value;
          })
        ]);
      } else {
        const leafOptionKeys = props.checkStrictly ? [option.key] : getLeafOptionKeys(option);
        const values = [];
        computedValueMap.value.forEach((value, key) => {
          if (!leafOptionKeys.includes(key)) {
            values.push(value);
          }
        });
        updateValue(values);
      }
    };
    const handleClickOption = (option, checked) => {
      if (props.multiple) {
        selectMultiple(option, checked != null ? checked : true);
      } else {
        selectSingle(option);
      }
    };
    const {
      activeKey,
      activeOption,
      selectedPath,
      displayColumns,
      setActiveKey,
      setSelectedPath,
      getNextActiveNode
    } = useSelectedPath(optionInfos, {
      optionMap,
      filteredLeafOptions,
      expandChild
    });
    provide(cascaderInjectionKey, reactive({
      onClickOption: handleClickOption,
      setActiveKey,
      setSelectedPath,
      loadMore,
      addLazyLoadOptions,
      slots,
      valueMap: computedValueMap,
      expandTrigger
    }));
    const handleKeyDown = getKeyDownHandler(/* @__PURE__ */ new Map([
      [
        KEYBOARD_KEY.ENTER,
        (ev) => {
          if (activeOption.value) {
            let checked;
            if (props.checkStrictly || activeOption.value.isLeaf) {
              checked = !computedValueMap.value.has(activeOption.value.key);
            } else {
              checked = !getCheckedStatus(activeOption.value, computedValueMap.value).checked;
            }
            setSelectedPath(activeOption.value.key);
            handleClickOption(activeOption.value, checked);
          }
        }
      ],
      [
        KEYBOARD_KEY.ARROW_DOWN,
        (ev) => {
          ev.preventDefault();
          const activeNode = getNextActiveNode("next");
          setActiveKey(activeNode == null ? void 0 : activeNode.key);
        }
      ],
      [
        KEYBOARD_KEY.ARROW_UP,
        (ev) => {
          ev.preventDefault();
          const activeNode = getNextActiveNode("preview");
          setActiveKey(activeNode == null ? void 0 : activeNode.key);
        }
      ],
      [
        KEYBOARD_KEY.ARROW_RIGHT,
        (ev) => {
          var _a, _b;
          ev.preventDefault();
          if ((_a = activeOption.value) == null ? void 0 : _a.children) {
            setSelectedPath(activeOption.value.key);
            setActiveKey((_b = activeOption.value.children[0]) == null ? void 0 : _b.key);
          }
        }
      ],
      [
        KEYBOARD_KEY.ARROW_LEFT,
        (ev) => {
          var _a;
          ev.preventDefault();
          if ((_a = activeOption.value) == null ? void 0 : _a.parent) {
            setSelectedPath(activeOption.value.parent.key);
            setActiveKey(activeOption.value.parent.key);
          }
        }
      ]
    ]));
    return {
      optionInfos,
      filteredLeafOptions,
      selectedPath,
      activeKey,
      displayColumns,
      handleKeyDown,
      totalLevel
    };
  }
});
function _sfc_render48(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_base_cascader_panel = resolveComponent("base-cascader-panel");
  return openBlock(), createBlock(_component_base_cascader_panel, {
    "display-columns": _ctx.displayColumns,
    "selected-path": _ctx.selectedPath,
    "active-key": _ctx.activeKey,
    multiple: _ctx.multiple,
    "total-level": _ctx.totalLevel,
    "check-strictly": _ctx.checkStrictly,
    onKeydown: _ctx.handleKeyDown
  }, createSlots({ _: 2 }, [
    _ctx.$slots.empty ? {
      name: "empty",
      fn: withCtx(() => [
        renderSlot(_ctx.$slots, "empty")
      ])
    } : void 0
  ]), 1032, ["display-columns", "selected-path", "active-key", "multiple", "total-level", "check-strictly", "onKeydown"]);
}
var CascaderPanel = _export_sfc(_sfc_main48, [["render", _sfc_render48]]);

// node_modules/@arco-design/web-vue/es/cascader/index.js
var Cascader = Object.assign(_Cascader, {
  CascaderPanel,
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Cascader.name, _Cascader);
    app.component(componentPrefix + CascaderPanel.name, CascaderPanel);
  }
});

// node_modules/@arco-design/web-vue/es/collapse/context.js
var collapseKey = Symbol("collapseCtx");

// node_modules/@arco-design/web-vue/es/collapse/collapse.js
var _sfc_main49 = defineComponent({
  name: "Collapse",
  props: {
    activeKey: {
      type: Array,
      default: void 0
    },
    defaultActiveKey: {
      type: Array,
      default: () => []
    },
    accordion: {
      type: Boolean,
      default: false
    },
    showExpandIcon: {
      type: Boolean,
      default: void 0
    },
    expandIconPosition: {
      type: String,
      default: "left"
    },
    bordered: {
      type: Boolean,
      default: true
    },
    destroyOnHide: {
      type: Boolean,
      default: false
    }
  },
  emits: {
    "update:activeKey": (activeKey) => true,
    "change": (activeKey, ev) => true
  },
  setup(props, { emit, slots }) {
    const { expandIconPosition, destroyOnHide, showExpandIcon } = toRefs(props);
    const prefixCls = getPrefixCls("collapse");
    const _activeKey = ref(props.defaultActiveKey);
    const computedActiveKeys = computed(() => {
      var _a;
      const activeKey = (_a = props.activeKey) != null ? _a : _activeKey.value;
      if (!isArray(activeKey)) {
        return [activeKey];
      }
      return activeKey;
    });
    const handleClick = (key, e2) => {
      let newActiveKeys = [];
      if (props.accordion) {
        if (!computedActiveKeys.value.includes(key)) {
          newActiveKeys = [key];
        }
        _activeKey.value = newActiveKeys;
      } else {
        newActiveKeys = [...computedActiveKeys.value];
        const _index = newActiveKeys.indexOf(key);
        if (_index > -1) {
          newActiveKeys.splice(_index, 1);
        } else if (props.accordion) {
          newActiveKeys = [key];
        } else {
          newActiveKeys.push(key);
        }
        _activeKey.value = newActiveKeys;
      }
      emit("update:activeKey", newActiveKeys);
      emit("change", newActiveKeys, e2);
    };
    provide(collapseKey, reactive({
      activeKeys: computedActiveKeys,
      slots,
      showExpandIcon,
      expandIconPosition,
      destroyOnHide,
      handleClick
    }));
    const cls = computed(() => [
      prefixCls,
      {
        [`${prefixCls}-borderless`]: !props.bordered
      }
    ]);
    return {
      prefixCls,
      cls
    };
  }
});
function _sfc_render49(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.cls)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
var _Collapse = _export_sfc(_sfc_main49, [["render", _sfc_render49]]);

// node_modules/@arco-design/web-vue/es/icon/icon-caret-right/icon-caret-right.js
var _sfc_main50 = defineComponent({
  name: "IconCaretRight",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-caret-right`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_125 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_220 = createBaseVNode("path", {
  d: "M34.829 23.063c.6.48.6 1.394 0 1.874L17.949 38.44c-.785.629-1.949.07-1.949-.937V10.497c0-1.007 1.164-1.566 1.95-.937l16.879 13.503Z",
  fill: "currentColor",
  stroke: "none"
}, null, -1);
var _hoisted_318 = [
  _hoisted_220
];
function _sfc_render50(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_318, 14, _hoisted_125);
}
var _IconCaretRight = _export_sfc(_sfc_main50, [["render", _sfc_render50]]);

// node_modules/@arco-design/web-vue/es/icon/icon-caret-right/index.js
var IconCaretRight = Object.assign(_IconCaretRight, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconCaretRight.name, _IconCaretRight);
  }
});

// node_modules/@arco-design/web-vue/es/icon/icon-caret-left/icon-caret-left.js
var _sfc_main51 = defineComponent({
  name: "IconCaretLeft",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-caret-left`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_126 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_221 = createBaseVNode("path", {
  d: "M13.171 24.937a1.2 1.2 0 0 1 0-1.874L30.051 9.56c.785-.629 1.949-.07 1.949.937v27.006c0 1.006-1.164 1.566-1.95.937L13.171 24.937Z",
  fill: "currentColor",
  stroke: "none"
}, null, -1);
var _hoisted_319 = [
  _hoisted_221
];
function _sfc_render51(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_319, 14, _hoisted_126);
}
var _IconCaretLeft = _export_sfc(_sfc_main51, [["render", _sfc_render51]]);

// node_modules/@arco-design/web-vue/es/icon/icon-caret-left/index.js
var IconCaretLeft = Object.assign(_IconCaretLeft, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconCaretLeft.name, _IconCaretLeft);
  }
});

// node_modules/@arco-design/web-vue/es/collapse/collapse-item.js
var CollapseItem = defineComponent({
  name: "CollapseItem",
  components: {
    IconHover,
    IconCaretRight,
    IconCaretLeft
  },
  props: {
    key: [String, Number],
    header: String,
    disabled: {
      type: Boolean,
      default: false
    },
    showExpandIcon: {
      type: Boolean,
      default: true
    },
    destroyOnHide: {
      type: Boolean,
      default: false
    }
  },
  setup(props, {
    slots
  }) {
    var _a;
    const instance = getCurrentInstance();
    const prefixCls = getPrefixCls("collapse-item");
    const collapseCtx = inject(collapseKey, {});
    const key = instance && isNumber(instance == null ? void 0 : instance.vnode.key) ? instance.vnode.key : String((_a = instance == null ? void 0 : instance.vnode.key) != null ? _a : "");
    const isActive = computed(() => {
      var _a2;
      return (_a2 = collapseCtx.activeKeys) == null ? void 0 : _a2.includes(key);
    });
    const mergedDestroyOnHide = computed(() => collapseCtx.destroyOnHide || props.destroyOnHide);
    const mergedShowExpandIcon = computed(() => {
      var _a2;
      return (_a2 = collapseCtx == null ? void 0 : collapseCtx.showExpandIcon) != null ? _a2 : props.showExpandIcon;
    });
    const mounted = ref(mergedDestroyOnHide.value ? isActive.value : true);
    const expandIconPosition = computed(() => {
      var _a2;
      return (_a2 = collapseCtx == null ? void 0 : collapseCtx.expandIconPosition) != null ? _a2 : "left";
    });
    const handleClick = (e2) => {
      var _a2;
      if (!props.disabled) {
        (_a2 = collapseCtx.handleClick) == null ? void 0 : _a2.call(collapseCtx, key, e2);
      }
    };
    watch(isActive, (isActive2) => {
      if (isActive2 && !mounted.value) {
        mounted.value = true;
      }
    });
    const transitionEvents = {
      onEnter: (el) => {
        el.style.height = `${el.scrollHeight}px`;
      },
      onAfterEnter: (el) => {
        el.style.height = "auto";
      },
      onBeforeLeave: (el) => {
        el.style.height = `${el.scrollHeight}px`;
      },
      onLeave: (el) => {
        el.style.height = "0";
      },
      onAfterLeave: () => {
        if (mergedDestroyOnHide.value) {
          mounted.value = false;
        }
      }
    };
    const cls = computed(() => [prefixCls, {
      [`${prefixCls}-active`]: isActive.value
    }]);
    const headerCls = computed(() => [`${prefixCls}-header`, `${prefixCls}-header-${collapseCtx == null ? void 0 : collapseCtx.expandIconPosition}`, {
      [`${prefixCls}-header-disabled`]: props.disabled
    }]);
    const iconCls = computed(() => [{
      [`${prefixCls}-icon-right`]: (collapseCtx == null ? void 0 : collapseCtx.expandIconPosition) === "right"
    }]);
    const contentCls = computed(() => [`${prefixCls}-content`, {
      [`${prefixCls}-content-expend`]: isActive.value
    }]);
    const defaultExpandIcon = () => expandIconPosition.value === "right" ? createVNode(resolveComponent("icon-caret-left"), {
      "class": `${prefixCls}-expand-icon`
    }, null) : createVNode(resolveComponent("icon-caret-right"), {
      "class": `${prefixCls}-expand-icon`
    }, null);
    const expandIconRender = () => mergedShowExpandIcon.value && createVNode(resolveComponent("icon-hover"), {
      "prefix": prefixCls,
      "class": iconCls.value,
      "disabled": props.disabled
    }, {
      default: () => {
        var _a2, _b, _c, _d;
        return [(_d = (_c = (_b = slots["expand-icon"]) != null ? _b : (_a2 = collapseCtx == null ? void 0 : collapseCtx.slots) == null ? void 0 : _a2["expand-icon"]) == null ? void 0 : _c({
          active: isActive.value,
          disabled: props.disabled,
          position: expandIconPosition.value
        })) != null ? _d : defaultExpandIcon()];
      }
    });
    return () => {
      var _a2, _b, _c;
      return createVNode("div", {
        "class": cls.value
      }, [createVNode("div", {
        "role": "button",
        "aria-disabled": props.disabled,
        "aria-expanded": isActive.value,
        "tabindex": "0",
        "class": headerCls.value,
        "onClick": handleClick
      }, [expandIconRender(), createVNode("div", {
        "class": `${prefixCls}-header-title`
      }, [(_b = (_a2 = slots.header) == null ? void 0 : _a2.call(slots)) != null ? _b : props.header]), slots.extra && createVNode("div", {
        "class": `${prefixCls}-header-extra`
      }, [(_c = slots.extra) == null ? void 0 : _c.call(slots)])]), createVNode(Transition, mergeProps({
        "name": "collapse-slider"
      }, transitionEvents), {
        default: () => {
          var _a3;
          return [withDirectives(createVNode("div", {
            "role": "region",
            "class": contentCls.value
          }, [mounted.value && createVNode("div", {
            "ref": "contentBoxRef",
            "class": `${prefixCls}-content-box`
          }, [(_a3 = slots.default) == null ? void 0 : _a3.call(slots)])]), [[vShow, isActive.value]])];
        }
      })]);
    };
  }
});

// node_modules/@arco-design/web-vue/es/collapse/index.js
var Collapse = Object.assign(_Collapse, {
  Item: CollapseItem,
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Collapse.name, _Collapse);
    app.component(componentPrefix + CollapseItem.name, CollapseItem);
  }
});

// node_modules/@arco-design/web-vue/es/_utils/use-prop-or-slot.js
function hasPropOrSlot(props, slots, propName) {
  return computed(() => Boolean(props[propName] || slots[propName]));
}

// node_modules/@arco-design/web-vue/es/comment/comment.js
var __defProp17 = Object.defineProperty;
var __getOwnPropSymbols17 = Object.getOwnPropertySymbols;
var __hasOwnProp17 = Object.prototype.hasOwnProperty;
var __propIsEnum17 = Object.prototype.propertyIsEnumerable;
var __defNormalProp17 = (obj, key, value) => key in obj ? __defProp17(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues17 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp17.call(b, prop))
      __defNormalProp17(a, prop, b[prop]);
  if (__getOwnPropSymbols17)
    for (var prop of __getOwnPropSymbols17(b)) {
      if (__propIsEnum17.call(b, prop))
        __defNormalProp17(a, prop, b[prop]);
    }
  return a;
};
var _sfc_main52 = defineComponent({
  name: "Comment",
  props: {
    author: {
      type: String
    },
    avatar: {
      type: String
    },
    content: {
      type: String
    },
    datetime: {
      type: String
    },
    align: {
      type: [String, Object],
      default: "left"
    }
  },
  setup(props, { slots }) {
    const prefixCls = getPrefixCls("comment");
    const [hasAuthor, hasAvatar, hasContent, hasDatetime] = [
      "author",
      "avatar",
      "content",
      "datetime"
    ].map((propName) => hasPropOrSlot(props, slots, propName));
    const computedAlign = computed(() => {
      const { align } = props;
      return __spreadValues17({}, isString(align) ? {
        datetime: align,
        actions: align
      } : align);
    });
    return {
      prefixCls,
      hasAuthor,
      hasAvatar,
      hasContent,
      hasDatetime,
      computedAlign
    };
  }
});
var _hoisted_127 = ["src"];
var _hoisted_222 = { key: 0 };
var _hoisted_320 = { key: 0 };
var _hoisted_45 = { key: 0 };
function _sfc_render52(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.prefixCls)
  }, [
    _ctx.hasAvatar ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(`${_ctx.prefixCls}-avatar`)
    }, [
      _ctx.avatar ? (openBlock(), createElementBlock("img", {
        key: 0,
        src: _ctx.avatar,
        alt: "comment-avatar"
      }, null, 8, _hoisted_127)) : renderSlot(_ctx.$slots, "avatar", { key: 1 })
    ], 2)) : createCommentVNode("v-if", true),
    createBaseVNode("div", {
      class: normalizeClass(`${_ctx.prefixCls}-inner`)
    }, [
      createBaseVNode("div", {
        class: normalizeClass(`${_ctx.prefixCls}-inner-content`)
      }, [
        _ctx.hasAuthor || _ctx.hasDatetime ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(`${_ctx.prefixCls}-title ${_ctx.prefixCls}-title-align-${_ctx.computedAlign.datetime}`)
        }, [
          _ctx.hasAuthor ? (openBlock(), createElementBlock("span", {
            key: 0,
            class: normalizeClass(`${_ctx.prefixCls}-author`)
          }, [
            _ctx.author ? (openBlock(), createElementBlock("span", _hoisted_222, toDisplayString(_ctx.author), 1)) : renderSlot(_ctx.$slots, "author", { key: 1 })
          ], 2)) : createCommentVNode("v-if", true),
          _ctx.hasDatetime ? (openBlock(), createElementBlock("span", {
            key: 1,
            class: normalizeClass(`${_ctx.prefixCls}-datetime`)
          }, [
            _ctx.datetime ? (openBlock(), createElementBlock("span", _hoisted_320, toDisplayString(_ctx.datetime), 1)) : renderSlot(_ctx.$slots, "datetime", { key: 1 })
          ], 2)) : createCommentVNode("v-if", true)
        ], 2)) : createCommentVNode("v-if", true),
        _ctx.hasContent ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass(`${_ctx.prefixCls}-content`)
        }, [
          _ctx.content ? (openBlock(), createElementBlock("span", _hoisted_45, toDisplayString(_ctx.content), 1)) : renderSlot(_ctx.$slots, "content", { key: 1 })
        ], 2)) : createCommentVNode("v-if", true),
        _ctx.$slots.actions ? (openBlock(), createElementBlock("div", {
          key: 2,
          class: normalizeClass(`${_ctx.prefixCls}-actions ${_ctx.prefixCls}-actions-align-${_ctx.computedAlign.actions}`)
        }, [
          renderSlot(_ctx.$slots, "actions")
        ], 2)) : createCommentVNode("v-if", true)
      ], 2),
      _ctx.$slots.default ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(`${_ctx.prefixCls}-inner-comment`)
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 2)) : createCommentVNode("v-if", true)
    ], 2)
  ], 2);
}
var _Comment = _export_sfc(_sfc_main52, [["render", _sfc_render52]]);

// node_modules/@arco-design/web-vue/es/comment/index.js
var Comment2 = Object.assign(_Comment, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Comment.name, _Comment);
  }
});

// node_modules/@arco-design/web-vue/es/config-provider/config-provider.js
var _sfc_main53 = defineComponent({
  name: "ConfigProvider",
  props: {
    prefixCls: {
      type: String,
      default: "arco"
    },
    locale: {
      type: Object
    },
    size: {
      type: String
    },
    global: {
      type: Boolean,
      default: false
    },
    updateAtScroll: {
      type: Boolean,
      default: false
    }
  },
  setup(props, { slots }) {
    const { prefixCls, locale, size, updateAtScroll } = toRefs(props);
    const config = reactive({
      slots,
      prefixCls,
      locale,
      size,
      updateAtScroll
    });
    if (props.global) {
      const instance = getCurrentInstance();
      if (instance) {
        instance.appContext.app.provide(configProviderInjectionKey, config);
      }
    } else {
      provide(configProviderInjectionKey, config);
    }
  }
});
function _sfc_render53(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}
var _ConfigProvider = _export_sfc(_sfc_main53, [["render", _sfc_render53]]);

// node_modules/@arco-design/web-vue/es/config-provider/index.js
var ConfigProvider = Object.assign(_ConfigProvider, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _ConfigProvider.name, _ConfigProvider);
  }
});

// node_modules/@arco-design/web-vue/es/_utils/date.js
var import_dayjs = __toESM(require_dayjs_min());
var import_customParseFormat = __toESM(require_customParseFormat());
var import_isBetween = __toESM(require_isBetween());
var import_weekOfYear = __toESM(require_weekOfYear());
var import_advancedFormat = __toESM(require_advancedFormat());
var import_weekYear = __toESM(require_weekYear());
var import_quarterOfYear = __toESM(require_quarterOfYear());
var import_zh_cn2 = __toESM(require_zh_cn());
var __defProp18 = Object.defineProperty;
var __defProps5 = Object.defineProperties;
var __getOwnPropDescs5 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols18 = Object.getOwnPropertySymbols;
var __hasOwnProp18 = Object.prototype.hasOwnProperty;
var __propIsEnum18 = Object.prototype.propertyIsEnumerable;
var __defNormalProp18 = (obj, key, value) => key in obj ? __defProp18(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues18 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp18.call(b, prop))
      __defNormalProp18(a, prop, b[prop]);
  if (__getOwnPropSymbols18)
    for (var prop of __getOwnPropSymbols18(b)) {
      if (__propIsEnum18.call(b, prop))
        __defNormalProp18(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps5 = (a, b) => __defProps5(a, __getOwnPropDescs5(b));
var overwriteIsDayjs = (_, Dayjs2, dayjs2) => {
  dayjs2 = function(date, c) {
    if (isDayjs(date)) {
      return date.clone();
    }
    const cfg = typeof c === "object" ? c : {};
    cfg.date = date;
    cfg.args = arguments;
    return new Dayjs2(cfg);
  };
  const proto = Dayjs2.prototype;
  const old$Utils = proto.$utils;
  proto.$utils = () => {
    const newUtils = old$Utils();
    newUtils.i = isDayjs;
    return newUtils;
  };
  dayjs2.isDayjs = isDayjs;
};
import_dayjs.default.extend(overwriteIsDayjs);
import_dayjs.default.extend(import_customParseFormat.default);
import_dayjs.default.extend(import_isBetween.default);
import_dayjs.default.extend(import_weekOfYear.default);
import_dayjs.default.extend(import_advancedFormat.default);
import_dayjs.default.extend(import_weekYear.default);
import_dayjs.default.extend(import_quarterOfYear.default);
var dayjs = import_dayjs.default;
var methods = {
  add(time, value, unit) {
    return time.add(value, unit);
  },
  subtract(time, value, unit) {
    return time.subtract(value, unit);
  },
  startOf(time, unit) {
    return time.startOf(unit);
  },
  endOf(time, unit) {
    return time.endOf(unit);
  },
  set(time, unit, value) {
    return time.set(unit, value);
  },
  isSameWeek(date1, date2, weekStart, localeName) {
    return date1.locale(__spreadProps5(__spreadValues18({}, dayjs.Ls[localeName.toLocaleLowerCase()]), { weekStart })).isSame(date2, "week");
  }
};
function getNow() {
  return dayjs();
}
function getSortedDayjsArray(values) {
  return [...values].sort((a, b) => a.valueOf() - b.valueOf());
}
function isValueChange(prevValue, currentValue) {
  const isDifference = (value1, value2) => {
    if (value1 === void 0 && value2 === void 0) {
      return false;
    }
    if (value1 && !value2 || !value1 && value2) {
      return true;
    }
    return (value1 == null ? void 0 : value1.valueOf()) !== (value2 == null ? void 0 : value2.valueOf());
  };
  if (currentValue === void 0 && prevValue === void 0) {
    return false;
  }
  if (isArray(currentValue) && isArray(prevValue)) {
    return isDifference(currentValue[0], prevValue[0]) || isDifference(currentValue[1], prevValue[1]);
  }
  if (!isArray(currentValue) && !isArray(prevValue)) {
    return isDifference(currentValue, prevValue);
  }
  return true;
}
function getDayjsValue(time, format) {
  const parseQuarterToMonth = (value) => {
    const reg = /(Q1)|(Q2)|(Q3)|(Q4)/;
    const quarter = {
      Q1: "01",
      Q2: "04",
      Q3: "07",
      Q4: "10"
    };
    const [q] = reg.exec(value);
    return value.replace(reg, quarter[q]);
  };
  const formatValue = (value) => {
    if (!value)
      return void 0;
    if (typeof value === "string") {
      if (isQuarter(format)) {
        return dayjs(parseQuarterToMonth(value), format.replace(/\[Q]Q/, "MM"));
      }
      return dayjs(value, format);
    }
    return dayjs(value);
  };
  if (isArray(time)) {
    return time.map(formatValue);
  }
  return formatValue(time);
}
function getDateValue(value) {
  const formatValue = (t2) => t2 ? t2.toDate() : void 0;
  if (isArray(value)) {
    return value.map(formatValue);
  }
  return formatValue(value);
}
function initializeDateLocale(localeName, weekStart) {
  dayjs.locale(__spreadProps5(__spreadValues18({}, dayjs.Ls[localeName.toLocaleLowerCase()]), { weekStart }));
}

// node_modules/@arco-design/web-vue/es/_hooks/use-state.js
function useState(defaultValue) {
  const value = ref(defaultValue);
  const setValue = (newValue) => {
    value.value = newValue;
  };
  return [value, setValue];
}

// node_modules/@arco-design/web-vue/es/date-picker/hooks/use-picker-state.js
function usePickerState(props) {
  const { modelValue, defaultValue, format } = toRefs(props);
  const computedModelValue = computed(() => {
    return getDayjsValue(modelValue.value, format.value);
  });
  const computedDefaultValue = computed(() => {
    return getDayjsValue(defaultValue.value, format.value);
  });
  const [localValue, setLocalValue] = useState(!isUndefined(computedModelValue.value) ? computedModelValue.value : !isUndefined(computedDefaultValue.value) ? computedDefaultValue.value : void 0);
  watch(computedModelValue, () => {
    if (isUndefined(computedModelValue.value)) {
      setLocalValue(void 0);
    }
  });
  const mergeValue = computed(() => computedModelValue.value || localValue.value);
  return {
    value: mergeValue,
    setValue: setLocalValue
  };
}

// node_modules/@arco-design/web-vue/es/_components/picker/input.js
var _sfc_main54 = defineComponent({
  name: "DateInput",
  components: {
    IconHover,
    IconClose,
    FeedbackIcon
  },
  props: {
    size: {
      type: String
    },
    focused: {
      type: Boolean
    },
    disabled: {
      type: Boolean
    },
    readonly: {
      type: Boolean
    },
    error: {
      type: Boolean
    },
    allowClear: {
      type: Boolean
    },
    placeholder: {
      type: String
    },
    inputValue: {
      type: String
    },
    value: {
      type: Object
    },
    format: {
      type: [String, Function],
      required: true
    }
  },
  emits: ["clear", "press-enter", "change", "blur"],
  setup(props, { emit, slots }) {
    const { error, focused, disabled, size, value, format, inputValue } = toRefs(props);
    const {
      mergedSize: _mergedSize,
      mergedDisabled,
      mergedError,
      feedback
    } = useFormItem({ size, disabled, error });
    const { mergedSize } = useSize(_mergedSize);
    const prefixCls = getPrefixCls("picker");
    const classNames = computed(() => [
      prefixCls,
      `${prefixCls}-size-${mergedSize.value}`,
      {
        [`${prefixCls}-focused`]: focused.value,
        [`${prefixCls}-disabled`]: mergedDisabled.value,
        [`${prefixCls}-error`]: mergedError.value,
        [`${prefixCls}-has-prefix`]: slots.prefix
      }
    ]);
    const displayValue = computed(() => {
      if (inputValue == null ? void 0 : inputValue.value)
        return inputValue == null ? void 0 : inputValue.value;
      if ((value == null ? void 0 : value.value) && isDayjs(value.value)) {
        return isFunction(format.value) ? format.value(value.value) : value.value.format(format.value);
      }
      return void 0;
    });
    const refInput = ref();
    return {
      feedback,
      prefixCls,
      classNames,
      displayValue,
      mergedDisabled,
      refInput,
      onPressEnter() {
        emit("press-enter");
      },
      onChange(e2) {
        emit("change", e2);
      },
      onClear(e2) {
        emit("clear", e2);
      },
      onBlur(e2) {
        emit("blur", e2);
      }
    };
  },
  methods: {
    focus() {
      this.refInput && this.refInput.focus && this.refInput.focus();
    },
    blur() {
      this.refInput && this.refInput.blur && this.refInput.blur();
    }
  }
});
var _hoisted_128 = ["disabled", "placeholder", "value"];
function _sfc_render54(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_IconClose = resolveComponent("IconClose");
  const _component_IconHover = resolveComponent("IconHover");
  const _component_FeedbackIcon = resolveComponent("FeedbackIcon");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.classNames)
  }, [
    _ctx.$slots.prefix ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(`${_ctx.prefixCls}-prefix`)
    }, [
      renderSlot(_ctx.$slots, "prefix")
    ], 2)) : createCommentVNode("v-if", true),
    createBaseVNode("div", {
      class: normalizeClass(`${_ctx.prefixCls}-input`)
    }, [
      createBaseVNode("input", mergeProps({
        ref: "refInput",
        disabled: _ctx.mergedDisabled,
        placeholder: _ctx.placeholder,
        class: `${_ctx.prefixCls}-start-time`,
        value: _ctx.displayValue
      }, _ctx.readonly ? { readonly: true } : {}, {
        onKeydown: _cache[0] || (_cache[0] = withKeys((...args) => _ctx.onPressEnter && _ctx.onPressEnter(...args), ["enter"])),
        onInput: _cache[1] || (_cache[1] = (...args) => _ctx.onChange && _ctx.onChange(...args)),
        onBlur: _cache[2] || (_cache[2] = (...args) => _ctx.onBlur && _ctx.onBlur(...args))
      }), null, 16, _hoisted_128)
    ], 2),
    createBaseVNode("div", {
      class: normalizeClass(`${_ctx.prefixCls}-suffix`)
    }, [
      _ctx.allowClear && !_ctx.mergedDisabled && _ctx.displayValue ? (openBlock(), createBlock(_component_IconHover, {
        key: 0,
        prefix: _ctx.prefixCls,
        class: normalizeClass(`${_ctx.prefixCls}-clear-icon`),
        onClick: _ctx.onClear
      }, {
        default: withCtx(() => [
          createVNode(_component_IconClose)
        ]),
        _: 1
      }, 8, ["prefix", "class", "onClick"])) : createCommentVNode("v-if", true),
      createBaseVNode("span", {
        class: normalizeClass(`${_ctx.prefixCls}-suffix-icon`)
      }, [
        renderSlot(_ctx.$slots, "suffix-icon")
      ], 2),
      _ctx.feedback ? (openBlock(), createBlock(_component_FeedbackIcon, {
        key: 1,
        type: _ctx.feedback
      }, null, 8, ["type"])) : createCommentVNode("v-if", true)
    ], 2)
  ], 2);
}
var DateInput = _export_sfc(_sfc_main54, [["render", _sfc_render54]]);

// node_modules/@arco-design/web-vue/es/time-picker/utils/index.js
function getColumnsFromFormat(format) {
  const units2 = ["H", "h", "m", "s", "a", "A"];
  const list = [];
  let use12Hours = false;
  units2.forEach((unit) => {
    if (format.indexOf(unit) !== -1) {
      list.push(unit);
      if (unit === "a" || unit === "A") {
        use12Hours = true;
      }
    }
  });
  return {
    list,
    use12Hours
  };
}
var scrollIds = /* @__PURE__ */ new Map();
function scrollTo(element, to, duration) {
  const scrollId = scrollIds.get(element);
  if (!isUndefined(scrollId)) {
    cancelAnimationFrame(scrollId);
  }
  if (duration <= 0) {
    element.scrollTop = to;
  }
  scrollIds.set(element, requestAnimationFrame(() => {
    const tween = new b_tween_es_default({
      from: { scrollTop: element.scrollTop },
      to: { scrollTop: to },
      duration,
      onUpdate: (keys) => {
        element.scrollTop = keys.scrollTop;
      }
    });
    tween.start();
  }));
}
function getFormattedValue(time, format) {
  const formatValue = (time2) => {
    if (isArray(time2)) {
      return time2.map((t2) => formatValue(t2));
    }
    if (isUndefined(time2))
      return void 0;
    return time2.format(format);
  };
  return formatValue(time);
}
function isValidRangeValue(value) {
  if (isUndefined(value))
    return true;
  if (!isArray(value))
    return false;
  return value.length === 0 || value.length === 2 && isDayjs(value[0]) && isDayjs(value[1]);
}
function isValidInputValue(time, format) {
  if (!time)
    return false;
  return typeof time === "string" && dayjs(time, format).format(format) === time;
}
function isDisabledTime(value, {
  disabledHours,
  disabledMinutes,
  disabledSeconds
}) {
  if (!value)
    return false;
  const hour = value.hour();
  const minute = value.minute();
  const second = value.second();
  const disabledHourList = (disabledHours == null ? void 0 : disabledHours()) || [];
  const disabledMinuteList = (disabledMinutes == null ? void 0 : disabledMinutes(hour)) || [];
  const disabledSecondList = (disabledSeconds == null ? void 0 : disabledSeconds(hour, minute)) || [];
  const isDisabledItem = (num, disabledList) => {
    return !isUndefined(num) && disabledList.includes(num);
  };
  return isDisabledItem(hour, disabledHourList) || isDisabledItem(minute, disabledMinuteList) || isDisabledItem(second, disabledSecondList);
}

// node_modules/@arco-design/web-vue/es/_components/render-function.js
var RenderFunction = defineComponent({
  name: "RenderFunction",
  props: {
    renderFunc: {
      type: Function,
      required: true
    }
  },
  render() {
    return this.renderFunc(this.$attrs);
  }
});

// node_modules/@arco-design/web-vue/es/date-picker/context.js
var PickerInjectionKey = Symbol("PickerInjectionKey");

// node_modules/@arco-design/web-vue/es/date-picker/hooks/use-inject-datepicker-transform.js
function useDatePickerTransform() {
  const { datePickerT } = inject(PickerInjectionKey) || {};
  return datePickerT || ((key, ...args) => key);
}

// node_modules/@arco-design/web-vue/es/date-picker/panels/shortcuts.js
var _sfc_main55 = defineComponent({
  name: "PanelShortcuts",
  components: {
    Button,
    RenderFunction
  },
  props: {
    prefixCls: {
      type: String,
      required: true
    },
    shortcuts: {
      type: Array,
      default: () => []
    },
    showNowBtn: {
      type: Boolean
    }
  },
  emits: ["item-click", "item-mouse-enter", "item-mouse-leave", "now-click"],
  setup(props, { emit }) {
    const datePickerT = useDatePickerTransform();
    return {
      datePickerT,
      onItemClick: (item) => {
        emit("item-click", item);
      },
      onItemMouseEnter: (item) => {
        emit("item-mouse-enter", item);
      },
      onItemMouseLeave: (item) => {
        emit("item-mouse-leave", item);
      },
      onNowClick: () => {
        emit("now-click");
      },
      isFunction
    };
  }
});
function _sfc_render55(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Button = resolveComponent("Button");
  const _component_RenderFunction = resolveComponent("RenderFunction");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(`${_ctx.prefixCls}-shortcuts`)
  }, [
    _ctx.showNowBtn ? (openBlock(), createBlock(_component_Button, {
      key: 0,
      size: "mini",
      onClick: _cache[0] || (_cache[0] = () => _ctx.onNowClick())
    }, {
      default: withCtx(() => [
        createTextVNode(toDisplayString(_ctx.datePickerT("datePicker.now")), 1)
      ]),
      _: 1
    })) : createCommentVNode("v-if", true),
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.shortcuts, (item, index3) => {
      return openBlock(), createBlock(_component_Button, {
        key: index3,
        size: "mini",
        onClick: () => _ctx.onItemClick(item),
        onMouseenter: () => _ctx.onItemMouseEnter(item),
        onMouseleave: () => _ctx.onItemMouseLeave(item)
      }, {
        default: withCtx(() => [
          _ctx.isFunction(item.label) ? (openBlock(), createBlock(_component_RenderFunction, {
            key: 0,
            "render-func": item.label
          }, null, 8, ["render-func"])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            createTextVNode(toDisplayString(item.label), 1)
          ], 2112))
        ]),
        _: 2
      }, 1032, ["onClick", "onMouseenter", "onMouseleave"]);
    }), 128))
  ], 2);
}
var PanelShortcuts = _export_sfc(_sfc_main55, [["render", _sfc_render55]]);

// node_modules/@arco-design/web-vue/es/date-picker/utils/index.js
function newArray(length) {
  return [...Array(length)];
}
function normalizeRangeValue(value) {
  if (isUndefined(value)) {
    return void 0;
  }
  return isArray(value) ? value : [value, void 0];
}
function isCompleteRangeValue(value) {
  return !!value && isDayjs(value[0]) && isDayjs(value[1]);
}
function isValidRangeValue2(value) {
  return isUndefined(value) || value.length === 0 || isCompleteRangeValue(value);
}
function mergeValueWithTime(defaultValue, dateValue, timeValue) {
  const dateVal = dateValue || defaultValue;
  const timeVal = timeValue || defaultValue;
  return timeVal.set("year", dateVal.year()).set("month", dateVal.month()).set("date", dateVal.date());
}

// node_modules/@arco-design/web-vue/es/icon/icon-double-left/icon-double-left.js
var _sfc_main56 = defineComponent({
  name: "IconDoubleLeft",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-double-left`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_129 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_223 = createBaseVNode("path", { d: "M36.857 9.9 22.715 24.042l14.142 14.142M25.544 9.9 11.402 24.042l14.142 14.142" }, null, -1);
var _hoisted_321 = [
  _hoisted_223
];
function _sfc_render56(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_321, 14, _hoisted_129);
}
var _IconDoubleLeft = _export_sfc(_sfc_main56, [["render", _sfc_render56]]);

// node_modules/@arco-design/web-vue/es/icon/icon-double-left/index.js
var IconDoubleLeft = Object.assign(_IconDoubleLeft, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconDoubleLeft.name, _IconDoubleLeft);
  }
});

// node_modules/@arco-design/web-vue/es/icon/icon-double-right/icon-double-right.js
var _sfc_main57 = defineComponent({
  name: "IconDoubleRight",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-double-right`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_130 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_224 = createBaseVNode("path", { d: "m11.143 38.1 14.142-14.142L11.143 9.816M22.456 38.1l14.142-14.142L22.456 9.816" }, null, -1);
var _hoisted_322 = [
  _hoisted_224
];
function _sfc_render57(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_322, 14, _hoisted_130);
}
var _IconDoubleRight = _export_sfc(_sfc_main57, [["render", _sfc_render57]]);

// node_modules/@arco-design/web-vue/es/icon/icon-double-right/index.js
var IconDoubleRight = Object.assign(_IconDoubleRight, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconDoubleRight.name, _IconDoubleRight);
  }
});

// node_modules/@arco-design/web-vue/es/date-picker/panels/header.js
var _sfc_main58 = defineComponent({
  name: "PanelHeader",
  components: {
    IconLeft,
    IconRight,
    IconDoubleLeft,
    IconDoubleRight,
    RenderFunction
  },
  props: {
    prefixCls: {
      type: String,
      required: true
    },
    title: {
      type: String,
      required: true
    },
    mode: {
      type: String,
      default: "date"
    },
    value: {
      type: Object
    },
    icons: {
      type: Object
    },
    onPrev: {
      type: Function
    },
    onSuperPrev: {
      type: Function
    },
    onNext: {
      type: Function
    },
    onSuperNext: {
      type: Function
    },
    onLabelClick: {
      type: Function
    }
  },
  emits: ["label-click"],
  setup(props) {
    return {
      showPrev: computed(() => isFunction(props.onPrev)),
      showSuperPrev: computed(() => isFunction(props.onSuperPrev)),
      showNext: computed(() => isFunction(props.onNext)),
      showSuperNext: computed(() => isFunction(props.onSuperNext)),
      year: computed(() => ["date", "quarter", "month", "week"].includes(props.mode) && props.value ? props.value.format("YYYY") : ""),
      month: computed(() => ["date", "week"].includes(props.mode) && props.value ? props.value.format("MM") : ""),
      getIconClassName: (show) => [
        `${props.prefixCls}-header-icon`,
        {
          [`${props.prefixCls}-header-icon-hidden`]: !show
        }
      ]
    };
  }
});
var _hoisted_131 = { key: 1 };
function _sfc_render58(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_RenderFunction = resolveComponent("RenderFunction");
  const _component_IconDoubleLeft = resolveComponent("IconDoubleLeft");
  const _component_IconLeft = resolveComponent("IconLeft");
  const _component_IconRight = resolveComponent("IconRight");
  const _component_IconDoubleRight = resolveComponent("IconDoubleRight");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(`${_ctx.prefixCls}-header`)
  }, [
    createBaseVNode("div", {
      class: normalizeClass(_ctx.getIconClassName(_ctx.showSuperPrev)),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onSuperPrev && _ctx.onSuperPrev(...args))
    }, [
      _ctx.showSuperPrev ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        _ctx.icons && _ctx.icons.prevDouble ? (openBlock(), createBlock(_component_RenderFunction, {
          key: 0,
          "render-func": _ctx.icons && _ctx.icons.prevDouble
        }, null, 8, ["render-func"])) : (openBlock(), createBlock(_component_IconDoubleLeft, { key: 1 }))
      ], 2112)) : createCommentVNode("v-if", true)
    ], 2),
    createBaseVNode("div", {
      class: normalizeClass(_ctx.getIconClassName(_ctx.showPrev)),
      onClick: _cache[1] || (_cache[1] = (...args) => _ctx.onPrev && _ctx.onPrev(...args))
    }, [
      _ctx.showPrev ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        _ctx.icons && _ctx.icons.prev ? (openBlock(), createBlock(_component_RenderFunction, {
          key: 0,
          "render-func": _ctx.icons && _ctx.icons.prev
        }, null, 8, ["render-func"])) : (openBlock(), createBlock(_component_IconLeft, { key: 1 }))
      ], 2112)) : createCommentVNode("v-if", true)
    ], 2),
    createBaseVNode("div", {
      class: normalizeClass(`${_ctx.prefixCls}-header-title`)
    }, [
      _ctx.onLabelClick && (_ctx.year || _ctx.month) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        _ctx.year ? (openBlock(), createElementBlock("span", {
          key: 0,
          class: normalizeClass(`${_ctx.prefixCls}-header-label`),
          onClick: _cache[2] || (_cache[2] = () => _ctx.onLabelClick && _ctx.onLabelClick("year"))
        }, toDisplayString(_ctx.year), 3)) : createCommentVNode("v-if", true),
        _ctx.year && _ctx.month ? (openBlock(), createElementBlock("span", _hoisted_131, "-")) : createCommentVNode("v-if", true),
        _ctx.month ? (openBlock(), createElementBlock("span", {
          key: 2,
          class: normalizeClass(`${_ctx.prefixCls}-header-label`),
          onClick: _cache[3] || (_cache[3] = () => _ctx.onLabelClick && _ctx.onLabelClick("month"))
        }, toDisplayString(_ctx.month), 3)) : createCommentVNode("v-if", true)
      ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        createTextVNode(toDisplayString(_ctx.title), 1)
      ], 2112))
    ], 2),
    createBaseVNode("div", {
      class: normalizeClass(_ctx.getIconClassName(_ctx.showNext)),
      onClick: _cache[4] || (_cache[4] = (...args) => _ctx.onNext && _ctx.onNext(...args))
    }, [
      _ctx.showNext ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        _ctx.icons && _ctx.icons.next ? (openBlock(), createBlock(_component_RenderFunction, {
          key: 0,
          "render-func": _ctx.icons && _ctx.icons.next
        }, null, 8, ["render-func"])) : (openBlock(), createBlock(_component_IconRight, { key: 1 }))
      ], 2112)) : createCommentVNode("v-if", true)
    ], 2),
    createBaseVNode("div", {
      class: normalizeClass(_ctx.getIconClassName(_ctx.showSuperNext)),
      onClick: _cache[5] || (_cache[5] = (...args) => _ctx.onSuperNext && _ctx.onSuperNext(...args))
    }, [
      _ctx.showSuperNext ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        _ctx.icons && _ctx.icons.nextDouble ? (openBlock(), createBlock(_component_RenderFunction, {
          key: 0,
          "render-func": _ctx.icons && _ctx.icons.nextDouble
        }, null, 8, ["render-func"])) : (openBlock(), createBlock(_component_IconDoubleRight, { key: 1 }))
      ], 2112)) : createCommentVNode("v-if", true)
    ], 2)
  ], 2);
}
var PanelHeader = _export_sfc(_sfc_main58, [["render", _sfc_render58]]);

// node_modules/@arco-design/web-vue/es/date-picker/hooks/use-cell-class-name.js
function useCellClassName(props) {
  const { rangeValues } = toRefs(props);
  const sortedRangeValues = computed(() => (rangeValues == null ? void 0 : rangeValues.value) && rangeValues.value.every(isDayjs) ? getSortedDayjsArray(rangeValues.value) : rangeValues == null ? void 0 : rangeValues.value);
  const rangeStart = computed(() => {
    var _a;
    return (_a = sortedRangeValues.value) == null ? void 0 : _a[0];
  });
  const rangeEnd = computed(() => {
    var _a;
    return (_a = sortedRangeValues.value) == null ? void 0 : _a[1];
  });
  return {
    getCellClassName: (cellData, disabled) => {
      const { value, isSameTime, mode, prefixCls } = props;
      const isInView = !cellData.isPrev && !cellData.isNext;
      const isSelected = value && isSameTime(cellData.value, value);
      let isToday = isSameTime(cellData.value, getNow());
      if (mode === "week") {
        isToday = getNow().isSame(cellData.value, "date");
      }
      const isRangeStart = isInView && rangeStart.value && isSameTime(cellData.value, rangeStart.value);
      const isRangeEnd = isInView && rangeEnd.value && isSameTime(cellData.value, rangeEnd.value);
      const isInRange = isInView && rangeStart.value && rangeEnd.value && (isRangeStart || isRangeEnd || cellData.value.isBetween(rangeStart.value, rangeEnd.value, null, "[]"));
      return [
        `${prefixCls}-cell`,
        {
          [`${prefixCls}-cell-in-view`]: isInView,
          [`${prefixCls}-cell-today`]: isToday,
          [`${prefixCls}-cell-selected`]: isSelected,
          [`${prefixCls}-cell-range-start`]: isRangeStart,
          [`${prefixCls}-cell-range-end`]: isRangeEnd,
          [`${prefixCls}-cell-in-range`]: isInRange,
          [`${prefixCls}-cell-disabled`]: disabled
        },
        cellData.classNames
      ];
    }
  };
}

// node_modules/@arco-design/web-vue/es/date-picker/panels/body.js
var _sfc_main59 = defineComponent({
  name: "PanelBody",
  components: {
    RenderFunction
  },
  props: {
    prefixCls: {
      type: String,
      required: true
    },
    rows: {
      type: Array,
      default: () => []
    },
    value: {
      type: Object
    },
    disabledDate: {
      type: Function
    },
    isSameTime: {
      type: Function,
      required: true
    },
    mode: {
      type: String
    },
    rangeValues: {
      type: Array
    },
    dateRender: {
      type: Function
    }
  },
  emits: ["cell-click", "cell-mouse-enter"],
  setup(props, { emit }) {
    const { prefixCls, value, disabledDate, isSameTime, mode, rangeValues } = toRefs(props);
    const { getCellClassName } = useCellClassName(reactive({
      prefixCls,
      value,
      isSameTime,
      mode,
      rangeValues
    }));
    const isCellDisabled = (cellData) => !!(isFunction(disabledDate == null ? void 0 : disabledDate.value) && (disabledDate == null ? void 0 : disabledDate.value(getDateValue(cellData.value))));
    return {
      isWeek: computed(() => (mode == null ? void 0 : mode.value) === "week"),
      getCellClassName: (cellData) => {
        const disabled = isCellDisabled(cellData);
        return getCellClassName(cellData, disabled);
      },
      onCellClick: (cellData) => {
        const disabled = isCellDisabled(cellData);
        if (disabled)
          return;
        emit("cell-click", cellData);
      },
      onCellMouseEnter: (cellData) => {
        const disabled = isCellDisabled(cellData);
        if (disabled)
          return;
        emit("cell-mouse-enter", cellData);
      },
      onCellMouseLeave: (cellData) => {
        const disabled = isCellDisabled(cellData);
        if (disabled)
          return;
        emit("cell-mouse-enter", cellData);
      },
      getDateValue
    };
  }
});
var _hoisted_132 = ["onMouseenter", "onMouseleave", "onClick"];
function _sfc_render59(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_RenderFunction = resolveComponent("RenderFunction");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(`${_ctx.prefixCls}-body`)
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.rows, (row, rowIndex) => {
      return openBlock(), createElementBlock("div", {
        key: rowIndex,
        class: normalizeClass([
          `${_ctx.prefixCls}-row`,
          {
            [`${_ctx.prefixCls}-row-week`]: _ctx.isWeek
          }
        ])
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(row, (cell, colIndex) => {
          return openBlock(), createElementBlock(Fragment, null, [
            createCommentVNode(" 一年中的第几周，只在 week 模式下显示 "),
            _ctx.isWeek && colIndex === 0 ? (openBlock(), createElementBlock("div", {
              key: colIndex,
              class: normalizeClass([`${_ctx.prefixCls}-cell`, `${_ctx.prefixCls}-cell-week`])
            }, [
              createBaseVNode("div", {
                class: normalizeClass(`${_ctx.prefixCls}-date`)
              }, [
                createBaseVNode("div", {
                  class: normalizeClass(`${_ctx.prefixCls}-date-value`)
                }, toDisplayString(cell.label), 3)
              ], 2)
            ], 2)) : (openBlock(), createElementBlock("div", {
              key: colIndex,
              class: normalizeClass(_ctx.getCellClassName(cell)),
              onMouseenter: () => {
                _ctx.onCellMouseEnter(cell);
              },
              onMouseleave: () => {
                _ctx.onCellMouseLeave(cell);
              },
              onClick: () => {
                _ctx.onCellClick(cell);
              }
            }, [
              _ctx.dateRender ? (openBlock(), createBlock(_component_RenderFunction, {
                key: 0,
                "render-func": _ctx.dateRender,
                date: _ctx.getDateValue(cell.value)
              }, null, 8, ["render-func", "date"])) : (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass(`${_ctx.prefixCls}-date`)
              }, [
                createBaseVNode("div", {
                  class: normalizeClass(`${_ctx.prefixCls}-date-value`)
                }, toDisplayString(cell.label), 3)
              ], 2))
            ], 42, _hoisted_132))
          ], 64);
        }), 256))
      ], 2);
    }), 128))
  ], 2);
}
var PanelBody = _export_sfc(_sfc_main59, [["render", _sfc_render59]]);

// node_modules/@arco-design/web-vue/es/date-picker/panels/week-list.js
var _sfc_main60 = defineComponent({
  name: "PanelWeekList",
  props: {
    prefixCls: {
      type: String,
      required: true
    },
    weekList: {
      type: Array,
      required: true
    }
  },
  setup() {
    const datePickerT = useDatePickerTransform();
    const labelList = computed(() => {
      return [
        "sunday",
        "monday",
        "tuesday",
        "wednesday",
        "thursday",
        "friday",
        "saturday"
      ].map((i2) => datePickerT(`datePicker.week.short.${i2}`));
    });
    return {
      labelList
    };
  }
});
function _sfc_render60(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(`${_ctx.prefixCls}-week-list`)
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.weekList, (key) => {
      return openBlock(), createElementBlock("div", {
        key,
        class: normalizeClass(`${_ctx.prefixCls}-week-list-item`)
      }, toDisplayString(_ctx.labelList[key] || ""), 3);
    }), 128))
  ], 2);
}
var PanelWeekList = _export_sfc(_sfc_main60, [["render", _sfc_render60]]);

// node_modules/@arco-design/web-vue/es/time-picker/time-column.js
var _sfc_main61 = defineComponent({
  name: "TimePickerColumn",
  props: {
    prefixCls: {
      type: String,
      required: true
    },
    list: {
      type: Array,
      required: true
    },
    value: {
      type: [Number, String]
    },
    visible: {
      type: Boolean
    }
  },
  emits: ["select"],
  setup(props, { emit }) {
    const { visible, value } = toRefs(props);
    const refMap = ref(/* @__PURE__ */ new Map());
    const refWrapper = ref();
    function scrollToTop(easing2 = false) {
      if (!refWrapper.value || isUndefined(value == null ? void 0 : value.value) || !(visible == null ? void 0 : visible.value)) {
        return;
      }
      const refSelected = refMap.value.get(value.value);
      if (refSelected) {
        scrollTo(refWrapper.value, refSelected.offsetTop, easing2 ? 100 : 0);
      }
    }
    watch([value, visible], (_, [, preVisible]) => {
      if (visible.value !== preVisible) {
        nextTick(() => {
          scrollToTop();
        });
      } else {
        scrollToTop(true);
      }
    });
    onMounted(() => {
      scrollToTop();
    });
    return {
      refWrapper,
      refMap,
      onItemRef(el, item) {
        refMap.value.set(item.value, el);
      },
      onItemClick(item) {
        if (!item.disabled) {
          emit("select", item.value);
        }
      }
    };
  }
});
var _hoisted_133 = ["onClick"];
function _sfc_render61(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    ref: "refWrapper",
    class: normalizeClass(`${_ctx.prefixCls}-column`)
  }, [
    createBaseVNode("ul", null, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.list, (item) => {
        return openBlock(), createElementBlock("li", {
          key: item.value,
          ref: (el) => {
            _ctx.onItemRef(el, item);
          },
          class: normalizeClass([
            `${_ctx.prefixCls}-cell`,
            {
              [`${_ctx.prefixCls}-cell-disabled`]: item.disabled,
              [`${_ctx.prefixCls}-cell-selected`]: item.selected
            }
          ]),
          onClick: () => {
            _ctx.onItemClick(item);
          }
        }, [
          createBaseVNode("div", {
            class: normalizeClass(`${_ctx.prefixCls}-cell-inner`)
          }, toDisplayString(item.label), 3)
        ], 10, _hoisted_133);
      }), 128))
    ])
  ], 2);
}
var TimeColumn = _export_sfc(_sfc_main61, [["render", _sfc_render61]]);

// node_modules/@arco-design/web-vue/es/_utils/pad.js
function padStart(string, length, char = " ") {
  const s = String(string);
  if (!length) {
    return s;
  }
  const newString = s.length < length ? `${char}${s}` : s;
  return newString.length < length ? padStart(newString, length, char) : newString;
}

// node_modules/@arco-design/web-vue/es/time-picker/hooks/use-time-list.js
function useTimeList(props) {
  const {
    format,
    step,
    use12Hours,
    hideDisabledOptions,
    disabledHours,
    disabledMinutes,
    disabledSeconds,
    selectedHour,
    selectedMinute,
    selectedSecond,
    selectedAmpm,
    disabled
  } = toRefs(props);
  const hours = computed(() => {
    var _a;
    const { hour: hourStep = 1 } = (step == null ? void 0 : step.value) || {};
    const disabledList = ((_a = disabledHours == null ? void 0 : disabledHours.value) == null ? void 0 : _a.call(disabledHours)) || [];
    let list = [];
    for (let i2 = 0; i2 < (use12Hours.value ? 12 : 24); i2 += hourStep) {
      list.push(i2);
    }
    if (use12Hours.value) {
      list[0] = 12;
    }
    if (hideDisabledOptions.value && disabledList.length) {
      list = list.filter((h2) => disabledList.indexOf(h2) < 0);
    }
    return list.map((h2) => ({
      label: padStart(h2, 2, "0"),
      value: h2,
      selected: selectedHour.value === h2,
      disabled: (disabled == null ? void 0 : disabled.value) || disabledList.includes(h2)
    }));
  });
  const minutes = computed(() => {
    var _a;
    const { minute: minuteStep = 1 } = (step == null ? void 0 : step.value) || {};
    const disabledList = ((_a = disabledMinutes == null ? void 0 : disabledMinutes.value) == null ? void 0 : _a.call(disabledMinutes, selectedHour.value)) || [];
    let list = [];
    for (let i2 = 0; i2 < 60; i2 += minuteStep) {
      list.push(i2);
    }
    if (hideDisabledOptions.value && disabledList.length) {
      list = list.filter((m) => disabledList.indexOf(m) < 0);
    }
    return list.map((m) => ({
      label: padStart(m, 2, "0"),
      value: m,
      selected: selectedMinute.value === m,
      disabled: (disabled == null ? void 0 : disabled.value) || disabledList.includes(m)
    }));
  });
  const seconds = computed(() => {
    var _a;
    const { second: secondStep = 1 } = (step == null ? void 0 : step.value) || {};
    const disabledList = ((_a = disabledSeconds == null ? void 0 : disabledSeconds.value) == null ? void 0 : _a.call(disabledSeconds, selectedHour.value, selectedMinute.value)) || [];
    let list = [];
    for (let i2 = 0; i2 < 60; i2 += secondStep) {
      list.push(i2);
    }
    if (hideDisabledOptions.value && disabledList.length) {
      list = list.filter((s) => disabledList.indexOf(s) < 0);
    }
    return list.map((s) => ({
      label: padStart(s, 2, "0"),
      value: s,
      selected: selectedSecond.value === s,
      disabled: (disabled == null ? void 0 : disabled.value) || disabledList.includes(s)
    }));
  });
  const AMPM = ["am", "pm"];
  const ampmList = computed(() => {
    const isUpperCase = getColumnsFromFormat(format.value).list.includes("A");
    return AMPM.map((a) => ({
      label: isUpperCase ? a.toUpperCase() : a,
      value: a,
      selected: selectedAmpm.value === a,
      disabled: disabled == null ? void 0 : disabled.value
    }));
  });
  return {
    hours,
    minutes,
    seconds,
    ampmList
  };
}

// node_modules/@arco-design/web-vue/es/time-picker/hooks/use-time-format.js
function useTimeFormat(props) {
  const {
    format: propFormat,
    use12Hours: propUse12Hours,
    defaultFormat
  } = toRefs(props);
  const format = computed(() => {
    let res = (propFormat == null ? void 0 : propFormat.value) || (defaultFormat == null ? void 0 : defaultFormat.value);
    if (!res || !getColumnsFromFormat(res).list.length) {
      res = (propUse12Hours == null ? void 0 : propUse12Hours.value) ? "hh:mm:ss a" : "HH:mm:ss";
    }
    return res;
  });
  const configFromFormat = computed(() => getColumnsFromFormat(format.value));
  const list = computed(() => configFromFormat.value.list);
  const formatUse12Hours = computed(() => configFromFormat.value.use12Hours);
  const computedUse12Hours = computed(() => !!((propUse12Hours == null ? void 0 : propUse12Hours.value) || formatUse12Hours.value));
  return {
    columns: list,
    use12Hours: computedUse12Hours,
    format
  };
}

// node_modules/@arco-design/web-vue/es/time-picker/hooks/use-is-disabled-time.js
function useIsDisabledTime(props) {
  const isDisabled = (value) => {
    return isDisabledTime(value, {
      disabledHours: props.disabledHours,
      disabledMinutes: props.disabledMinutes,
      disabledSeconds: props.disabledSeconds
    });
  };
  return (value) => {
    return isArray(value) ? value.some((i2) => isDisabled(i2)) : isDisabled(value);
  };
}

// node_modules/@arco-design/web-vue/es/time-picker/panel.js
var _sfc_main62 = defineComponent({
  name: "TimePickerPanel",
  components: {
    TimeColumn,
    Button
  },
  props: {
    value: {
      type: Object
    },
    visible: {
      type: Boolean
    },
    format: {
      type: String,
      default: "HH:mm:ss"
    },
    use12Hours: {
      type: Boolean
    },
    step: {
      type: Object
    },
    disabledHours: {
      type: Function
    },
    disabledMinutes: {
      type: Function
    },
    disabledSeconds: {
      type: Function
    },
    hideDisabledOptions: {
      type: Boolean
    },
    hideFooter: {
      type: Boolean
    },
    isRange: {
      type: Boolean
    },
    disabled: {
      type: Boolean
    }
  },
  emits: {
    select: (value) => isDayjs(value),
    confirm: (value) => isDayjs(value)
  },
  setup(props, { emit }) {
    const {
      value,
      visible,
      format,
      step,
      use12Hours,
      hideDisabledOptions,
      disabledHours,
      disabledMinutes,
      disabledSeconds,
      disabled
    } = toRefs(props);
    const prefixCls = getPrefixCls("timepicker");
    const { t: t2 } = useI18n();
    const {
      columns,
      use12Hours: computedUse12Hours,
      format: computedFormat
    } = useTimeFormat(reactive({
      format,
      use12Hours
    }));
    const selectedValue = ref(value == null ? void 0 : value.value);
    const setSelectedValue = (value2) => {
      selectedValue.value = value2;
    };
    watch([visible, value], () => {
      if (!visible.value)
        return;
      setSelectedValue(value == null ? void 0 : value.value);
    });
    const selectedHour = computed(() => {
      var _a;
      const _hour = (_a = selectedValue.value) == null ? void 0 : _a.hour();
      if (isUndefined(_hour) || !computedUse12Hours.value)
        return _hour;
      if (_hour > 12)
        return _hour - 12;
      if (_hour === 0)
        return 12;
      return _hour;
    });
    const selectedMinute = computed(() => {
      var _a;
      return (_a = selectedValue.value) == null ? void 0 : _a.minute();
    });
    const selectedSecond = computed(() => {
      var _a;
      return (_a = selectedValue.value) == null ? void 0 : _a.second();
    });
    const selectedAmpm = computed(() => {
      var _a;
      const _hour = (_a = selectedValue.value) == null ? void 0 : _a.hour();
      return !isUndefined(_hour) && _hour >= 12 ? "pm" : "am";
    });
    const { hours, minutes, seconds, ampmList } = useTimeList(reactive({
      format: computedFormat,
      step,
      use12Hours: computedUse12Hours,
      hideDisabledOptions,
      disabledHours,
      disabledMinutes,
      disabledSeconds,
      selectedHour,
      selectedMinute,
      selectedSecond,
      selectedAmpm,
      disabled
    }));
    const isDisabledTime2 = useIsDisabledTime(reactive({
      disabledHours,
      disabledMinutes,
      disabledSeconds
    }));
    const confirmBtnDisabled = computed(() => isDisabledTime2(selectedValue.value));
    function emitConfirm(value2) {
      if (isUndefined(value2))
        return;
      emit("confirm", value2);
    }
    function emitSelect(value2) {
      setSelectedValue(value2);
      emit("select", value2);
    }
    function onSelect(value2, type = "hour") {
      let newValue;
      const hour = selectedHour.value || "00";
      const minute = selectedMinute.value || "00";
      const second = selectedSecond.value || "00";
      const ampm = selectedAmpm.value || "am";
      switch (type) {
        case "hour":
          newValue = `${value2}:${minute}:${second}`;
          break;
        case "minute":
          newValue = `${hour}:${value2}:${second}`;
          break;
        case "second":
          newValue = `${hour}:${minute}:${value2}`;
          break;
        case "ampm":
          newValue = `${hour}:${minute}:${second} ${value2}`;
          break;
        default:
          newValue = "00:00:00";
      }
      let valueFormat = "HH:mm:ss";
      if (computedUse12Hours.value) {
        valueFormat = "HH:mm:ss a";
        if (type !== "ampm") {
          newValue = `${newValue} ${ampm}`;
        }
      }
      newValue = dayjs(newValue, valueFormat);
      emitSelect(newValue);
    }
    return {
      prefixCls,
      t: t2,
      hours,
      minutes,
      seconds,
      ampmList,
      selectedValue,
      selectedHour,
      selectedMinute,
      selectedSecond,
      selectedAmpm,
      computedUse12Hours,
      confirmBtnDisabled,
      columns,
      onSelect,
      onSelectNow() {
        const newValue = dayjs(/* @__PURE__ */ new Date());
        emitSelect(newValue);
      },
      onConfirm() {
        emitConfirm(selectedValue.value);
      }
    };
  }
});
function _sfc_render62(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_TimeColumn = resolveComponent("TimeColumn");
  const _component_Button = resolveComponent("Button");
  return openBlock(), createElementBlock(Fragment, null, [
    createBaseVNode("div", {
      class: normalizeClass(_ctx.prefixCls)
    }, [
      _ctx.columns.includes("H") || _ctx.columns.includes("h") ? (openBlock(), createBlock(_component_TimeColumn, {
        key: 0,
        value: _ctx.selectedHour,
        list: _ctx.hours,
        "prefix-cls": _ctx.prefixCls,
        visible: _ctx.visible,
        onSelect: _cache[0] || (_cache[0] = (value) => {
          _ctx.onSelect(value, "hour");
        })
      }, null, 8, ["value", "list", "prefix-cls", "visible"])) : createCommentVNode("v-if", true),
      _ctx.columns.includes("m") ? (openBlock(), createBlock(_component_TimeColumn, {
        key: 1,
        value: _ctx.selectedMinute,
        list: _ctx.minutes,
        "prefix-cls": _ctx.prefixCls,
        visible: _ctx.visible,
        onSelect: _cache[1] || (_cache[1] = (value) => {
          _ctx.onSelect(value, "minute");
        })
      }, null, 8, ["value", "list", "prefix-cls", "visible"])) : createCommentVNode("v-if", true),
      _ctx.columns.includes("s") ? (openBlock(), createBlock(_component_TimeColumn, {
        key: 2,
        value: _ctx.selectedSecond,
        list: _ctx.seconds,
        "prefix-cls": _ctx.prefixCls,
        visible: _ctx.visible,
        onSelect: _cache[2] || (_cache[2] = (value) => {
          _ctx.onSelect(value, "second");
        })
      }, null, 8, ["value", "list", "prefix-cls", "visible"])) : createCommentVNode("v-if", true),
      _ctx.computedUse12Hours ? (openBlock(), createBlock(_component_TimeColumn, {
        key: 3,
        value: _ctx.selectedAmpm,
        list: _ctx.ampmList,
        "prefix-cls": _ctx.prefixCls,
        visible: _ctx.visible,
        onSelect: _cache[3] || (_cache[3] = (value) => {
          _ctx.onSelect(value, "ampm");
        })
      }, null, 8, ["value", "list", "prefix-cls", "visible"])) : createCommentVNode("v-if", true)
    ], 2),
    _ctx.$slots["extra-footer"] ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(`${_ctx.prefixCls}-footer-extra-wrapper`)
    }, [
      renderSlot(_ctx.$slots, "extra-footer")
    ], 2)) : createCommentVNode("v-if", true),
    !_ctx.hideFooter ? (openBlock(), createElementBlock("div", {
      key: 1,
      class: normalizeClass(`${_ctx.prefixCls}-footer-btn-wrapper`)
    }, [
      !_ctx.isRange ? (openBlock(), createBlock(_component_Button, {
        key: 0,
        size: "mini",
        onClick: _ctx.onSelectNow
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(_ctx.t("datePicker.now")), 1)
        ]),
        _: 1
      }, 8, ["onClick"])) : createCommentVNode("v-if", true),
      createVNode(_component_Button, {
        type: "primary",
        size: "mini",
        disabled: _ctx.confirmBtnDisabled || !_ctx.selectedValue,
        onClick: _ctx.onConfirm
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(_ctx.t("datePicker.ok")), 1)
        ]),
        _: 1
      }, 8, ["disabled", "onClick"])
    ], 2)) : createCommentVNode("v-if", true)
  ], 64);
}
var Panel = _export_sfc(_sfc_main62, [["render", _sfc_render62]]);

// node_modules/@arco-design/web-vue/es/icon/icon-calendar/icon-calendar.js
var _sfc_main63 = defineComponent({
  name: "IconCalendar",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-calendar`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_134 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_225 = createBaseVNode("path", { d: "M7 22h34M14 5v8m20-8v8M8 41h32a1 1 0 0 0 1-1V10a1 1 0 0 0-1-1H8a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1Z" }, null, -1);
var _hoisted_323 = [
  _hoisted_225
];
function _sfc_render63(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_323, 14, _hoisted_134);
}
var _IconCalendar = _export_sfc(_sfc_main63, [["render", _sfc_render63]]);

// node_modules/@arco-design/web-vue/es/icon/icon-calendar/index.js
var IconCalendar = Object.assign(_IconCalendar, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconCalendar.name, _IconCalendar);
  }
});

// node_modules/@arco-design/web-vue/es/icon/icon-clock-circle/icon-clock-circle.js
var _sfc_main64 = defineComponent({
  name: "IconClockCircle",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-clock-circle`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_135 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_226 = createBaseVNode("path", { d: "M24 14v10h9.5m8.5 0c0 9.941-8.059 18-18 18S6 33.941 6 24 14.059 6 24 6s18 8.059 18 18Z" }, null, -1);
var _hoisted_324 = [
  _hoisted_226
];
function _sfc_render64(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_324, 14, _hoisted_135);
}
var _IconClockCircle = _export_sfc(_sfc_main64, [["render", _sfc_render64]]);

// node_modules/@arco-design/web-vue/es/icon/icon-clock-circle/index.js
var IconClockCircle = Object.assign(_IconClockCircle, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconClockCircle.name, _IconClockCircle);
  }
});

// node_modules/@arco-design/web-vue/es/_hooks/use-merge-state.js
function useMergeState(defaultValue, props) {
  const { value } = toRefs(props);
  const [localValue, setLocalValue] = useState(!isUndefined(value.value) ? value.value : defaultValue);
  watch(value, (newVal) => {
    isUndefined(newVal) && setLocalValue(void 0);
  });
  const mergeValue = computed(() => !isUndefined(value.value) ? value.value : localValue.value);
  return [mergeValue, setLocalValue, localValue];
}

// node_modules/@arco-design/web-vue/es/date-picker/panels/date/index.js
var __defProp19 = Object.defineProperty;
var __defProps6 = Object.defineProperties;
var __getOwnPropDescs6 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols19 = Object.getOwnPropertySymbols;
var __hasOwnProp19 = Object.prototype.hasOwnProperty;
var __propIsEnum19 = Object.prototype.propertyIsEnumerable;
var __defNormalProp19 = (obj, key, value) => key in obj ? __defProp19(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues19 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp19.call(b, prop))
      __defNormalProp19(a, prop, b[prop]);
  if (__getOwnPropSymbols19)
    for (var prop of __getOwnPropSymbols19(b)) {
      if (__propIsEnum19.call(b, prop))
        __defNormalProp19(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps6 = (a, b) => __defProps6(a, __getOwnPropDescs6(b));
var ROW_COUNT = 6;
var COL_COUNT = 7;
var CELL_COUNT = ROW_COUNT * COL_COUNT;
function getCellData(time) {
  return {
    label: time.date(),
    value: time
  };
}
var _sfc_main65 = defineComponent({
  name: "DatePanel",
  components: {
    PanelHeader,
    PanelBody,
    PanelWeekList,
    TimePanel: Panel,
    IconCalendar,
    IconClockCircle
  },
  props: {
    isRange: {
      type: Boolean
    },
    value: {
      type: Object
    },
    rangeValues: {
      type: Array
    },
    headerValue: {
      type: Object,
      required: true
    },
    footerValue: {
      type: Object
    },
    timePickerValue: {
      type: Object
    },
    headerOperations: {
      type: Object,
      default: () => ({})
    },
    headerIcons: {
      type: Object,
      default: () => ({})
    },
    dayStartOfWeek: {
      type: Number,
      default: 0
    },
    disabledDate: {
      type: Function
    },
    disabledTime: {
      type: Function
    },
    isSameTime: {
      type: Function
    },
    mode: {
      type: String,
      default: "date"
    },
    showTime: {
      type: Boolean
    },
    timePickerProps: {
      type: Object
    },
    currentView: {
      type: String
    },
    dateRender: {
      type: Function
    },
    disabled: {
      type: Boolean
    },
    onHeaderLabelClick: {
      type: Function
    }
  },
  emits: [
    "select",
    "time-picker-select",
    "cell-mouse-enter",
    "current-view-change",
    "update:currentView"
  ],
  setup(props, { emit }) {
    const {
      isRange,
      headerValue,
      footerValue,
      dayStartOfWeek,
      isSameTime,
      mode,
      showTime,
      currentView,
      disabledTime
    } = toRefs(props);
    const datePickerT = useDatePickerTransform();
    const isWeek = computed(() => (mode == null ? void 0 : mode.value) === "week");
    const prefixCls = computed(() => getPrefixCls(isWeek.value ? "panel-week" : "panel-date"));
    const pickerPrefixCls = getPrefixCls("picker");
    const [localCurrentView, setLocalCurrentView] = useMergeState("date", reactive({ value: currentView }));
    const showViewTabs = computed(() => showTime.value && isRange.value);
    const showDateView = computed(() => !showTime.value || !showViewTabs.value || localCurrentView.value === "date");
    const showTimeView = computed(() => showTime.value && (!showViewTabs.value || localCurrentView.value === "time"));
    const classNames = computed(() => [
      prefixCls.value,
      {
        [`${prefixCls.value}-with-view-tabs`]: showViewTabs.value
      }
    ]);
    const headerTitle = computed(() => headerValue.value.format("YYYY-MM"));
    const disabledTimeProps = computed(() => {
      var _a;
      return showTime.value && ((_a = disabledTime == null ? void 0 : disabledTime.value) == null ? void 0 : _a.call(disabledTime, getDateValue((footerValue == null ? void 0 : footerValue.value) || getNow()))) || {};
    });
    const weekList = computed(() => {
      const list = [0, 1, 2, 3, 4, 5, 6];
      const index3 = Math.max(dayStartOfWeek.value % 7, 0);
      return [...list.slice(index3), ...list.slice(0, index3)];
    });
    const rows = computed(() => {
      const startDate = methods.startOf(headerValue.value, "month");
      const startDay = startDate.day();
      const days = startDate.daysInMonth();
      const startIndex = weekList.value.indexOf(startDay);
      const flatData = newArray(CELL_COUNT);
      for (let i2 = 0; i2 < flatData.length; i2++) {
        flatData[i2] = __spreadProps6(__spreadValues19({}, getCellData(methods.add(startDate, i2 - startIndex, "day"))), {
          isPrev: i2 < startIndex,
          isNext: i2 > startIndex + days - 1
        });
      }
      const rows2 = newArray(ROW_COUNT).map((_, index3) => {
        const row = flatData.slice(index3 * COL_COUNT, (index3 + 1) * COL_COUNT);
        if (isWeek.value) {
          const valueOfWeek = row[0].value;
          row.unshift({
            label: valueOfWeek.week(),
            value: valueOfWeek
          });
        }
        return row;
      });
      return rows2;
    });
    const mergedIsSameTime = computed(() => (isSameTime == null ? void 0 : isSameTime.value) || ((current, target3) => {
      return current.isSame(target3, "day");
    }));
    function onCellClick(cellData) {
      emit("select", cellData.value);
    }
    function onTimePanelSelect(time) {
      emit("time-picker-select", time);
    }
    function onCellMouseEnter(cellData) {
      emit("cell-mouse-enter", cellData.value);
    }
    return {
      prefixCls,
      classNames,
      pickerPrefixCls,
      headerTitle,
      rows,
      weekList: computed(() => isWeek.value ? [-1, ...weekList.value] : weekList.value),
      mergedIsSameTime,
      disabledTimeProps,
      onCellClick,
      onCellMouseEnter,
      onTimePanelSelect,
      showViewTabs,
      showDateView,
      showTimeView,
      changeViewTo: (newView) => {
        emit("current-view-change", newView);
        emit("update:currentView", newView);
        setLocalCurrentView(newView);
      },
      datePickerT
    };
  }
});
function _sfc_render65(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_PanelHeader = resolveComponent("PanelHeader");
  const _component_PanelWeekList = resolveComponent("PanelWeekList");
  const _component_PanelBody = resolveComponent("PanelBody");
  const _component_TimePanel = resolveComponent("TimePanel");
  const _component_IconCalendar = resolveComponent("IconCalendar");
  const _component_IconClockCircle = resolveComponent("IconClockCircle");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.classNames)
  }, [
    _ctx.showDateView ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(`${_ctx.prefixCls}-inner`)
    }, [
      createVNode(_component_PanelHeader, mergeProps(__spreadProps6(__spreadValues19({}, _ctx.headerOperations), {
        icons: _ctx.headerIcons
      }), {
        "prefix-cls": _ctx.pickerPrefixCls,
        title: _ctx.headerTitle,
        mode: _ctx.mode,
        value: _ctx.headerValue,
        "on-label-click": _ctx.onHeaderLabelClick
      }), null, 16, ["prefix-cls", "title", "mode", "value", "on-label-click"]),
      createVNode(_component_PanelWeekList, {
        "prefix-cls": _ctx.pickerPrefixCls,
        "week-list": _ctx.weekList
      }, null, 8, ["prefix-cls", "week-list"]),
      createVNode(_component_PanelBody, {
        mode: _ctx.mode,
        "prefix-cls": _ctx.pickerPrefixCls,
        rows: _ctx.rows,
        value: _ctx.isRange ? void 0 : _ctx.value,
        "range-values": _ctx.rangeValues,
        "disabled-date": _ctx.disabledDate,
        "is-same-time": _ctx.mergedIsSameTime,
        "date-render": _ctx.dateRender,
        onCellClick: _ctx.onCellClick,
        onCellMouseEnter: _ctx.onCellMouseEnter
      }, null, 8, ["mode", "prefix-cls", "rows", "value", "range-values", "disabled-date", "is-same-time", "date-render", "onCellClick", "onCellMouseEnter"])
    ], 2)) : createCommentVNode("v-if", true),
    _ctx.showTimeView ? (openBlock(), createElementBlock("div", {
      key: 1,
      class: normalizeClass(`${_ctx.prefixCls}-timepicker`)
    }, [
      createBaseVNode("header", {
        class: normalizeClass(`${_ctx.prefixCls}-timepicker-title`)
      }, toDisplayString(_ctx.datePickerT("datePicker.selectTime")), 3),
      createVNode(_component_TimePanel, mergeProps(__spreadValues19(__spreadValues19({}, _ctx.timePickerProps), _ctx.disabledTimeProps), {
        "hide-footer": "",
        value: _ctx.value || _ctx.isRange ? _ctx.timePickerValue : void 0,
        disabled: _ctx.disabled,
        onSelect: _ctx.onTimePanelSelect
      }), null, 16, ["value", "disabled", "onSelect"])
    ], 2)) : createCommentVNode("v-if", true),
    _ctx.showViewTabs ? (openBlock(), createElementBlock("div", {
      key: 2,
      class: normalizeClass(`${_ctx.prefixCls}-footer`)
    }, [
      createBaseVNode("div", {
        class: normalizeClass(`${_ctx.prefixCls}-view-tabs`)
      }, [
        createBaseVNode("div", {
          class: normalizeClass([
            `${_ctx.prefixCls}-view-tab-pane`,
            { [`${_ctx.prefixCls}-view-tab-pane-active`]: _ctx.showDateView }
          ]),
          onClick: _cache[0] || (_cache[0] = () => _ctx.changeViewTo("date"))
        }, [
          createVNode(_component_IconCalendar),
          createBaseVNode("span", {
            class: normalizeClass(`${_ctx.prefixCls}-view-tab-pane-text`)
          }, toDisplayString(_ctx.footerValue && _ctx.footerValue.format("YYYY-MM-DD")), 3)
        ], 2),
        createBaseVNode("div", {
          class: normalizeClass([
            `${_ctx.prefixCls}-view-tab-pane`,
            { [`${_ctx.prefixCls}-view-tab-pane-active`]: _ctx.showTimeView }
          ]),
          onClick: _cache[1] || (_cache[1] = () => _ctx.changeViewTo("time"))
        }, [
          createVNode(_component_IconClockCircle),
          createBaseVNode("span", {
            class: normalizeClass(`${_ctx.prefixCls}-view-tab-pane-text`)
          }, toDisplayString(_ctx.timePickerValue && _ctx.timePickerValue.format("HH:mm:ss")), 3)
        ], 2)
      ], 2)
    ], 2)) : createCommentVNode("v-if", true)
  ], 2);
}
var DatePanel = _export_sfc(_sfc_main65, [["render", _sfc_render65]]);

// node_modules/@arco-design/web-vue/es/date-picker/panels/week/index.js
var _sfc_main66 = defineComponent({
  name: "WeekPanel",
  components: {
    DatePanel
  },
  props: {
    dayStartOfWeek: {
      type: Number,
      default: 0
    }
  },
  emits: ["select", "cell-mouse-enter"],
  setup(props, { emit }) {
    const { locale } = useI18n();
    const isSameTime = (current, target3) => {
      return methods.isSameWeek(current, target3, props.dayStartOfWeek, locale.value);
    };
    return {
      isSameTime,
      onSelect: (value) => {
        const startDateOfWeek = methods.startOf(value, "week");
        emit("select", startDateOfWeek);
      },
      onCellMouseEnter: (value) => {
        const startDateOfWeek = methods.startOf(value, "week");
        emit("cell-mouse-enter", startDateOfWeek);
      }
    };
  }
});
function _sfc_render66(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_DatePanel = resolveComponent("DatePanel");
  return openBlock(), createBlock(_component_DatePanel, mergeProps(_ctx.$attrs, {
    mode: "week",
    "is-week": "",
    "day-start-of-week": _ctx.dayStartOfWeek,
    "is-same-time": _ctx.isSameTime,
    onSelect: _ctx.onSelect,
    onCellMouseEnter: _ctx.onCellMouseEnter
  }), null, 16, ["day-start-of-week", "is-same-time", "onSelect", "onCellMouseEnter"]);
}
var WeekPanel = _export_sfc(_sfc_main66, [["render", _sfc_render66]]);

// node_modules/@arco-design/web-vue/es/date-picker/panels/month/index.js
var __defProp20 = Object.defineProperty;
var __defProps7 = Object.defineProperties;
var __getOwnPropDescs7 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols20 = Object.getOwnPropertySymbols;
var __hasOwnProp20 = Object.prototype.hasOwnProperty;
var __propIsEnum20 = Object.prototype.propertyIsEnumerable;
var __defNormalProp20 = (obj, key, value) => key in obj ? __defProp20(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues20 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp20.call(b, prop))
      __defNormalProp20(a, prop, b[prop]);
  if (__getOwnPropSymbols20)
    for (var prop of __getOwnPropSymbols20(b)) {
      if (__propIsEnum20.call(b, prop))
        __defNormalProp20(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps7 = (a, b) => __defProps7(a, __getOwnPropDescs7(b));
var MONTH_LIST = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];
var CELL_COUNT2 = 12;
var ROW_COUNT2 = 4;
var COL_COUNT2 = 3;
var _sfc_main67 = defineComponent({
  name: "MonthPanel",
  components: {
    PanelHeader,
    PanelBody
  },
  props: {
    headerValue: {
      type: Object,
      required: true
    },
    headerOperations: {
      type: Object,
      default: () => ({})
    },
    headerIcons: {
      type: Object,
      default: () => ({})
    },
    value: {
      type: Object
    },
    disabledDate: {
      type: Function
    },
    rangeValues: {
      type: Array
    },
    dateRender: {
      type: Function
    },
    onHeaderLabelClick: {
      type: Function
    }
  },
  emits: ["select", "cell-mouse-enter"],
  setup(props, { emit }) {
    const datePickerT = useDatePickerTransform();
    const { headerValue } = toRefs(props);
    const prefixCls = computed(() => getPrefixCls("panel-month"));
    const pickerPrefixCls = getPrefixCls("picker");
    const headerTitle = computed(() => headerValue.value.format("YYYY"));
    const rows = computed(() => {
      const year = headerValue.value.year();
      const flatData = newArray(CELL_COUNT2).map((_, index3) => ({
        label: datePickerT(`datePicker.month.long.${MONTH_LIST[index3]}`),
        value: dayjs(`${year}-${index3 + 1}`, "YYYY-M")
      }));
      const rows2 = newArray(ROW_COUNT2).map((_, index3) => flatData.slice(index3 * COL_COUNT2, (index3 + 1) * COL_COUNT2));
      return rows2;
    });
    const isSameTime = (current, target3) => current.isSame(target3, "month");
    function onCellClick(cellData) {
      emit("select", cellData.value);
    }
    function onCellMouseEnter(cellData) {
      emit("cell-mouse-enter", cellData.value);
    }
    return {
      prefixCls,
      pickerPrefixCls,
      headerTitle,
      rows,
      isSameTime,
      onCellClick,
      onCellMouseEnter
    };
  }
});
function _sfc_render67(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_PanelHeader = resolveComponent("PanelHeader");
  const _component_PanelBody = resolveComponent("PanelBody");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.prefixCls)
  }, [
    createBaseVNode("div", {
      class: normalizeClass(`${_ctx.prefixCls}-inner`)
    }, [
      createVNode(_component_PanelHeader, mergeProps(__spreadProps7(__spreadValues20({}, _ctx.headerOperations), {
        icons: _ctx.headerIcons
      }), {
        "prefix-cls": _ctx.pickerPrefixCls,
        title: _ctx.headerTitle,
        mode: "month",
        value: _ctx.headerValue,
        "on-label-click": _ctx.onHeaderLabelClick
      }), null, 16, ["prefix-cls", "title", "value", "on-label-click"]),
      createVNode(_component_PanelBody, {
        mode: "month",
        "prefix-cls": _ctx.pickerPrefixCls,
        rows: _ctx.rows,
        value: _ctx.value,
        "range-values": _ctx.rangeValues,
        "disabled-date": _ctx.disabledDate,
        "is-same-time": _ctx.isSameTime,
        "date-render": _ctx.dateRender,
        onCellClick: _ctx.onCellClick,
        onCellMouseEnter: _ctx.onCellMouseEnter
      }, null, 8, ["prefix-cls", "rows", "value", "range-values", "disabled-date", "is-same-time", "date-render", "onCellClick", "onCellMouseEnter"])
    ], 2)
  ], 2);
}
var MonthPanel = _export_sfc(_sfc_main67, [["render", _sfc_render67]]);

// node_modules/@arco-design/web-vue/es/date-picker/panels/year/index.js
var __defProp21 = Object.defineProperty;
var __defProps8 = Object.defineProperties;
var __getOwnPropDescs8 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols21 = Object.getOwnPropertySymbols;
var __hasOwnProp21 = Object.prototype.hasOwnProperty;
var __propIsEnum21 = Object.prototype.propertyIsEnumerable;
var __defNormalProp21 = (obj, key, value) => key in obj ? __defProp21(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues21 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp21.call(b, prop))
      __defNormalProp21(a, prop, b[prop]);
  if (__getOwnPropSymbols21)
    for (var prop of __getOwnPropSymbols21(b)) {
      if (__propIsEnum21.call(b, prop))
        __defNormalProp21(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps8 = (a, b) => __defProps8(a, __getOwnPropDescs8(b));
var ROW_COUNT3 = 4;
var COL_COUNT3 = 3;
var CELL_COUNT3 = ROW_COUNT3 * COL_COUNT3;
var SPAN = 10;
var _sfc_main68 = defineComponent({
  name: "YearPanel",
  components: {
    PanelHeader,
    PanelBody
  },
  props: {
    headerValue: {
      type: Object,
      required: true
    },
    headerOperations: {
      type: Object,
      default: () => ({})
    },
    headerIcons: {
      type: Object,
      default: () => ({})
    },
    value: {
      type: Object
    },
    disabledDate: {
      type: Function
    },
    rangeValues: {
      type: Array
    },
    dateRender: {
      type: Function
    }
  },
  emits: ["select", "cell-mouse-enter"],
  setup(props, { emit }) {
    const { headerValue } = toRefs(props);
    const prefixCls = computed(() => getPrefixCls("panel-year"));
    const pickerPrefixCls = getPrefixCls("picker");
    const rows = computed(() => {
      const startYear = Math.floor(headerValue.value.year() / SPAN) * SPAN - 1;
      const flatData = newArray(CELL_COUNT3).map((_, index3) => ({
        label: startYear + index3,
        value: dayjs(`${startYear + index3}`, "YYYY"),
        isPrev: index3 < 1,
        isNext: index3 > SPAN
      }));
      const rows2 = newArray(ROW_COUNT3).map((_, index3) => flatData.slice(index3 * COL_COUNT3, (index3 + 1) * COL_COUNT3));
      return rows2;
    });
    const headerTitle = computed(() => `${rows.value[0][1].label}-${rows.value[ROW_COUNT3 - 1][COL_COUNT3 - 1].label}`);
    const isSameTime = (current, target3) => current.isSame(target3, "year");
    function onCellClick(cellData) {
      emit("select", cellData.value);
    }
    function onCellMouseEnter(cellData) {
      emit("cell-mouse-enter", cellData.value);
    }
    return {
      prefixCls,
      pickerPrefixCls,
      headerTitle,
      rows,
      isSameTime,
      onCellClick,
      onCellMouseEnter
    };
  }
});
function _sfc_render68(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_PanelHeader = resolveComponent("PanelHeader");
  const _component_PanelBody = resolveComponent("PanelBody");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.prefixCls)
  }, [
    createBaseVNode("div", {
      class: normalizeClass(`${_ctx.prefixCls}-inner`)
    }, [
      createVNode(_component_PanelHeader, mergeProps(__spreadProps8(__spreadValues21({}, _ctx.headerOperations), {
        icons: _ctx.headerIcons
      }), {
        "prefix-cls": _ctx.pickerPrefixCls,
        title: _ctx.headerTitle
      }), null, 16, ["prefix-cls", "title"]),
      createVNode(_component_PanelBody, {
        mode: "year",
        "prefix-cls": _ctx.pickerPrefixCls,
        rows: _ctx.rows,
        value: _ctx.value,
        "range-values": _ctx.rangeValues,
        "disabled-date": _ctx.disabledDate,
        "is-same-time": _ctx.isSameTime,
        "date-render": _ctx.dateRender,
        onCellClick: _ctx.onCellClick,
        onCellMouseEnter: _ctx.onCellMouseEnter
      }, null, 8, ["prefix-cls", "rows", "value", "range-values", "disabled-date", "is-same-time", "date-render", "onCellClick", "onCellMouseEnter"])
    ], 2)
  ], 2);
}
var YearPanel = _export_sfc(_sfc_main68, [["render", _sfc_render68]]);

// node_modules/@arco-design/web-vue/es/date-picker/panels/quarter/index.js
var __defProp22 = Object.defineProperty;
var __defProps9 = Object.defineProperties;
var __getOwnPropDescs9 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols22 = Object.getOwnPropertySymbols;
var __hasOwnProp22 = Object.prototype.hasOwnProperty;
var __propIsEnum22 = Object.prototype.propertyIsEnumerable;
var __defNormalProp22 = (obj, key, value) => key in obj ? __defProp22(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues22 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp22.call(b, prop))
      __defNormalProp22(a, prop, b[prop]);
  if (__getOwnPropSymbols22)
    for (var prop of __getOwnPropSymbols22(b)) {
      if (__propIsEnum22.call(b, prop))
        __defNormalProp22(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps9 = (a, b) => __defProps9(a, __getOwnPropDescs9(b));
var _sfc_main69 = defineComponent({
  name: "QuarterPanel",
  components: {
    PanelHeader,
    PanelBody
  },
  props: {
    headerValue: {
      type: Object,
      required: true
    },
    headerOperations: {
      type: Object,
      default: () => ({})
    },
    headerIcons: {
      type: Object,
      default: () => ({})
    },
    value: {
      type: Object
    },
    disabledDate: {
      type: Function
    },
    rangeValues: {
      type: Array
    },
    dateRender: {
      type: Function
    },
    onHeaderLabelClick: {
      type: Function
    }
  },
  emits: ["select", "cell-mouse-enter"],
  setup(props, { emit }) {
    const { headerValue } = toRefs(props);
    const prefixCls = computed(() => getPrefixCls("panel-quarter"));
    const pickerPrefixCls = getPrefixCls("picker");
    const headerTitle = computed(() => headerValue.value.format("YYYY"));
    const rows = computed(() => {
      const year = headerValue.value.year();
      return [
        [1, 2, 3, 4].map((q) => ({
          label: `Q${q}`,
          value: dayjs(`${year}-${padStart((q - 1) * 3 + 1, 2, "0")}-01`)
        }))
      ];
    });
    const isSameTime = (current, target3) => current.isSame(target3, "month") || current.isSame(target3, "year") && Math.floor(current.month() / 3) === Math.floor(target3.month() / 3);
    function onCellClick(cellData) {
      emit("select", cellData.value);
    }
    function onCellMouseEnter(cellData) {
      emit("cell-mouse-enter", cellData.value);
    }
    return {
      prefixCls,
      pickerPrefixCls,
      headerTitle,
      rows,
      isSameTime,
      onCellClick,
      onCellMouseEnter
    };
  }
});
function _sfc_render69(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_PanelHeader = resolveComponent("PanelHeader");
  const _component_PanelBody = resolveComponent("PanelBody");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.prefixCls)
  }, [
    createBaseVNode("div", {
      class: normalizeClass(`${_ctx.prefixCls}-inner`)
    }, [
      createVNode(_component_PanelHeader, mergeProps(__spreadProps9(__spreadValues22({}, _ctx.headerOperations), {
        icons: _ctx.headerIcons
      }), {
        "prefix-cls": _ctx.pickerPrefixCls,
        title: _ctx.headerTitle,
        mode: "quarter",
        value: _ctx.headerValue,
        "on-label-click": _ctx.onHeaderLabelClick
      }), null, 16, ["prefix-cls", "title", "value", "on-label-click"]),
      createVNode(_component_PanelBody, {
        mode: "quarter",
        "prefix-cls": _ctx.pickerPrefixCls,
        rows: _ctx.rows,
        value: _ctx.value,
        "range-values": _ctx.rangeValues,
        "disabled-date": _ctx.disabledDate,
        "is-same-time": _ctx.isSameTime,
        "date-render": _ctx.dateRender,
        onCellClick: _ctx.onCellClick,
        onCellMouseEnter: _ctx.onCellMouseEnter
      }, null, 8, ["prefix-cls", "rows", "value", "range-values", "disabled-date", "is-same-time", "date-render", "onCellClick", "onCellMouseEnter"])
    ], 2)
  ], 2);
}
var QuarterPanel = _export_sfc(_sfc_main69, [["render", _sfc_render69]]);

// node_modules/@arco-design/web-vue/es/icon/icon-link/icon-link.js
var _sfc_main70 = defineComponent({
  name: "IconLink",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-link`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_136 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_227 = createBaseVNode("path", { d: "m14.1 25.414-4.95 4.95a6 6 0 0 0 8.486 8.485l8.485-8.485a6 6 0 0 0 0-8.485m7.779.707 4.95-4.95a6 6 0 1 0-8.486-8.485l-8.485 8.485a6 6 0 0 0 0 8.485" }, null, -1);
var _hoisted_325 = [
  _hoisted_227
];
function _sfc_render70(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_325, 14, _hoisted_136);
}
var _IconLink = _export_sfc(_sfc_main70, [["render", _sfc_render70]]);

// node_modules/@arco-design/web-vue/es/icon/icon-link/index.js
var IconLink = Object.assign(_IconLink, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconLink.name, _IconLink);
  }
});

// node_modules/@arco-design/web-vue/es/link/link.js
var _sfc_main71 = defineComponent({
  name: "Link",
  components: { IconLink, IconLoading },
  props: {
    href: String,
    status: {
      type: String,
      default: "normal"
    },
    hoverable: {
      type: Boolean,
      default: true
    },
    icon: Boolean,
    loading: Boolean,
    disabled: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { slots, emit }) {
    const prefixCls = getPrefixCls("link");
    const showIcon = hasPropOrSlot(props, slots, "icon");
    const handleClick = (ev) => {
      if (props.disabled || props.loading) {
        ev.preventDefault();
        return;
      }
      emit("click", ev);
    };
    const cls = computed(() => [
      prefixCls,
      `${prefixCls}-status-${props.status}`,
      {
        [`${prefixCls}-disabled`]: props.disabled,
        [`${prefixCls}-loading`]: props.loading,
        [`${prefixCls}-hoverless`]: !props.hoverable,
        [`${prefixCls}-with-icon`]: props.loading || showIcon.value
      }
    ]);
    return {
      cls,
      prefixCls,
      showIcon,
      handleClick
    };
  }
});
var _hoisted_137 = ["href"];
function _sfc_render71(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_loading = resolveComponent("icon-loading");
  const _component_icon_link = resolveComponent("icon-link");
  return openBlock(), createElementBlock("a", {
    href: _ctx.disabled ? void 0 : _ctx.href,
    class: normalizeClass(_ctx.cls),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    _ctx.loading || _ctx.showIcon ? (openBlock(), createElementBlock("span", {
      key: 0,
      class: normalizeClass(`${_ctx.prefixCls}-icon`)
    }, [
      _ctx.loading ? (openBlock(), createBlock(_component_icon_loading, { key: 0 })) : renderSlot(_ctx.$slots, "icon", { key: 1 }, () => [
        createVNode(_component_icon_link)
      ])
    ], 2)) : createCommentVNode("v-if", true),
    renderSlot(_ctx.$slots, "default")
  ], 10, _hoisted_137);
}
var _Link = _export_sfc(_sfc_main71, [["render", _sfc_render71]]);

// node_modules/@arco-design/web-vue/es/link/index.js
var Link = Object.assign(_Link, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Link.name, _Link);
  }
});

// node_modules/@arco-design/web-vue/es/date-picker/panels/footer.js
var _sfc_main72 = defineComponent({
  name: "PanelFooter",
  components: {
    Link,
    Button
  },
  props: {
    prefixCls: {
      type: String,
      required: true
    },
    showTodayBtn: {
      type: Boolean
    },
    showConfirmBtn: {
      type: Boolean
    },
    confirmBtnDisabled: {
      type: Boolean
    }
  },
  emits: ["today-btn-click", "confirm-btn-click"],
  setup(_, { emit }) {
    const datePickerT = useDatePickerTransform();
    return {
      datePickerT,
      onTodayClick: () => {
        emit("today-btn-click");
      },
      onConfirmBtnClick: () => {
        emit("confirm-btn-click");
      }
    };
  }
});
function _sfc_render72(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Link = resolveComponent("Link");
  const _component_Button = resolveComponent("Button");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(`${_ctx.prefixCls}-footer`)
  }, [
    _ctx.$slots.extra ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(`${_ctx.prefixCls}-footer-extra-wrapper`)
    }, [
      renderSlot(_ctx.$slots, "extra")
    ], 2)) : createCommentVNode("v-if", true),
    _ctx.showTodayBtn ? (openBlock(), createElementBlock("div", {
      key: 1,
      class: normalizeClass(`${_ctx.prefixCls}-footer-now-wrapper`)
    }, [
      createVNode(_component_Link, { onClick: _ctx.onTodayClick }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(_ctx.datePickerT("datePicker.today")), 1)
        ]),
        _: 1
      }, 8, ["onClick"])
    ], 2)) : createCommentVNode("v-if", true),
    _ctx.$slots.btn || _ctx.showConfirmBtn ? (openBlock(), createElementBlock("div", {
      key: 2,
      class: normalizeClass(`${_ctx.prefixCls}-footer-btn-wrapper`)
    }, [
      renderSlot(_ctx.$slots, "btn"),
      _ctx.showConfirmBtn ? (openBlock(), createBlock(_component_Button, {
        key: 0,
        class: normalizeClass(`${_ctx.prefixCls}-btn-confirm`),
        type: "primary",
        size: "mini",
        disabled: _ctx.confirmBtnDisabled,
        onClick: _ctx.onConfirmBtnClick
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(_ctx.datePickerT("datePicker.ok")), 1)
        ]),
        _: 1
      }, 8, ["class", "disabled", "onClick"])) : createCommentVNode("v-if", true)
    ], 2)) : createCommentVNode("v-if", true)
  ], 2);
}
var PanelFooter = _export_sfc(_sfc_main72, [["render", _sfc_render72]]);

// node_modules/@arco-design/web-vue/es/date-picker/hooks/use-panel-span.js
function usePanelSpan(props) {
  const { mode } = toRefs(props);
  const span = computed(() => ({ date: 1, week: 1, year: 10 * 12, quarter: 12, month: 12 })[mode.value]);
  const superSpan = computed(() => ["year"].includes(mode.value) ? 10 * 12 : 12);
  return {
    span,
    superSpan
  };
}

// node_modules/@arco-design/web-vue/es/date-picker/hooks/use-header-value.js
function useHeaderValue(props) {
  const { mode, value, defaultValue, selectedValue, format, onChange } = toRefs(props);
  const computedMode = computed(() => (mode == null ? void 0 : mode.value) || "date");
  const { span, superSpan } = usePanelSpan(reactive({
    mode: computedMode
  }));
  const isSame = (current, target3) => {
    const unit = computedMode.value === "date" || computedMode.value === "week" ? "M" : "y";
    return current.isSame(target3, unit);
  };
  const computedValue = computed(() => getDayjsValue(value == null ? void 0 : value.value, format.value));
  const computedDefaultValue = computed(() => getDayjsValue(defaultValue == null ? void 0 : defaultValue.value, format.value));
  const localValue = ref(computedDefaultValue.value || getNow());
  const headerValue = computed(() => computedValue.value || localValue.value);
  const setLocalValue = (newVal) => {
    if (!newVal)
      return;
    localValue.value = newVal;
  };
  const setHeaderValue = (newVal, emitChange = true) => {
    var _a;
    if (!newVal)
      return;
    if (emitChange && !isSame(headerValue.value, newVal)) {
      (_a = onChange == null ? void 0 : onChange.value) == null ? void 0 : _a.call(onChange, newVal);
    }
    setLocalValue(newVal);
  };
  if (selectedValue == null ? void 0 : selectedValue.value) {
    setLocalValue(selectedValue.value);
  }
  watch(() => selectedValue == null ? void 0 : selectedValue.value, (newVal) => {
    setHeaderValue(newVal);
  });
  function getDefaultLocalValue() {
    return (selectedValue == null ? void 0 : selectedValue.value) || computedDefaultValue.value || getNow();
  }
  function resetHeaderValue(emitChange = true) {
    const defaultLocalValue = getDefaultLocalValue();
    if (emitChange) {
      setHeaderValue(defaultLocalValue);
    } else {
      setLocalValue(defaultLocalValue);
    }
  }
  const showSingleBtn = computed(() => span.value !== superSpan.value);
  const headerOperations = computed(() => ({
    onSuperPrev: () => {
      setHeaderValue(methods.subtract(headerValue.value, superSpan.value, "M"));
    },
    onPrev: showSingleBtn.value ? () => {
      setHeaderValue(methods.subtract(headerValue.value, span.value, "M"));
    } : void 0,
    onNext: showSingleBtn.value ? () => {
      setHeaderValue(methods.add(headerValue.value, span.value, "M"));
    } : void 0,
    onSuperNext: () => {
      setHeaderValue(methods.add(headerValue.value, superSpan.value, "M"));
    }
  }));
  return {
    headerValue,
    setHeaderValue,
    headerOperations,
    resetHeaderValue,
    getDefaultLocalValue
  };
}

// node_modules/@arco-design/web-vue/es/date-picker/picker-panel.js
var _sfc_main73 = defineComponent({
  name: "DatePikerPanel",
  components: {
    DatePanel,
    PanelShortcuts,
    PanelFooter,
    WeekPanel,
    MonthPanel,
    YearPanel,
    QuarterPanel,
    RenderFunction
  },
  props: {
    mode: {
      type: String
    },
    headerMode: {
      type: String
    },
    prefixCls: {
      type: String,
      required: true
    },
    value: {
      type: Object
    },
    headerValue: {
      type: Object,
      required: true
    },
    timePickerValue: {
      type: Object
    },
    showTime: {
      type: Boolean
    },
    showConfirmBtn: {
      type: Boolean
    },
    shortcuts: {
      type: Array,
      default: () => []
    },
    shortcutsPosition: {
      type: String,
      default: "bottom"
    },
    format: {
      type: String,
      required: true
    },
    dayStartOfWeek: {
      type: Number,
      default: 0
    },
    disabledDate: {
      type: Function
    },
    disabledTime: {
      type: Function
    },
    timePickerProps: {
      type: Object
    },
    extra: {
      type: Function
    },
    dateRender: {
      type: Function
    },
    hideTrigger: {
      type: Boolean
    },
    confirmBtnDisabled: {
      type: Boolean
    },
    showNowBtn: {
      type: Boolean
    },
    headerIcons: {
      type: Object,
      default: () => ({})
    },
    headerOperations: {
      type: Object
    }
  },
  emits: [
    "cell-click",
    "time-picker-select",
    "shortcut-click",
    "shortcut-mouse-enter",
    "shortcut-mouse-leave",
    "confirm",
    "today-btn-click",
    "header-label-click",
    "header-select",
    "month-header-click"
  ],
  setup(props, { emit }) {
    const {
      prefixCls,
      shortcuts,
      shortcutsPosition,
      format,
      value,
      disabledDate,
      hideTrigger,
      showNowBtn,
      dateRender,
      showConfirmBtn,
      headerValue,
      headerIcons,
      headerOperations,
      headerMode
    } = toRefs(props);
    const hasShortcuts = computed(() => Boolean(shortcuts.value && shortcuts.value.length));
    const showShortcutsNowBtn = computed(() => showNowBtn.value && showConfirmBtn.value && !hasShortcuts.value);
    const showShortcuts = computed(() => showShortcutsNowBtn.value || hasShortcuts.value);
    const showShortcutsInLeft = computed(() => showShortcuts.value && shortcutsPosition.value === "left");
    const showShortcutsInRight = computed(() => showShortcuts.value && shortcutsPosition.value === "right");
    const showShortcutsInBottom = computed(() => showShortcuts.value && shortcutsPosition.value === "bottom");
    const classNames = computed(() => [
      `${prefixCls.value}-container`,
      {
        [`${prefixCls.value}-container-panel-only`]: hideTrigger.value,
        [`${prefixCls.value}-container-shortcuts-placement-left`]: showShortcutsInLeft.value,
        [`${prefixCls.value}-container-shortcuts-placement-right`]: showShortcutsInRight.value
      }
    ]);
    const footerValue = computed(() => (value == null ? void 0 : value.value) || getNow());
    const {
      headerValue: headerPanelHeaderValue,
      setHeaderValue: setHeaderPanelHeaderValue,
      headerOperations: headerPanelHeaderOperations
    } = useHeaderValue(reactive({
      mode: headerMode,
      format
    }));
    watch(headerValue, (val) => {
      setHeaderPanelHeaderValue(val);
    });
    function getShortcutValue(shortcut) {
      const { value: value2 } = shortcut;
      return getDayjsValue(isFunction(value2) ? value2() : value2, shortcut.format || format.value);
    }
    function onShortcutClick(shortcut) {
      emit("shortcut-click", getShortcutValue(shortcut), shortcut);
    }
    function onShortcutMouseEnter(shortcut) {
      emit("shortcut-mouse-enter", getShortcutValue(shortcut));
    }
    function onShortcutMouseLeave(shortcut) {
      emit("shortcut-mouse-leave", getShortcutValue(shortcut));
    }
    function onPanelSelect(date) {
      emit("cell-click", date);
    }
    function onTimePickerSelect(time) {
      emit("time-picker-select", time);
    }
    function onTodayBtnClick() {
      emit("today-btn-click", getNow());
    }
    function onConfirmBtnClick() {
      emit("confirm");
    }
    function onPanelHeaderLabelClick(type) {
      emit("header-label-click", type);
    }
    function onHeaderPanelSelect(date) {
      emit("header-select", date);
    }
    function onMonthHeaderLabelClick() {
      emit("month-header-click");
    }
    const shortcutsProps = reactive({
      prefixCls,
      shortcuts,
      showNowBtn: showShortcutsNowBtn,
      onItemClick: onShortcutClick,
      onItemMouseEnter: onShortcutMouseEnter,
      onItemMouseLeave: onShortcutMouseLeave,
      onNowClick: onTodayBtnClick
    });
    const commonPanelProps = reactive({
      value,
      headerValue,
      headerIcons,
      headerOperations,
      disabledDate,
      dateRender,
      onSelect: onPanelSelect,
      onHeaderLabelClick: onPanelHeaderLabelClick
    });
    return {
      classNames,
      showShortcutsInLeft,
      showShortcutsInRight,
      showShortcutsInBottom,
      shortcutsProps,
      commonPanelProps,
      footerValue,
      onTodayBtnClick,
      onConfirmBtnClick,
      onTimePickerSelect,
      onHeaderPanelSelect,
      headerPanelHeaderValue,
      headerPanelHeaderOperations,
      onMonthHeaderLabelClick
    };
  }
});
function _sfc_render73(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_PanelShortcuts = resolveComponent("PanelShortcuts");
  const _component_YearPanel = resolveComponent("YearPanel");
  const _component_MonthPanel = resolveComponent("MonthPanel");
  const _component_WeekPanel = resolveComponent("WeekPanel");
  const _component_QuarterPanel = resolveComponent("QuarterPanel");
  const _component_DatePanel = resolveComponent("DatePanel");
  const _component_RenderFunction = resolveComponent("RenderFunction");
  const _component_PanelFooter = resolveComponent("PanelFooter");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.classNames)
  }, [
    _ctx.showShortcutsInLeft ? (openBlock(), createBlock(_component_PanelShortcuts, normalizeProps(mergeProps({ key: 0 }, _ctx.shortcutsProps)), null, 16)) : createCommentVNode("v-if", true),
    createBaseVNode("div", {
      class: normalizeClass(`${_ctx.prefixCls}-panel-wrapper`)
    }, [
      _ctx.headerMode ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        _ctx.headerMode === "year" ? (openBlock(), createBlock(_component_YearPanel, {
          key: 0,
          "header-value": _ctx.headerPanelHeaderValue,
          "header-icons": _ctx.headerIcons,
          "header-operations": _ctx.headerPanelHeaderOperations,
          onSelect: _ctx.onHeaderPanelSelect
        }, null, 8, ["header-value", "header-icons", "header-operations", "onSelect"])) : _ctx.headerMode === "month" ? (openBlock(), createBlock(_component_MonthPanel, {
          key: 1,
          "header-value": _ctx.headerPanelHeaderValue,
          "header-icons": _ctx.headerIcons,
          "header-operations": _ctx.headerPanelHeaderOperations,
          onSelect: _ctx.onHeaderPanelSelect,
          onHeaderLabelClick: _ctx.onMonthHeaderLabelClick
        }, null, 8, ["header-value", "header-icons", "header-operations", "onSelect", "onHeaderLabelClick"])) : createCommentVNode("v-if", true)
      ], 2112)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        _ctx.mode === "week" ? (openBlock(), createBlock(_component_WeekPanel, mergeProps({ key: 0 }, _ctx.commonPanelProps, { "day-start-of-week": _ctx.dayStartOfWeek }), null, 16, ["day-start-of-week"])) : _ctx.mode === "month" ? (openBlock(), createBlock(_component_MonthPanel, normalizeProps(mergeProps({ key: 1 }, _ctx.commonPanelProps)), null, 16)) : _ctx.mode === "year" ? (openBlock(), createBlock(_component_YearPanel, normalizeProps(mergeProps({ key: 2 }, _ctx.commonPanelProps)), null, 16)) : _ctx.mode === "quarter" ? (openBlock(), createBlock(_component_QuarterPanel, normalizeProps(mergeProps({ key: 3 }, _ctx.commonPanelProps)), null, 16)) : (openBlock(), createBlock(_component_DatePanel, mergeProps({ key: 4 }, _ctx.commonPanelProps, {
          mode: "date",
          "show-time": _ctx.showTime,
          "time-picker-props": _ctx.timePickerProps,
          "day-start-of-week": _ctx.dayStartOfWeek,
          "footer-value": _ctx.footerValue,
          "time-picker-value": _ctx.timePickerValue,
          "disabled-time": _ctx.disabledTime,
          onTimePickerSelect: _ctx.onTimePickerSelect
        }), null, 16, ["show-time", "time-picker-props", "day-start-of-week", "footer-value", "time-picker-value", "disabled-time", "onTimePickerSelect"])),
        createVNode(_component_PanelFooter, {
          "prefix-cls": _ctx.prefixCls,
          "show-today-btn": _ctx.showNowBtn && !(_ctx.showConfirmBtn || _ctx.showShortcutsInBottom),
          "show-confirm-btn": _ctx.showConfirmBtn,
          "confirm-btn-disabled": _ctx.confirmBtnDisabled,
          onTodayBtnClick: _ctx.onTodayBtnClick,
          onConfirmBtnClick: _ctx.onConfirmBtnClick
        }, createSlots({ _: 2 }, [
          _ctx.extra ? {
            name: "extra",
            fn: withCtx(() => [
              _ctx.extra ? (openBlock(), createBlock(_component_RenderFunction, {
                key: 0,
                "render-func": _ctx.extra
              }, null, 8, ["render-func"])) : createCommentVNode("v-if", true)
            ])
          } : void 0,
          _ctx.showShortcutsInBottom ? {
            name: "btn",
            fn: withCtx(() => [
              createVNode(_component_PanelShortcuts, normalizeProps(guardReactiveProps(_ctx.shortcutsProps)), null, 16)
            ])
          } : void 0
        ]), 1032, ["prefix-cls", "show-today-btn", "show-confirm-btn", "confirm-btn-disabled", "onTodayBtnClick", "onConfirmBtnClick"])
      ], 64))
    ], 2),
    _ctx.showShortcutsInRight ? (openBlock(), createBlock(_component_PanelShortcuts, normalizeProps(mergeProps({ key: 1 }, _ctx.shortcutsProps)), null, 16)) : createCommentVNode("v-if", true)
  ], 2);
}
var PickerPanel = _export_sfc(_sfc_main73, [["render", _sfc_render73]]);

// node_modules/@arco-design/web-vue/es/date-picker/hooks/use-format.js
function getDefaultFormat(mode = "date", showTime = false) {
  switch (mode) {
    case "date":
      return showTime ? "YYYY-MM-DD HH:mm:ss" : "YYYY-MM-DD";
    case "month":
      return "YYYY-MM";
    case "year":
      return "YYYY";
    case "week":
      return "gggg-wo";
    case "quarter":
      return "YYYY-[Q]Q";
    default:
      return "YYYY-MM-DD";
  }
}
function useFormat(props) {
  const {
    format: propFormat,
    mode,
    showTime,
    valueFormat: propValueFormat
  } = toRefs(props);
  const format = computed(() => !isFunction(propFormat == null ? void 0 : propFormat.value) && (propFormat == null ? void 0 : propFormat.value) || getDefaultFormat(mode == null ? void 0 : mode.value, showTime == null ? void 0 : showTime.value));
  const valueFormat = computed(() => (propValueFormat == null ? void 0 : propValueFormat.value) || format.value);
  const parseValueFormat = computed(() => ["timestamp", "Date"].includes(valueFormat.value) ? format.value : valueFormat.value);
  return {
    format,
    valueFormat,
    parseValueFormat
  };
}

// node_modules/@arco-design/web-vue/es/date-picker/hooks/use-is-disabled-date.js
function useIsDisabledDate(props) {
  const { mode, showTime, disabledDate, disabledTime, isRange } = toRefs(props);
  const needCheckTime = computed(() => (mode == null ? void 0 : mode.value) === "date" && (showTime == null ? void 0 : showTime.value));
  const isDisabledDate = computed(() => {
    return (current, type) => {
      if (!(disabledDate == null ? void 0 : disabledDate.value))
        return false;
      const dateValue = getDateValue(current);
      if (isRange == null ? void 0 : isRange.value)
        return disabledDate.value(dateValue, type);
      return disabledDate.value(dateValue);
    };
  });
  const isDisabledItem = (num, getDisabledList) => {
    const list = (getDisabledList == null ? void 0 : getDisabledList()) || [];
    return list.includes(num);
  };
  const isDisabledTime2 = computed(() => {
    return (current, type) => {
      if (!needCheckTime.value)
        return false;
      if (!(disabledTime == null ? void 0 : disabledTime.value))
        return false;
      const dateValue = getDateValue(current);
      const disabledTimeProps = (isRange == null ? void 0 : isRange.value) ? disabledTime.value(dateValue, type) : disabledTime.value(dateValue);
      return isDisabledItem(current.hour(), disabledTimeProps.disabledHours) || isDisabledItem(current.minute(), disabledTimeProps.disabledMinutes) || isDisabledItem(current.second(), disabledTimeProps.disabledSeconds);
    };
  });
  return function isDisabled(value, type) {
    return value && (isDisabledDate.value(value, type || "start") || isDisabledTime2.value(value, type || "start"));
  };
}

// node_modules/@arco-design/web-vue/es/_utils/get-value-by-path.js
var getValueByPath = (obj, path) => {
  if (!obj || !path) {
    return void 0;
  }
  const keys = path.split(".");
  if (keys.length === 0) {
    return void 0;
  }
  let temp = obj;
  for (let i2 = 0; i2 < keys.length; i2++) {
    if (!isObject(temp) && !isArray(temp) || !keys[i2]) {
      return void 0;
    }
    if (i2 !== keys.length - 1) {
      temp = temp[keys[i2]];
    } else {
      return temp[keys[i2]];
    }
  }
  return void 0;
};
var setValueByPath = (obj, path, value) => {
  if (!obj || !path) {
    return;
  }
  const keys = path.split(".");
  if (keys.length === 0) {
    return;
  }
  let temp = obj;
  for (let i2 = 0; i2 < keys.length; i2++) {
    if (!isObject(temp) && !isArray(temp) || !keys[i2]) {
      return;
    }
    if (i2 !== keys.length - 1) {
      temp = temp[keys[i2]];
    } else {
      temp[keys[i2]] = value;
    }
  }
};

// node_modules/@arco-design/web-vue/es/date-picker/hooks/use-provide-datepicker-transform.js
function useDatePickerTransform2(props) {
  const { locale } = toRefs(props);
  const { locale: i18nLocale, t: t2 } = useI18n();
  dayjs.locale(i18nLocale.value.toLowerCase());
  const datePickerT = (key, ...args) => {
    const keyForLocale = key.startsWith("datePicker.") ? key.split(".").slice(1).join(".") : key;
    return getValueByPath((locale == null ? void 0 : locale.value) || {}, keyForLocale) || t2(key, ...args);
  };
  provide(PickerInjectionKey, {
    datePickerT
  });
  return datePickerT;
}

// node_modules/@arco-design/web-vue/es/date-picker/hooks/use-time-picker-value.js
function useTimePickerValue(props) {
  const { timePickerProps, selectedValue } = toRefs(props);
  const timePickerPropsFormat = computed(() => {
    var _a;
    return (_a = timePickerProps == null ? void 0 : timePickerProps.value) == null ? void 0 : _a.format;
  });
  const timePickerPropsUse12Hours = computed(() => {
    var _a;
    return !!((_a = timePickerProps == null ? void 0 : timePickerProps.value) == null ? void 0 : _a.use12Hours);
  });
  const { format } = useTimeFormat(reactive({
    format: timePickerPropsFormat,
    use12Hours: timePickerPropsUse12Hours
  }));
  const defaultTimePickerValue = computed(() => {
    var _a;
    return getDayjsValue((_a = timePickerProps == null ? void 0 : timePickerProps.value) == null ? void 0 : _a.defaultValue, format.value);
  });
  const getDefaultValue = () => (selectedValue == null ? void 0 : selectedValue.value) || defaultTimePickerValue.value || getNow();
  const timePickerValue = ref(getDefaultValue());
  function setTimePickerValue(val) {
    if (val) {
      timePickerValue.value = val;
    }
  }
  function resetTimePickerValue() {
    timePickerValue.value = getDefaultValue();
  }
  watch(selectedValue, (newVal) => {
    setTimePickerValue(newVal);
  });
  return [timePickerValue, setTimePickerValue, resetTimePickerValue];
}

// node_modules/@arco-design/web-vue/es/date-picker/hooks/use-value-format.js
function getReturnValue(date, format) {
  if (format === "timestamp") {
    return date.toDate().getTime();
  }
  if (format === "Date") {
    return date.toDate();
  }
  return date.format(format);
}
function useReturnValue(props) {
  const { format } = toRefs(props);
  return (date) => getReturnValue(date, format.value);
}
function getReturnRangeValue(dates, format) {
  return dates.map((date) => date ? getReturnValue(date, format) : void 0);
}

// node_modules/@arco-design/web-vue/es/date-picker/picker.js
var __defProp23 = Object.defineProperty;
var __defProps10 = Object.defineProperties;
var __getOwnPropDescs10 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols23 = Object.getOwnPropertySymbols;
var __hasOwnProp23 = Object.prototype.hasOwnProperty;
var __propIsEnum23 = Object.prototype.propertyIsEnumerable;
var __defNormalProp23 = (obj, key, value) => key in obj ? __defProp23(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues23 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp23.call(b, prop))
      __defNormalProp23(a, prop, b[prop]);
  if (__getOwnPropSymbols23)
    for (var prop of __getOwnPropSymbols23(b)) {
      if (__propIsEnum23.call(b, prop))
        __defNormalProp23(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps10 = (a, b) => __defProps10(a, __getOwnPropDescs10(b));
var _sfc_main74 = defineComponent({
  name: "Picker",
  components: {
    DateInput,
    Trigger,
    PickerPanel,
    IconCalendar
  },
  inheritAttrs: false,
  props: {
    locale: {
      type: Object
    },
    hideTrigger: {
      type: Boolean
    },
    allowClear: {
      type: Boolean,
      default: true
    },
    readonly: {
      type: Boolean
    },
    error: {
      type: Boolean
    },
    size: {
      type: String
    },
    shortcuts: {
      type: Array,
      default: () => []
    },
    shortcutsPosition: {
      type: String,
      default: "bottom"
    },
    position: {
      type: String,
      default: "bl"
    },
    popupVisible: {
      type: Boolean,
      default: void 0
    },
    defaultPopupVisible: {
      type: Boolean,
      default: false
    },
    triggerProps: {
      type: Object
    },
    unmountOnClose: {
      type: Boolean
    },
    placeholder: {
      type: String
    },
    disabled: {
      type: Boolean
    },
    disabledDate: {
      type: Function
    },
    disabledTime: {
      type: Function
    },
    pickerValue: {
      type: [Object, String, Number]
    },
    defaultPickerValue: {
      type: [Object, String, Number]
    },
    popupContainer: {
      type: [String, Object]
    },
    mode: {
      type: String,
      default: "date"
    },
    format: {
      type: [String, Function]
    },
    valueFormat: {
      type: String
    },
    previewShortcut: {
      type: Boolean,
      default: true
    },
    showConfirmBtn: {
      type: Boolean
    },
    showTime: {
      type: Boolean
    },
    timePickerProps: {
      type: Object
    },
    showNowBtn: {
      type: Boolean,
      default: true
    },
    dayStartOfWeek: {
      type: Number,
      default: 0
    },
    modelValue: {
      type: [Object, String, Number]
    },
    defaultValue: {
      type: [Object, String, Number]
    },
    disabledInput: {
      type: Boolean,
      default: false
    }
  },
  emits: {
    "change": (value, date, dateString) => true,
    "update:modelValue": (value) => true,
    "select": (value, date, dateString) => true,
    "popup-visible-change": (visible) => true,
    "update:popupVisible": (visible) => true,
    "ok": (value, date, dateString) => true,
    "clear": () => true,
    "select-shortcut": (shortcut) => true,
    "picker-value-change": (value, date, dateString) => true,
    "update:pickerValue": (value) => true
  },
  setup(props, { emit, slots }) {
    const {
      mode,
      modelValue,
      defaultValue,
      format,
      valueFormat,
      placeholder,
      popupVisible,
      defaultPopupVisible,
      disabled,
      showTime,
      timePickerProps,
      disabledDate,
      disabledTime,
      readonly: readonly2,
      locale,
      pickerValue,
      defaultPickerValue,
      dayStartOfWeek,
      previewShortcut,
      showConfirmBtn
    } = toRefs(props);
    const { locale: globalLocal } = useI18n();
    watchEffect(() => {
      initializeDateLocale(globalLocal.value, dayStartOfWeek.value);
    });
    const { mergedDisabled, eventHandlers } = useFormItem({ disabled });
    const datePickerT = useDatePickerTransform2(reactive({
      locale
    }));
    const prefixCls = getPrefixCls("picker");
    const refInput = ref();
    const computedPlaceholder = computed(() => (placeholder == null ? void 0 : placeholder.value) || {
      date: datePickerT("datePicker.placeholder.date"),
      month: datePickerT("datePicker.placeholder.month"),
      year: datePickerT("datePicker.placeholder.year"),
      week: datePickerT("datePicker.placeholder.week"),
      quarter: datePickerT("datePicker.placeholder.quarter")
    }[mode.value] || datePickerT("datePicker.placeholder.date"));
    const {
      format: computedFormat,
      valueFormat: returnValueFormat,
      parseValueFormat
    } = useFormat(reactive({ format, mode, showTime, valueFormat }));
    const inputFormat = computed(() => format && isFunction(format.value) ? (value) => {
      var _a;
      return (_a = format.value) == null ? void 0 : _a.call(format, getDateValue(value));
    } : computedFormat.value);
    const getReturnValue2 = useReturnValue(reactive({
      format: returnValueFormat
    }));
    const isDisabledDate = useIsDisabledDate(reactive({
      mode,
      disabledDate,
      disabledTime,
      showTime
    }));
    const needConfirm = computed(() => showTime.value || showConfirmBtn.value);
    const confirmBtnDisabled = computed(() => needConfirm.value && (!forSelectedValue.value || isDisabledDate(forSelectedValue.value)));
    const isDateTime = computed(() => mode.value === "date" && showTime.value);
    const { value: selectedValue, setValue: setSelectedValue } = usePickerState(reactive({
      modelValue,
      defaultValue,
      format: parseValueFormat
    }));
    const [processValue, setProcessValue] = useState();
    const [previewValue, setPreviewValue] = useState();
    const forSelectedValue = computed(() => {
      var _a;
      return (_a = processValue.value) != null ? _a : selectedValue.value;
    });
    const panelValue = computed(() => {
      var _a, _b;
      return (_b = (_a = previewValue.value) != null ? _a : processValue.value) != null ? _b : selectedValue.value;
    });
    const [inputValue, setInputValue] = useState();
    const [panelVisible, setLocalPanelVisible] = useMergeState(defaultPopupVisible.value, reactive({ value: popupVisible }));
    const setPanelVisible = (newVisible) => {
      if (panelVisible.value !== newVisible) {
        setLocalPanelVisible(newVisible);
        emit("popup-visible-change", newVisible);
        emit("update:popupVisible", newVisible);
      }
    };
    const { headerValue, setHeaderValue, headerOperations, resetHeaderValue } = useHeaderValue(reactive({
      mode,
      value: pickerValue,
      defaultValue: defaultPickerValue,
      selectedValue: panelValue,
      format: parseValueFormat,
      onChange: (newVal) => {
        const returnValue = getReturnValue2(newVal);
        const formattedValue = getFormattedValue(newVal, parseValueFormat.value);
        const dateValue = getDateValue(newVal);
        emit("picker-value-change", returnValue, dateValue, formattedValue);
        emit("update:pickerValue", returnValue);
      }
    }));
    const [timePickerValue, , resetTimePickerValue] = useTimePickerValue(reactive({
      timePickerProps,
      selectedValue: panelValue
    }));
    const inputEditable = computed(() => !readonly2.value && !isFunction(inputFormat.value));
    const headerMode = ref();
    watch(panelVisible, (newVisible) => {
      setProcessValue(void 0);
      setPreviewValue(void 0);
      headerMode.value = void 0;
      if (newVisible) {
        resetHeaderValue();
        resetTimePickerValue();
      }
      if (!newVisible) {
        setInputValue(void 0);
      }
    });
    function emitChange(value, emitOk) {
      var _a, _b;
      const returnValue = value ? getReturnValue2(value) : void 0;
      const formattedValue = getFormattedValue(value, parseValueFormat.value);
      const dateValue = getDateValue(value);
      if (isValueChange(value, selectedValue.value)) {
        emit("update:modelValue", returnValue);
        emit("change", returnValue, dateValue, formattedValue);
        (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onChange) == null ? void 0 : _b.call(_a);
      }
      if (emitOk) {
        emit("ok", returnValue, dateValue, formattedValue);
      }
    }
    function confirm(value, showPanel, emitOk) {
      if (isDisabledDate(value)) {
        return;
      }
      emitChange(value, emitOk);
      setSelectedValue(value);
      setProcessValue(void 0);
      setPreviewValue(void 0);
      setInputValue(void 0);
      headerMode.value = void 0;
      if (isBoolean(showPanel)) {
        setPanelVisible(showPanel);
      }
    }
    function select(value, emitSelect) {
      setProcessValue(value);
      setPreviewValue(void 0);
      setInputValue(void 0);
      headerMode.value = void 0;
      if (emitSelect) {
        const returnValue = value ? getReturnValue2(value) : void 0;
        const formattedValue = getFormattedValue(value, parseValueFormat.value);
        const dateValue = getDateValue(value);
        emit("select", returnValue, dateValue, formattedValue);
      }
    }
    function focusInput(index3) {
      refInput.value && refInput.value.focus && refInput.value.focus(index3);
    }
    function getMergedOpValue(date, time) {
      if (!isDateTime.value && !timePickerProps.value)
        return date;
      return mergeValueWithTime(getNow(), date, time);
    }
    function onPanelVisibleChange(visible) {
      if (mergedDisabled.value)
        return;
      setPanelVisible(visible);
    }
    function onInputClear(e2) {
      e2.stopPropagation();
      confirm(void 0);
      emit("clear");
    }
    function onInputBlur() {
      var _a, _b;
      (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onBlur) == null ? void 0 : _b.call(_a);
    }
    function onInputChange(e2) {
      setPanelVisible(true);
      const targetValue = e2.target.value;
      setInputValue(targetValue);
      if (!isValidInputValue(targetValue, computedFormat.value))
        return;
      const newValue = dayjs(targetValue, computedFormat.value);
      if (isDisabledDate(newValue))
        return;
      if (needConfirm.value) {
        select(newValue);
      } else {
        confirm(newValue, true);
      }
    }
    function onInputPressEnter() {
      confirm(panelValue.value, false);
    }
    function onPanelSelect(value) {
      if (needConfirm.value) {
        select(value, true);
      } else {
        confirm(value, false);
      }
    }
    function onPanelCellClick(value) {
      const newValue = getMergedOpValue(value, timePickerValue.value);
      onPanelSelect(newValue);
    }
    function onTimePickerSelect(time) {
      const newValue = getMergedOpValue(panelValue.value || getNow(), time);
      onPanelSelect(newValue);
    }
    function onPanelConfirm() {
      confirm(panelValue.value, false, true);
    }
    function onPanelClick() {
      if (props.disabledInput) {
        focusInput();
      }
    }
    let clearPreviewTimer;
    onUnmounted(() => {
      clearTimeout(clearPreviewTimer);
    });
    function onPanelShortcutMouseEnter(value) {
      clearTimeout(clearPreviewTimer);
      setPreviewValue(value);
      setInputValue(void 0);
    }
    function onPanelShortcutMouseLeave() {
      clearTimeout(clearPreviewTimer);
      clearPreviewTimer = setTimeout(() => {
        setPreviewValue(void 0);
      }, 100);
    }
    function onPanelShortcutClick(value, shortcut) {
      emit("select-shortcut", shortcut);
      confirm(value, false);
    }
    function onPanelHeaderLabelClick(type) {
      headerMode.value = type;
    }
    function onMonthHeaderClick() {
      headerMode.value = "year";
    }
    function onPanelHeaderSelect(date) {
      let newValue = headerValue.value;
      newValue = newValue.set("year", date.year());
      if (headerMode.value === "month") {
        newValue = newValue.set("month", date.month());
      }
      setHeaderValue(newValue);
      if (mode.value === "quarter" || mode.value === "month") {
        headerMode.value = void 0;
        return;
      }
      headerMode.value = headerMode.value === "year" ? "month" : void 0;
    }
    const computedTimePickerProps = computed(() => __spreadProps10(__spreadValues23({
      format: computedFormat.value
    }, omit((timePickerProps == null ? void 0 : timePickerProps.value) || {}, ["defaultValue"])), {
      visible: panelVisible.value
    }));
    const panelProps = computed(() => __spreadProps10(__spreadValues23({}, pick(props, [
      "mode",
      "shortcuts",
      "shortcutsPosition",
      "dayStartOfWeek",
      "disabledDate",
      "disabledTime",
      "showTime",
      "hideTrigger"
    ])), {
      showNowBtn: props.showNowBtn && mode.value === "date",
      prefixCls,
      format: parseValueFormat.value,
      value: panelValue.value,
      visible: panelVisible.value,
      showConfirmBtn: needConfirm.value,
      confirmBtnDisabled: confirmBtnDisabled.value,
      timePickerProps: computedTimePickerProps.value,
      extra: slots.extra,
      dateRender: slots.cell,
      headerValue: headerValue.value,
      headerIcons: {
        prev: slots["icon-prev"],
        prevDouble: slots["icon-prev-double"],
        next: slots["icon-next"],
        nextDouble: slots["icon-next-double"]
      },
      headerOperations: headerOperations.value,
      timePickerValue: timePickerValue.value,
      headerMode: headerMode.value,
      onCellClick: onPanelCellClick,
      onTimePickerSelect,
      onConfirm: onPanelConfirm,
      onShortcutClick: onPanelShortcutClick,
      onShortcutMouseEnter: previewShortcut.value ? onPanelShortcutMouseEnter : void 0,
      onShortcutMouseLeave: previewShortcut.value ? onPanelShortcutMouseLeave : void 0,
      onTodayBtnClick: onPanelSelect,
      onHeaderLabelClick: onPanelHeaderLabelClick,
      onHeaderSelect: onPanelHeaderSelect,
      onMonthHeaderClick
    }));
    return {
      prefixCls,
      refInput,
      panelProps,
      panelValue,
      inputValue,
      selectedValue,
      inputFormat,
      computedPlaceholder,
      panelVisible,
      inputEditable,
      needConfirm,
      mergedDisabled,
      onPanelVisibleChange,
      onInputClear,
      onInputChange,
      onInputPressEnter,
      onInputBlur,
      onPanelClick
    };
  }
});
function _sfc_render74(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_IconCalendar = resolveComponent("IconCalendar");
  const _component_DateInput = resolveComponent("DateInput");
  const _component_PickerPanel = resolveComponent("PickerPanel");
  const _component_Trigger = resolveComponent("Trigger");
  return !_ctx.hideTrigger ? (openBlock(), createBlock(_component_Trigger, mergeProps({
    key: 0,
    trigger: "click",
    "animation-name": "slide-dynamic-origin",
    "auto-fit-transform-origin": "",
    "click-to-close": false,
    "popup-offset": 4
  }, _ctx.triggerProps, {
    position: _ctx.position,
    disabled: _ctx.mergedDisabled || _ctx.readonly,
    "prevent-focus": true,
    "popup-visible": _ctx.panelVisible,
    "unmount-on-close": _ctx.unmountOnClose,
    "popup-container": _ctx.popupContainer,
    onPopupVisibleChange: _ctx.onPanelVisibleChange
  }), {
    content: withCtx(() => [
      createVNode(_component_PickerPanel, mergeProps(_ctx.panelProps, { onClick: _ctx.onPanelClick }), null, 16, ["onClick"])
    ]),
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default", {}, () => [
        createVNode(_component_DateInput, mergeProps(_ctx.$attrs, {
          ref: "refInput",
          size: _ctx.size,
          focused: _ctx.panelVisible,
          visible: _ctx.panelVisible,
          error: _ctx.error,
          disabled: _ctx.mergedDisabled,
          readonly: !_ctx.inputEditable || _ctx.disabledInput,
          "allow-clear": _ctx.allowClear && !_ctx.readonly,
          placeholder: _ctx.computedPlaceholder,
          "input-value": _ctx.inputValue,
          value: _ctx.needConfirm ? _ctx.panelValue : _ctx.selectedValue,
          format: _ctx.inputFormat,
          onClear: _ctx.onInputClear,
          onChange: _ctx.onInputChange,
          onPressEnter: _ctx.onInputPressEnter,
          onBlur: _ctx.onInputBlur
        }), createSlots({
          "suffix-icon": withCtx(() => [
            renderSlot(_ctx.$slots, "suffix-icon", {}, () => [
              createVNode(_component_IconCalendar)
            ])
          ]),
          _: 2
        }, [
          _ctx.$slots.prefix ? {
            name: "prefix",
            fn: withCtx(() => [
              renderSlot(_ctx.$slots, "prefix")
            ])
          } : void 0
        ]), 1040, ["size", "focused", "visible", "error", "disabled", "readonly", "allow-clear", "placeholder", "input-value", "value", "format", "onClear", "onChange", "onPressEnter", "onBlur"])
      ])
    ]),
    _: 3
  }, 16, ["position", "disabled", "popup-visible", "unmount-on-close", "popup-container", "onPopupVisibleChange"])) : (openBlock(), createBlock(_component_PickerPanel, normalizeProps(mergeProps({ key: 1 }, __spreadValues23(__spreadValues23({}, _ctx.$attrs), _ctx.panelProps))), null, 16));
}
var Picker = _export_sfc(_sfc_main74, [["render", _sfc_render74]]);

// node_modules/@arco-design/web-vue/es/date-picker/pickers/date-picker.js
var _DatePicker = defineComponent({
  name: "DatePicker",
  props: {
    modelValue: {
      type: [Object, String, Number]
    },
    defaultValue: {
      type: [Object, String, Number]
    },
    format: {
      type: [String, Function]
    },
    dayStartOfWeek: {
      type: Number,
      default: 0
    },
    showTime: {
      type: Boolean
    },
    timePickerProps: {
      type: Object
    },
    disabledTime: {
      type: Function
    },
    showNowBtn: {
      type: Boolean,
      default: true
    }
  },
  setup(props, {
    attrs,
    slots
  }) {
    return () => createVNode(Picker, mergeProps(props, attrs, {
      "mode": "date"
    }), slots);
  }
});

// node_modules/@arco-design/web-vue/es/date-picker/pickers/week-picker.js
var WeekPicker = defineComponent({
  name: "WeekPicker",
  props: {
    modelValue: {
      type: [Object, String, Number]
    },
    defaultValue: {
      type: [Object, String, Number]
    },
    format: {
      type: String,
      default: "gggg-wo"
    },
    valueFormat: {
      type: String,
      default: "YYYY-MM-DD"
    },
    dayStartOfWeek: {
      type: Number,
      default: 0
    }
  },
  setup(props, {
    attrs,
    slots
  }) {
    return () => createVNode(Picker, mergeProps(props, attrs, {
      "mode": "week"
    }), slots);
  }
});

// node_modules/@arco-design/web-vue/es/date-picker/pickers/month-picker.js
var MonthPicker = defineComponent({
  name: "MonthPicker",
  props: {
    modelValue: {
      type: [Object, String, Number]
    },
    defaultValue: {
      type: [Object, String, Number]
    },
    format: {
      type: String,
      default: "YYYY-MM"
    }
  },
  setup(props, {
    attrs,
    slots
  }) {
    return () => createVNode(Picker, mergeProps(props, attrs, {
      "mode": "month"
    }), slots);
  }
});

// node_modules/@arco-design/web-vue/es/date-picker/pickers/year-picker.js
var YearPicker = defineComponent({
  name: "YearPicker",
  props: {
    modelValue: {
      type: [Object, String, Number]
    },
    defaultValue: {
      type: [Object, String, Number]
    },
    format: {
      type: String,
      default: "YYYY"
    }
  },
  setup(props, {
    attrs,
    slots
  }) {
    return () => createVNode(Picker, mergeProps(props, attrs, {
      "mode": "year"
    }), slots);
  }
});

// node_modules/@arco-design/web-vue/es/date-picker/pickers/quarter-picker.js
var QuarterPicker = defineComponent({
  name: "QuarterPicker",
  props: {
    modelValue: {
      type: [Object, String, Number]
    },
    defaultValue: {
      type: [Object, String, Number]
    },
    format: {
      type: String,
      default: "YYYY-[Q]Q"
    },
    valueFormat: {
      type: String,
      default: "YYYY-MM"
    }
  },
  setup(props, {
    attrs,
    slots
  }) {
    return () => createVNode(Picker, mergeProps(props, attrs, {
      "mode": "quarter"
    }), slots);
  }
});

// node_modules/@arco-design/web-vue/es/date-picker/hooks/use-range-picker-state.js
function useRangePickerState(props) {
  const { modelValue, defaultValue, format } = toRefs(props);
  const computedModelValue = computed(() => {
    return getDayjsValue(normalizeRangeValue(modelValue.value), format.value);
  });
  const computedDefaultValue = computed(() => {
    return getDayjsValue(normalizeRangeValue(defaultValue.value), format.value);
  });
  const [localValue, setLocalValue] = useState(!isUndefined(computedModelValue.value) ? computedModelValue.value : !isUndefined(computedDefaultValue.value) ? computedDefaultValue.value : []);
  watch(computedModelValue, () => {
    if (isUndefined(computedModelValue.value)) {
      setLocalValue([]);
    }
  });
  const mergeValue = computed(() => computedModelValue.value || localValue.value);
  return {
    value: mergeValue,
    setValue: setLocalValue
  };
}

// node_modules/@arco-design/web-vue/es/date-picker/hooks/use-range-header-value.js
function useRangeHeaderValue(props) {
  const {
    startHeaderMode,
    endHeaderMode,
    mode,
    value,
    defaultValue,
    selectedValue,
    format,
    onChange
  } = toRefs(props);
  const unit = computed(() => ["date", "week"].includes(mode.value) ? "M" : "y");
  const isSame = (current, target3) => current.isSame(target3, unit.value);
  const { span, superSpan } = usePanelSpan(reactive({
    mode
  }));
  const startValue = computed(() => {
    var _a;
    return (_a = value.value) == null ? void 0 : _a[0];
  });
  const endValue = computed(() => {
    var _a;
    return (_a = value.value) == null ? void 0 : _a[1];
  });
  const startDefaultValue = computed(() => {
    var _a;
    return (_a = defaultValue.value) == null ? void 0 : _a[0];
  });
  const endDefaultValue = computed(() => {
    var _a;
    return (_a = defaultValue.value) == null ? void 0 : _a[1];
  });
  const emitChange = (newVal) => {
    (onChange == null ? void 0 : onChange.value) && onChange.value(newVal);
  };
  const {
    headerValue: startHeaderValue,
    setHeaderValue: setStartHeaderValue,
    headerOperations: startHeaderOperations,
    getDefaultLocalValue: getDefaultStartHeaderValue
  } = useHeaderValue(reactive({
    mode: startHeaderMode,
    value: startValue,
    defaultValue: startDefaultValue,
    selectedValue: void 0,
    format,
    onChange: (newVal) => {
      emitChange([newVal, endHeaderValue.value]);
    }
  }));
  const {
    headerValue: endHeaderValue,
    setHeaderValue: setEndHeaderValue,
    headerOperations: endHeaderOperations,
    getDefaultLocalValue: getDefaultEndHeaderValue
  } = useHeaderValue(reactive({
    mode: endHeaderMode,
    value: endValue,
    defaultValue: endDefaultValue,
    selectedValue: void 0,
    format,
    onChange: (newVal) => {
      emitChange([startHeaderValue.value, newVal]);
    }
  }));
  const setHeaderValue = (newVal) => {
    const isSameStartValue = isSame(startHeaderValue.value, newVal[0]);
    const isSameEndValue = isSame(endHeaderValue.value, newVal[1]);
    setStartHeaderValue(newVal[0], false);
    setEndHeaderValue(newVal[1], false);
    if (!isSameStartValue || !isSameEndValue) {
      (onChange == null ? void 0 : onChange.value) && (onChange == null ? void 0 : onChange.value(newVal));
    }
  };
  function getFixedValue(values) {
    let [header02, header12] = getSortedDayjsArray(values);
    const nextHeader = methods.add(header02, span.value, "M");
    if (header12.isBefore(nextHeader, unit.value)) {
      header12 = nextHeader;
    }
    return [header02, header12];
  }
  function getFormSelectedValue() {
    var _a, _b;
    let selected02 = (_a = selectedValue.value) == null ? void 0 : _a[0];
    let selected12 = (_b = selectedValue.value) == null ? void 0 : _b[1];
    if (selected02 && selected12) {
      [selected02, selected12] = getSortedDayjsArray([selected02, selected12]);
    }
    return [selected02, selected12];
  }
  const [selected0, selected1] = getFormSelectedValue();
  const [header0, header1] = getFixedValue([
    selected0 || startHeaderValue.value,
    selected1 || endHeaderValue.value
  ]);
  setStartHeaderValue(header0, false);
  setEndHeaderValue(header1, false);
  const resetHeaderValue = () => {
    const defaultStartHeaderValue = getDefaultStartHeaderValue();
    const defaultEndHeaderValue = getDefaultEndHeaderValue();
    nextTick(() => {
      const [selected02, selected12] = getFormSelectedValue();
      const [header02, header12] = getFixedValue([
        selected02 || defaultStartHeaderValue,
        selected12 || defaultEndHeaderValue
      ]);
      setHeaderValue([header02, header12]);
    });
  };
  const canShortenMonth = computed(() => methods.add(startHeaderValue.value, span.value, "M").isBefore(endHeaderValue.value, unit.value));
  const canShortenYear = computed(() => methods.add(startHeaderValue.value, superSpan.value, "M").isBefore(endHeaderValue.value, unit.value));
  const computedStartHeaderOperations = computed(() => {
    const operations = ["onSuperPrev", "onPrev"];
    if (canShortenMonth.value)
      operations.push("onNext");
    if (canShortenYear.value)
      operations.push("onSuperNext");
    return pick(startHeaderOperations.value, operations);
  });
  const computedEndHeaderOperations = computed(() => {
    const operations = ["onSuperNext", "onNext"];
    if (canShortenMonth.value)
      operations.push("onPrev");
    if (canShortenYear.value)
      operations.push("onSuperPrev");
    return pick(endHeaderOperations.value, operations);
  });
  return {
    startHeaderValue,
    endHeaderValue,
    startHeaderOperations: computedStartHeaderOperations,
    endHeaderOperations: computedEndHeaderOperations,
    setHeaderValue,
    resetHeaderValue
  };
}

// node_modules/@arco-design/web-vue/es/_components/picker/input-range.js
var _sfc_main75 = defineComponent({
  name: "DateInputRange",
  components: {
    IconHover,
    IconClose,
    FeedbackIcon
  },
  props: {
    size: {
      type: String
    },
    focused: {
      type: Boolean
    },
    focusedIndex: {
      type: Number
    },
    error: {
      type: Boolean
    },
    disabled: {
      type: [Boolean, Array],
      default: false
    },
    readonly: {
      type: Boolean
    },
    allowClear: {
      type: Boolean
    },
    placeholder: {
      type: Array,
      default: () => []
    },
    inputValue: {
      type: Array
    },
    value: {
      type: Array,
      default: () => []
    },
    format: {
      type: [String, Function],
      required: true
    }
  },
  emits: [
    "focused-index-change",
    "update:focusedIndex",
    "change",
    "clear",
    "press-enter"
  ],
  setup(props, { emit, slots }) {
    const {
      error,
      focused,
      disabled,
      size,
      value,
      format,
      focusedIndex,
      inputValue
    } = toRefs(props);
    const {
      mergedSize: _mergedSize,
      mergedDisabled,
      mergedError,
      feedback
    } = useFormItem({ size, error });
    const { mergedSize } = useSize(_mergedSize);
    const refInput0 = ref();
    const refInput1 = ref();
    const getDisabled = (index3) => {
      if (mergedDisabled.value) {
        return mergedDisabled.value;
      }
      return isArray(disabled.value) ? disabled.value[index3] : disabled.value;
    };
    const disabled0 = computed(() => getDisabled(0));
    const disabled1 = computed(() => getDisabled(1));
    const prefixCls = getPrefixCls("picker");
    const classNames = computed(() => [
      prefixCls,
      `${prefixCls}-range`,
      `${prefixCls}-size-${mergedSize.value}`,
      {
        [`${prefixCls}-focused`]: focused.value,
        [`${prefixCls}-disabled`]: disabled0.value && disabled1.value,
        [`${prefixCls}-error`]: mergedError.value,
        [`${prefixCls}-has-prefix`]: slots.prefix
      }
    ]);
    function getInputWrapClassName(index3) {
      return [
        `${prefixCls}-input`,
        {
          [`${prefixCls}-input-active`]: index3 === (focusedIndex == null ? void 0 : focusedIndex.value)
        }
      ];
    }
    function getDisplayValue(index3) {
      var _a, _b;
      if (inputValue == null ? void 0 : inputValue.value) {
        return (_a = inputValue == null ? void 0 : inputValue.value) == null ? void 0 : _a[index3];
      }
      const targetValue = (_b = value == null ? void 0 : value.value) == null ? void 0 : _b[index3];
      if (targetValue && isDayjs(targetValue)) {
        return isFunction(format.value) ? format.value(targetValue) : targetValue.format(format.value);
      }
      return void 0;
    }
    const displayValue0 = computed(() => getDisplayValue(0));
    const displayValue1 = computed(() => getDisplayValue(1));
    function changeFocusedInput(index3) {
      emit("focused-index-change", index3);
      emit("update:focusedIndex", index3);
    }
    function onChange(e2) {
      e2.stopPropagation();
      emit("change", e2);
    }
    function onPressEnter() {
      emit("press-enter");
    }
    function onPressTab(e2) {
      e2.preventDefault();
    }
    function onClear(e2) {
      emit("clear", e2);
    }
    return {
      prefixCls,
      classNames,
      refInput0,
      refInput1,
      disabled0,
      disabled1,
      mergedDisabled,
      getDisabled,
      getInputWrapClassName,
      displayValue0,
      displayValue1,
      changeFocusedInput,
      onChange,
      onPressEnter,
      onPressTab,
      onClear,
      feedback
    };
  },
  methods: {
    focus(index3) {
      const targetIndex = isNumber(index3) ? index3 : this.focusedIndex;
      const targetElement = targetIndex === 0 ? this.refInput0 : this.refInput1;
      !isUndefined(targetIndex) && !this.getDisabled(targetIndex) && targetElement && targetElement.focus && targetElement.focus();
    },
    blur() {
      const targetElement = this.focusedIndex === 0 ? this.refInput0 : this.refInput1;
      targetElement && targetElement.blur && targetElement.blur();
    }
  }
});
var _hoisted_138 = ["disabled", "placeholder", "value"];
var _hoisted_228 = createTextVNode(" - ");
var _hoisted_326 = ["disabled", "placeholder", "value"];
function _sfc_render75(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_IconClose = resolveComponent("IconClose");
  const _component_IconHover = resolveComponent("IconHover");
  const _component_FeedbackIcon = resolveComponent("FeedbackIcon");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.classNames)
  }, [
    _ctx.$slots.prefix ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(`${_ctx.prefixCls}-prefix`)
    }, [
      renderSlot(_ctx.$slots, "prefix")
    ], 2)) : createCommentVNode("v-if", true),
    createBaseVNode("div", {
      class: normalizeClass(_ctx.getInputWrapClassName(0))
    }, [
      createBaseVNode("input", mergeProps({
        ref: "refInput0",
        disabled: _ctx.disabled0,
        placeholder: _ctx.placeholder[0],
        value: _ctx.displayValue0
      }, _ctx.readonly ? { readonly: true } : {}, {
        onInput: _cache[0] || (_cache[0] = (...args) => _ctx.onChange && _ctx.onChange(...args)),
        onKeydown: [
          _cache[1] || (_cache[1] = withKeys((...args) => _ctx.onPressEnter && _ctx.onPressEnter(...args), ["enter"])),
          _cache[2] || (_cache[2] = withKeys((...args) => _ctx.onPressTab && _ctx.onPressTab(...args), ["tab"]))
        ],
        onClick: _cache[3] || (_cache[3] = () => _ctx.changeFocusedInput(0))
      }), null, 16, _hoisted_138)
    ], 2),
    createBaseVNode("span", {
      class: normalizeClass(`${_ctx.prefixCls}-separator`)
    }, [
      renderSlot(_ctx.$slots, "separator", {}, () => [
        _hoisted_228
      ])
    ], 2),
    createBaseVNode("div", {
      class: normalizeClass(_ctx.getInputWrapClassName(1))
    }, [
      createBaseVNode("input", mergeProps({
        ref: "refInput1",
        disabled: _ctx.disabled1,
        placeholder: _ctx.placeholder[1],
        value: _ctx.displayValue1
      }, _ctx.readonly ? { readonly: true } : {}, {
        onInput: _cache[4] || (_cache[4] = (...args) => _ctx.onChange && _ctx.onChange(...args)),
        onKeydown: [
          _cache[5] || (_cache[5] = withKeys((...args) => _ctx.onPressEnter && _ctx.onPressEnter(...args), ["enter"])),
          _cache[6] || (_cache[6] = withKeys((...args) => _ctx.onPressTab && _ctx.onPressTab(...args), ["tab"]))
        ],
        onClick: _cache[7] || (_cache[7] = () => _ctx.changeFocusedInput(1))
      }), null, 16, _hoisted_326)
    ], 2),
    createBaseVNode("div", {
      class: normalizeClass(`${_ctx.prefixCls}-suffix`)
    }, [
      _ctx.allowClear && !_ctx.mergedDisabled && _ctx.value.length === 2 ? (openBlock(), createBlock(_component_IconHover, {
        key: 0,
        prefix: _ctx.prefixCls,
        class: normalizeClass(`${_ctx.prefixCls}-clear-icon`),
        onClick: _ctx.onClear
      }, {
        default: withCtx(() => [
          createVNode(_component_IconClose)
        ]),
        _: 1
      }, 8, ["prefix", "class", "onClick"])) : createCommentVNode("v-if", true),
      createBaseVNode("span", {
        class: normalizeClass(`${_ctx.prefixCls}-suffix-icon`)
      }, [
        renderSlot(_ctx.$slots, "suffix-icon")
      ], 2),
      _ctx.feedback ? (openBlock(), createBlock(_component_FeedbackIcon, {
        key: 1,
        type: _ctx.feedback
      }, null, 8, ["type"])) : createCommentVNode("v-if", true)
    ], 2)
  ], 2);
}
var DateRangeInput = _export_sfc(_sfc_main75, [["render", _sfc_render75]]);

// node_modules/@arco-design/web-vue/es/date-picker/range-picker-panel.js
var __defProp24 = Object.defineProperty;
var __defProps11 = Object.defineProperties;
var __getOwnPropDescs11 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols24 = Object.getOwnPropertySymbols;
var __hasOwnProp24 = Object.prototype.hasOwnProperty;
var __propIsEnum24 = Object.prototype.propertyIsEnumerable;
var __defNormalProp24 = (obj, key, value) => key in obj ? __defProp24(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues24 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp24.call(b, prop))
      __defNormalProp24(a, prop, b[prop]);
  if (__getOwnPropSymbols24)
    for (var prop of __getOwnPropSymbols24(b)) {
      if (__propIsEnum24.call(b, prop))
        __defNormalProp24(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps11 = (a, b) => __defProps11(a, __getOwnPropDescs11(b));
var _sfc_main76 = defineComponent({
  name: "DateRangePikerPanel",
  components: {
    PanelShortcuts,
    PanelFooter,
    RenderFunction,
    DatePanel,
    WeekPanel,
    MonthPanel,
    YearPanel,
    QuarterPanel
  },
  props: {
    mode: {
      type: String,
      default: "date"
    },
    value: {
      type: Array,
      default: () => []
    },
    footerValue: {
      type: Array
    },
    timePickerValue: {
      type: Array
    },
    showTime: {
      type: Boolean
    },
    showConfirmBtn: {
      type: Boolean
    },
    prefixCls: {
      type: String,
      required: true
    },
    shortcuts: {
      type: Array,
      default: () => []
    },
    shortcutsPosition: {
      type: String,
      default: "bottom"
    },
    format: {
      type: String,
      required: true
    },
    dayStartOfWeek: {
      type: Number,
      default: 0
    },
    disabledDate: {
      type: Function
    },
    disabledTime: {
      type: Function
    },
    timePickerProps: {
      type: Object
    },
    extra: {
      type: Function
    },
    dateRender: {
      type: Function
    },
    hideTrigger: {
      type: Boolean
    },
    startHeaderProps: {
      type: Object,
      default: () => ({})
    },
    endHeaderProps: {
      type: Object,
      default: () => ({})
    },
    confirmBtnDisabled: {
      type: Boolean
    },
    disabled: {
      type: Array,
      default: () => [false, false]
    },
    visible: {
      type: Boolean
    },
    startHeaderMode: {
      type: String
    },
    endHeaderMode: {
      type: String
    }
  },
  emits: [
    "cell-click",
    "cell-mouse-enter",
    "time-picker-select",
    "shortcut-click",
    "shortcut-mouse-enter",
    "shortcut-mouse-leave",
    "confirm",
    "start-header-label-click",
    "end-header-label-click",
    "start-header-select",
    "end-header-select"
  ],
  setup(props, { emit }) {
    const {
      prefixCls,
      shortcuts,
      shortcutsPosition,
      format,
      hideTrigger,
      value,
      disabledDate,
      disabledTime,
      startHeaderProps,
      endHeaderProps,
      dateRender,
      visible,
      startHeaderMode,
      endHeaderMode
    } = toRefs(props);
    const showShortcuts = computed(() => isArray(shortcuts.value) && shortcuts.value.length);
    const classNames = computed(() => [
      `${prefixCls.value}-range-container`,
      {
        [`${prefixCls.value}-range-container-panel-only`]: hideTrigger.value,
        [`${prefixCls.value}-range-container-shortcuts-placement-left`]: showShortcuts.value && shortcutsPosition.value === "left",
        [`${prefixCls.value}-range-container-shortcuts-placement-right`]: showShortcuts.value && shortcutsPosition.value === "right"
      }
    ]);
    const currentDateView = ref("date");
    watch(visible, (newVal, oldVal) => {
      if (newVal && !oldVal) {
        currentDateView.value = "date";
      }
    });
    function getShortcutValue(shortcut) {
      return getDayjsValue(normalizeRangeValue(isFunction(shortcut.value) ? shortcut.value() : shortcut.value), shortcut.format || format.value);
    }
    function onShortcutClick(shortcut) {
      emit("shortcut-click", getShortcutValue(shortcut), shortcut);
    }
    function onShortcutMouseEnter(shortcut) {
      emit("shortcut-mouse-enter", getShortcutValue(shortcut));
    }
    function onShortcutMouseLeave(shortcut) {
      emit("shortcut-mouse-leave", getShortcutValue(shortcut));
    }
    function onPanelCellClick(date) {
      emit("cell-click", date);
    }
    function onPanelCellMouseEnter(date) {
      emit("cell-mouse-enter", date);
    }
    function onConfirmBtnClick() {
      emit("confirm");
    }
    function onStartTimePickerSelect(time) {
      emit("time-picker-select", time, "start");
    }
    function onEndTimePickerSelect(time) {
      emit("time-picker-select", time, "end");
    }
    function onStartPanelHeaderLabelClick(type) {
      emit("start-header-label-click", type);
    }
    function onEndPanelHeaderLabelClick(type) {
      emit("end-header-label-click", type);
    }
    function onStartHeaderPanelSelect(date) {
      emit("start-header-select", date);
    }
    function onEndHeaderPanelSelect(date) {
      emit("end-header-select", date);
    }
    function getDisabledDateFunc(index3) {
      return isFunction(disabledDate == null ? void 0 : disabledDate.value) ? (current) => {
        var _a;
        return ((_a = disabledDate == null ? void 0 : disabledDate.value) == null ? void 0 : _a.call(disabledDate, current, index3 === 0 ? "start" : "end")) || false;
      } : void 0;
    }
    function getDisabledTimeFunc(index3) {
      return isFunction(disabledTime == null ? void 0 : disabledTime.value) ? (current) => {
        var _a;
        return ((_a = disabledTime == null ? void 0 : disabledTime.value) == null ? void 0 : _a.call(disabledTime, current, index3 === 0 ? "start" : "end")) || false;
      } : void 0;
    }
    function getDateRenderFunc(index3) {
      return isFunction(dateRender == null ? void 0 : dateRender.value) ? (props2) => {
        var _a;
        const mergeProps2 = __spreadProps11(__spreadValues24({}, props2), {
          type: index3 === 0 ? "start" : "end"
        });
        return (_a = dateRender == null ? void 0 : dateRender.value) == null ? void 0 : _a.call(dateRender, mergeProps2);
      } : void 0;
    }
    const shortcutsProps = reactive({
      prefixCls,
      shortcuts,
      onItemClick: onShortcutClick,
      onItemMouseEnter: onShortcutMouseEnter,
      onItemMouseLeave: onShortcutMouseLeave
    });
    const startPanelProps = computed(() => __spreadProps11(__spreadValues24({}, startHeaderProps.value), {
      rangeValues: value.value,
      disabledDate: getDisabledDateFunc(0),
      dateRender: getDateRenderFunc(0),
      onSelect: startHeaderMode.value ? onStartHeaderPanelSelect : onPanelCellClick,
      onCellMouseEnter: onPanelCellMouseEnter,
      onHeaderLabelClick: onStartPanelHeaderLabelClick
    }));
    const endPanelProps = computed(() => __spreadProps11(__spreadValues24({}, endHeaderProps.value), {
      rangeValues: value.value,
      disabledDate: getDisabledDateFunc(1),
      dateRender: getDateRenderFunc(1),
      onSelect: endHeaderMode.value ? onEndHeaderPanelSelect : onPanelCellClick,
      onCellMouseEnter: onPanelCellMouseEnter,
      onHeaderLabelClick: onEndPanelHeaderLabelClick
    }));
    return {
      pick,
      classNames,
      showShortcuts,
      shortcutsProps,
      startPanelProps,
      endPanelProps,
      getDisabledTimeFunc,
      onConfirmBtnClick,
      currentDateView,
      onStartTimePickerSelect,
      onEndTimePickerSelect,
      onStartHeaderPanelSelect,
      onEndHeaderPanelSelect
    };
  }
});
function _sfc_render76(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_PanelShortcuts = resolveComponent("PanelShortcuts");
  const _component_YearPanel = resolveComponent("YearPanel");
  const _component_MonthPanel = resolveComponent("MonthPanel");
  const _component_WeekPanel = resolveComponent("WeekPanel");
  const _component_QuarterPanel = resolveComponent("QuarterPanel");
  const _component_DatePanel = resolveComponent("DatePanel");
  const _component_RenderFunction = resolveComponent("RenderFunction");
  const _component_PanelFooter = resolveComponent("PanelFooter");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.classNames)
  }, [
    _ctx.showShortcuts && _ctx.shortcutsPosition === "left" ? (openBlock(), createBlock(_component_PanelShortcuts, normalizeProps(mergeProps({ key: 0 }, _ctx.shortcutsProps)), null, 16)) : createCommentVNode("v-if", true),
    createBaseVNode("div", {
      class: normalizeClass(`${_ctx.prefixCls}-range-panel-wrapper`)
    }, [
      createCommentVNode(" panel "),
      createBaseVNode("div", {
        class: normalizeClass(`${_ctx.prefixCls}-range`)
      }, [
        createBaseVNode("div", {
          class: normalizeClass(`${_ctx.prefixCls}-range-wrapper`)
        }, [
          _ctx.startHeaderMode || _ctx.endHeaderMode ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            _ctx.startHeaderMode === "year" ? (openBlock(), createBlock(_component_YearPanel, normalizeProps(mergeProps({ key: 0 }, _ctx.startPanelProps)), null, 16)) : createCommentVNode("v-if", true),
            _ctx.endHeaderMode === "year" ? (openBlock(), createBlock(_component_YearPanel, normalizeProps(mergeProps({ key: 1 }, _ctx.endPanelProps)), null, 16)) : _ctx.startHeaderMode === "month" ? (openBlock(), createBlock(_component_MonthPanel, normalizeProps(mergeProps({ key: 2 }, _ctx.startPanelProps)), null, 16)) : _ctx.endHeaderMode === "month" ? (openBlock(), createBlock(_component_MonthPanel, normalizeProps(mergeProps({ key: 3 }, _ctx.endPanelProps)), null, 16)) : createCommentVNode("v-if", true)
          ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            createCommentVNode(" week "),
            _ctx.mode === "week" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createVNode(_component_WeekPanel, mergeProps(_ctx.startPanelProps, { "day-start-of-week": _ctx.dayStartOfWeek }), null, 16, ["day-start-of-week"]),
              createVNode(_component_WeekPanel, mergeProps(_ctx.endPanelProps, { "day-start-of-week": _ctx.dayStartOfWeek }), null, 16, ["day-start-of-week"])
            ], 64)) : _ctx.mode === "month" ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createCommentVNode(" month "),
              createVNode(_component_MonthPanel, normalizeProps(guardReactiveProps(_ctx.startPanelProps)), null, 16),
              createVNode(_component_MonthPanel, normalizeProps(guardReactiveProps(_ctx.endPanelProps)), null, 16)
            ], 64)) : _ctx.mode === "year" ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
              createCommentVNode(" year "),
              createVNode(_component_YearPanel, normalizeProps(guardReactiveProps(_ctx.startPanelProps)), null, 16),
              createVNode(_component_YearPanel, normalizeProps(guardReactiveProps(_ctx.endPanelProps)), null, 16)
            ], 64)) : _ctx.mode === "quarter" ? (openBlock(), createElementBlock(Fragment, { key: 3 }, [
              createCommentVNode(" quarter "),
              createVNode(_component_QuarterPanel, normalizeProps(guardReactiveProps(_ctx.startPanelProps)), null, 16),
              createVNode(_component_QuarterPanel, normalizeProps(guardReactiveProps(_ctx.endPanelProps)), null, 16)
            ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 4 }, [
              createCommentVNode(" date "),
              createVNode(_component_DatePanel, mergeProps({
                currentView: _ctx.currentDateView,
                "onUpdate:currentView": _cache[0] || (_cache[0] = ($event) => _ctx.currentDateView = $event)
              }, _ctx.startPanelProps, {
                "is-range": "",
                value: _ctx.value && _ctx.value[0],
                "footer-value": _ctx.footerValue && _ctx.footerValue[0],
                "time-picker-value": _ctx.timePickerValue && _ctx.timePickerValue[0],
                "day-start-of-week": _ctx.dayStartOfWeek,
                "show-time": _ctx.showTime,
                "time-picker-props": _ctx.timePickerProps,
                "disabled-time": _ctx.getDisabledTimeFunc(0),
                disabled: _ctx.disabled[0],
                onTimePickerSelect: _ctx.onStartTimePickerSelect
              }), null, 16, ["currentView", "value", "footer-value", "time-picker-value", "day-start-of-week", "show-time", "time-picker-props", "disabled-time", "disabled", "onTimePickerSelect"]),
              createVNode(_component_DatePanel, mergeProps({
                currentView: _ctx.currentDateView,
                "onUpdate:currentView": _cache[1] || (_cache[1] = ($event) => _ctx.currentDateView = $event)
              }, _ctx.endPanelProps, {
                "is-range": "",
                value: _ctx.value && _ctx.value[1],
                "footer-value": _ctx.footerValue && _ctx.footerValue[1],
                "time-picker-value": _ctx.timePickerValue && _ctx.timePickerValue[1],
                "day-start-of-week": _ctx.dayStartOfWeek,
                "show-time": _ctx.showTime,
                "time-picker-props": _ctx.timePickerProps,
                "disabled-time": _ctx.getDisabledTimeFunc(1),
                disabled: _ctx.disabled[1],
                onTimePickerSelect: _ctx.onEndTimePickerSelect
              }), null, 16, ["currentView", "value", "footer-value", "time-picker-value", "day-start-of-week", "show-time", "time-picker-props", "disabled-time", "disabled", "onTimePickerSelect"])
            ], 64))
          ], 2112))
        ], 2)
      ], 2),
      createCommentVNode(" footer "),
      createVNode(_component_PanelFooter, {
        "prefix-cls": _ctx.prefixCls,
        "show-today-btn": false,
        "show-confirm-btn": _ctx.showConfirmBtn,
        "confirm-btn-disabled": _ctx.confirmBtnDisabled,
        onConfirmBtnClick: _ctx.onConfirmBtnClick
      }, createSlots({ _: 2 }, [
        _ctx.extra || _ctx.$slots.extra ? {
          name: "extra",
          fn: withCtx(() => [
            _ctx.$slots.extra ? renderSlot(_ctx.$slots, "extra", { key: 0 }) : (openBlock(), createBlock(_component_RenderFunction, {
              key: 1,
              "render-func": _ctx.extra
            }, null, 8, ["render-func"]))
          ])
        } : void 0,
        _ctx.showShortcuts && _ctx.shortcutsPosition === "bottom" ? {
          name: "btn",
          fn: withCtx(() => [
            createVNode(_component_PanelShortcuts, normalizeProps(guardReactiveProps(_ctx.shortcutsProps)), null, 16)
          ])
        } : void 0
      ]), 1032, ["prefix-cls", "show-confirm-btn", "confirm-btn-disabled", "onConfirmBtnClick"])
    ], 2),
    _ctx.showShortcuts && _ctx.shortcutsPosition === "right" ? (openBlock(), createBlock(_component_PanelShortcuts, normalizeProps(mergeProps({ key: 1 }, _ctx.shortcutsProps)), null, 16)) : createCommentVNode("v-if", true)
  ], 2);
}
var RangePickerPanel = _export_sfc(_sfc_main76, [["render", _sfc_render76]]);

// node_modules/@arco-design/web-vue/es/date-picker/hooks/use-range-time-picker-value.js
var __defProp25 = Object.defineProperty;
var __defProps12 = Object.defineProperties;
var __getOwnPropDescs12 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols25 = Object.getOwnPropertySymbols;
var __hasOwnProp25 = Object.prototype.hasOwnProperty;
var __propIsEnum25 = Object.prototype.propertyIsEnumerable;
var __defNormalProp25 = (obj, key, value) => key in obj ? __defProp25(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues25 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp25.call(b, prop))
      __defNormalProp25(a, prop, b[prop]);
  if (__getOwnPropSymbols25)
    for (var prop of __getOwnPropSymbols25(b)) {
      if (__propIsEnum25.call(b, prop))
        __defNormalProp25(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps12 = (a, b) => __defProps12(a, __getOwnPropDescs12(b));
function useRangeTimePickerValue(props) {
  const { timePickerProps, selectedValue } = toRefs(props);
  const startValue = computed(() => {
    var _a;
    return (_a = selectedValue == null ? void 0 : selectedValue.value) == null ? void 0 : _a[0];
  });
  const endValue = computed(() => {
    var _a;
    return (_a = selectedValue == null ? void 0 : selectedValue.value) == null ? void 0 : _a[1];
  });
  const timePickerDefaultValue = computed(() => {
    var _a;
    return (_a = timePickerProps == null ? void 0 : timePickerProps.value) == null ? void 0 : _a.defaultValue;
  });
  const startTimePickerProps = computed(() => isArray(timePickerDefaultValue.value) ? __spreadProps12(__spreadValues25({}, timePickerProps == null ? void 0 : timePickerProps.value), {
    defaultValue: timePickerDefaultValue.value[0]
  }) : timePickerProps == null ? void 0 : timePickerProps.value);
  const endTimePickerProps = computed(() => isArray(timePickerDefaultValue.value) ? __spreadProps12(__spreadValues25({}, timePickerProps == null ? void 0 : timePickerProps.value), {
    defaultValue: timePickerDefaultValue.value[1]
  }) : timePickerProps == null ? void 0 : timePickerProps.value);
  const [startTimeValue, setStartTimeValue, resetStartTimeValue] = useTimePickerValue(reactive({
    timePickerProps: startTimePickerProps,
    selectedValue: startValue
  }));
  const [endTimeValue, setEndTimeValue, resetEndTimeValue] = useTimePickerValue(reactive({
    timePickerProps: endTimePickerProps,
    selectedValue: endValue
  }));
  const rangeTimePickerValue = computed(() => [
    startTimeValue.value,
    endTimeValue.value
  ]);
  function setTimeValue(val) {
    if (!val)
      return;
    setStartTimeValue(val[0]);
    setEndTimeValue(val[1]);
  }
  function resetTimeValue() {
    resetStartTimeValue();
    resetEndTimeValue();
  }
  return [rangeTimePickerValue, setTimeValue, resetTimeValue];
}

// node_modules/@arco-design/web-vue/es/date-picker/range-picker.js
var __defProp26 = Object.defineProperty;
var __defProps13 = Object.defineProperties;
var __getOwnPropDescs13 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols26 = Object.getOwnPropertySymbols;
var __hasOwnProp26 = Object.prototype.hasOwnProperty;
var __propIsEnum26 = Object.prototype.propertyIsEnumerable;
var __defNormalProp26 = (obj, key, value) => key in obj ? __defProp26(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues26 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp26.call(b, prop))
      __defNormalProp26(a, prop, b[prop]);
  if (__getOwnPropSymbols26)
    for (var prop of __getOwnPropSymbols26(b)) {
      if (__propIsEnum26.call(b, prop))
        __defNormalProp26(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps13 = (a, b) => __defProps13(a, __getOwnPropDescs13(b));
var _sfc_main77 = defineComponent({
  name: "RangePicker",
  components: {
    RangePickerPanel,
    DateRangeInput,
    Trigger,
    IconCalendar
  },
  inheritAttrs: false,
  props: {
    mode: {
      type: String,
      default: "date"
    },
    modelValue: {
      type: Array
    },
    defaultValue: {
      type: Array
    },
    pickerValue: {
      type: Array
    },
    defaultPickerValue: {
      type: Array
    },
    disabled: {
      type: [Boolean, Array],
      default: false
    },
    dayStartOfWeek: {
      type: Number,
      default: 0
    },
    format: {
      type: String
    },
    valueFormat: {
      type: String
    },
    showTime: {
      type: Boolean
    },
    timePickerProps: {
      type: Object
    },
    placeholder: {
      type: Array
    },
    disabledDate: {
      type: Function
    },
    disabledTime: {
      type: Function
    },
    separator: {
      type: String
    },
    exchangeTime: {
      type: Boolean,
      default: true
    },
    popupContainer: {
      type: [String, Object]
    },
    locale: {
      type: Object
    },
    hideTrigger: {
      type: Boolean
    },
    allowClear: {
      type: Boolean,
      default: true
    },
    readonly: {
      type: Boolean
    },
    error: {
      type: Boolean
    },
    size: {
      type: String
    },
    shortcuts: {
      type: Array,
      default: () => []
    },
    shortcutsPosition: {
      type: String,
      default: "bottom"
    },
    position: {
      type: String,
      default: "bl"
    },
    popupVisible: {
      type: Boolean,
      default: void 0
    },
    defaultPopupVisible: {
      type: Boolean
    },
    triggerProps: {
      type: Object
    },
    unmountOnClose: {
      type: Boolean
    },
    previewShortcut: {
      type: Boolean,
      default: true
    },
    showConfirmBtn: {
      type: Boolean
    },
    disabledInput: {
      type: Boolean,
      default: false
    }
  },
  emits: {
    "change": (value, date, dateString) => {
      return true;
    },
    "update:modelValue": (value) => {
      return true;
    },
    "select": (value, date, dateString) => {
      return true;
    },
    "popup-visible-change": (visible) => {
      return true;
    },
    "update:popupVisible": (visible) => {
      return true;
    },
    "ok": (value, date, dateString) => {
      return true;
    },
    "clear": () => {
      return true;
    },
    "select-shortcut": (shortcut) => {
      return true;
    },
    "picker-value-change": (value, date, dateString) => {
      return true;
    },
    "update:pickerValue": (value) => {
      return true;
    }
  },
  setup(props, { emit, slots }) {
    const {
      mode,
      showTime,
      format,
      modelValue,
      defaultValue,
      popupVisible,
      defaultPopupVisible,
      placeholder,
      timePickerProps,
      disabled,
      disabledDate,
      disabledTime,
      locale,
      pickerValue,
      defaultPickerValue,
      valueFormat,
      size,
      error,
      dayStartOfWeek,
      exchangeTime,
      previewShortcut,
      showConfirmBtn
    } = toRefs(props);
    const { locale: globalLocal } = useI18n();
    watchEffect(() => {
      initializeDateLocale(globalLocal.value, dayStartOfWeek.value);
    });
    const {
      mergedSize,
      mergedDisabled: formDisabled,
      mergedError,
      eventHandlers
    } = useFormItem({
      size,
      error
    });
    const datePickerT = useDatePickerTransform2(reactive({
      locale
    }));
    const prefixCls = getPrefixCls("picker");
    const computedPlaceholder = computed(() => (placeholder == null ? void 0 : placeholder.value) || {
      date: datePickerT("datePicker.rangePlaceholder.date"),
      month: datePickerT("datePicker.rangePlaceholder.month"),
      year: datePickerT("datePicker.rangePlaceholder.year"),
      week: datePickerT("datePicker.rangePlaceholder.week"),
      quarter: datePickerT("datePicker.rangePlaceholder.quarter")
    }[mode.value] || datePickerT("datePicker.rangePlaceholder.date"));
    const {
      format: computedFormat,
      valueFormat: returnValueFormat,
      parseValueFormat
    } = useFormat(reactive({
      mode,
      format,
      showTime,
      valueFormat
    }));
    const disabledArray = computed(() => {
      const disabled0 = disabled.value === true || formDisabled.value || isArray(disabled.value) && disabled.value[0] === true;
      const disabled1 = disabled.value === true || formDisabled.value || isArray(disabled.value) && disabled.value[1] === true;
      return [disabled0, disabled1];
    });
    const triggerDisabled = computed(() => disabledArray.value[0] && disabledArray.value[1]);
    function getFocusedIndex(cur = 0) {
      return disabledArray.value[cur] ? cur ^ 1 : cur;
    }
    const refInput = ref();
    const focusedIndex = ref(getFocusedIndex());
    const nextFocusedIndex = computed(() => {
      const cur = focusedIndex.value;
      const next = cur ^ 1;
      return disabledArray.value[next] ? cur : next;
    });
    const isNextDisabled = computed(() => disabledArray.value[focusedIndex.value ^ 1]);
    const { value: selectedValue, setValue: setSelectedValue } = useRangePickerState(reactive({
      modelValue,
      defaultValue,
      format: parseValueFormat
    }));
    const [processValue, setProcessValue] = useState();
    const [previewValue, setPreviewValue] = useState();
    const forSelectedValue = computed(() => {
      var _a;
      return (_a = processValue.value) != null ? _a : selectedValue.value;
    });
    const panelValue = computed(() => {
      var _a, _b;
      return (_b = (_a = previewValue.value) != null ? _a : processValue.value) != null ? _b : selectedValue.value;
    });
    const [inputValue, setInputValue] = useState();
    const startHeaderMode = ref();
    const endHeaderMode = ref();
    const [panelVisible, setLocalPanelVisible] = useMergeState(defaultPopupVisible.value, reactive({ value: popupVisible }));
    const setPanelVisible = (newVisible) => {
      if (panelVisible.value !== newVisible) {
        setLocalPanelVisible(newVisible);
        emit("popup-visible-change", newVisible);
        emit("update:popupVisible", newVisible);
      }
    };
    const {
      startHeaderValue,
      endHeaderValue,
      startHeaderOperations,
      endHeaderOperations,
      resetHeaderValue,
      setHeaderValue
    } = useRangeHeaderValue(reactive({
      mode,
      startHeaderMode,
      endHeaderMode,
      value: pickerValue,
      defaultValue: defaultPickerValue,
      selectedValue: panelValue,
      format: parseValueFormat,
      onChange: (newVal) => {
        const returnValue = getReturnRangeValue(newVal, returnValueFormat.value);
        const formattedValue = getFormattedValue(newVal, parseValueFormat.value);
        const dateValue = getDateValue(newVal);
        emit("picker-value-change", returnValue, dateValue, formattedValue);
        emit("update:pickerValue", returnValue);
      }
    }));
    function onStartPanelHeaderLabelClick(type) {
      startHeaderMode.value = type;
    }
    function onEndPanelHeaderLabelClick(type) {
      endHeaderMode.value = type;
    }
    function onStartPanelHeaderSelect(date) {
      let newStartValue = startHeaderValue.value;
      newStartValue = newStartValue.set("year", date.year());
      if (startHeaderMode.value === "month") {
        newStartValue = newStartValue.set("month", date.month());
      }
      setHeaderValue([newStartValue, endHeaderValue.value]);
      startHeaderMode.value = void 0;
    }
    function onEndPanelHeaderSelect(date) {
      let newEndValue = endHeaderValue.value;
      newEndValue = newEndValue.set("year", date.year());
      if (endHeaderMode.value === "month") {
        newEndValue = newEndValue.set("month", date.month());
      }
      setHeaderValue([startHeaderValue.value, newEndValue]);
      endHeaderMode.value = void 0;
    }
    const footerValue = ref([
      panelValue.value[0] || getNow(),
      panelValue.value[1] || getNow()
    ]);
    watch(panelValue, () => {
      const [value0, value1] = panelValue.value;
      footerValue.value[0] = value0 || footerValue.value[0];
      footerValue.value[1] = value1 || footerValue.value[1];
    });
    const [timePickerValue, setTimePickerValue, resetTimePickerValue] = useRangeTimePickerValue(reactive({
      timePickerProps,
      selectedValue: panelValue
    }));
    const isDateTime = computed(() => mode.value === "date" && showTime.value);
    const hasTime = computed(() => isDateTime.value || timePickerProps.value);
    const isDisabledDate = useIsDisabledDate(reactive({
      mode,
      isRange: true,
      showTime,
      disabledDate,
      disabledTime
    }));
    const needConfirm = computed(() => isDateTime.value || showConfirmBtn.value);
    const confirmBtnDisabled = computed(() => needConfirm.value && (!isCompleteRangeValue(forSelectedValue.value) || isDisabledDate(forSelectedValue.value[0], "start") || isDisabledDate(forSelectedValue.value[1], "end")));
    watch(panelVisible, (newVisible) => {
      if (mode.value === "year") {
        startHeaderMode.value = "year";
        endHeaderMode.value = "year";
      } else {
        startHeaderMode.value = void 0;
        endHeaderMode.value = void 0;
      }
      setProcessValue(void 0);
      setPreviewValue(void 0);
      if (newVisible) {
        resetHeaderValue();
        resetTimePickerValue();
        focusedIndex.value = getFocusedIndex(focusedIndex.value);
        nextTick(() => focusInput(focusedIndex.value));
      }
      if (!newVisible) {
        setInputValue(void 0);
      }
    });
    watch(focusedIndex, () => {
      if (props.disabledInput) {
        focusInput(focusedIndex.value);
        setInputValue(void 0);
      }
    });
    function emitChange(value, emitOk) {
      var _a, _b;
      const returnValue = value ? getReturnRangeValue(value, returnValueFormat.value) : void 0;
      const formattedValue = getFormattedValue(value, parseValueFormat.value);
      const dateValue = getDateValue(value);
      if (isValueChange(value, selectedValue.value)) {
        emit("update:modelValue", returnValue);
        emit("change", returnValue, dateValue, formattedValue);
        (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onChange) == null ? void 0 : _b.call(_a);
      }
      if (emitOk) {
        emit("ok", returnValue, dateValue, formattedValue);
      }
    }
    function confirm(value, showPanel, emitOk) {
      if (isDisabledDate(value == null ? void 0 : value[0], "start") || isDisabledDate(value == null ? void 0 : value[1], "end")) {
        return;
      }
      let newValue = value ? [...value] : void 0;
      if (isCompleteRangeValue(newValue)) {
        let sortedValue = getSortedDayjsArray(newValue);
        if (hasTime.value && !exchangeTime.value) {
          sortedValue = [
            getMergedOpValue(sortedValue[0], newValue[0]),
            getMergedOpValue(sortedValue[1], newValue[1])
          ];
        }
        newValue = sortedValue;
      }
      emitChange(newValue, emitOk);
      setSelectedValue(newValue || []);
      setProcessValue(void 0);
      setPreviewValue(void 0);
      setInputValue(void 0);
      startHeaderMode.value = void 0;
      endHeaderMode.value = void 0;
      if (isBoolean(showPanel)) {
        setPanelVisible(showPanel);
      }
    }
    function emitSelectEvent(value) {
      const returnValue = getReturnRangeValue(value, returnValueFormat.value);
      const formattedValue = getFormattedValue(value, parseValueFormat.value);
      const dateValue = getDateValue(value);
      emit("select", returnValue, dateValue, formattedValue);
    }
    function select(value, options) {
      const { emitSelect = false, updateHeader = false } = options || {};
      let newValue = [...value];
      if (isCompleteRangeValue(newValue)) {
        newValue = getSortedDayjsArray(newValue);
      }
      setProcessValue(newValue);
      setPreviewValue(void 0);
      setInputValue(void 0);
      startHeaderMode.value = void 0;
      endHeaderMode.value = void 0;
      if (emitSelect) {
        emitSelectEvent(newValue);
      }
      if (updateHeader) {
        resetHeaderValue();
      }
    }
    function preview(value, options) {
      const { updateHeader = false } = options || {};
      setPreviewValue(value);
      setInputValue(void 0);
      if (updateHeader) {
        resetHeaderValue();
      }
    }
    function focusInput(index3) {
      refInput.value && refInput.value.focus && refInput.value.focus(index3);
    }
    function getMergedOpValue(date, time) {
      if (!hasTime.value)
        return date;
      return mergeValueWithTime(getNow(), date, time);
    }
    function onPanelVisibleChange(visible) {
      setPanelVisible(visible);
    }
    function onPanelCellMouseEnter(date) {
      if (processValue.value && panelValue.value[nextFocusedIndex.value] && (!needConfirm.value || !isCompleteRangeValue(processValue.value))) {
        const newValue = [...panelValue.value];
        const mergedOpValue = getMergedOpValue(date, timePickerValue.value[focusedIndex.value]);
        newValue[focusedIndex.value] = mergedOpValue;
        preview(newValue);
      }
    }
    function getValueToModify(isTime = false) {
      if (isNextDisabled.value)
        return [...selectedValue.value];
      if (processValue.value) {
        return isTime || !isCompleteRangeValue(processValue.value) ? [...processValue.value] : [];
      }
      return isTime ? [...selectedValue.value] : [];
    }
    function onPanelCellClick(date) {
      const newValue = getValueToModify();
      const mergedOpValue = getMergedOpValue(date, timePickerValue.value[focusedIndex.value]);
      newValue[focusedIndex.value] = mergedOpValue;
      emitSelectEvent(newValue);
      if (!needConfirm.value && isCompleteRangeValue(newValue)) {
        confirm(newValue, false);
      } else {
        select(newValue);
        if (!isCompleteRangeValue(newValue)) {
          focusedIndex.value = nextFocusedIndex.value;
        }
      }
    }
    function onTimePickerSelect(time, type) {
      const updateIndex = type === "start" ? 0 : 1;
      const mergedOpValue = getMergedOpValue(timePickerValue.value[updateIndex], time);
      const newTimeValue = [...timePickerValue.value];
      newTimeValue[updateIndex] = mergedOpValue;
      setTimePickerValue(newTimeValue);
      const newValue = getValueToModify(true);
      if (newValue[updateIndex]) {
        newValue[updateIndex] = mergedOpValue;
        select(newValue, { emitSelect: true });
      }
    }
    let clearShortcutPreviewTimer;
    onUnmounted(() => {
      clearTimeout(clearShortcutPreviewTimer);
    });
    function onPanelShortcutMouseEnter(value) {
      clearTimeout(clearShortcutPreviewTimer);
      preview(value, { updateHeader: true });
    }
    function onPanelShortcutMouseLeave() {
      clearTimeout(clearShortcutPreviewTimer);
      clearShortcutPreviewTimer = setTimeout(() => {
        setPreviewValue(void 0);
        setInputValue(void 0);
        resetHeaderValue();
      }, 100);
    }
    function onPanelShortcutClick(value, shortcut) {
      emit("select-shortcut", shortcut);
      confirm(value, false);
    }
    function onPanelConfirm() {
      confirm(panelValue.value, false, true);
    }
    function onInputClear(e2) {
      e2.stopPropagation();
      confirm(void 0);
      emit("clear");
    }
    function onInputChange(e2) {
      setPanelVisible(true);
      const targetValue = e2.target.value;
      if (!targetValue) {
        setInputValue(void 0);
        return;
      }
      const formattedPanelValue = getFormattedValue(panelValue.value, computedFormat.value);
      const newInputValue = isArray(inputValue.value) ? [...inputValue.value] : formattedPanelValue || [];
      newInputValue[focusedIndex.value] = targetValue;
      setInputValue(newInputValue);
      if (!isValidInputValue(targetValue, computedFormat.value))
        return;
      const targetValueDayjs = dayjs(targetValue, computedFormat.value);
      if (isDisabledDate(targetValueDayjs, focusedIndex.value === 0 ? "start" : "end"))
        return;
      const newValue = isArray(panelValue.value) ? [...panelValue.value] : [];
      newValue[focusedIndex.value] = targetValueDayjs;
      select(newValue, { updateHeader: true });
    }
    function onInputPressEnter() {
      if (isValidRangeValue2(panelValue.value)) {
        confirm(panelValue.value, false);
      } else {
        focusedIndex.value = nextFocusedIndex.value;
      }
    }
    const computedTimePickerProps = computed(() => __spreadProps13(__spreadValues26({
      format: computedFormat.value
    }, omit((timePickerProps == null ? void 0 : timePickerProps.value) || {}, ["defaultValue"])), {
      visible: panelVisible.value
    }));
    const headerIcons = computed(() => ({
      prev: slots["icon-prev"],
      prevDouble: slots["icon-prev-double"],
      next: slots["icon-next"],
      nextDouble: slots["icon-next-double"]
    }));
    const startHeaderProps = reactive({
      headerValue: startHeaderValue,
      headerOperations: startHeaderOperations,
      headerIcons
    });
    const endHeaderProps = reactive({
      headerValue: endHeaderValue,
      headerOperations: endHeaderOperations,
      headerIcons
    });
    const rangePanelProps = computed(() => __spreadProps13(__spreadValues26({}, pick(props, [
      "mode",
      "showTime",
      "shortcuts",
      "shortcutsPosition",
      "dayStartOfWeek",
      "disabledDate",
      "disabledTime",
      "hideTrigger"
    ])), {
      prefixCls,
      format: parseValueFormat.value,
      value: panelValue.value,
      showConfirmBtn: needConfirm.value,
      confirmBtnDisabled: confirmBtnDisabled.value,
      timePickerValue: timePickerValue.value,
      timePickerProps: computedTimePickerProps.value,
      extra: slots.extra,
      dateRender: slots.cell,
      startHeaderProps,
      endHeaderProps,
      footerValue: footerValue.value,
      disabled: disabledArray.value,
      visible: panelVisible.value,
      onCellClick: onPanelCellClick,
      onCellMouseEnter: onPanelCellMouseEnter,
      onShortcutClick: onPanelShortcutClick,
      onShortcutMouseEnter: previewShortcut.value ? onPanelShortcutMouseEnter : void 0,
      onShortcutMouseLeave: previewShortcut.value ? onPanelShortcutMouseLeave : void 0,
      onConfirm: onPanelConfirm,
      onTimePickerSelect,
      startHeaderMode: startHeaderMode.value,
      endHeaderMode: endHeaderMode.value,
      onStartHeaderLabelClick: onStartPanelHeaderLabelClick,
      onEndHeaderLabelClick: onEndPanelHeaderLabelClick,
      onStartHeaderSelect: onStartPanelHeaderSelect,
      onEndHeaderSelect: onEndPanelHeaderSelect
    }));
    return {
      prefixCls,
      refInput,
      computedFormat,
      computedPlaceholder,
      panelVisible,
      panelValue,
      inputValue,
      focusedIndex,
      triggerDisabled,
      mergedSize,
      mergedError,
      onPanelVisibleChange,
      onInputClear,
      onInputChange,
      onInputPressEnter,
      rangePanelProps
    };
  }
});
function _sfc_render77(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_IconCalendar = resolveComponent("IconCalendar");
  const _component_DateRangeInput = resolveComponent("DateRangeInput");
  const _component_RangePickerPanel = resolveComponent("RangePickerPanel");
  const _component_Trigger = resolveComponent("Trigger");
  return !_ctx.hideTrigger ? (openBlock(), createBlock(_component_Trigger, mergeProps({
    key: 0,
    trigger: "click",
    "animation-name": "slide-dynamic-origin",
    "auto-fit-transform-origin": "",
    "click-to-close": false,
    "popup-offset": 4
  }, _ctx.triggerProps, {
    "unmount-on-close": _ctx.unmountOnClose,
    position: _ctx.position,
    disabled: _ctx.triggerDisabled || _ctx.readonly,
    "popup-visible": _ctx.panelVisible,
    "popup-container": _ctx.popupContainer,
    onPopupVisibleChange: _ctx.onPanelVisibleChange
  }), {
    content: withCtx(() => [
      createVNode(_component_RangePickerPanel, normalizeProps(guardReactiveProps(_ctx.rangePanelProps)), null, 16)
    ]),
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default", {}, () => [
        createVNode(_component_DateRangeInput, mergeProps({ ref: "refInput" }, _ctx.$attrs, {
          focusedIndex: _ctx.focusedIndex,
          "onUpdate:focusedIndex": _cache[0] || (_cache[0] = ($event) => _ctx.focusedIndex = $event),
          size: _ctx.size,
          focused: _ctx.panelVisible,
          visible: _ctx.panelVisible,
          error: _ctx.error,
          disabled: _ctx.disabled,
          readonly: _ctx.readonly || _ctx.disabledInput,
          "allow-clear": _ctx.allowClear && !_ctx.readonly,
          placeholder: _ctx.computedPlaceholder,
          "input-value": _ctx.inputValue,
          value: _ctx.panelValue,
          format: _ctx.computedFormat,
          onClear: _ctx.onInputClear,
          onChange: _ctx.onInputChange,
          onPressEnter: _ctx.onInputPressEnter
        }), createSlots({
          "suffix-icon": withCtx(() => [
            renderSlot(_ctx.$slots, "suffix-icon", {}, () => [
              createVNode(_component_IconCalendar)
            ])
          ]),
          separator: withCtx(() => [
            renderSlot(_ctx.$slots, "separator", {}, () => [
              createTextVNode(toDisplayString(_ctx.separator || "-"), 1)
            ])
          ]),
          _: 2
        }, [
          _ctx.$slots.prefix ? {
            name: "prefix",
            fn: withCtx(() => [
              renderSlot(_ctx.$slots, "prefix")
            ])
          } : void 0
        ]), 1040, ["focusedIndex", "size", "focused", "visible", "error", "disabled", "readonly", "allow-clear", "placeholder", "input-value", "value", "format", "onClear", "onChange", "onPressEnter"])
      ])
    ]),
    _: 3
  }, 16, ["unmount-on-close", "position", "disabled", "popup-visible", "popup-container", "onPopupVisibleChange"])) : (openBlock(), createBlock(_component_RangePickerPanel, normalizeProps(mergeProps({ key: 1 }, __spreadValues26(__spreadValues26({}, _ctx.$attrs), _ctx.rangePanelProps))), null, 16));
}
var RangePicker = _export_sfc(_sfc_main77, [["render", _sfc_render77]]);

// node_modules/@arco-design/web-vue/es/date-picker/index.js
var DatePicker = Object.assign(_DatePicker, {
  WeekPicker,
  MonthPicker,
  YearPicker,
  QuarterPicker,
  RangePicker,
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _DatePicker.name, _DatePicker);
    app.component(componentPrefix + YearPicker.name, YearPicker);
    app.component(componentPrefix + QuarterPicker.name, QuarterPicker);
    app.component(componentPrefix + MonthPicker.name, MonthPicker);
    app.component(componentPrefix + WeekPicker.name, WeekPicker);
    app.component(componentPrefix + RangePicker.name, RangePicker);
  }
});

// node_modules/@arco-design/web-vue/es/descriptions/context.js
var descriptionsInjectionKey = Symbol("ArcoDescriptions");

// node_modules/@arco-design/web-vue/es/_utils/responsive-observe.js
var __defProp27 = Object.defineProperty;
var __defProps14 = Object.defineProperties;
var __getOwnPropDescs14 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols27 = Object.getOwnPropertySymbols;
var __hasOwnProp27 = Object.prototype.hasOwnProperty;
var __propIsEnum27 = Object.prototype.propertyIsEnumerable;
var __defNormalProp27 = (obj, key, value) => key in obj ? __defProp27(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues27 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp27.call(b, prop))
      __defNormalProp27(a, prop, b[prop]);
  if (__getOwnPropSymbols27)
    for (var prop of __getOwnPropSymbols27(b)) {
      if (__propIsEnum27.call(b, prop))
        __defNormalProp27(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps14 = (a, b) => __defProps14(a, __getOwnPropDescs14(b));
var responsiveArray = [
  "xxl",
  "xl",
  "lg",
  "md",
  "sm",
  "xs"
];
var responsiveMap = {
  xs: "(max-width: 575px)",
  sm: "(min-width: 576px)",
  md: "(min-width: 768px)",
  lg: "(min-width: 992px)",
  xl: "(min-width: 1200px)",
  xxl: "(min-width: 1600px)"
};
var subscribers = [];
var subUid = -1;
var screens = {};
var responsiveObserve = {
  matchHandlers: {},
  dispatch(pointMap, breakpointChecked) {
    screens = pointMap;
    if (subscribers.length < 1) {
      return false;
    }
    subscribers.forEach((item) => {
      item.func(screens, breakpointChecked);
    });
    return true;
  },
  subscribe(func) {
    if (subscribers.length === 0) {
      this.register();
    }
    const token = (++subUid).toString();
    subscribers.push({
      token,
      func
    });
    func(screens, null);
    return token;
  },
  unsubscribe(token) {
    subscribers = subscribers.filter((item) => item.token !== token);
    if (subscribers.length === 0) {
      this.unregister();
    }
  },
  unregister() {
    Object.keys(responsiveMap).forEach((screen) => {
      const matchMediaQuery = responsiveMap[screen];
      if (!matchMediaQuery)
        return;
      const handler = this.matchHandlers[matchMediaQuery];
      if (handler && handler.mql && handler.listener) {
        if (handler.mql.removeEventListener) {
          handler.mql.removeEventListener("change", handler.listener);
        } else {
          handler.mql.removeListener(handler.listener);
        }
      }
    });
  },
  register() {
    Object.keys(responsiveMap).forEach((screen) => {
      const matchMediaQuery = responsiveMap[screen];
      if (!matchMediaQuery)
        return;
      const listener = ({ matches }) => {
        this.dispatch(__spreadProps14(__spreadValues27({}, screens), {
          [screen]: matches
        }), screen);
      };
      const mql = window.matchMedia(matchMediaQuery);
      if (mql.addEventListener) {
        mql.addEventListener("change", listener);
      } else {
        mql.addListener(listener);
      }
      this.matchHandlers[matchMediaQuery] = {
        mql,
        listener
      };
      listener(mql);
    });
  }
};

// node_modules/@arco-design/web-vue/es/grid/hook/use-responsive-state.js
function isResponsiveValue(val) {
  return isObject(val);
}
function useResponsiveState(val, defaultVal, fallbackToXs = false) {
  const screens2 = ref({
    xs: true,
    sm: true,
    md: true,
    lg: true,
    xl: true,
    xxl: true
  });
  const result = computed(() => {
    let res = defaultVal;
    if (isResponsiveValue(val.value)) {
      for (let i2 = 0; i2 < responsiveArray.length; i2++) {
        const breakpoint = responsiveArray[i2];
        if ((screens2.value[breakpoint] || breakpoint === "xs" && fallbackToXs) && val.value[breakpoint] !== void 0) {
          res = val.value[breakpoint];
          break;
        }
      }
    } else {
      res = val.value;
    }
    return res;
  });
  let subscribeToken = "";
  onMounted(() => {
    subscribeToken = responsiveObserve.subscribe((screensVal) => {
      if (isResponsiveValue(val.value)) {
        screens2.value = screensVal;
      }
    });
  });
  onUnmounted(() => {
    if (subscribeToken) {
      responsiveObserve.unsubscribe(subscribeToken);
    }
  });
  return result;
}

// node_modules/@arco-design/web-vue/es/descriptions/descriptions.js
var __defProp28 = Object.defineProperty;
var __getOwnPropSymbols28 = Object.getOwnPropertySymbols;
var __hasOwnProp28 = Object.prototype.hasOwnProperty;
var __propIsEnum28 = Object.prototype.propertyIsEnumerable;
var __defNormalProp28 = (obj, key, value) => key in obj ? __defProp28(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues28 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp28.call(b, prop))
      __defNormalProp28(a, prop, b[prop]);
  if (__getOwnPropSymbols28)
    for (var prop of __getOwnPropSymbols28(b)) {
      if (__propIsEnum28.call(b, prop))
        __defNormalProp28(a, prop, b[prop]);
    }
  return a;
};
var getTotalSpan = (renderData) => {
  return renderData ? renderData.reduce((total, data) => total + data.span, 0) : 0;
};
var _Descriptions = defineComponent({
  name: "Descriptions",
  props: {
    data: {
      type: Array,
      default: () => []
    },
    column: {
      type: [Number, Object],
      default: 3
    },
    title: String,
    layout: {
      type: String,
      default: "horizontal"
    },
    align: {
      type: [String, Object],
      default: "left"
    },
    size: {
      type: String
    },
    bordered: {
      type: Boolean,
      default: false
    },
    labelStyle: {
      type: Object
    },
    valueStyle: {
      type: Object
    },
    tableLayout: {
      type: String,
      default: "auto"
    }
  },
  setup(props, {
    slots
  }) {
    const {
      column,
      size
    } = toRefs(props);
    const prefixCls = getPrefixCls("descriptions");
    const {
      mergedSize
    } = useSize(size);
    const computedColumn = useResponsiveState(column, 3, true);
    const labelAlign = computed(() => {
      var _a;
      return (_a = isObject(props.align) ? props.align.label : props.align) != null ? _a : "left";
    });
    const valueAlign = computed(() => {
      var _a;
      return (_a = isObject(props.align) ? props.align.value : props.align) != null ? _a : "left";
    });
    const labelStyle = computed(() => __spreadValues28({
      textAlign: labelAlign.value
    }, props.labelStyle));
    const valueStyle = computed(() => __spreadValues28({
      textAlign: valueAlign.value
    }, props.valueStyle));
    const descItemMap = reactive(/* @__PURE__ */ new Map());
    const sortedSpans = computed(() => Array.from(descItemMap.values()).sort((a, b) => a.index - b.index).map((data) => data.span));
    const addItem = (id, data) => {
      descItemMap.set(id, data);
    };
    const removeItem = (id) => {
      descItemMap.delete(id);
    };
    provide(descriptionsInjectionKey, reactive({
      addItem,
      removeItem
    }));
    const getGroupedData = (data) => {
      const groupedData2 = [];
      data.forEach((item, index3) => {
        var _a;
        const itemSpan = Math.min((_a = isVNode(item) ? sortedSpans.value[index3] : item.span) != null ? _a : 1, computedColumn.value);
        const lastData = groupedData2[groupedData2.length - 1];
        const lastDataTotalSpan = getTotalSpan(lastData);
        if (lastDataTotalSpan === 0 || lastDataTotalSpan >= computedColumn.value) {
          groupedData2.push([{
            data: item,
            span: itemSpan
          }]);
        } else {
          lastData.push({
            data: item,
            span: itemSpan + lastDataTotalSpan > computedColumn.value ? computedColumn.value - lastDataTotalSpan : itemSpan
          });
        }
      });
      if (groupedData2.length) {
        const lastData = groupedData2[groupedData2.length - 1];
        const lastDataTotalSpan = getTotalSpan(lastData);
        if (lastDataTotalSpan < computedColumn.value) {
          lastData[lastData.length - 1].span += computedColumn.value - lastDataTotalSpan;
        }
      }
      return groupedData2;
    };
    const groupedData = computed(() => {
      var _a;
      return getGroupedData((_a = props.data) != null ? _a : []);
    });
    const renderLabel = (item, index3) => {
      var _a, _b, _c, _d, _e;
      if (isVNode(item)) {
        return isSlotsChildren(item, item.children) && ((_b = (_a = item.children).label) == null ? void 0 : _b.call(_a)) || ((_c = item.props) == null ? void 0 : _c.label);
      }
      return (_e = (_d = slots.label) == null ? void 0 : _d.call(slots, {
        label: item.label,
        index: index3,
        data: item
      })) != null ? _e : isFunction(item.label) ? item.label() : item.label;
    };
    const renderValue = (item, index3) => {
      var _a, _b;
      if (isVNode(item)) {
        return item;
      }
      return (_b = (_a = slots.value) == null ? void 0 : _a.call(slots, {
        value: item.value,
        index: index3,
        data: item
      })) != null ? _b : isFunction(item.value) ? item.value() : item.value;
    };
    const renderVerticalItems = (data) => createVNode(Fragment, null, [createVNode("tr", {
      "class": `${prefixCls}-row`
    }, [data.map((item, index3) => createVNode("td", {
      "key": `label-${index3}`,
      "class": [`${prefixCls}-item-label`, `${prefixCls}-item-label-block`],
      "style": labelStyle.value,
      "colspan": item.span
    }, [renderLabel(item.data, index3)]))]), createVNode("tr", {
      "class": `${prefixCls}-row`
    }, [data.map((item, index3) => createVNode("td", {
      "key": `value-${index3}`,
      "class": [`${prefixCls}-item-value`, `${prefixCls}-item-value-block`],
      "style": valueStyle.value,
      "colspan": item.span
    }, [renderValue(item.data, index3)]))])]);
    const renderHorizontalItems = (data, index3) => createVNode("tr", {
      "class": `${prefixCls}-row`,
      "key": `tr-${index3}`
    }, [data.map((item) => createVNode(Fragment, null, [createVNode("td", {
      "class": [`${prefixCls}-item-label`, `${prefixCls}-item-label-block`],
      "style": labelStyle.value
    }, [renderLabel(item.data, index3)]), createVNode("td", {
      "class": [`${prefixCls}-item-value`, `${prefixCls}-item-value-block`],
      "style": valueStyle.value,
      "colspan": item.span * 2 - 1
    }, [renderValue(item.data, index3)])]))]);
    const renderInlineItems = (data, index3) => createVNode("tr", {
      "class": `${prefixCls}-row`,
      "key": `inline-${index3}`
    }, [data.map((item, index22) => createVNode("td", {
      "key": `item-${index22}`,
      "class": `${prefixCls}-item`,
      "colspan": item.span
    }, [createVNode("div", {
      "class": [`${prefixCls}-item-label`, `${prefixCls}-item-label-inline`],
      "style": labelStyle.value
    }, [renderLabel(item.data, index22)]), createVNode("div", {
      "class": [`${prefixCls}-item-value`, `${prefixCls}-item-value-inline`],
      "style": valueStyle.value
    }, [renderValue(item.data, index22)])]))]);
    const renderItems = (data, index3) => {
      if (["inline-horizontal", "inline-vertical"].includes(props.layout)) {
        return renderInlineItems(data, index3);
      }
      if (props.layout === "vertical") {
        return renderVerticalItems(data);
      }
      return renderHorizontalItems(data, index3);
    };
    const cls = computed(() => [prefixCls, `${prefixCls}-layout-${props.layout}`, `${prefixCls}-size-${mergedSize.value}`, {
      [`${prefixCls}-border`]: props.bordered
    }, {
      [`${prefixCls}-table-layout-fixed`]: props.tableLayout === "fixed"
    }]);
    const renderTitle = () => {
      var _a, _b;
      const title = (_b = (_a = slots.title) == null ? void 0 : _a.call(slots)) != null ? _b : props.title;
      if (title) {
        return createVNode("div", {
          "class": `${prefixCls}-title`
        }, [title]);
      }
      return null;
    };
    return () => {
      const _groupedData = slots.default ? getGroupedData(getAllElements(slots.default())) : groupedData.value;
      return createVNode("div", {
        "class": cls.value
      }, [renderTitle(), createVNode("div", {
        "class": `${prefixCls}-body`
      }, [createVNode("table", {
        "class": `${prefixCls}-table`
      }, [createVNode("tbody", null, [_groupedData.map((data, index3) => renderItems(data, index3))])])])]);
    };
  }
});

// node_modules/@arco-design/web-vue/es/descriptions/descriptions-item.js
var _sfc_main78 = defineComponent({
  name: "DescriptionsItem",
  props: {
    span: {
      type: Number,
      default: 1
    },
    label: String
  },
  setup(props) {
    var _a;
    const { span } = toRefs(props);
    const prefixCls = getPrefixCls("descriptions");
    const descCtx = inject(descriptionsInjectionKey, {});
    const instance = getCurrentInstance();
    const itemRef = ref();
    const { computedIndex } = useIndex({
      itemRef,
      selector: `.${prefixCls}-item-value`,
      parentClassName: `${prefixCls}-table`
    });
    const itemData = reactive({
      index: computedIndex,
      span
    });
    if (instance == null ? void 0 : instance.uid) {
      (_a = descCtx.addItem) == null ? void 0 : _a.call(descCtx, instance.uid, itemData);
    }
    const getItemRef = () => {
      var _a2;
      const itemEle = ((_a2 = instance == null ? void 0 : instance.proxy) == null ? void 0 : _a2.$el).parentElement;
      if (itemEle && itemEle !== itemRef.value) {
        itemRef.value = itemEle;
      }
    };
    onMounted(() => getItemRef());
    onUpdated(() => getItemRef());
    onBeforeUnmount(() => {
      var _a2;
      if (instance == null ? void 0 : instance.uid) {
        (_a2 = descCtx.removeItem) == null ? void 0 : _a2.call(descCtx, instance.uid);
      }
    });
    return {
      prefixCls
    };
  }
});
function _sfc_render78(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}
var DescriptionsItem = _export_sfc(_sfc_main78, [["render", _sfc_render78]]);

// node_modules/@arco-design/web-vue/es/descriptions/index.js
var Descriptions = Object.assign(_Descriptions, {
  DescriptionsItem,
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Descriptions.name, _Descriptions);
    app.component(componentPrefix + DescriptionsItem.name, DescriptionsItem);
  }
});

// node_modules/@arco-design/web-vue/es/divider/divider.js
var _Divider = defineComponent({
  name: "Divider",
  props: {
    direction: {
      type: String,
      default: "horizontal"
    },
    orientation: {
      type: String,
      default: "center"
    },
    type: {
      type: String
    },
    size: {
      type: Number
    },
    margin: {
      type: [Number, String]
    }
  },
  setup(props, {
    slots
  }) {
    const prefixCls = getPrefixCls("divider");
    const isHorizontal2 = computed(() => props.direction === "horizontal");
    const mergedStyles = computed(() => {
      const styles = {};
      if (props.size) {
        styles[isHorizontal2.value ? "border-left-width" : "border-bottom-width"] = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.type) {
        styles[isHorizontal2.value ? "border-left-style" : "border-bottom-style"] = props.type;
      }
      if (props.margin) {
        const margin = isNumber(props.margin) ? `${props.margin}px` : props.margin;
        styles.margin = isHorizontal2.value ? `${margin} 0` : `0 ${margin}`;
      }
      return styles;
    });
    return () => {
      var _a;
      const children = (_a = slots.default) == null ? void 0 : _a.call(slots);
      const classNames = [prefixCls, `${prefixCls}-${props.direction}`, {
        [`${prefixCls}-with-text`]: children
      }];
      return createVNode("div", {
        "role": "separator",
        "class": classNames,
        "style": mergedStyles.value
      }, [children && props.direction === "horizontal" && createVNode("span", {
        "class": [`${prefixCls}-text`, `${prefixCls}-text-${props.orientation}`]
      }, [children])]);
    };
  }
});

// node_modules/@arco-design/web-vue/es/divider/index.js
var Divider = Object.assign(_Divider, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Divider.name, _Divider);
  }
});

// node_modules/@arco-design/web-vue/es/_hooks/use-overflow.js
var useOverflow = (elementRef) => {
  const isSetOverflow = ref(false);
  const originStyle = {
    overflow: "",
    width: "",
    boxSizing: ""
  };
  const setOverflowHidden = () => {
    if (elementRef.value) {
      const element = elementRef.value;
      if (!isSetOverflow.value && element.style.overflow !== "hidden") {
        const scrollBarWidth = getScrollBarWidth(element);
        if (scrollBarWidth > 0 || isScroll(element)) {
          originStyle.overflow = element.style.overflow;
          originStyle.width = element.style.width;
          originStyle.boxSizing = element.style.boxSizing;
          element.style.overflow = "hidden";
          element.style.width = `${element.offsetWidth - scrollBarWidth}px`;
          element.style.boxSizing = "border-box";
          isSetOverflow.value = true;
        }
      }
    }
  };
  const resetOverflow = () => {
    if (elementRef.value && isSetOverflow.value) {
      const element = elementRef.value;
      element.style.overflow = originStyle.overflow;
      element.style.width = originStyle.width;
      element.style.boxSizing = originStyle.boxSizing;
      isSetOverflow.value = false;
    }
  };
  return {
    setOverflowHidden,
    resetOverflow
  };
};

// node_modules/@arco-design/web-vue/es/drawer/drawer.js
var __defProp29 = Object.defineProperty;
var __getOwnPropSymbols29 = Object.getOwnPropertySymbols;
var __hasOwnProp29 = Object.prototype.hasOwnProperty;
var __propIsEnum29 = Object.prototype.propertyIsEnumerable;
var __defNormalProp29 = (obj, key, value) => key in obj ? __defProp29(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues29 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp29.call(b, prop))
      __defNormalProp29(a, prop, b[prop]);
  if (__getOwnPropSymbols29)
    for (var prop of __getOwnPropSymbols29(b)) {
      if (__propIsEnum29.call(b, prop))
        __defNormalProp29(a, prop, b[prop]);
    }
  return a;
};
var DRAWER_PLACEMENTS = ["top", "right", "bottom", "left"];
var _sfc_main79 = defineComponent({
  name: "Drawer",
  components: {
    ClientOnly,
    ArcoButton: Button,
    IconHover,
    IconClose
  },
  inheritAttrs: false,
  props: {
    visible: {
      type: Boolean,
      default: false
    },
    defaultVisible: {
      type: Boolean,
      default: false
    },
    placement: {
      type: String,
      default: "right",
      validator: (value) => DRAWER_PLACEMENTS.includes(value)
    },
    title: String,
    mask: {
      type: Boolean,
      default: true
    },
    maskClosable: {
      type: Boolean,
      default: true
    },
    closable: {
      type: Boolean,
      default: true
    },
    okText: String,
    cancelText: String,
    okLoading: {
      type: Boolean,
      default: false
    },
    okButtonProps: {
      type: Object
    },
    cancelButtonProps: {
      type: Object
    },
    unmountOnClose: Boolean,
    width: {
      type: [Number, String],
      default: 250
    },
    height: {
      type: [Number, String],
      default: 250
    },
    popupContainer: {
      type: [String, Object],
      default: "body"
    },
    drawerStyle: {
      type: Object
    },
    onBeforeOk: {
      type: Function
    },
    onBeforeCancel: {
      type: Function
    },
    escToClose: {
      type: Boolean,
      default: true
    },
    renderToBody: {
      type: Boolean,
      default: true
    },
    header: {
      type: Boolean,
      default: true
    },
    footer: {
      type: Boolean,
      default: true
    },
    hideCancel: {
      type: Boolean,
      default: false
    }
  },
  emits: {
    "update:visible": (visible) => true,
    "ok": () => true,
    "cancel": () => true,
    "open": () => true,
    "close": () => true,
    "beforeOpen": () => true,
    "beforeClose": () => true
  },
  setup(props, { emit }) {
    const { popupContainer } = toRefs(props);
    const prefixCls = getPrefixCls("drawer");
    const { t: t2 } = useI18n();
    const _visible = ref(props.defaultVisible);
    const computedVisible = computed(() => {
      var _a;
      return (_a = props.visible) != null ? _a : _visible.value;
    });
    const _okLoading = ref(false);
    const mergedOkLoading = computed(() => props.okLoading || _okLoading.value);
    const { teleportContainer, containerRef } = useTeleportContainer({
      popupContainer,
      visible: computedVisible
    });
    const mounted = ref(computedVisible.value);
    let globalKeyDownListener = false;
    const handleGlobalKeyDown = (ev) => {
      if (props.escToClose && ev.key === KEYBOARD_KEY.ESC && isLastDialog()) {
        handleCancel();
      }
    };
    const addGlobalKeyDownListener = () => {
      if (props.escToClose && !globalKeyDownListener) {
        globalKeyDownListener = true;
        on(document.documentElement, "keydown", handleGlobalKeyDown);
      }
    };
    const removeGlobalKeyDownListener = () => {
      if (globalKeyDownListener) {
        globalKeyDownListener = false;
        off(document.documentElement, "keydown", handleGlobalKeyDown);
      }
    };
    const { zIndex, isLastDialog } = usePopupManager("dialog", {
      visible: computedVisible
    });
    const isFixed = computed(() => {
      return (containerRef == null ? void 0 : containerRef.value) === document.body;
    });
    let promiseNumber = 0;
    const close = () => {
      promiseNumber++;
      if (_okLoading.value) {
        _okLoading.value = false;
      }
      _visible.value = false;
      emit("update:visible", false);
    };
    const handleOk = async () => {
      const currentPromiseNumber = promiseNumber;
      const closed = await new Promise(async (resolve) => {
        var _a;
        if (isFunction(props.onBeforeOk)) {
          let result = props.onBeforeOk((closed2 = true) => resolve(closed2));
          if (isPromise(result) || !isBoolean(result)) {
            _okLoading.value = true;
          }
          if (isPromise(result)) {
            try {
              result = (_a = await result) != null ? _a : true;
            } catch (error) {
              result = false;
            }
          }
          if (isBoolean(result)) {
            resolve(result);
          }
        } else {
          resolve(true);
        }
      });
      if (currentPromiseNumber === promiseNumber) {
        if (closed) {
          emit("ok");
          close();
        } else if (_okLoading.value) {
          _okLoading.value = false;
        }
      }
    };
    const handleCancel = () => {
      var _a;
      let result = true;
      if (isFunction(props.onBeforeCancel)) {
        result = (_a = props.onBeforeCancel()) != null ? _a : false;
      }
      if (result) {
        emit("cancel");
        close();
      }
    };
    const handleMask = () => {
      if (props.maskClosable) {
        handleCancel();
      }
    };
    const handleOpen = () => {
      if (computedVisible.value) {
        emit("open");
      }
    };
    const handleClose = () => {
      if (!computedVisible.value) {
        mounted.value = false;
        resetOverflow();
        emit("close");
      }
    };
    const { setOverflowHidden, resetOverflow } = useOverflow(containerRef);
    onMounted(() => {
      if (computedVisible.value) {
        mounted.value = true;
        setOverflowHidden();
        addGlobalKeyDownListener();
      }
    });
    onBeforeUnmount(() => {
      resetOverflow();
      removeGlobalKeyDownListener();
    });
    watch(computedVisible, (visible) => {
      if (_visible.value !== visible) {
        _visible.value = visible;
      }
      if (visible) {
        emit("beforeOpen");
        mounted.value = true;
        setOverflowHidden();
        addGlobalKeyDownListener();
      } else {
        emit("beforeClose");
        removeGlobalKeyDownListener();
      }
    });
    const style = computed(() => {
      var _a;
      const style2 = __spreadValues29({
        [props.placement]: 0
      }, (_a = props.drawerStyle) != null ? _a : {});
      if (["right", "left"].includes(props.placement)) {
        style2.width = isNumber(props.width) ? `${props.width}px` : props.width;
      } else {
        style2.height = isNumber(props.height) ? `${props.height}px` : props.height;
      }
      return style2;
    });
    return {
      prefixCls,
      style,
      t: t2,
      mounted,
      computedVisible,
      mergedOkLoading,
      zIndex,
      handleOk,
      handleCancel,
      handleOpen,
      handleClose,
      handleMask,
      isFixed,
      teleportContainer
    };
  }
});
function _sfc_render79(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_close = resolveComponent("icon-close");
  const _component_icon_hover = resolveComponent("icon-hover");
  const _component_arco_button = resolveComponent("arco-button");
  const _component_client_only = resolveComponent("client-only");
  return openBlock(), createBlock(_component_client_only, null, {
    default: withCtx(() => [
      (openBlock(), createBlock(Teleport, {
        to: _ctx.teleportContainer,
        disabled: !_ctx.renderToBody
      }, [
        !_ctx.unmountOnClose || _ctx.computedVisible || _ctx.mounted ? withDirectives((openBlock(), createElementBlock("div", mergeProps({
          key: 0,
          class: `${_ctx.prefixCls}-container`,
          style: _ctx.isFixed ? { zIndex: _ctx.zIndex } : { zIndex: "inherit", position: "absolute" }
        }, _ctx.$attrs), [
          createVNode(Transition, {
            name: "fade-drawer",
            appear: ""
          }, {
            default: withCtx(() => [
              _ctx.mask ? withDirectives((openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(`${_ctx.prefixCls}-mask`),
                onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleMask && _ctx.handleMask(...args))
              }, null, 2)), [
                [vShow, _ctx.computedVisible]
              ]) : createCommentVNode("v-if", true)
            ]),
            _: 1
          }),
          createVNode(Transition, {
            name: `slide-${_ctx.placement}-drawer`,
            appear: "",
            onAfterEnter: _ctx.handleOpen,
            onAfterLeave: _ctx.handleClose
          }, {
            default: withCtx(() => [
              withDirectives(createBaseVNode("div", {
                class: normalizeClass(_ctx.prefixCls),
                style: normalizeStyle(_ctx.style)
              }, [
                _ctx.header ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(`${_ctx.prefixCls}-header`)
                }, [
                  renderSlot(_ctx.$slots, "header", {}, () => [
                    _ctx.$slots.title || _ctx.title ? (openBlock(), createElementBlock("div", {
                      key: 0,
                      class: normalizeClass(`${_ctx.prefixCls}-title`)
                    }, [
                      renderSlot(_ctx.$slots, "title", {}, () => [
                        createTextVNode(toDisplayString(_ctx.title), 1)
                      ])
                    ], 2)) : createCommentVNode("v-if", true),
                    _ctx.closable ? (openBlock(), createElementBlock("div", {
                      key: 1,
                      tabindex: "-1",
                      role: "button",
                      "aria-label": "Close",
                      class: normalizeClass(`${_ctx.prefixCls}-close-btn`),
                      onClick: _cache[1] || (_cache[1] = (...args) => _ctx.handleCancel && _ctx.handleCancel(...args))
                    }, [
                      createVNode(_component_icon_hover, null, {
                        default: withCtx(() => [
                          createVNode(_component_icon_close)
                        ]),
                        _: 1
                      })
                    ], 2)) : createCommentVNode("v-if", true)
                  ])
                ], 2)) : createCommentVNode("v-if", true),
                createBaseVNode("div", {
                  class: normalizeClass(`${_ctx.prefixCls}-body`)
                }, [
                  renderSlot(_ctx.$slots, "default")
                ], 2),
                _ctx.footer ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass(`${_ctx.prefixCls}-footer`)
                }, [
                  renderSlot(_ctx.$slots, "footer", {}, () => [
                    !_ctx.hideCancel ? (openBlock(), createBlock(_component_arco_button, mergeProps({ key: 0 }, _ctx.cancelButtonProps, { onClick: _ctx.handleCancel }), {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(_ctx.cancelText || _ctx.t("drawer.cancelText")), 1)
                      ]),
                      _: 1
                    }, 16, ["onClick"])) : createCommentVNode("v-if", true),
                    createVNode(_component_arco_button, mergeProps({
                      type: "primary",
                      loading: _ctx.mergedOkLoading
                    }, _ctx.okButtonProps, { onClick: _ctx.handleOk }), {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(_ctx.okText || _ctx.t("drawer.okText")), 1)
                      ]),
                      _: 1
                    }, 16, ["loading", "onClick"])
                  ])
                ], 2)) : createCommentVNode("v-if", true)
              ], 6), [
                [vShow, _ctx.computedVisible]
              ])
            ]),
            _: 3
          }, 8, ["name", "onAfterEnter", "onAfterLeave"])
        ], 16)), [
          [vShow, _ctx.computedVisible || _ctx.mounted]
        ]) : createCommentVNode("v-if", true)
      ], 8, ["to", "disabled"]))
    ]),
    _: 3
  });
}
var _Drawer = _export_sfc(_sfc_main79, [["render", _sfc_render79]]);

// node_modules/@arco-design/web-vue/es/drawer/index.js
var __defProp30 = Object.defineProperty;
var __getOwnPropSymbols30 = Object.getOwnPropertySymbols;
var __hasOwnProp30 = Object.prototype.hasOwnProperty;
var __propIsEnum30 = Object.prototype.propertyIsEnumerable;
var __defNormalProp30 = (obj, key, value) => key in obj ? __defProp30(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues30 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp30.call(b, prop))
      __defNormalProp30(a, prop, b[prop]);
  if (__getOwnPropSymbols30)
    for (var prop of __getOwnPropSymbols30(b)) {
      if (__propIsEnum30.call(b, prop))
        __defNormalProp30(a, prop, b[prop]);
    }
  return a;
};
var open = (config, appContext) => {
  let container2 = getOverlay("drawer");
  const handleOk = () => {
    if (vm.component) {
      vm.component.props.visible = false;
    }
    if (isFunction(config.onOk)) {
      config.onOk();
    }
  };
  const handleCancel = () => {
    if (vm.component) {
      vm.component.props.visible = false;
    }
    if (isFunction(config.onCancel)) {
      config.onCancel();
    }
  };
  const handleClose = async () => {
    await nextTick();
    if (container2) {
      render(null, container2);
      document.body.removeChild(container2);
    }
    container2 = null;
    if (isFunction(config.onClose)) {
      config.onClose();
    }
  };
  const handleReturnClose = () => {
    if (vm.component) {
      vm.component.props.visible = false;
    }
  };
  const defaultConfig = {
    visible: true,
    renderToBody: false,
    unmountOnClose: true,
    onOk: handleOk,
    onCancel: handleCancel,
    onClose: handleClose
  };
  const vm = createVNode(_Drawer, __spreadValues30(__spreadValues30(__spreadValues30({}, defaultConfig), omit(config, [
    "content",
    "title",
    "footer",
    "visible",
    "unmountOnClose",
    "onOk",
    "onCancel",
    "onClose"
  ])), {
    header: typeof config.header === "boolean" ? config.header : void 0,
    footer: typeof config.footer === "boolean" ? config.footer : void 0
  }), {
    default: getSlotFunction(config.content),
    header: typeof config.header !== "boolean" ? getSlotFunction(config.header) : void 0,
    title: getSlotFunction(config.title),
    footer: typeof config.footer !== "boolean" ? getSlotFunction(config.footer) : void 0
  });
  if (appContext != null ? appContext : Drawer._context) {
    vm.appContext = appContext != null ? appContext : Drawer._context;
  }
  render(vm, container2);
  document.body.appendChild(container2);
  return {
    close: handleReturnClose
  };
};
var Drawer = Object.assign(_Drawer, {
  open,
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Drawer.name, _Drawer);
    const drawerWithContext = {
      open: (config, appContext = app._context) => open(config, appContext)
    };
    app.config.globalProperties.$drawer = drawerWithContext;
  },
  _context: null
});

// node_modules/@arco-design/web-vue/es/form/form.js
var _sfc_main80 = defineComponent({
  name: "Form",
  props: {
    model: {
      type: Object,
      required: true
    },
    layout: {
      type: String,
      default: "horizontal"
    },
    size: {
      type: String
    },
    labelColProps: {
      type: Object,
      default: () => ({ span: 5, offset: 0 })
    },
    wrapperColProps: {
      type: Object,
      default: () => ({ span: 19, offset: 0 })
    },
    labelColStyle: Object,
    wrapperColStyle: Object,
    labelAlign: {
      type: String,
      default: "right"
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    rules: {
      type: Object
    },
    autoLabelWidth: {
      type: Boolean,
      default: false
    }
  },
  emits: {
    submit: (data, ev) => true,
    submitSuccess: (values, ev) => true,
    submitFailed: (data, ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("form");
    const {
      model,
      layout,
      disabled,
      labelAlign,
      labelColProps,
      wrapperColProps,
      labelColStyle,
      wrapperColStyle,
      size,
      rules
    } = toRefs(props);
    const { mergedSize } = useSize(size);
    const autoLabelWidth = computed(() => props.layout === "horizontal" && props.autoLabelWidth);
    const fields = [];
    const touchedFields = [];
    const labelWidth = reactive({});
    const maxLabelWidth = computed(() => Math.max(...Object.values(labelWidth)));
    const addField = (formItemInfo) => {
      if (formItemInfo && formItemInfo.field) {
        fields.push(formItemInfo);
      }
    };
    const removeField = (formItemInfo) => {
      if (formItemInfo && formItemInfo.field) {
        fields.splice(fields.indexOf(formItemInfo), 1);
      }
    };
    const setFields = (data) => {
      fields.forEach((field) => {
        if (data[field.field]) {
          field.setField(data[field.field]);
        }
      });
    };
    const setLabelWidth = (width, uid) => {
      if (uid && labelWidth[uid] !== width) {
        labelWidth[uid] = width;
      }
    };
    const removeLabelWidth = (uid) => {
      if (uid) {
        delete labelWidth[uid];
      }
    };
    const resetFields = (field) => {
      const _fields = field ? [].concat(field) : [];
      fields.forEach((field2) => {
        if (_fields.length === 0 || _fields.includes(field2.field)) {
          field2.resetField();
        }
      });
    };
    const clearValidate = (field) => {
      const _fields = field ? [].concat(field) : [];
      fields.forEach((field2) => {
        if (_fields.length === 0 || _fields.includes(field2.field)) {
          field2.clearValidate();
        }
      });
    };
    const validate3 = (callback) => {
      const list = [];
      fields.forEach((field) => {
        list.push(field.validate());
      });
      return Promise.all(list).then((result) => {
        const errors = {};
        let hasError = false;
        result.forEach((item) => {
          if (item) {
            hasError = true;
            errors[item.field] = item;
          }
        });
        if (isFunction(callback)) {
          callback(hasError ? errors : void 0);
        }
        return hasError ? errors : void 0;
      });
    };
    const validateField = (field, callback) => {
      const list = [];
      for (const ctx of fields) {
        if (isArray(field) && field.includes(ctx.field) || field === ctx.field) {
          list.push(ctx.validate());
        }
      }
      return Promise.all(list).then((result) => {
        const errors = {};
        let hasError = false;
        result.forEach((item) => {
          if (item) {
            hasError = true;
            errors[item.field] = item;
          }
        });
        if (isFunction(callback)) {
          callback(hasError ? errors : void 0);
        }
        return hasError ? errors : void 0;
      });
    };
    const handleSubmit = (e2) => {
      const list = [];
      fields.forEach((field) => {
        list.push(field.validate());
      });
      Promise.all(list).then((result) => {
        const errors = {};
        let hasError = false;
        result.forEach((item) => {
          if (item) {
            hasError = true;
            errors[item.field] = item;
          }
        });
        if (hasError) {
          emit("submitFailed", { values: model.value, errors }, e2);
        } else {
          emit("submitSuccess", model.value, e2);
        }
        emit("submit", { values: model.value, errors: hasError ? errors : void 0 }, e2);
      });
    };
    provide(formInjectionKey, reactive({
      layout,
      disabled,
      labelAlign,
      labelColProps,
      wrapperColProps,
      labelColStyle,
      wrapperColStyle,
      model,
      size: mergedSize,
      rules,
      fields,
      touchedFields,
      addField,
      removeField,
      validateField,
      setLabelWidth,
      removeLabelWidth,
      maxLabelWidth,
      autoLabelWidth
    }));
    const cls = computed(() => [
      prefixCls,
      `${prefixCls}-layout-${props.layout}`,
      `${prefixCls}-size-${mergedSize.value}`,
      {
        [`${prefixCls}-auto-label-width`]: props.autoLabelWidth
      }
    ]);
    return {
      cls,
      handleSubmit,
      innerValidate: validate3,
      innerValidateField: validateField,
      innerResetFields: resetFields,
      innerClearValidate: clearValidate,
      innerSetFields: setFields
    };
  },
  methods: {
    validate(callback) {
      return this.innerValidate(callback);
    },
    validateField(field, callback) {
      return this.innerValidateField(field, callback);
    },
    resetFields(field) {
      return this.innerResetFields(field);
    },
    clearValidate(field) {
      return this.innerClearValidate(field);
    },
    setFields(data) {
      return this.innerSetFields(data);
    }
  }
});
function _sfc_render80(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("form", {
    class: normalizeClass(_ctx.cls),
    onSubmit: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.handleSubmit && _ctx.handleSubmit(...args), ["prevent"]))
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 34);
}
var _Form = _export_sfc(_sfc_main80, [["render", _sfc_render80]]);

// node_modules/b-validate/es/is.js
var opt2 = Object.prototype.toString;
function isArray2(obj) {
  return opt2.call(obj) === "[object Array]";
}
function isObject2(obj) {
  return opt2.call(obj) === "[object Object]";
}
function isString2(obj) {
  return opt2.call(obj) === "[object String]";
}
function isNumber2(obj) {
  return opt2.call(obj) === "[object Number]" && obj === obj;
}
function isBoolean2(obj) {
  return opt2.call(obj) === "[object Boolean]";
}
function isFunction2(obj) {
  return opt2.call(obj) === "[object Function]";
}
function isEmptyObject2(obj) {
  return isObject2(obj) && Object.keys(obj).length === 0;
}
function isEmptyValue(obj) {
  return obj === void 0 || obj === null || obj === "";
}
function isEmptyArray(obj) {
  return isArray2(obj) && !obj.length;
}
var isEqual2 = function(obj, other) {
  if (typeof obj !== "object" || typeof other !== "object") {
    return obj === other;
  }
  if (isFunction2(obj) && isFunction2(other)) {
    return obj === other || obj.toString() === other.toString();
  }
  if (Object.keys(obj).length !== Object.keys(other).length) {
    return false;
  }
  for (var key in obj) {
    var result = isEqual2(obj[key], other[key]);
    if (!result) {
      return false;
    }
  }
  return true;
};

// node_modules/b-validate/es/util.js
var mergeTemplate = function(defaultValidateMessages, validateMessages) {
  var result = Object.assign({}, defaultValidateMessages);
  Object.keys(validateMessages || {}).forEach(function(key) {
    var defaultValue = result[key];
    var newValue = validateMessages === null || validateMessages === void 0 ? void 0 : validateMessages[key];
    result[key] = isObject2(defaultValue) ? Object.assign(Object.assign({}, defaultValue), newValue) : newValue || defaultValue;
  });
  return result;
};
var getTemplate = function(validateMessages, keyPath) {
  var keys = keyPath.split(".");
  var result = validateMessages;
  for (var i2 = 0; i2 < keys.length; i2++) {
    result = result && result[keys[i2]];
    if (result === void 0) {
      return result;
    }
  }
  return result;
};

// node_modules/b-validate/es/locale/en-US.js
var defaultTypeTemplate = "#{field} is not a #{type} type";
var defaultValidateLocale = {
  required: "#{field} is required",
  type: {
    ip: defaultTypeTemplate,
    email: defaultTypeTemplate,
    url: defaultTypeTemplate,
    string: defaultTypeTemplate,
    number: defaultTypeTemplate,
    array: defaultTypeTemplate,
    object: defaultTypeTemplate,
    boolean: defaultTypeTemplate
  },
  number: {
    min: "`#{value}` is not greater than `#{min}`",
    max: "`#{value}` is not less than `#{max}`",
    equal: "`#{value}` is not equal to `#{equal}`",
    range: "`#{value}` is not in range `#{min} ~ #{max}`",
    positive: "`#{value}` is not a positive number",
    negative: "`#{value}` is not a negative number"
  },
  string: {
    maxLength: "#{field} cannot be longer than #{maxLength} characters",
    minLength: "#{field} must be at least #{minLength} characters",
    length: "#{field} must be exactly #{length} characters",
    match: "`#{value}` does not match pattern #{pattern}",
    uppercase: "`#{value}` must be all uppercase",
    lowercase: "`#{value}` must be all lowercased"
  },
  array: {
    length: "#{field} must be exactly #{length} in length",
    minLength: "#{field} cannot be less than #{minLength} in length",
    maxLength: "#{field} cannot be greater than #{maxLength} in length",
    includes: "#{field} is not includes #{includes}",
    deepEqual: "#{field} is not deep equal with #{deepEqual}",
    empty: "#{field} is not an empty array"
  },
  object: {
    deepEqual: "#{field} is not deep equal to expected value",
    hasKeys: "#{field} does not contain required fields",
    empty: "#{field} is not an empty object"
  },
  boolean: {
    true: "Expect true but got `#{value}`",
    false: "Expect false but got `#{value}`"
  }
};

// node_modules/b-validate/es/rules/base.js
var Base = function Base2(obj, options) {
  var this$1$1 = this;
  this.getValidateMsg = function(keyPath, info) {
    if (info === void 0)
      info = {};
    var data = Object.assign(Object.assign({}, info), { value: this$1$1.obj, field: this$1$1.field, type: this$1$1.type });
    var template = getTemplate(this$1$1.validateMessages, keyPath);
    if (isFunction2(template)) {
      return template(data);
    }
    if (isString2(template)) {
      return template.replace(/\#\{.+?\}/g, function(variable) {
        var key = variable.slice(2, -1);
        if (key in data) {
          if (isObject2(data[key]) || isArray2(data[key])) {
            try {
              return JSON.stringify(data[key]);
            } catch (_) {
              return data[key];
            }
          }
          return String(data[key]);
        }
        return variable;
      });
    }
    return template;
  };
  if (isObject2(options) && isString2(obj) && options.trim) {
    this.obj = obj.trim();
  } else if (isObject2(options) && options.ignoreEmptyString && obj === "") {
    this.obj = void 0;
  } else {
    this.obj = obj;
  }
  this.message = options.message;
  this.type = options.type;
  this.error = null;
  this.field = options.field || options.type;
  this.validateMessages = mergeTemplate(defaultValidateLocale, options.validateMessages);
};
var prototypeAccessors = { not: { configurable: true }, isRequired: { configurable: true }, end: { configurable: true } };
prototypeAccessors.not.get = function() {
  this._not = !this._not;
  return this;
};
prototypeAccessors.isRequired.get = function() {
  if (isEmptyValue(this.obj) || isEmptyArray(this.obj)) {
    var message2 = this.getValidateMsg("required");
    this.error = {
      value: this.obj,
      type: this.type,
      requiredError: true,
      message: this.message || (isObject2(message2) ? message2 : (this._not ? "[NOT MODE]:" : "") + message2)
    };
  }
  return this;
};
prototypeAccessors.end.get = function() {
  return this.error;
};
Base.prototype.addError = function addError(message2) {
  if (!this.error && message2) {
    this.error = {
      value: this.obj,
      type: this.type,
      message: this.message || (isObject2(message2) ? message2 : (this._not ? "[NOT MODE]:" : "") + message2)
    };
  }
};
Base.prototype.validate = function validate(expression, errorMessage) {
  var _expression = this._not ? expression : !expression;
  if (_expression) {
    this.addError(errorMessage);
  }
  return this;
};
Base.prototype.collect = function collect(callback) {
  callback && callback(this.error);
};
Object.defineProperties(Base.prototype, prototypeAccessors);

// node_modules/b-validate/es/rules/string.js
var StringValidator = function(Base4) {
  function StringValidator2(obj, options) {
    Base4.call(this, obj, Object.assign(Object.assign({}, options), { type: "string" }));
    this.validate(options && options.strict ? isString2(this.obj) : true, this.getValidateMsg("type.string"));
  }
  if (Base4)
    StringValidator2.__proto__ = Base4;
  StringValidator2.prototype = Object.create(Base4 && Base4.prototype);
  StringValidator2.prototype.constructor = StringValidator2;
  var prototypeAccessors2 = { uppercase: { configurable: true }, lowercase: { configurable: true } };
  StringValidator2.prototype.maxLength = function maxLength(length) {
    return this.obj ? this.validate(this.obj.length <= length, this.getValidateMsg("string.maxLength", { maxLength: length })) : this;
  };
  StringValidator2.prototype.minLength = function minLength(length) {
    return this.obj ? this.validate(this.obj.length >= length, this.getValidateMsg("string.minLength", { minLength: length })) : this;
  };
  StringValidator2.prototype.length = function length(length$1) {
    return this.obj ? this.validate(this.obj.length === length$1, this.getValidateMsg("string.length", { length: length$1 })) : this;
  };
  StringValidator2.prototype.match = function match(pattern) {
    var isRegex = pattern instanceof RegExp;
    if (isRegex) {
      pattern.lastIndex = 0;
    }
    return this.validate(this.obj === void 0 || isRegex && pattern.test(this.obj), this.getValidateMsg("string.match", { pattern }));
  };
  prototypeAccessors2.uppercase.get = function() {
    return this.obj ? this.validate(this.obj.toUpperCase() === this.obj, this.getValidateMsg("string.uppercase")) : this;
  };
  prototypeAccessors2.lowercase.get = function() {
    return this.obj ? this.validate(this.obj.toLowerCase() === this.obj, this.getValidateMsg("string.lowercase")) : this;
  };
  Object.defineProperties(StringValidator2.prototype, prototypeAccessors2);
  return StringValidator2;
}(Base);

// node_modules/b-validate/es/rules/number.js
var NumberValidator = function(Base4) {
  function NumberValidator2(obj, options) {
    Base4.call(this, obj, Object.assign(Object.assign({}, options), { type: "number" }));
    this.validate(options && options.strict ? isNumber2(this.obj) : true, this.getValidateMsg("type.number"));
  }
  if (Base4)
    NumberValidator2.__proto__ = Base4;
  NumberValidator2.prototype = Object.create(Base4 && Base4.prototype);
  NumberValidator2.prototype.constructor = NumberValidator2;
  var prototypeAccessors2 = { positive: { configurable: true }, negative: { configurable: true } };
  NumberValidator2.prototype.min = function min(num) {
    return !isEmptyValue(this.obj) ? this.validate(this.obj >= num, this.getValidateMsg("number.min", { min: num })) : this;
  };
  NumberValidator2.prototype.max = function max(num) {
    return !isEmptyValue(this.obj) ? this.validate(this.obj <= num, this.getValidateMsg("number.max", { max: num })) : this;
  };
  NumberValidator2.prototype.equal = function equal(num) {
    return !isEmptyValue(this.obj) ? this.validate(this.obj === num, this.getValidateMsg("number.equal", { equal: num })) : this;
  };
  NumberValidator2.prototype.range = function range(min, max) {
    return !isEmptyValue(this.obj) ? this.validate(this.obj >= min && this.obj <= max, this.getValidateMsg("number.range", { min, max })) : this;
  };
  prototypeAccessors2.positive.get = function() {
    return !isEmptyValue(this.obj) ? this.validate(this.obj > 0, this.getValidateMsg("number.positive")) : this;
  };
  prototypeAccessors2.negative.get = function() {
    return !isEmptyValue(this.obj) ? this.validate(this.obj < 0, this.getValidateMsg("number.negative")) : this;
  };
  Object.defineProperties(NumberValidator2.prototype, prototypeAccessors2);
  return NumberValidator2;
}(Base);

// node_modules/b-validate/es/rules/array.js
var ArrayValidator = function(Base4) {
  function ArrayValidator2(obj, options) {
    Base4.call(this, obj, Object.assign(Object.assign({}, options), { type: "array" }));
    this.validate(options && options.strict ? isArray2(this.obj) : true, this.getValidateMsg("type.array", { value: this.obj, type: this.type }));
  }
  if (Base4)
    ArrayValidator2.__proto__ = Base4;
  ArrayValidator2.prototype = Object.create(Base4 && Base4.prototype);
  ArrayValidator2.prototype.constructor = ArrayValidator2;
  var prototypeAccessors2 = { empty: { configurable: true } };
  ArrayValidator2.prototype.length = function length(num) {
    return this.obj ? this.validate(this.obj.length === num, this.getValidateMsg("array.length", { value: this.obj, length: num })) : this;
  };
  ArrayValidator2.prototype.minLength = function minLength(num) {
    return this.obj ? this.validate(this.obj.length >= num, this.getValidateMsg("array.minLength", { value: this.obj, minLength: num })) : this;
  };
  ArrayValidator2.prototype.maxLength = function maxLength(num) {
    return this.obj ? this.validate(this.obj.length <= num, this.getValidateMsg("array.maxLength", { value: this.obj, maxLength: num })) : this;
  };
  ArrayValidator2.prototype.includes = function includes(arrays) {
    var this$1$1 = this;
    return this.obj ? this.validate(arrays.every(function(el) {
      return this$1$1.obj.indexOf(el) !== -1;
    }), this.getValidateMsg("array.includes", {
      value: this.obj,
      includes: arrays
    })) : this;
  };
  ArrayValidator2.prototype.deepEqual = function deepEqual(other) {
    return this.obj ? this.validate(isEqual2(this.obj, other), this.getValidateMsg("array.deepEqual", { value: this.obj, deepEqual: other })) : this;
  };
  prototypeAccessors2.empty.get = function() {
    return this.validate(isEmptyArray(this.obj), this.getValidateMsg("array.empty", { value: this.obj }));
  };
  Object.defineProperties(ArrayValidator2.prototype, prototypeAccessors2);
  return ArrayValidator2;
}(Base);

// node_modules/b-validate/es/rules/object.js
var ObjectValidator = function(Base4) {
  function ObjectValidator2(obj, options) {
    Base4.call(this, obj, Object.assign(Object.assign({}, options), { type: "object" }));
    this.validate(options && options.strict ? isObject2(this.obj) : true, this.getValidateMsg("type.object"));
  }
  if (Base4)
    ObjectValidator2.__proto__ = Base4;
  ObjectValidator2.prototype = Object.create(Base4 && Base4.prototype);
  ObjectValidator2.prototype.constructor = ObjectValidator2;
  var prototypeAccessors2 = { empty: { configurable: true } };
  ObjectValidator2.prototype.deepEqual = function deepEqual(other) {
    return this.obj ? this.validate(isEqual2(this.obj, other), this.getValidateMsg("object.deepEqual", { deepEqual: other })) : this;
  };
  ObjectValidator2.prototype.hasKeys = function hasKeys(keys) {
    var this$1$1 = this;
    return this.obj ? this.validate(keys.every(function(el) {
      return this$1$1.obj[el];
    }), this.getValidateMsg("object.hasKeys", { keys })) : this;
  };
  prototypeAccessors2.empty.get = function() {
    return this.validate(isEmptyObject2(this.obj), this.getValidateMsg("object.empty"));
  };
  Object.defineProperties(ObjectValidator2.prototype, prototypeAccessors2);
  return ObjectValidator2;
}(Base);

// node_modules/b-validate/es/rules/boolean.js
var BooleanValidator = function(Base4) {
  function BooleanValidator2(obj, options) {
    Base4.call(this, obj, Object.assign(Object.assign({}, options), { type: "boolean" }));
    this.validate(options && options.strict ? isBoolean2(this.obj) : true, this.getValidateMsg("type.boolean"));
  }
  if (Base4)
    BooleanValidator2.__proto__ = Base4;
  BooleanValidator2.prototype = Object.create(Base4 && Base4.prototype);
  BooleanValidator2.prototype.constructor = BooleanValidator2;
  var prototypeAccessors2 = { true: { configurable: true }, false: { configurable: true } };
  prototypeAccessors2.true.get = function() {
    return this.validate(this.obj === true, this.getValidateMsg("boolean.true"));
  };
  prototypeAccessors2.false.get = function() {
    return this.validate(this.obj === false, this.getValidateMsg("boolean.false"));
  };
  Object.defineProperties(BooleanValidator2.prototype, prototypeAccessors2);
  return BooleanValidator2;
}(Base);

// node_modules/b-validate/es/rules/type.js
var regexEmail = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var regexUrl = new RegExp("^(?!mailto:)(?:(?:http|https|ftp)://)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$", "i");
var regexIp = /^(2(5[0-5]{1}|[0-4]\d{1})|[0-1]?\d{1,2})(\.(2(5[0-5]{1}|[0-4]\d{1})|[0-1]?\d{1,2})){3}$/;
var TypeValidator = function(Base4) {
  function TypeValidator2(obj, options) {
    Base4.call(this, obj, Object.assign(Object.assign({}, options), { type: "type" }));
  }
  if (Base4)
    TypeValidator2.__proto__ = Base4;
  TypeValidator2.prototype = Object.create(Base4 && Base4.prototype);
  TypeValidator2.prototype.constructor = TypeValidator2;
  var prototypeAccessors2 = { email: { configurable: true }, url: { configurable: true }, ip: { configurable: true } };
  prototypeAccessors2.email.get = function() {
    this.type = "email";
    return this.validate(this.obj === void 0 || regexEmail.test(this.obj), this.getValidateMsg("type.email"));
  };
  prototypeAccessors2.url.get = function() {
    this.type = "url";
    return this.validate(this.obj === void 0 || regexUrl.test(this.obj), this.getValidateMsg("type.url"));
  };
  prototypeAccessors2.ip.get = function() {
    this.type = "ip";
    return this.validate(this.obj === void 0 || regexIp.test(this.obj), this.getValidateMsg("type.ip"));
  };
  Object.defineProperties(TypeValidator2.prototype, prototypeAccessors2);
  return TypeValidator2;
}(Base);

// node_modules/b-validate/es/rules/custom.js
var CustomValidator = function(Base4) {
  function CustomValidator2(obj, options) {
    Base4.call(this, obj, Object.assign(Object.assign({}, options), { type: "custom" }));
  }
  if (Base4)
    CustomValidator2.__proto__ = Base4;
  CustomValidator2.prototype = Object.create(Base4 && Base4.prototype);
  CustomValidator2.prototype.constructor = CustomValidator2;
  var prototypeAccessors2 = { validate: { configurable: true } };
  prototypeAccessors2.validate.get = function() {
    var _this = this;
    return function(validator, callback) {
      var ret;
      if (validator) {
        ret = validator(_this.obj, _this.addError.bind(_this));
        if (ret && ret.then) {
          if (callback) {
            ret.then(function() {
              callback && callback(_this.error);
            }, function(e2) {
              console.error(e2);
            });
          }
          return [ret, _this];
        } else {
          callback && callback(_this.error);
          return _this.error;
        }
      }
    };
  };
  Object.defineProperties(CustomValidator2.prototype, prototypeAccessors2);
  return CustomValidator2;
}(Base);

// node_modules/b-validate/es/index.js
var BValidate = function(obj, options) {
  return new Validate(obj, Object.assign({ field: "value" }, options));
};
BValidate.globalConfig = {};
BValidate.setGlobalConfig = function(options) {
  BValidate.globalConfig = options || {};
};
var Validate = function Validate2(obj, _options) {
  var globalConfig = BValidate.globalConfig;
  var options = Object.assign(Object.assign(Object.assign({}, globalConfig), _options), { validateMessages: mergeTemplate(globalConfig.validateMessages, _options.validateMessages) });
  this.string = new StringValidator(obj, options);
  this.number = new NumberValidator(obj, options);
  this.array = new ArrayValidator(obj, options);
  this.object = new ObjectValidator(obj, options);
  this.boolean = new BooleanValidator(obj, options);
  this.type = new TypeValidator(obj, options);
  this.custom = new CustomValidator(obj, options);
};
var Schema = function Schema2(schema, options) {
  if (options === void 0)
    options = {};
  this.schema = schema;
  this.options = options;
};
Schema.prototype.messages = function messages(validateMessages) {
  this.options = Object.assign(Object.assign({}, this.options), { validateMessages: mergeTemplate(this.options.validateMessages, validateMessages) });
};
Schema.prototype.validate = function validate2(values, callback) {
  var this$1$1 = this;
  if (!isObject2(values)) {
    return;
  }
  var promises = [];
  var errors = null;
  function setError(key, error) {
    if (!errors) {
      errors = {};
    }
    if (!errors[key] || error.requiredError) {
      errors[key] = error;
    }
  }
  if (this.schema) {
    Object.keys(this.schema).forEach(function(key) {
      if (isArray2(this$1$1.schema[key])) {
        var loop = function(i3) {
          var rule = this$1$1.schema[key][i3];
          var type = rule.type;
          var message2 = rule.message;
          if (!type && !rule.validator) {
            throw "You must specify a type to field " + key + "!";
          }
          var _options = Object.assign(Object.assign({}, this$1$1.options), { message: message2, field: key });
          if ("ignoreEmptyString" in rule) {
            _options.ignoreEmptyString = rule.ignoreEmptyString;
          }
          if ("strict" in rule) {
            _options.strict = rule.strict;
          }
          var validator = new Validate(values[key], _options);
          var bv = validator.type[type] || null;
          if (!bv) {
            if (rule.validator) {
              bv = validator.custom.validate(rule.validator);
              if (Object.prototype.toString.call(bv) === "[object Array]" && bv[0].then) {
                promises.push({
                  function: bv[0],
                  _this: bv[1],
                  key
                });
              } else if (bv) {
                setError(key, bv);
              }
              return;
            } else {
              bv = validator[type];
            }
          }
          Object.keys(rule).forEach(function(r2) {
            if (rule.required) {
              bv = bv.isRequired;
            }
            if (r2 !== "message" && bv[r2] && rule[r2] && typeof bv[r2] === "object") {
              bv = bv[r2];
            }
            if (bv[r2] && rule[r2] !== void 0 && typeof bv[r2] === "function") {
              bv = bv[r2](rule[r2]);
            }
          });
          bv.collect(function(error) {
            if (error) {
              setError(key, error);
            }
          });
          if (errors) {
            return "break";
          }
        };
        for (var i2 = 0; i2 < this$1$1.schema[key].length; i2++) {
          var returned = loop(i2);
          if (returned === "break")
            break;
        }
      }
    });
  }
  if (promises.length > 0) {
    Promise.all(promises.map(function(a) {
      return a.function;
    })).then(function() {
      promises.forEach(function(promise) {
        if (promise._this.error) {
          setError(promise.key, promise._this.error);
        }
      });
      callback && callback(errors);
    });
  } else {
    callback && callback(errors);
  }
};

// node_modules/@arco-design/web-vue/es/grid/context.js
var RowContextInjectionKey = Symbol("RowContextInjectionKey");
var GridContextInjectionKey = Symbol("GridContextInjectionKey");
var GridDataCollectorInjectionKey = Symbol("GridDataCollectorInjectionKey");

// node_modules/@arco-design/web-vue/es/grid/grid-row.js
var _sfc_main81 = defineComponent({
  name: "Row",
  props: {
    gutter: {
      type: [Number, Object, Array],
      default: 0
    },
    justify: {
      type: String,
      default: "start"
    },
    align: {
      type: String,
      default: "start"
    },
    div: {
      type: Boolean
    },
    wrap: {
      type: Boolean,
      default: true
    }
  },
  setup(props) {
    const { gutter, align, justify, div, wrap } = toRefs(props);
    const prefixCls = getPrefixCls("row");
    const classNames = computed(() => {
      return {
        [`${prefixCls}`]: !div.value,
        [`${prefixCls}-nowrap`]: !wrap.value,
        [`${prefixCls}-align-${align.value}`]: align.value,
        [`${prefixCls}-justify-${justify.value}`]: justify.value
      };
    });
    const propGutterHorizontal = computed(() => Array.isArray(gutter.value) ? gutter.value[0] : gutter.value);
    const propGutterVertical = computed(() => Array.isArray(gutter.value) ? gutter.value[1] : 0);
    const gutterHorizontal = useResponsiveState(propGutterHorizontal, 0);
    const gutterVertical = useResponsiveState(propGutterVertical, 0);
    const styles = computed(() => {
      const result = {};
      if ((gutterHorizontal.value || gutterVertical.value) && !div.value) {
        const marginHorizontal = -gutterHorizontal.value / 2;
        const marginVertical = -gutterVertical.value / 2;
        if (marginHorizontal) {
          result.marginLeft = `${marginHorizontal}px`;
          result.marginRight = `${marginHorizontal}px`;
        }
        if (marginVertical) {
          result.marginTop = `${marginVertical}px`;
          result.marginBottom = `${marginVertical}px`;
        }
      }
      return result;
    });
    const resultGutter = computed(() => [
      gutterHorizontal.value,
      gutterVertical.value
    ]);
    provide(RowContextInjectionKey, reactive({
      gutter: resultGutter,
      div
    }));
    return {
      classNames,
      styles
    };
  }
});
function _sfc_render81(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.classNames),
    style: normalizeStyle(_ctx.styles)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 6);
}
var Row = _export_sfc(_sfc_main81, [["render", _sfc_render81]]);

// node_modules/@arco-design/web-vue/es/grid/hook/use-responsive-value.js
function useResponsiveValue(props) {
  const value = computed(() => {
    const { val, key, xs, sm, md, lg, xl, xxl } = props.value;
    if (!xs && !sm && !md && !lg && !xl && !xxl) {
      return val;
    }
    const result = {};
    responsiveArray.forEach((breakpoint) => {
      const config = props.value[breakpoint];
      if (isNumber(config)) {
        result[breakpoint] = config;
      } else if (isObject(config) && isNumber(config[key])) {
        result[breakpoint] = config[key];
      }
    });
    return result;
  });
  return value;
}

// node_modules/@arco-design/web-vue/es/grid/grid-col.js
var __defProp31 = Object.defineProperty;
var __getOwnPropSymbols31 = Object.getOwnPropertySymbols;
var __hasOwnProp31 = Object.prototype.hasOwnProperty;
var __propIsEnum31 = Object.prototype.propertyIsEnumerable;
var __defNormalProp31 = (obj, key, value) => key in obj ? __defProp31(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues31 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp31.call(b, prop))
      __defNormalProp31(a, prop, b[prop]);
  if (__getOwnPropSymbols31)
    for (var prop of __getOwnPropSymbols31(b)) {
      if (__propIsEnum31.call(b, prop))
        __defNormalProp31(a, prop, b[prop]);
    }
  return a;
};
function getAllowableFlexValue(flexValue) {
  if (isString(flexValue) && (["initial", "auto", "none"].includes(flexValue) || /^\d+$/.test(flexValue)) || isNumber(flexValue)) {
    return flexValue;
  }
  if (isString(flexValue) && /^\d+(px|em|rem|%)$/.test(flexValue)) {
    return `0 0 ${flexValue}`;
  }
  return void 0;
}
var _sfc_main82 = defineComponent({
  name: "Col",
  props: {
    span: {
      type: Number,
      default: 24
    },
    offset: {
      type: Number
    },
    order: {
      type: Number
    },
    xs: {
      type: [Number, Object]
    },
    sm: {
      type: [Number, Object]
    },
    md: {
      type: [Number, Object]
    },
    lg: {
      type: [Number, Object]
    },
    xl: {
      type: [Number, Object]
    },
    xxl: {
      type: [Number, Object]
    },
    flex: {
      type: [Number, String]
    }
  },
  setup(props) {
    const prefixCls = getPrefixCls("col");
    const rowContext = inject(RowContextInjectionKey, {});
    const flexValue = computed(() => getAllowableFlexValue(props.flex));
    const mergeClassName = computed(() => {
      const { div } = rowContext;
      const { span: span2, offset, order, xs, sm, md, lg, xl, xxl } = props;
      const result = {
        [`${prefixCls}`]: !div,
        [`${prefixCls}-order-${order}`]: order,
        [`${prefixCls}-${span2}`]: !div && !xs && !sm && !md && !lg && !xl && !xxl,
        [`${prefixCls}-offset-${offset}`]: offset && offset > 0
      };
      const screenList = { xs, sm, md, lg, xl, xxl };
      Object.keys(screenList).forEach((screen) => {
        const screenValue = screenList[screen];
        if (screenValue && isNumber(screenValue)) {
          result[`${prefixCls}-${screen}-${screenValue}`] = true;
        } else if (screenValue && isObject(screenValue)) {
          result[`${prefixCls}-${screen}-${screenValue.span}`] = screenValue.span;
          result[`${prefixCls}-${screen}-offset-${screenValue.offset}`] = screenValue.offset;
          result[`${prefixCls}-${screen}-order-${screenValue.order}`] = screenValue.order;
        }
      });
      return result;
    });
    const classNames = computed(() => {
      return flexValue.value ? prefixCls : mergeClassName.value;
    });
    const paddingStyles = computed(() => {
      const { gutter, div } = rowContext;
      const result = {};
      if (Array.isArray(gutter) && !div) {
        const paddingHorizontal = gutter[0] && gutter[0] / 2 || 0;
        const paddingVertical = gutter[1] && gutter[1] / 2 || 0;
        if (paddingHorizontal) {
          result.paddingLeft = `${paddingHorizontal}px`;
          result.paddingRight = `${paddingHorizontal}px`;
        }
        if (paddingVertical) {
          result.paddingTop = `${paddingVertical}px`;
          result.paddingBottom = `${paddingVertical}px`;
        }
      }
      return result;
    });
    const flexStyles = computed(() => flexValue.value ? { flex: flexValue.value } : {});
    const responsiveConfig = computed(() => pick(props, responsiveArray));
    const propSpan = useResponsiveValue(computed(() => __spreadValues31({
      val: props.span,
      key: "span"
    }, responsiveConfig.value)));
    const span = useResponsiveState(propSpan, 24, true);
    return {
      visible: computed(() => !!span.value),
      classNames,
      styles: computed(() => __spreadValues31(__spreadValues31({}, paddingStyles.value), flexStyles.value))
    };
  }
});
function _sfc_render82(_ctx, _cache, $props, $setup, $data, $options) {
  return _ctx.visible ? (openBlock(), createElementBlock("div", {
    key: 0,
    class: normalizeClass(_ctx.classNames),
    style: normalizeStyle(_ctx.styles)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 6)) : createCommentVNode("v-if", true);
}
var Col = _export_sfc(_sfc_main82, [["render", _sfc_render82]]);

// node_modules/@arco-design/web-vue/es/grid/utils/index.js
function resolveItemData(cols, props) {
  var _a, _b;
  const originSpan = (_a = props.span) != null ? _a : 1;
  const originOffset = (_b = props.offset) != null ? _b : 0;
  const offset = Math.min(originOffset, cols);
  const span = Math.min(offset > 0 ? originSpan + originOffset : originSpan, cols);
  return {
    span,
    offset,
    suffix: "suffix" in props ? props.suffix !== false : false
  };
}
function setItemVisible({
  cols,
  collapsed,
  collapsedRows,
  itemDataList
}) {
  let overflow = false;
  let displayIndexList = [];
  function isOverflow(span) {
    return Math.ceil(span / cols) > collapsedRows;
  }
  if (collapsed) {
    let spanSum = 0;
    for (let i2 = 0; i2 < itemDataList.length; i2++) {
      if (itemDataList[i2].suffix) {
        spanSum += itemDataList[i2].span;
        displayIndexList.push(i2);
      }
    }
    if (!isOverflow(spanSum)) {
      let current = 0;
      while (current < itemDataList.length) {
        const item = itemDataList[current];
        if (!item.suffix) {
          spanSum += item.span;
          if (isOverflow(spanSum)) {
            break;
          }
          displayIndexList.push(current);
        }
        current++;
      }
    }
    overflow = itemDataList.some((item, index3) => !item.suffix && !displayIndexList.includes(index3));
  } else {
    displayIndexList = itemDataList.map((_, index3) => index3);
  }
  return {
    overflow,
    displayIndexList
  };
}

// node_modules/@arco-design/web-vue/es/grid/grid.js
var _sfc_main83 = defineComponent({
  name: "Grid",
  props: {
    cols: {
      type: [Number, Object],
      default: 24
    },
    rowGap: {
      type: [Number, Object],
      default: 0
    },
    colGap: {
      type: [Number, Object],
      default: 0
    },
    collapsed: {
      type: Boolean,
      default: false
    },
    collapsedRows: {
      type: Number,
      default: 1
    }
  },
  setup(props) {
    const {
      cols: propCols,
      rowGap: propRowGap,
      colGap: propColGap,
      collapsedRows,
      collapsed
    } = toRefs(props);
    const cols = useResponsiveState(propCols, 24);
    const colGap = useResponsiveState(propColGap, 0);
    const rowGap = useResponsiveState(propRowGap, 0);
    const prefixCls = getPrefixCls("grid");
    const classNames = computed(() => [prefixCls]);
    const style = computed(() => [
      {
        "gap": `${rowGap.value}px ${colGap.value}px`,
        "grid-template-columns": `repeat(${cols.value}, minmax(0px, 1fr))`
      }
    ]);
    const itemDataMap = reactive(/* @__PURE__ */ new Map());
    const itemDataList = computed(() => {
      const list = [];
      for (const [index3, itemData] of itemDataMap.entries()) {
        list[index3] = itemData;
      }
      return list;
    });
    const gridContext = reactive({
      overflow: false,
      displayIndexList: [],
      cols: cols.value,
      colGap: colGap.value
    });
    watchEffect(() => {
      gridContext.cols = cols.value;
      gridContext.colGap = colGap.value;
    });
    watchEffect(() => {
      const displayInfo = setItemVisible({
        cols: cols.value,
        collapsed: collapsed.value,
        collapsedRows: collapsedRows.value,
        itemDataList: itemDataList.value
      });
      gridContext.overflow = displayInfo.overflow;
      gridContext.displayIndexList = displayInfo.displayIndexList;
    });
    provide(GridContextInjectionKey, gridContext);
    provide(GridDataCollectorInjectionKey, {
      collectItemData(index3, itemData) {
        itemDataMap.set(index3, itemData);
      },
      removeItemData(index3) {
        itemDataMap.delete(index3);
      }
    });
    return {
      classNames,
      style
    };
  }
});
function _sfc_render83(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.classNames),
    style: normalizeStyle(_ctx.style)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 6);
}
var _Grid = _export_sfc(_sfc_main83, [["render", _sfc_render83]]);

// node_modules/@arco-design/web-vue/es/grid/grid-item.js
var __defProp32 = Object.defineProperty;
var __defProps15 = Object.defineProperties;
var __getOwnPropDescs15 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols32 = Object.getOwnPropertySymbols;
var __hasOwnProp32 = Object.prototype.hasOwnProperty;
var __propIsEnum32 = Object.prototype.propertyIsEnumerable;
var __defNormalProp32 = (obj, key, value) => key in obj ? __defProp32(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues32 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp32.call(b, prop))
      __defNormalProp32(a, prop, b[prop]);
  if (__getOwnPropSymbols32)
    for (var prop of __getOwnPropSymbols32(b)) {
      if (__propIsEnum32.call(b, prop))
        __defNormalProp32(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps15 = (a, b) => __defProps15(a, __getOwnPropDescs15(b));
var _sfc_main84 = defineComponent({
  name: "GridItem",
  props: {
    span: {
      type: [Number, Object],
      default: 1
    },
    offset: {
      type: [Number, Object],
      default: 0
    },
    suffix: {
      type: Boolean,
      default: false
    }
  },
  setup(props) {
    const prefixCls = getPrefixCls("grid-item");
    const domRef = ref();
    const { computedIndex } = useIndex({
      itemRef: domRef,
      selector: `.${prefixCls}`
    });
    const gridContext = inject(GridContextInjectionKey, {
      overflow: false,
      displayIndexList: [],
      cols: 24,
      colGap: 0
    });
    const gridDataCollector = inject(GridDataCollectorInjectionKey);
    const visible = computed(() => {
      var _a;
      return (_a = gridContext == null ? void 0 : gridContext.displayIndexList) == null ? void 0 : _a.includes(computedIndex.value);
    });
    const { span: propSpan, offset: propOffset } = toRefs(props);
    const rSpan = useResponsiveState(propSpan, 1);
    const rOffset = useResponsiveState(propOffset, 0);
    const itemData = computed(() => resolveItemData(gridContext.cols, __spreadProps15(__spreadValues32({}, props), {
      span: rSpan.value,
      offset: rOffset.value
    })));
    const classNames = computed(() => [prefixCls]);
    const offsetStyle = computed(() => {
      const { offset, span } = itemData.value;
      const { colGap } = gridContext;
      if (offset > 0) {
        const oneSpan = `(100% - ${colGap * (span - 1)}px) / ${span}`;
        return {
          "margin-left": `calc((${oneSpan} * ${offset}) + ${colGap * offset}px)`
        };
      }
      return {};
    });
    const columnStart = computed(() => {
      const { suffix, span } = itemData.value;
      const { cols } = gridContext;
      if (suffix) {
        return `${cols - span + 1}`;
      }
      return `span ${span}`;
    });
    const style = computed(() => {
      const { span } = itemData.value;
      return [
        {
          "grid-column": `${columnStart.value} / span ${span}`
        },
        offsetStyle.value,
        !visible.value || span === 0 ? { display: "none" } : {}
      ];
    });
    watchEffect(() => {
      if (computedIndex.value !== -1) {
        gridDataCollector == null ? void 0 : gridDataCollector.collectItemData(computedIndex.value, itemData.value);
      }
    });
    onUnmounted(() => {
      if (computedIndex.value !== -1) {
        gridDataCollector == null ? void 0 : gridDataCollector.removeItemData(computedIndex.value);
      }
    });
    return {
      classNames,
      style,
      domRef,
      overflow: computed(() => gridContext.overflow)
    };
  }
});
function _sfc_render84(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    ref: "domRef",
    class: normalizeClass(_ctx.classNames),
    style: normalizeStyle(_ctx.style)
  }, [
    renderSlot(_ctx.$slots, "default", { overflow: _ctx.overflow })
  ], 6);
}
var GridItem = _export_sfc(_sfc_main84, [["render", _sfc_render84]]);

// node_modules/@arco-design/web-vue/es/grid/index.js
var Grid = Object.assign(_Grid, {
  Row,
  Col,
  Item: GridItem,
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + Row.name, Row);
    app.component(componentPrefix + Col.name, Col);
    app.component(componentPrefix + _Grid.name, _Grid);
    app.component(componentPrefix + GridItem.name, GridItem);
  }
});

// node_modules/@arco-design/web-vue/es/tooltip/tooltip.js
var __defProp33 = Object.defineProperty;
var __getOwnPropSymbols33 = Object.getOwnPropertySymbols;
var __hasOwnProp33 = Object.prototype.hasOwnProperty;
var __propIsEnum33 = Object.prototype.propertyIsEnumerable;
var __defNormalProp33 = (obj, key, value) => key in obj ? __defProp33(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues33 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp33.call(b, prop))
      __defNormalProp33(a, prop, b[prop]);
  if (__getOwnPropSymbols33)
    for (var prop of __getOwnPropSymbols33(b)) {
      if (__propIsEnum33.call(b, prop))
        __defNormalProp33(a, prop, b[prop]);
    }
  return a;
};
var _sfc_main85 = defineComponent({
  name: "Tooltip",
  components: {
    Trigger
  },
  props: {
    popupVisible: {
      type: Boolean,
      default: void 0
    },
    defaultPopupVisible: {
      type: Boolean,
      default: false
    },
    content: String,
    position: {
      type: String,
      default: "top"
    },
    mini: {
      type: Boolean,
      default: false
    },
    backgroundColor: {
      type: String
    },
    contentClass: {
      type: [String, Array, Object]
    },
    contentStyle: {
      type: Object
    },
    arrowClass: {
      type: [String, Array, Object]
    },
    arrowStyle: {
      type: Object
    },
    popupContainer: {
      type: [String, Object]
    }
  },
  emits: {
    "update:popupVisible": (visible) => true,
    "popupVisibleChange": (visible) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("tooltip");
    const _popupVisible = ref(props.defaultPopupVisible);
    const computedPopupVisible = computed(() => {
      var _a;
      return (_a = props.popupVisible) != null ? _a : _popupVisible.value;
    });
    const handlePopupVisibleChange = (visible) => {
      _popupVisible.value = visible;
      emit("update:popupVisible", visible);
      emit("popupVisibleChange", visible);
    };
    const contentCls = computed(() => [
      `${prefixCls}-content`,
      props.contentClass,
      { [`${prefixCls}-mini`]: props.mini }
    ]);
    const computedContentStyle = computed(() => {
      if (props.backgroundColor || props.contentStyle) {
        return __spreadValues33({
          backgroundColor: props.backgroundColor
        }, props.contentStyle);
      }
      return void 0;
    });
    const arrowCls = computed(() => [
      `${prefixCls}-popup-arrow`,
      props.arrowClass
    ]);
    const computedArrowStyle = computed(() => {
      if (props.backgroundColor || props.arrowStyle) {
        return __spreadValues33({
          backgroundColor: props.backgroundColor
        }, props.arrowStyle);
      }
      return void 0;
    });
    return {
      prefixCls,
      computedPopupVisible,
      contentCls,
      computedContentStyle,
      arrowCls,
      computedArrowStyle,
      handlePopupVisibleChange
    };
  }
});
function _sfc_render85(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Trigger = resolveComponent("Trigger");
  return openBlock(), createBlock(_component_Trigger, {
    class: normalizeClass(_ctx.prefixCls),
    trigger: "hover",
    position: _ctx.position,
    "popup-visible": _ctx.computedPopupVisible,
    "popup-offset": 10,
    "show-arrow": "",
    "content-class": _ctx.contentCls,
    "content-style": _ctx.computedContentStyle,
    "arrow-class": _ctx.arrowCls,
    "arrow-style": _ctx.computedArrowStyle,
    "popup-container": _ctx.popupContainer,
    "animation-name": "zoom-in-fade-out",
    "auto-fit-transform-origin": "",
    role: "tooltip",
    onPopupVisibleChange: _ctx.handlePopupVisibleChange
  }, {
    content: withCtx(() => [
      renderSlot(_ctx.$slots, "content", {}, () => [
        createTextVNode(toDisplayString(_ctx.content), 1)
      ])
    ]),
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 8, ["class", "position", "popup-visible", "content-class", "content-style", "arrow-class", "arrow-style", "popup-container", "onPopupVisibleChange"]);
}
var _Tooltip = _export_sfc(_sfc_main85, [["render", _sfc_render85]]);

// node_modules/@arco-design/web-vue/es/tooltip/index.js
var Tooltip = Object.assign(_Tooltip, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Tooltip.name, _Tooltip);
  }
});

// node_modules/@arco-design/web-vue/es/icon/icon-question-circle/icon-question-circle.js
var _sfc_main86 = defineComponent({
  name: "IconQuestionCircle",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-question-circle`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_139 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_229 = createBaseVNode("path", { d: "M42 24c0 9.941-8.059 18-18 18S6 33.941 6 24 14.059 6 24 6s18 8.059 18 18Z" }, null, -1);
var _hoisted_327 = createBaseVNode("path", { d: "M24.006 31v4.008m0-6.008L24 28c0-3 3-4 4.78-6.402C30.558 19.195 28.288 15 23.987 15c-4.014 0-5.382 2.548-5.388 4.514v.465" }, null, -1);
var _hoisted_46 = [
  _hoisted_229,
  _hoisted_327
];
function _sfc_render86(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_46, 14, _hoisted_139);
}
var _IconQuestionCircle = _export_sfc(_sfc_main86, [["render", _sfc_render86]]);

// node_modules/@arco-design/web-vue/es/icon/icon-question-circle/index.js
var IconQuestionCircle = Object.assign(_IconQuestionCircle, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconQuestionCircle.name, _IconQuestionCircle);
  }
});

// node_modules/@arco-design/web-vue/es/form/form-item-label.js
var _sfc_main87 = defineComponent({
  name: "FormItemLabel",
  components: {
    ResizeObserver: ResizeObserver3,
    Tooltip,
    IconQuestionCircle
  },
  props: {
    required: {
      type: Boolean,
      default: false
    },
    showColon: {
      type: Boolean,
      default: false
    },
    component: {
      type: String,
      default: "label"
    },
    asteriskPosition: {
      type: String,
      default: "start"
    },
    tooltip: {
      type: String
    },
    attrs: Object
  },
  setup() {
    const prefixCls = getPrefixCls("form-item-label");
    const formCtx = inject(formInjectionKey, void 0);
    const instance = getCurrentInstance();
    const labelRef = ref();
    const handleResize = () => {
      if (labelRef.value && isNumber(labelRef.value.offsetWidth)) {
        formCtx == null ? void 0 : formCtx.setLabelWidth(labelRef.value.offsetWidth, instance == null ? void 0 : instance.uid);
      }
    };
    onMounted(() => {
      if (labelRef.value && isNumber(labelRef.value.offsetWidth)) {
        formCtx == null ? void 0 : formCtx.setLabelWidth(labelRef.value.offsetWidth, instance == null ? void 0 : instance.uid);
      }
    });
    onBeforeUnmount(() => {
      formCtx == null ? void 0 : formCtx.removeLabelWidth(instance == null ? void 0 : instance.uid);
    });
    return {
      prefixCls,
      labelRef,
      handleResize
    };
  }
});
var _hoisted_140 = createBaseVNode("svg", {
  fill: "currentColor",
  viewBox: "0 0 1024 1024",
  width: "1em",
  height: "1em"
}, [
  createBaseVNode("path", { d: "M583.338667 17.066667c18.773333 0 34.133333 15.36 34.133333 34.133333v349.013333l313.344-101.888a34.133333 34.133333 0 0 1 43.008 22.016l42.154667 129.706667a34.133333 34.133333 0 0 1-21.845334 43.178667l-315.733333 102.4 208.896 287.744a34.133333 34.133333 0 0 1-7.509333 47.786666l-110.421334 80.213334a34.133333 34.133333 0 0 1-47.786666-7.509334L505.685333 706.218667 288.426667 1005.226667a34.133333 34.133333 0 0 1-47.786667 7.509333l-110.421333-80.213333a34.133333 34.133333 0 0 1-7.509334-47.786667l214.186667-295.253333L29.013333 489.813333a34.133333 34.133333 0 0 1-22.016-43.008l42.154667-129.877333a34.133333 34.133333 0 0 1 43.008-22.016l320.512 104.106667L412.672 51.2c0-18.773333 15.36-34.133333 34.133333-34.133333h136.533334z" })
], -1);
var _hoisted_230 = [
  _hoisted_140
];
var _hoisted_328 = createBaseVNode("svg", {
  fill: "currentColor",
  viewBox: "0 0 1024 1024",
  width: "1em",
  height: "1em"
}, [
  createBaseVNode("path", { d: "M583.338667 17.066667c18.773333 0 34.133333 15.36 34.133333 34.133333v349.013333l313.344-101.888a34.133333 34.133333 0 0 1 43.008 22.016l42.154667 129.706667a34.133333 34.133333 0 0 1-21.845334 43.178667l-315.733333 102.4 208.896 287.744a34.133333 34.133333 0 0 1-7.509333 47.786666l-110.421334 80.213334a34.133333 34.133333 0 0 1-47.786666-7.509334L505.685333 706.218667 288.426667 1005.226667a34.133333 34.133333 0 0 1-47.786667 7.509333l-110.421333-80.213333a34.133333 34.133333 0 0 1-7.509334-47.786667l214.186667-295.253333L29.013333 489.813333a34.133333 34.133333 0 0 1-22.016-43.008l42.154667-129.877333a34.133333 34.133333 0 0 1 43.008-22.016l320.512 104.106667L412.672 51.2c0-18.773333 15.36-34.133333 34.133333-34.133333h136.533334z" })
], -1);
var _hoisted_47 = [
  _hoisted_328
];
function _sfc_render87(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_question_circle = resolveComponent("icon-question-circle");
  const _component_Tooltip = resolveComponent("Tooltip");
  const _component_ResizeObserver = resolveComponent("ResizeObserver");
  return openBlock(), createBlock(_component_ResizeObserver, { onResize: _ctx.handleResize }, {
    default: withCtx(() => [
      (openBlock(), createBlock(resolveDynamicComponent(_ctx.component), mergeProps({
        ref: "labelRef",
        class: _ctx.prefixCls
      }, _ctx.attrs), {
        default: withCtx(() => [
          _ctx.required && _ctx.asteriskPosition === "start" ? (openBlock(), createElementBlock("strong", {
            key: 0,
            class: normalizeClass(`${_ctx.prefixCls}-required-symbol`)
          }, _hoisted_230, 2)) : createCommentVNode("v-if", true),
          renderSlot(_ctx.$slots, "default"),
          _ctx.tooltip ? (openBlock(), createBlock(_component_Tooltip, {
            key: 1,
            content: _ctx.tooltip
          }, {
            default: withCtx(() => [
              createVNode(_component_icon_question_circle, {
                class: normalizeClass(`${_ctx.prefixCls}-tooltip`)
              }, null, 8, ["class"])
            ]),
            _: 1
          }, 8, ["content"])) : createCommentVNode("v-if", true),
          _ctx.required && _ctx.asteriskPosition === "end" ? (openBlock(), createElementBlock("strong", {
            key: 2,
            class: normalizeClass(`${_ctx.prefixCls}-required-symbol`)
          }, _hoisted_47, 2)) : createCommentVNode("v-if", true),
          createTextVNode(" " + toDisplayString(_ctx.showColon ? ":" : ""), 1)
        ]),
        _: 3
      }, 16, ["class"]))
    ]),
    _: 3
  }, 8, ["onResize"]);
}
var FormItemLabel = _export_sfc(_sfc_main87, [["render", _sfc_render87]]);

// node_modules/@arco-design/web-vue/es/form/form-item-message.js
var _sfc_main88 = defineComponent({
  name: "FormItemMessage",
  props: {
    error: Array,
    help: String
  },
  setup() {
    const prefixCls = getPrefixCls("form-item-message");
    return {
      prefixCls
    };
  }
});
function _sfc_render88(_ctx, _cache, $props, $setup, $data, $options) {
  return _ctx.help || _ctx.$slots.help ? (openBlock(), createBlock(Transition, {
    key: 0,
    name: "form-blink",
    appear: ""
  }, {
    default: withCtx(() => [
      createBaseVNode("div", {
        class: normalizeClass([_ctx.prefixCls, `${_ctx.prefixCls}-help`])
      }, [
        renderSlot(_ctx.$slots, "help", {}, () => [
          createTextVNode(toDisplayString(_ctx.help), 1)
        ])
      ], 2)
    ]),
    _: 3
  })) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(_ctx.error, (item) => {
    return openBlock(), createBlock(Transition, {
      key: item,
      name: "form-blink",
      appear: ""
    }, {
      default: withCtx(() => [
        createBaseVNode("div", {
          role: "alert",
          class: normalizeClass([_ctx.prefixCls])
        }, toDisplayString(item), 3)
      ]),
      _: 2
    }, 1024);
  }), 128));
}
var FormItemMessage = _export_sfc(_sfc_main88, [["render", _sfc_render88]]);

// node_modules/@arco-design/web-vue/es/form/interface.js
var VALIDATE_STATUSES = [
  "success",
  "warning",
  "error",
  "validating"
];

// node_modules/@arco-design/web-vue/es/form/utils.js
var getFinalValidateStatus = (validateStatus) => {
  let status = "";
  for (const key of Object.keys(validateStatus)) {
    const _status = validateStatus[key];
    if (_status) {
      if (!status || VALIDATE_STATUSES.indexOf(_status) > VALIDATE_STATUSES.indexOf(status)) {
        status = validateStatus[key];
      }
    }
  }
  return status;
};
var getFinalValidateMessage = (validateMessage) => {
  const messages2 = [];
  for (const key of Object.keys(validateMessage)) {
    const _message = validateMessage[key];
    if (_message) {
      messages2.push(_message);
    }
  }
  return messages2;
};

// node_modules/@arco-design/web-vue/es/form/form-item.js
var __defProp34 = Object.defineProperty;
var __getOwnPropSymbols34 = Object.getOwnPropertySymbols;
var __hasOwnProp34 = Object.prototype.hasOwnProperty;
var __propIsEnum34 = Object.prototype.propertyIsEnumerable;
var __defNormalProp34 = (obj, key, value) => key in obj ? __defProp34(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues34 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp34.call(b, prop))
      __defNormalProp34(a, prop, b[prop]);
  if (__getOwnPropSymbols34)
    for (var prop of __getOwnPropSymbols34(b)) {
      if (__propIsEnum34.call(b, prop))
        __defNormalProp34(a, prop, b[prop]);
    }
  return a;
};
var __objRest = (source, exclude) => {
  var target3 = {};
  for (var prop in source)
    if (__hasOwnProp34.call(source, prop) && exclude.indexOf(prop) < 0)
      target3[prop] = source[prop];
  if (source != null && __getOwnPropSymbols34)
    for (var prop of __getOwnPropSymbols34(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum34.call(source, prop))
        target3[prop] = source[prop];
    }
  return target3;
};
var _sfc_main89 = defineComponent({
  name: "FormItem",
  components: {
    ArcoRow: Row,
    ArcoCol: Col,
    FormItemLabel,
    FormItemMessage
  },
  props: {
    field: {
      type: String,
      default: ""
    },
    label: String,
    tooltip: {
      type: String
    },
    showColon: {
      type: Boolean,
      default: false
    },
    noStyle: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    help: String,
    extra: String,
    required: {
      type: Boolean,
      default: false
    },
    asteriskPosition: {
      type: String,
      default: "start"
    },
    rules: {
      type: [Object, Array]
    },
    validateStatus: {
      type: String
    },
    validateTrigger: {
      type: [String, Array],
      default: "change"
    },
    labelColProps: Object,
    wrapperColProps: Object,
    hideLabel: {
      type: Boolean,
      default: false
    },
    hideAsterisk: {
      type: Boolean,
      default: false
    },
    labelColStyle: Object,
    wrapperColStyle: Object,
    rowProps: Object,
    rowClass: [String, Array, Object],
    contentClass: [String, Array, Object],
    contentFlex: {
      type: Boolean,
      default: true
    },
    mergeProps: {
      type: [Boolean, Function],
      default: true
    },
    labelColFlex: {
      type: [Number, String]
    },
    feedback: {
      type: Boolean,
      default: false
    },
    labelComponent: {
      type: String,
      default: "label"
    },
    labelAttrs: Object
  },
  setup(props) {
    const prefixCls = getPrefixCls("form-item");
    const { field } = toRefs(props);
    const formCtx = inject(formInjectionKey, {});
    const { autoLabelWidth, layout } = toRefs(formCtx);
    const mergedLabelCol = computed(() => {
      var _a;
      const colProps = __spreadValues34({}, (_a = props.labelColProps) != null ? _a : formCtx.labelColProps);
      if (props.labelColFlex) {
        colProps.flex = props.labelColFlex;
      } else if (formCtx.autoLabelWidth) {
        colProps.flex = `${formCtx.maxLabelWidth}px`;
      }
      return colProps;
    });
    const mergedWrapperCol = computed(() => {
      var _a;
      const colProps = __spreadValues34({}, (_a = props.wrapperColProps) != null ? _a : formCtx.wrapperColProps);
      if (props.labelColFlex || formCtx.autoLabelWidth) {
        colProps.flex = "auto";
      }
      return colProps;
    });
    const mergedLabelStyle = computed(() => {
      var _a;
      return (_a = props.labelColStyle) != null ? _a : formCtx.labelColStyle;
    });
    const mergedWrapperStyle = computed(() => {
      var _a;
      return (_a = props.wrapperColStyle) != null ? _a : formCtx.wrapperColStyle;
    });
    const initialValue = getValueByPath(formCtx.model, props.field);
    const validateStatus = reactive({});
    const validateMessage = reactive({});
    const finalStatus = computed(() => getFinalValidateStatus(validateStatus));
    const finalMessage = computed(() => getFinalValidateMessage(validateMessage));
    const validateDisabled = ref(false);
    const fieldValue = computed(() => getValueByPath(formCtx.model, props.field));
    const computedDisabled = computed(() => {
      var _a;
      return Boolean((_a = props.disabled) != null ? _a : formCtx == null ? void 0 : formCtx.disabled);
    });
    const computedValidateStatus = computed(() => {
      var _a;
      return (_a = props.validateStatus) != null ? _a : finalStatus.value;
    });
    const isError = computed(() => finalStatus.value === "error");
    const mergedRules = computed(() => {
      var _a, _b, _c;
      const baseRules = [].concat((_c = (_b = props.rules) != null ? _b : (_a = formCtx == null ? void 0 : formCtx.rules) == null ? void 0 : _a[props.field]) != null ? _c : []);
      const hasRequiredRule = baseRules.some((item) => item.required);
      if (props.required && !hasRequiredRule) {
        return [{ required: true }].concat(baseRules);
      }
      return baseRules;
    });
    const isRequired = computed(() => mergedRules.value.some((item) => item.required));
    const formItemCtx = props.noStyle ? inject(formItemInjectionKey, void 0) : void 0;
    const updateValidateState = (field2, { status, message: message2 }) => {
      validateStatus[field2] = status;
      validateMessage[field2] = message2;
      if (props.noStyle) {
        formItemCtx == null ? void 0 : formItemCtx.updateValidateState(field2, { status, message: message2 });
      }
    };
    const computedFeedback = computed(() => props.feedback && computedValidateStatus.value ? computedValidateStatus.value : void 0);
    const validateField = () => {
      if (validateDisabled.value) {
        return Promise.resolve();
      }
      const rules = mergedRules.value;
      if (!field.value || rules.length === 0) {
        if (finalStatus.value) {
          clearValidate();
        }
        return Promise.resolve();
      }
      const _field = field.value;
      const _value = fieldValue.value;
      updateValidateState(_field, {
        status: "",
        message: ""
      });
      const schema = new Schema({
        [_field]: rules.map((_a) => {
          var rule = __objRest(_a, []);
          if (!rule.type && !rule.validator) {
            rule.type = "string";
          }
          return rule;
        })
      }, { ignoreEmptyString: true });
      return new Promise((resolve) => {
        schema.validate({ [_field]: _value }, (err) => {
          var _a;
          const isError2 = Boolean(err == null ? void 0 : err[_field]);
          updateValidateState(_field, {
            status: isError2 ? "error" : "",
            message: (_a = err == null ? void 0 : err[_field].message) != null ? _a : ""
          });
          const error = isError2 ? {
            label: props.label,
            field: field.value,
            value: err[_field].value,
            type: err[_field].type,
            isRequiredError: Boolean(err[_field].requiredError),
            message: err[_field].message
          } : void 0;
          resolve(error);
        });
      });
    };
    const validateTriggers = computed(() => [].concat(props.validateTrigger));
    const eventHandlers = computed(() => validateTriggers.value.reduce((event, trigger) => {
      switch (trigger) {
        case "change":
          event.onChange = () => {
            validateField();
          };
          return event;
        case "input":
          event.onInput = () => {
            nextTick(() => {
              validateField();
            });
          };
          return event;
        case "focus":
          event.onFocus = () => {
            validateField();
          };
          return event;
        case "blur":
          event.onBlur = () => {
            validateField();
          };
          return event;
        default:
          return event;
      }
    }, {}));
    provide(formItemInjectionKey, reactive({
      eventHandlers,
      size: formCtx && toRef(formCtx, "size"),
      disabled: computedDisabled,
      error: isError,
      feedback: computedFeedback,
      updateValidateState
    }));
    const clearValidate = () => {
      if (field.value) {
        updateValidateState(field.value, {
          status: "",
          message: ""
        });
      }
    };
    const setField = (data) => {
      var _a, _b;
      if (field.value) {
        validateDisabled.value = true;
        if ("value" in data && (formCtx == null ? void 0 : formCtx.model) && field.value) {
          setValueByPath(formCtx.model, field.value, data.value);
        }
        if (data.status || data.message) {
          updateValidateState(field.value, {
            status: (_a = data.status) != null ? _a : "",
            message: (_b = data.message) != null ? _b : ""
          });
        }
        nextTick(() => {
          validateDisabled.value = false;
        });
      }
    };
    const resetField = () => {
      clearValidate();
      validateDisabled.value = true;
      if ((formCtx == null ? void 0 : formCtx.model) && field.value) {
        setValueByPath(formCtx.model, field.value, initialValue);
      }
      nextTick(() => {
        validateDisabled.value = false;
      });
    };
    const formItemInfo = reactive({
      field,
      disabled: computedDisabled,
      error: isError,
      validate: validateField,
      clearValidate,
      resetField,
      setField
    });
    onMounted(() => {
      var _a;
      if (formItemInfo.field) {
        (_a = formCtx.addField) == null ? void 0 : _a.call(formCtx, formItemInfo);
      }
    });
    onBeforeUnmount(() => {
      var _a;
      if (formItemInfo.field) {
        (_a = formCtx.removeField) == null ? void 0 : _a.call(formCtx, formItemInfo);
      }
    });
    const cls = computed(() => [
      prefixCls,
      `${prefixCls}-layout-${formCtx.layout}`,
      {
        [`${prefixCls}-error`]: isError.value,
        [`${prefixCls}-status-${computedValidateStatus.value}`]: Boolean(computedValidateStatus.value)
      },
      props.rowClass
    ]);
    const labelColCls = computed(() => [
      `${prefixCls}-label-col`,
      {
        [`${prefixCls}-label-col-left`]: formCtx.labelAlign === "left",
        [`${prefixCls}-label-col-flex`]: formCtx.autoLabelWidth || props.labelColFlex
      }
    ]);
    const wrapperColCls = computed(() => [
      `${prefixCls}-wrapper-col`,
      {
        [`${prefixCls}-wrapper-col-flex`]: !mergedWrapperCol.value
      }
    ]);
    return {
      prefixCls,
      cls,
      isRequired,
      isError,
      finalMessage,
      mergedLabelCol,
      mergedWrapperCol,
      labelColCls,
      autoLabelWidth,
      layout,
      mergedLabelStyle,
      wrapperColCls,
      mergedWrapperStyle
    };
  }
});
function _sfc_render89(_ctx, _cache, $props, $setup, $data, $options) {
  var _a;
  const _component_FormItemLabel = resolveComponent("FormItemLabel");
  const _component_ArcoCol = resolveComponent("ArcoCol");
  const _component_FormItemMessage = resolveComponent("FormItemMessage");
  const _component_ArcoRow = resolveComponent("ArcoRow");
  return _ctx.noStyle ? renderSlot(_ctx.$slots, "default", { key: 0 }) : (openBlock(), createBlock(_component_ArcoRow, mergeProps({
    key: 1,
    class: [
      _ctx.cls,
      {
        [`${_ctx.prefixCls}-has-help`]: Boolean((_a = _ctx.$slots.help) != null ? _a : _ctx.help)
      }
    ],
    wrap: !(_ctx.labelColFlex || _ctx.autoLabelWidth),
    div: _ctx.layout !== "horizontal" || _ctx.hideLabel
  }, _ctx.rowProps), {
    default: withCtx(() => [
      !_ctx.hideLabel ? (openBlock(), createBlock(_component_ArcoCol, mergeProps({
        key: 0,
        class: _ctx.labelColCls,
        style: _ctx.mergedLabelStyle
      }, _ctx.mergedLabelCol), {
        default: withCtx(() => [
          createVNode(_component_FormItemLabel, {
            required: _ctx.hideAsterisk ? false : _ctx.isRequired,
            "show-colon": _ctx.showColon,
            "asterisk-position": _ctx.asteriskPosition,
            component: _ctx.labelComponent,
            attrs: _ctx.labelAttrs,
            tooltip: _ctx.tooltip
          }, {
            default: withCtx(() => [
              _ctx.$slots.label || _ctx.label ? renderSlot(_ctx.$slots, "label", { key: 0 }, () => [
                createTextVNode(toDisplayString(_ctx.label), 1)
              ]) : createCommentVNode("v-if", true)
            ]),
            _: 3
          }, 8, ["required", "show-colon", "asterisk-position", "component", "attrs", "tooltip"])
        ]),
        _: 3
      }, 16, ["class", "style"])) : createCommentVNode("v-if", true),
      createVNode(_component_ArcoCol, mergeProps({
        class: _ctx.wrapperColCls,
        style: _ctx.mergedWrapperStyle
      }, _ctx.mergedWrapperCol), {
        default: withCtx(() => [
          createBaseVNode("div", {
            class: normalizeClass(`${_ctx.prefixCls}-content-wrapper`)
          }, [
            createBaseVNode("div", {
              class: normalizeClass([
                `${_ctx.prefixCls}-content`,
                {
                  [`${_ctx.prefixCls}-content-flex`]: _ctx.contentFlex
                },
                _ctx.contentClass
              ])
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2)
          ], 2),
          _ctx.isError || _ctx.$slots.help || _ctx.help ? (openBlock(), createBlock(_component_FormItemMessage, {
            key: 0,
            error: _ctx.finalMessage,
            help: _ctx.help
          }, createSlots({ _: 2 }, [
            _ctx.$slots.help ? {
              name: "help",
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, "help")
              ])
            } : void 0
          ]), 1032, ["error", "help"])) : createCommentVNode("v-if", true),
          _ctx.$slots.extra || _ctx.extra ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: normalizeClass(`${_ctx.prefixCls}-extra`)
          }, [
            renderSlot(_ctx.$slots, "extra", {}, () => [
              createTextVNode(toDisplayString(_ctx.extra), 1)
            ])
          ], 2)) : createCommentVNode("v-if", true)
        ]),
        _: 3
      }, 16, ["class", "style"])
    ]),
    _: 3
  }, 16, ["class", "wrap", "div"]));
}
var FormItem = _export_sfc(_sfc_main89, [["render", _sfc_render89]]);

// node_modules/@arco-design/web-vue/es/form/index.js
var Form = Object.assign(_Form, {
  Item: FormItem,
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Form.name, _Form);
    app.component(componentPrefix + FormItem.name, FormItem);
  }
});

// node_modules/@arco-design/web-vue/es/icon-component/icon.js
var _sfc_main90 = defineComponent({
  name: "Icon",
  props: {
    type: String,
    size: [Number, String],
    rotate: Number,
    spin: Boolean
  },
  setup(props) {
    const prefixCls = getPrefixCls("icon");
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const cls = computed(() => [
      prefixCls,
      {
        [`${prefixCls}-loading`]: props.spin
      },
      props.type
    ]);
    return {
      cls,
      innerStyle
    };
  }
});
function _sfc_render90(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    fill: "currentColor"
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 6);
}
var _Icon = _export_sfc(_sfc_main90, [["render", _sfc_render90]]);

// node_modules/@arco-design/web-vue/es/icon-component/add-from-icon-font-cn.js
function _isSlot3(s) {
  return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
var scriptUrlCache = [];
var addFromIconFontCn = (options) => {
  const {
    src,
    extraProps = {}
  } = options;
  if (!isServerRendering && (src == null ? void 0 : src.length) && !scriptUrlCache.includes(src)) {
    const script = document.createElement("script");
    script.setAttribute("src", src);
    script.setAttribute("data-namespace", src);
    scriptUrlCache.push(src);
    document.body.appendChild(script);
  }
  return defineComponent({
    name: "IconFont",
    props: {
      type: String,
      size: [Number, String],
      rotate: Number,
      spin: Boolean
    },
    setup(props, {
      slots
    }) {
      return () => {
        var _a;
        const children = props.type ? createVNode("use", {
          "xlink:href": `#${props.type}`
        }, null) : (_a = slots.default) == null ? void 0 : _a.call(slots);
        return createVNode(_Icon, mergeProps(props, extraProps), _isSlot3(children) ? children : {
          default: () => [children]
        });
      };
    }
  });
};

// node_modules/@arco-design/web-vue/es/icon-component/index.js
var Icon = Object.assign(_Icon, {
  addFromIconFontCn,
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Icon.name, _Icon);
  }
});

// node_modules/@arco-design/web-vue/es/image/image-footer.js
var _sfc_main91 = defineComponent({
  name: "ImageFooter",
  props: {
    title: {
      type: String
    },
    description: {
      type: String
    }
  },
  setup() {
    const prefixCls = getPrefixCls("image-footer");
    return {
      prefixCls
    };
  }
});
var _hoisted_141 = ["title"];
var _hoisted_231 = ["title"];
function _sfc_render91(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.prefixCls)
  }, [
    _ctx.title || _ctx.description ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(`${_ctx.prefixCls}-caption`)
    }, [
      _ctx.title ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(`${_ctx.prefixCls}-caption-title`),
        title: _ctx.title
      }, toDisplayString(_ctx.title), 11, _hoisted_141)) : createCommentVNode("v-if", true),
      _ctx.description ? (openBlock(), createElementBlock("div", {
        key: 1,
        class: normalizeClass(`${_ctx.prefixCls}-caption-description`),
        title: _ctx.description
      }, toDisplayString(_ctx.description), 11, _hoisted_231)) : createCommentVNode("v-if", true)
    ], 2)) : createCommentVNode("v-if", true),
    _ctx.$slots.extra ? (openBlock(), createElementBlock("div", {
      key: 1,
      class: normalizeClass(`${_ctx.prefixCls}-extra`)
    }, [
      renderSlot(_ctx.$slots, "extra")
    ], 2)) : createCommentVNode("v-if", true)
  ], 2);
}
var ImageFooter = _export_sfc(_sfc_main91, [["render", _sfc_render91]]);

// node_modules/@arco-design/web-vue/es/image/preview-arrow.js
var _sfc_main92 = defineComponent({
  name: "ImagePreviewArrow",
  components: {
    IconLeft,
    IconRight
  },
  props: {
    onPrev: {
      type: Function
    },
    onNext: {
      type: Function
    }
  },
  setup() {
    const prefixCls = getPrefixCls("image-preview-arrow");
    return {
      prefixCls
    };
  }
});
function _sfc_render92(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_left = resolveComponent("icon-left");
  const _component_icon_right = resolveComponent("icon-right");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.prefixCls)
  }, [
    createBaseVNode("div", {
      class: normalizeClass([
        `${_ctx.prefixCls}-left`,
        {
          [`${_ctx.prefixCls}-disabled`]: !_ctx.onPrev
        }
      ]),
      onClick: _cache[0] || (_cache[0] = (e2) => {
        e2.preventDefault();
        _ctx.onPrev && _ctx.onPrev();
      })
    }, [
      createVNode(_component_icon_left)
    ], 2),
    createBaseVNode("div", {
      class: normalizeClass([
        `${_ctx.prefixCls}-right`,
        {
          [`${_ctx.prefixCls}-disabled`]: !_ctx.onNext
        }
      ]),
      onClick: _cache[1] || (_cache[1] = (e2) => {
        e2.preventDefault();
        _ctx.onNext && _ctx.onNext();
      })
    }, [
      createVNode(_component_icon_right)
    ], 2)
  ], 2);
}
var PreviewArrow = _export_sfc(_sfc_main92, [["render", _sfc_render92]]);

// node_modules/@arco-design/web-vue/es/image/preview-action.js
function _isSlot4(s) {
  return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
var _ImagePreviewAction = defineComponent({
  name: "ImagePreviewAction",
  components: {
    Tooltip
  },
  inheritAttrs: false,
  props: {
    name: {
      type: String
    },
    disabled: {
      type: Boolean
    }
  },
  setup(props, {
    slots,
    attrs
  }) {
    const prefixCls = getPrefixCls("image-preview-toolbar-action");
    return () => {
      var _a;
      const {
        name,
        disabled
      } = props;
      const children = (_a = slots.default) == null ? void 0 : _a.call(slots);
      if (!children || !children.length)
        return null;
      const content = createVNode("div", mergeProps({
        "class": [`${prefixCls}`, {
          [`${prefixCls}-disabled`]: disabled
        }],
        "onMousedown": (e2) => {
          e2.preventDefault();
        }
      }, attrs), [createVNode("span", {
        "class": `${prefixCls}-content`
      }, [children])]);
      return name ? createVNode(Tooltip, {
        "class": `${prefixCls}-tooltip`,
        "content": name
      }, _isSlot4(content) ? content : {
        default: () => [content]
      }) : content;
    };
  }
});

// node_modules/@arco-design/web-vue/es/image/preview-toolbar.vue_vue&type=script&lang.js
var _sfc_main93 = defineComponent({
  name: "ImagePreviewToolbar",
  components: {
    RenderFunction,
    PreviewAction: _ImagePreviewAction
  },
  props: {
    actions: {
      type: Array,
      default: () => []
    },
    actionsLayout: {
      type: Array,
      default: () => []
    }
  },
  setup(props) {
    const {
      actions,
      actionsLayout
    } = toRefs(props);
    const prefixCls = getPrefixCls("image-preview-toolbar");
    const resultActions = computed(() => {
      const actionsLayoutSet = new Set(actionsLayout.value);
      const filterWithLayout = (item) => actionsLayoutSet.has(item.key);
      const filteredActions = actions.value.filter(filterWithLayout);
      return filteredActions.sort((pre, cur) => {
        const preIndex = actionsLayout.value.indexOf(pre.key);
        const curIndex = actionsLayout.value.indexOf(cur.key);
        return preIndex > curIndex ? 1 : -1;
      });
    });
    return {
      prefixCls,
      resultActions
    };
  }
});

// node_modules/@arco-design/web-vue/es/image/preview-toolbar.js
function _sfc_render93(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_RenderFunction = resolveComponent("RenderFunction");
  const _component_PreviewAction = resolveComponent("PreviewAction");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.prefixCls)
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.resultActions, (action) => {
      return openBlock(), createBlock(_component_PreviewAction, {
        key: action.key,
        name: action.name,
        disabled: action.disabled,
        onClick: action.onClick
      }, {
        default: withCtx(() => [
          createVNode(_component_RenderFunction, {
            "render-func": action.content
          }, null, 8, ["render-func"])
        ]),
        _: 2
      }, 1032, ["name", "disabled", "onClick"]);
    }), 128)),
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
var PreviewToolbar = _export_sfc(_sfc_main93, [["render", _sfc_render93]]);

// node_modules/@arco-design/web-vue/es/image/hooks/use-image-load-status.js
function useImageLoadStatus(defaultValue) {
  const status = ref(defaultValue || "beforeLoad");
  const isBeforeLoad = computed(() => status.value === "beforeLoad");
  const isLoading = computed(() => status.value === "loading");
  const isError = computed(() => status.value === "error");
  const isLoaded = computed(() => status.value === "loaded");
  return {
    status,
    isBeforeLoad,
    isLoading,
    isError,
    isLoaded,
    setLoadStatus: (newStatus) => {
      status.value = newStatus;
    }
  };
}

// node_modules/@arco-design/web-vue/es/image/utils/get-fix-translate.js
function getFixTranslate(wrapperRect, imgRect, translateX, translateY, scale) {
  let fixTranslateX = translateX;
  let fixTranslateY = translateY;
  if (translateX) {
    if (wrapperRect.width > imgRect.width) {
      fixTranslateX = 0;
    } else {
      if (imgRect.left > wrapperRect.left) {
        fixTranslateX -= Math.abs(wrapperRect.left - imgRect.left) / scale;
      }
      if (imgRect.right < wrapperRect.right) {
        fixTranslateX += Math.abs(wrapperRect.right - imgRect.right) / scale;
      }
    }
  }
  if (translateY) {
    if (wrapperRect.height > imgRect.height) {
      fixTranslateY = 0;
    } else {
      if (imgRect.top > wrapperRect.top) {
        fixTranslateY -= Math.abs(wrapperRect.top - imgRect.top) / scale;
      }
      if (imgRect.bottom < wrapperRect.bottom) {
        fixTranslateY += Math.abs(wrapperRect.bottom - imgRect.bottom) / scale;
      }
    }
  }
  return [fixTranslateX, fixTranslateY];
}

// node_modules/@arco-design/web-vue/es/image/hooks/use-image-drag.js
function useImageDrag(props) {
  const { wrapperEl, imageEl, scale } = toRefs(props);
  const translate = ref([0, 0]);
  const moving = ref(false);
  let startPageX = 0;
  let startPageY = 0;
  let startTranslate = [0, 0];
  const checkAndFixTranslate = () => {
    if (!wrapperEl.value || !imageEl.value)
      return;
    const wrapperRect = wrapperEl.value.getBoundingClientRect();
    const imgRect = imageEl.value.getBoundingClientRect();
    const [x, y] = getFixTranslate(wrapperRect, imgRect, translate.value[0], translate.value[1], scale.value);
    if (x !== translate.value[0] || y !== translate.value[1]) {
      translate.value = [x, y];
    }
  };
  const onMoving = (e2) => {
    e2.preventDefault && e2.preventDefault();
    const nextX = startTranslate[0] + (e2.pageX - startPageX) / scale.value;
    const nextY = startTranslate[1] + (e2.pageY - startPageY) / scale.value;
    translate.value = [nextX, nextY];
  };
  const onMoveEnd = (e2) => {
    e2.preventDefault && e2.preventDefault();
    moving.value = false;
    checkAndFixTranslate();
    offEvents();
  };
  const onMoveStart = (e2) => {
    if (e2.target !== e2.currentTarget)
      return;
    e2.preventDefault && e2.preventDefault();
    moving.value = true;
    startPageX = e2.pageX;
    startPageY = e2.pageY;
    startTranslate = [...translate.value];
    on(window, "mousemove", onMoving, false);
    on(window, "mouseup", onMoveEnd, false);
  };
  function offEvents() {
    off(window, "mousemove", onMoving, false);
    off(window, "mouseup", onMoveEnd, false);
  }
  watchEffect((onInvalidate) => {
    imageEl.value && on(imageEl.value, "mousedown", onMoveStart);
    onInvalidate(() => {
      imageEl.value && off(imageEl.value, "mousedown", onMoveStart);
      offEvents();
    });
  });
  watch([scale], () => {
    nextTick(() => checkAndFixTranslate());
  });
  return {
    translate,
    moving,
    resetTranslate() {
      translate.value = [0, 0];
    }
  };
}

// node_modules/@arco-design/web-vue/es/icon/icon-zoom-out/icon-zoom-out.js
var _sfc_main94 = defineComponent({
  name: "IconZoomOut",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-zoom-out`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_142 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_232 = createBaseVNode("path", { d: "M32.607 32.607A14.953 14.953 0 0 0 37 22c0-8.284-6.716-15-15-15-8.284 0-15 6.716-15 15 0 8.284 6.716 15 15 15 4.142 0 7.892-1.679 10.607-4.393Zm0 0L41.5 41.5M29 22H15" }, null, -1);
var _hoisted_329 = [
  _hoisted_232
];
function _sfc_render94(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_329, 14, _hoisted_142);
}
var _IconZoomOut = _export_sfc(_sfc_main94, [["render", _sfc_render94]]);

// node_modules/@arco-design/web-vue/es/icon/icon-zoom-out/index.js
var IconZoomOut = Object.assign(_IconZoomOut, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconZoomOut.name, _IconZoomOut);
  }
});

// node_modules/@arco-design/web-vue/es/icon/icon-zoom-in/icon-zoom-in.js
var _sfc_main95 = defineComponent({
  name: "IconZoomIn",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-zoom-in`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_143 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_233 = createBaseVNode("path", { d: "M32.607 32.607A14.953 14.953 0 0 0 37 22c0-8.284-6.716-15-15-15-8.284 0-15 6.716-15 15 0 8.284 6.716 15 15 15 4.142 0 7.892-1.679 10.607-4.393Zm0 0L41.5 41.5M29 22H15m7 7V15" }, null, -1);
var _hoisted_330 = [
  _hoisted_233
];
function _sfc_render95(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_330, 14, _hoisted_143);
}
var _IconZoomIn = _export_sfc(_sfc_main95, [["render", _sfc_render95]]);

// node_modules/@arco-design/web-vue/es/icon/icon-zoom-in/index.js
var IconZoomIn = Object.assign(_IconZoomIn, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconZoomIn.name, _IconZoomIn);
  }
});

// node_modules/@arco-design/web-vue/es/icon/icon-fullscreen/icon-fullscreen.js
var _sfc_main96 = defineComponent({
  name: "IconFullscreen",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-fullscreen`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_144 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_234 = createBaseVNode("path", { d: "M42 17V9a1 1 0 0 0-1-1h-8M6 17V9a1 1 0 0 1 1-1h8m27 23v8a1 1 0 0 1-1 1h-8M6 31v8a1 1 0 0 0 1 1h8" }, null, -1);
var _hoisted_331 = [
  _hoisted_234
];
function _sfc_render96(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_331, 14, _hoisted_144);
}
var _IconFullscreen = _export_sfc(_sfc_main96, [["render", _sfc_render96]]);

// node_modules/@arco-design/web-vue/es/icon/icon-fullscreen/index.js
var IconFullscreen = Object.assign(_IconFullscreen, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconFullscreen.name, _IconFullscreen);
  }
});

// node_modules/@arco-design/web-vue/es/icon/icon-rotate-left/icon-rotate-left.js
var _sfc_main97 = defineComponent({
  name: "IconRotateLeft",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-rotate-left`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_145 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_235 = createBaseVNode("path", { d: "M10 22a1 1 0 0 1 1-1h20a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H11a1 1 0 0 1-1-1V22ZM23 11h11a6 6 0 0 1 6 6v6M22.5 12.893 19.587 11 22.5 9.107v3.786Z" }, null, -1);
var _hoisted_332 = [
  _hoisted_235
];
function _sfc_render97(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_332, 14, _hoisted_145);
}
var _IconRotateLeft = _export_sfc(_sfc_main97, [["render", _sfc_render97]]);

// node_modules/@arco-design/web-vue/es/icon/icon-rotate-left/index.js
var IconRotateLeft = Object.assign(_IconRotateLeft, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconRotateLeft.name, _IconRotateLeft);
  }
});

// node_modules/@arco-design/web-vue/es/icon/icon-rotate-right/icon-rotate-right.js
var _sfc_main98 = defineComponent({
  name: "IconRotateRight",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-rotate-right`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_146 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_236 = createBaseVNode("path", { d: "M38 22a1 1 0 0 0-1-1H17a1 1 0 0 0-1 1v16a1 1 0 0 0 1 1h20a1 1 0 0 0 1-1V22ZM25 11H14a6 6 0 0 0-6 6v6M25.5 12.893 28.413 11 25.5 9.107v3.786Z" }, null, -1);
var _hoisted_333 = [
  _hoisted_236
];
function _sfc_render98(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_333, 14, _hoisted_146);
}
var _IconRotateRight = _export_sfc(_sfc_main98, [["render", _sfc_render98]]);

// node_modules/@arco-design/web-vue/es/icon/icon-rotate-right/index.js
var IconRotateRight = Object.assign(_IconRotateRight, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconRotateRight.name, _IconRotateRight);
  }
});

// node_modules/@arco-design/web-vue/es/icon/icon-original-size/icon-original-size.js
var _sfc_main99 = defineComponent({
  name: "IconOriginalSize",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-original-size`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_147 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_237 = createBaseVNode("path", { d: "m5.5 11.5 5-2.5h1v32M34 11.5 39 9h1v32" }, null, -1);
var _hoisted_334 = createBaseVNode("path", {
  d: "M24 17h1v1h-1v-1ZM24 30h1v1h-1v-1Z",
  fill: "currentColor",
  stroke: "none"
}, null, -1);
var _hoisted_48 = createBaseVNode("path", { d: "M24 17h1v1h-1v-1ZM24 30h1v1h-1v-1Z" }, null, -1);
var _hoisted_5 = [
  _hoisted_237,
  _hoisted_334,
  _hoisted_48
];
function _sfc_render99(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_5, 14, _hoisted_147);
}
var _IconOriginalSize = _export_sfc(_sfc_main99, [["render", _sfc_render99]]);

// node_modules/@arco-design/web-vue/es/icon/icon-original-size/index.js
var IconOriginalSize = Object.assign(_IconOriginalSize, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconOriginalSize.name, _IconOriginalSize);
  }
});

// node_modules/@arco-design/web-vue/es/_hooks/use-popup-overflow-hidden.js
function usePopupOverflowHidden(props) {
  const { container: container2, hidden } = toRefs(props);
  let needResetContainerStyle = false;
  let originContainerStyle = {};
  const getScrollBarWidth2 = (element) => {
    return element.tagName === "BODY" ? window.innerWidth - (document.body.clientWidth || document.documentElement.clientWidth) : element.offsetWidth - element.clientWidth;
  };
  const setContainerStyle = () => {
    if (container2.value && container2.value.style.overflow !== "hidden") {
      const originStyle = container2.value.style;
      needResetContainerStyle = true;
      const containerScrollBarWidth = getScrollBarWidth2(container2.value);
      if (containerScrollBarWidth) {
        originContainerStyle.width = originStyle.width;
        container2.value.style.width = `calc(${container2.value.style.width || "100%"} - ${containerScrollBarWidth}px)`;
      }
      originContainerStyle.overflow = originStyle.overflow;
      container2.value.style.overflow = "hidden";
    }
  };
  const resetContainerStyle = () => {
    if (container2.value && needResetContainerStyle) {
      const originStyle = originContainerStyle;
      Object.keys(originStyle).forEach((i2) => {
        container2.value.style[i2] = originStyle[i2];
      });
    }
    needResetContainerStyle = false;
    originContainerStyle = {};
  };
  watchEffect((onInvalidate) => {
    hidden.value ? setContainerStyle() : resetContainerStyle();
    onInvalidate(() => {
      resetContainerStyle();
    });
  });
  return [resetContainerStyle, setContainerStyle];
}

// node_modules/@arco-design/web-vue/es/_hooks/use-popup-container.js
function usePopupContainer(defaultPopupContainer, props) {
  const { popupContainer } = toRefs(props);
  const container2 = computed(() => (isString(popupContainer.value) ? querySelector(popupContainer.value) : popupContainer.value) || defaultPopupContainer);
  return container2;
}

// node_modules/@arco-design/web-vue/es/image/utils/get-scale.js
var scaleAttr = [
  25,
  33,
  50,
  67,
  75,
  80,
  90,
  100,
  110,
  125,
  150,
  175,
  200,
  250,
  300,
  400,
  500
].map((item) => +(item / 100).toFixed(2));
var minScale = scaleAttr[0];
var maxScale = scaleAttr[scaleAttr.length - 1];
function getScale(cur = 1, type = "zoomIn") {
  let index3 = scaleAttr.indexOf(cur);
  if (index3 === -1) {
    index3 = findClosestIndex(cur);
  }
  if (type === "zoomIn") {
    return index3 === scaleAttr.length - 1 ? cur : scaleAttr[index3 + 1];
  }
  return index3 === 0 ? cur : scaleAttr[index3 - 1];
}
function findClosestIndex(scale) {
  let closestIndex = scaleAttr.length - 1;
  for (let i2 = 0; i2 < scaleAttr.length; i2++) {
    const current = scaleAttr[i2];
    if (scale === current) {
      closestIndex = i2;
      break;
    }
    if (scale < current) {
      const pre = scaleAttr[i2 - 1];
      closestIndex = pre === void 0 || Math.abs(pre - scale) <= Math.abs(current - scale) ? i2 - 1 : i2;
      break;
    }
  }
  return closestIndex;
}

// node_modules/@arco-design/web-vue/es/image/preview.vue_vue&type=script&lang.js
var __defProp35 = Object.defineProperty;
var __getOwnPropSymbols35 = Object.getOwnPropertySymbols;
var __hasOwnProp35 = Object.prototype.hasOwnProperty;
var __propIsEnum35 = Object.prototype.propertyIsEnumerable;
var __defNormalProp35 = (obj, key, value) => key in obj ? __defProp35(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues35 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp35.call(b, prop))
      __defNormalProp35(a, prop, b[prop]);
  if (__getOwnPropSymbols35)
    for (var prop of __getOwnPropSymbols35(b)) {
      if (__propIsEnum35.call(b, prop))
        __defNormalProp35(a, prop, b[prop]);
    }
  return a;
};
var ROTATE_STEP = 90;
var _sfc_main100 = defineComponent({
  name: "ImagePreview",
  components: {
    PreviewArrow,
    PreviewToolbar,
    IconLoading,
    IconClose
  },
  props: {
    renderToBody: {
      type: Boolean,
      default: true
    },
    src: {
      type: String
    },
    visible: {
      type: Boolean,
      default: void 0
    },
    defaultVisible: {
      type: Boolean,
      default: false
    },
    maskClosable: {
      type: Boolean,
      default: true
    },
    closable: {
      type: Boolean,
      default: true
    },
    actionsLayout: {
      type: Array,
      default: () => ["fullScreen", "rotateRight", "rotateLeft", "zoomIn", "zoomOut", "originalSize"]
    },
    popupContainer: {
      type: [Object, String]
    },
    inGroup: {
      type: Boolean,
      default: false
    },
    groupArrowProps: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [
    "close",
    "update:visible"
  ],
  setup(props, {
    emit
  }) {
    const {
      t: t2
    } = useI18n();
    const {
      src,
      popupContainer,
      visible,
      defaultVisible,
      maskClosable
    } = toRefs(props);
    const refWrapper = ref();
    const refImage = ref();
    const prefixCls = getPrefixCls("image-preview");
    const [mergedVisible, setVisible] = useMergeState(defaultVisible.value, reactive({
      value: visible
    }));
    const classNames = computed(() => [prefixCls, {
      [`${prefixCls}-hide`]: !mergedVisible.value
    }]);
    const container2 = usePopupContainer(document.body, reactive({
      popupContainer
    }));
    const isFixed = computed(() => container2.value === document.body);
    const {
      zIndex
    } = usePopupManager("dialog", {
      visible: mergedVisible
    });
    const wrapperStyles = computed(() => {
      const positionStyles = isFixed.value ? {
        zIndex: zIndex.value,
        position: "fixed"
      } : {
        zIndex: "inherit",
        position: "absolute"
      };
      return __spreadValues35({}, positionStyles);
    });
    const {
      isLoading,
      isLoaded,
      setLoadStatus
    } = useImageLoadStatus();
    const rotate = ref(0);
    const scale = ref(1);
    const {
      translate,
      moving,
      resetTranslate
    } = useImageDrag(reactive({
      wrapperEl: refWrapper,
      imageEl: refImage,
      visible: mergedVisible,
      scale
    }));
    const scaleValueVisible = ref(false);
    let hideScaleTimer = null;
    const showScaleValue = () => {
      !scaleValueVisible.value && (scaleValueVisible.value = true);
      hideScaleTimer && clearTimeout(hideScaleTimer);
      hideScaleTimer = setTimeout(() => {
        scaleValueVisible.value = false;
      }, 1e3);
    };
    usePopupOverflowHidden(reactive({
      container: container2,
      hidden: mergedVisible
    }));
    function reset() {
      rotate.value = 0;
      scale.value = 1;
      resetTranslate();
    }
    watch([src, mergedVisible], () => {
      if (mergedVisible.value) {
        reset();
        setLoadStatus("loading");
      }
    });
    function close() {
      if (mergedVisible.value) {
        emit("close");
        emit("update:visible", false);
        setVisible(false);
      }
    }
    function onMaskClick(e2) {
      if (maskClosable.value && e2.target === e2.currentTarget) {
        close();
      }
    }
    function changeScale(newScale) {
      if (scale.value !== newScale) {
        scale.value = newScale;
        showScaleValue();
      }
    }
    return {
      prefixCls,
      classNames,
      container: container2,
      wrapperStyles,
      scale,
      translate,
      rotate,
      moving,
      mergedVisible,
      isLoading,
      isLoaded,
      scaleValueVisible,
      refWrapper,
      refImage,
      onMaskClick,
      onCloseClick: close,
      onImgLoad() {
        setLoadStatus("loaded");
      },
      onImgError() {
        setLoadStatus("error");
      },
      actions: computed(() => [
        {
          key: "fullScreen",
          name: t2("imagePreview.fullScreen"),
          content: () => h(IconFullscreen),
          onClick: () => {
            const wrapperRect = refWrapper.value.getBoundingClientRect();
            const imgRect = refImage.value.getBoundingClientRect();
            const newHeightScale = wrapperRect.height / (imgRect.height / scale.value);
            const newWidthScale = wrapperRect.width / (imgRect.width / scale.value);
            const newScale = Math.max(newHeightScale, newWidthScale);
            changeScale(newScale);
          }
        },
        {
          key: "rotateRight",
          name: t2("imagePreview.rotateRight"),
          content: () => h(IconRotateRight),
          onClick: () => {
            rotate.value = (rotate.value + ROTATE_STEP) % 360;
          }
        },
        {
          key: "rotateLeft",
          name: t2("imagePreview.rotateLeft"),
          content: () => h(IconRotateLeft),
          onClick: () => {
            rotate.value = rotate.value === 0 ? 360 - ROTATE_STEP : rotate.value - ROTATE_STEP;
          }
        },
        {
          key: "zoomIn",
          name: t2("imagePreview.zoomIn"),
          content: () => h(IconZoomIn),
          onClick: () => {
            const newScale = getScale(scale.value, "zoomIn");
            changeScale(newScale);
          },
          disabled: scale.value === maxScale
        },
        {
          key: "zoomOut",
          name: t2("imagePreview.zoomOut"),
          content: () => h(IconZoomOut),
          onClick: () => {
            const newScale = getScale(scale.value, "zoomOut");
            changeScale(newScale);
          },
          disabled: scale.value === minScale
        },
        {
          key: "originalSize",
          name: t2("imagePreview.originalSize"),
          content: () => h(IconOriginalSize),
          onClick: () => {
            changeScale(1);
          }
        }
      ])
    };
  }
});

// node_modules/@arco-design/web-vue/es/image/preview.js
var _hoisted_148 = ["src"];
function _sfc_render100(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_IconLoading = resolveComponent("IconLoading");
  const _component_PreviewToolbar = resolveComponent("PreviewToolbar");
  const _component_IconClose = resolveComponent("IconClose");
  const _component_PreviewArrow = resolveComponent("PreviewArrow");
  return openBlock(), createBlock(Teleport, {
    to: _ctx.container,
    disabled: !_ctx.renderToBody
  }, [
    createBaseVNode("div", {
      class: normalizeClass(_ctx.classNames),
      style: normalizeStyle(_ctx.wrapperStyles)
    }, [
      createVNode(Transition, {
        name: "image-fade",
        onBeforeEnter: _cache[0] || (_cache[0] = (el) => {
          el.parentNode.style.display = "block";
        }),
        onAfterLeave: _cache[1] || (_cache[1] = (el) => {
          el.parentNode.style.display = "";
        })
      }, {
        default: withCtx(() => [
          withDirectives(createBaseVNode("div", {
            class: normalizeClass(`${_ctx.prefixCls}-mask`)
          }, null, 2), [
            [vShow, _ctx.mergedVisible]
          ])
        ]),
        _: 1
      }),
      _ctx.mergedVisible ? (openBlock(), createElementBlock("div", {
        key: 0,
        ref: "refWrapper",
        class: normalizeClass(`${_ctx.prefixCls}-wrapper`),
        onClick: _cache[6] || (_cache[6] = (...args) => _ctx.onMaskClick && _ctx.onMaskClick(...args))
      }, [
        createCommentVNode(" img "),
        createBaseVNode("div", {
          class: normalizeClass(`${_ctx.prefixCls}-img-container`),
          style: normalizeStyle({ transform: `scale(${_ctx.scale}, ${_ctx.scale})` }),
          onClick: _cache[4] || (_cache[4] = (...args) => _ctx.onMaskClick && _ctx.onMaskClick(...args))
        }, [
          (openBlock(), createElementBlock("img", {
            ref: "refImage",
            key: _ctx.src,
            src: _ctx.src,
            class: normalizeClass([
              `${_ctx.prefixCls}-img`,
              {
                [`${_ctx.prefixCls}-img-moving`]: _ctx.moving
              }
            ]),
            style: normalizeStyle({
              transform: `translate(${_ctx.translate[0]}px, ${_ctx.translate[1]}px) rotate(${_ctx.rotate}deg)`
            }),
            onLoad: _cache[2] || (_cache[2] = (...args) => _ctx.onImgLoad && _ctx.onImgLoad(...args)),
            onError: _cache[3] || (_cache[3] = (...args) => _ctx.onImgError && _ctx.onImgError(...args))
          }, null, 46, _hoisted_148))
        ], 6),
        createCommentVNode(" loading "),
        _ctx.isLoading ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(`${_ctx.prefixCls}-loading`)
        }, [
          createVNode(_component_IconLoading)
        ], 2)) : createCommentVNode("v-if", true),
        createCommentVNode(" scale value "),
        createVNode(Transition, { name: "image-fade" }, {
          default: withCtx(() => [
            _ctx.scaleValueVisible ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(`${_ctx.prefixCls}-scale-value`)
            }, toDisplayString((_ctx.scale * 100).toFixed(0)) + "% ", 3)) : createCommentVNode("v-if", true)
          ]),
          _: 1
        }),
        createCommentVNode(" toolbar "),
        _ctx.isLoaded && _ctx.actionsLayout.length ? (openBlock(), createBlock(_component_PreviewToolbar, {
          key: 1,
          actions: _ctx.actions,
          "actions-layout": _ctx.actionsLayout
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "actions")
          ]),
          _: 3
        }, 8, ["actions", "actions-layout"])) : createCommentVNode("v-if", true),
        createCommentVNode(" close btn "),
        _ctx.closable ? (openBlock(), createElementBlock("div", {
          key: 2,
          class: normalizeClass(`${_ctx.prefixCls}-close-btn`),
          onClick: _cache[5] || (_cache[5] = (...args) => _ctx.onCloseClick && _ctx.onCloseClick(...args))
        }, [
          createVNode(_component_IconClose)
        ], 2)) : createCommentVNode("v-if", true),
        createCommentVNode(" group arrow "),
        _ctx.inGroup ? (openBlock(), createBlock(_component_PreviewArrow, normalizeProps(mergeProps({ key: 3 }, _ctx.groupArrowProps)), null, 16)) : createCommentVNode("v-if", true)
      ], 2)) : createCommentVNode("v-if", true)
    ], 6)
  ], 8, ["to", "disabled"]);
}
var ImagePreview = _export_sfc(_sfc_main100, [["render", _sfc_render100]]);

// node_modules/@arco-design/web-vue/es/image/utils/index.js
function normalizeImageSizeProp(size) {
  if (isUndefined(size))
    return void 0;
  if (!isNumber(size) && /^\d+(%)$/.test(size))
    return size;
  const num = parseInt(size, 10);
  return isNumber(num) ? `${num}px` : void 0;
}

// node_modules/@arco-design/web-vue/es/image/context.js
var PreviewGroupInjectionKey = Symbol("PreviewGroupInjectionKey");

// node_modules/@arco-design/web-vue/es/image/image.js
var __defProp36 = Object.defineProperty;
var __getOwnPropSymbols36 = Object.getOwnPropertySymbols;
var __hasOwnProp36 = Object.prototype.hasOwnProperty;
var __propIsEnum36 = Object.prototype.propertyIsEnumerable;
var __defNormalProp36 = (obj, key, value) => key in obj ? __defProp36(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues36 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp36.call(b, prop))
      __defNormalProp36(a, prop, b[prop]);
  if (__getOwnPropSymbols36)
    for (var prop of __getOwnPropSymbols36(b)) {
      if (__propIsEnum36.call(b, prop))
        __defNormalProp36(a, prop, b[prop]);
    }
  return a;
};
var uuid = 0;
var _sfc_main101 = defineComponent({
  name: "Image",
  components: {
    IconImageClose,
    IconLoading,
    ImageFooter,
    ImagePreview
  },
  inheritAttrs: false,
  props: {
    renderToBody: {
      type: Boolean,
      default: true
    },
    src: {
      type: String
    },
    width: {
      type: [String, Number]
    },
    height: {
      type: [String, Number]
    },
    title: {
      type: String
    },
    description: {
      type: String
    },
    fit: {
      type: String
    },
    alt: {
      type: String
    },
    hideFooter: {
      type: [Boolean, String],
      default: false
    },
    footerPosition: {
      type: String,
      default: "inner"
    },
    showLoader: {
      type: Boolean,
      default: false
    },
    preview: {
      type: Boolean,
      default: true
    },
    previewVisible: {
      type: Boolean,
      default: void 0
    },
    defaultPreviewVisible: {
      type: Boolean,
      default: false
    },
    previewProps: {
      type: Object
    },
    footerClass: {
      type: [String, Array, Object]
    }
  },
  emits: [
    "preview-visible-change",
    "update:previewVisible"
  ],
  setup(props, { attrs, slots, emit }) {
    const { t: t2 } = useI18n();
    const {
      height,
      width,
      hideFooter,
      title,
      description,
      src,
      footerPosition,
      defaultPreviewVisible,
      previewVisible,
      preview,
      previewProps
    } = toRefs(props);
    const groupContext = inject(PreviewGroupInjectionKey, void 0);
    const prefixCls = getPrefixCls("image");
    const refImg = ref();
    const { isLoaded, isError, isLoading, setLoadStatus } = useImageLoadStatus();
    const sizeStyle = computed(() => ({
      width: normalizeImageSizeProp(width == null ? void 0 : width.value),
      height: normalizeImageSizeProp(height == null ? void 0 : height.value)
    }));
    const fitStyle = computed(() => {
      if (props.fit) {
        return { objectFit: props.fit };
      }
      return {};
    });
    const wrapperClassNames = computed(() => [
      `${prefixCls}`,
      {
        [`${prefixCls}-loading`]: isLoading.value,
        [`${prefixCls}-loading-error`]: isError.value,
        [`${prefixCls}-with-footer-inner`]: isLoaded && showFooter && footerPosition.value === "inner",
        [`${prefixCls}-with-footer-outer`]: isLoaded && showFooter && footerPosition.value === "outer"
      },
      attrs.class
    ]);
    const wrapperStyles = computed(() => [
      sizeStyle.value,
      attrs.style
    ]);
    const showFooter = computed(() => {
      if (!((title == null ? void 0 : title.value) || (description == null ? void 0 : description.value) || slots.extra)) {
        return false;
      }
      if (isBoolean(hideFooter.value))
        return !hideFooter.value && isLoaded.value;
      return hideFooter.value === "never";
    });
    const imgProps = computed(() => omit(attrs, ["class", "style"]));
    const [mergedPreviewVisible, setPreviewVisible] = useMergeState(defaultPreviewVisible.value, reactive({
      value: previewVisible
    }));
    const mergePreview = computed(() => !(groupContext == null ? void 0 : groupContext.preview) && preview.value);
    watchEffect(() => {
      if (isServerRendering || !refImg.value)
        return;
      refImg.value.src = src == null ? void 0 : src.value;
      setLoadStatus("loading");
    });
    const imageId = uuid++;
    watchEffect((onInvalidate) => {
      var _a, _b, _c;
      const unRegister = (_c = groupContext == null ? void 0 : groupContext.registerImageUrl) == null ? void 0 : _c.call(groupContext, imageId, ((_b = (_a = previewProps == null ? void 0 : previewProps.value) == null ? void 0 : _a.src) != null ? _b : src == null ? void 0 : src.value) || "", preview.value);
      onInvalidate(() => {
        unRegister == null ? void 0 : unRegister();
      });
    });
    function onImgLoaded() {
      setLoadStatus("loaded");
    }
    function onImgLoadError() {
      setLoadStatus("error");
    }
    function onImgClick() {
      if (!preview.value)
        return;
      if (groupContext == null ? void 0 : groupContext.preview) {
        groupContext.preview(imageId);
      } else {
        emit("preview-visible-change", true);
        setPreviewVisible(true);
      }
    }
    function onPreviewClose() {
      emit("preview-visible-change", false);
      setPreviewVisible(false);
    }
    return {
      t: t2,
      refImg,
      prefixCls,
      wrapperClassNames,
      wrapperStyles,
      showFooter,
      imgProps,
      imgStyle: sizeStyle.value,
      isLoaded,
      isError,
      isLoading,
      mergedPreviewVisible,
      mergePreview,
      onImgLoaded,
      onImgLoadError,
      onImgClick,
      onPreviewClose,
      fitStyle
    };
  }
});
var _hoisted_149 = ["title", "alt"];
function _sfc_render101(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_IconImageClose = resolveComponent("IconImageClose");
  const _component_IconLoading = resolveComponent("IconLoading");
  const _component_ImageFooter = resolveComponent("ImageFooter");
  const _component_ImagePreview = resolveComponent("ImagePreview");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.wrapperClassNames),
    style: normalizeStyle(_ctx.wrapperStyles)
  }, [
    createBaseVNode("img", mergeProps({
      ref: "refImg",
      class: `${_ctx.prefixCls}-img`
    }, _ctx.imgProps, {
      style: __spreadValues36(__spreadValues36({}, _ctx.imgStyle), _ctx.fitStyle),
      title: _ctx.title,
      alt: _ctx.alt,
      onLoad: _cache[0] || (_cache[0] = (...args) => _ctx.onImgLoaded && _ctx.onImgLoaded(...args)),
      onError: _cache[1] || (_cache[1] = (...args) => _ctx.onImgLoadError && _ctx.onImgLoadError(...args)),
      onClick: _cache[2] || (_cache[2] = (...args) => _ctx.onImgClick && _ctx.onImgClick(...args))
    }), null, 16, _hoisted_149),
    !_ctx.isLoaded ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(`${_ctx.prefixCls}-overlay`)
    }, [
      _ctx.isError ? renderSlot(_ctx.$slots, "error", { key: 0 }, () => [
        createBaseVNode("div", {
          class: normalizeClass(`${_ctx.prefixCls}-error`)
        }, [
          createBaseVNode("div", {
            class: normalizeClass(`${_ctx.prefixCls}-error-icon`)
          }, [
            renderSlot(_ctx.$slots, "error-icon", {}, () => [
              createVNode(_component_IconImageClose)
            ])
          ], 2),
          createBaseVNode("div", {
            class: normalizeClass(`${_ctx.prefixCls}-error-alt`)
          }, toDisplayString(_ctx.alt || _ctx.description), 3)
        ], 2)
      ]) : createCommentVNode("v-if", true),
      _ctx.isLoading && (_ctx.showLoader || _ctx.$slots.loader) ? renderSlot(_ctx.$slots, "loader", { key: 1 }, () => [
        createBaseVNode("div", {
          class: normalizeClass([`${_ctx.prefixCls}-loader`])
        }, [
          createBaseVNode("div", {
            class: normalizeClass(`${_ctx.prefixCls}-loader-spin`)
          }, [
            createVNode(_component_IconLoading),
            createBaseVNode("div", {
              class: normalizeClass(`${_ctx.prefixCls}-loader-spin-text`)
            }, toDisplayString(_ctx.t("image.loading")), 3)
          ], 2)
        ], 2)
      ]) : createCommentVNode("v-if", true)
    ], 2)) : createCommentVNode("v-if", true),
    _ctx.showFooter ? (openBlock(), createBlock(_component_ImageFooter, {
      key: 1,
      class: normalizeClass(_ctx.footerClass),
      "prefix-cls": _ctx.prefixCls,
      title: _ctx.title,
      description: _ctx.description
    }, createSlots({ _: 2 }, [
      _ctx.$slots.extra ? {
        name: "extra",
        fn: withCtx(() => [
          renderSlot(_ctx.$slots, "extra")
        ])
      } : void 0
    ]), 1032, ["class", "prefix-cls", "title", "description"])) : createCommentVNode("v-if", true),
    _ctx.isLoaded && _ctx.mergePreview ? (openBlock(), createBlock(_component_ImagePreview, mergeProps({
      key: 2,
      src: _ctx.src
    }, _ctx.previewProps, {
      visible: _ctx.mergedPreviewVisible,
      "render-to-body": _ctx.renderToBody,
      onClose: _ctx.onPreviewClose
    }), {
      actions: withCtx(() => [
        renderSlot(_ctx.$slots, "preview-actions")
      ]),
      _: 3
    }, 16, ["src", "visible", "render-to-body", "onClose"])) : createCommentVNode("v-if", true)
  ], 6);
}
var _Image = _export_sfc(_sfc_main101, [["render", _sfc_render101]]);

// node_modules/@arco-design/web-vue/es/image/preview-group.vue_vue&type=script&lang.js
var _sfc_main102 = defineComponent({
  name: "ImagePreviewGroup",
  components: {
    ImagePreview
  },
  inheritAttrs: false,
  props: {
    renderToBody: {
      type: Boolean,
      default: true
    },
    srcList: {
      type: Array
    },
    current: {
      type: Number
    },
    defaultCurrent: {
      type: Number,
      default: 0
    },
    infinite: {
      type: Boolean,
      default: false
    },
    visible: {
      type: Boolean,
      default: void 0
    },
    defaultVisible: {
      type: Boolean,
      default: false
    },
    maskClosable: {
      type: Boolean,
      default: true
    },
    closable: {
      type: Boolean,
      default: true
    },
    actionsLayout: {
      type: Array,
      default: () => ["fullScreen", "rotateRight", "rotateLeft", "zoomIn", "zoomOut", "originalSize"]
    },
    popupContainer: {
      type: [Object, String]
    }
  },
  emits: [
    "change",
    "update:current",
    "visible-change",
    "update:visible"
  ],
  setup(props, {
    emit
  }) {
    const {
      srcList,
      visible,
      defaultVisible,
      current,
      defaultCurrent,
      infinite
    } = toRefs(props);
    const [mergedVisible, setLocalVisible] = useMergeState(defaultVisible.value, reactive({
      value: visible
    }));
    const setVisible = (newVisible) => {
      if (newVisible !== mergedVisible.value) {
        emit("visible-change", newVisible);
        emit("update:visible", newVisible);
        setLocalVisible(newVisible);
      }
    };
    const propImageUrlMap = computed(() => new Map(isArray(srcList == null ? void 0 : srcList.value) ? srcList == null ? void 0 : srcList.value.map((url, index3) => [index3, {
      url,
      canPreview: true
    }]) : []));
    const imageUrlMap = ref(new Map(propImageUrlMap.value || []));
    const imageIdList = computed(() => Array.from(imageUrlMap.value.keys()));
    const imageCount = computed(() => imageIdList.value.length);
    function registerImageUrl(id, url, canPreview) {
      if (!propImageUrlMap.value.has(id))
        imageUrlMap.value.set(id, {
          url,
          canPreview
        });
      return function unRegisterPreviewUrl() {
        if (!propImageUrlMap.value.has(id)) {
          imageUrlMap.value.delete(id);
        }
      };
    }
    watch(propImageUrlMap, () => {
      imageUrlMap.value = new Map(propImageUrlMap.value || []);
    });
    const [currentIndex, setLocalCurrentIndex] = useMergeState(defaultCurrent.value, reactive({
      value: current
    }));
    const setCurrentIndex = (index3) => {
      if (index3 !== currentIndex.value) {
        emit("change", index3);
        emit("update:current", index3);
        setLocalCurrentIndex(index3);
      }
    };
    const currentId = computed(() => imageIdList.value[currentIndex.value]);
    const setCurrentId = (nextId) => {
      const nextIndex2 = imageIdList.value.indexOf(nextId);
      if (nextIndex2 !== currentIndex.value) {
        setCurrentIndex(nextIndex2);
      }
    };
    const currentUrl = computed(() => {
      var _a;
      return (_a = imageUrlMap.value.get(currentId.value)) == null ? void 0 : _a.url;
    });
    provide(PreviewGroupInjectionKey, reactive({
      registerImageUrl,
      preview: (imageId) => {
        setVisible(true);
        setCurrentId(imageId);
      }
    }));
    const nextIndex = computed(() => {
      const findNext = (start2, end) => {
        var _a;
        for (let i2 = start2; i2 <= end; i2++) {
          const id = imageIdList.value[i2];
          if ((_a = imageUrlMap.value.get(id)) == null ? void 0 : _a.canPreview) {
            return i2;
          }
        }
        return void 0;
      };
      const next = findNext(currentIndex.value + 1, imageCount.value - 1);
      return isUndefined(next) && infinite.value ? findNext(0, currentIndex.value - 1) : next;
    });
    const prevIndex = computed(() => {
      const findPrev = (start2, end) => {
        var _a;
        for (let i2 = start2; i2 >= end; i2--) {
          const id = imageIdList.value[i2];
          if ((_a = imageUrlMap.value.get(id)) == null ? void 0 : _a.canPreview) {
            return i2;
          }
        }
        return void 0;
      };
      const prev = findPrev(currentIndex.value - 1, 0);
      return isUndefined(prev) && infinite.value ? findPrev(imageCount.value - 1, currentIndex.value + 1) : prev;
    });
    const onPrev = computed(() => !isUndefined(prevIndex.value) ? () => {
      !isUndefined(prevIndex.value) && setCurrentIndex(prevIndex.value);
    } : void 0);
    const onNext = computed(() => !isUndefined(nextIndex.value) ? () => {
      !isUndefined(nextIndex.value) && setCurrentIndex(nextIndex.value);
    } : void 0);
    return {
      mergedVisible,
      currentUrl,
      prevIndex,
      nextIndex,
      onClose() {
        setVisible(false);
      },
      groupArrowProps: reactive({
        onPrev,
        onNext
      })
    };
  }
});

// node_modules/@arco-design/web-vue/es/image/preview-group.js
var __defProp37 = Object.defineProperty;
var __defProps16 = Object.defineProperties;
var __getOwnPropDescs16 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols37 = Object.getOwnPropertySymbols;
var __hasOwnProp37 = Object.prototype.hasOwnProperty;
var __propIsEnum37 = Object.prototype.propertyIsEnumerable;
var __defNormalProp37 = (obj, key, value) => key in obj ? __defProp37(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues37 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp37.call(b, prop))
      __defNormalProp37(a, prop, b[prop]);
  if (__getOwnPropSymbols37)
    for (var prop of __getOwnPropSymbols37(b)) {
      if (__propIsEnum37.call(b, prop))
        __defNormalProp37(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps16 = (a, b) => __defProps16(a, __getOwnPropDescs16(b));
function _sfc_render102(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ImagePreview = resolveComponent("ImagePreview");
  return openBlock(), createElementBlock(Fragment, null, [
    renderSlot(_ctx.$slots, "default"),
    createVNode(_component_ImagePreview, mergeProps(__spreadProps16(__spreadValues37({}, _ctx.$attrs), { groupArrowProps: _ctx.groupArrowProps }), {
      "in-group": "",
      src: _ctx.currentUrl,
      visible: _ctx.mergedVisible,
      "mask-closable": _ctx.maskClosable,
      closable: _ctx.closable,
      "actions-layout": _ctx.actionsLayout,
      "popup-container": _ctx.popupContainer,
      "render-to-body": _ctx.renderToBody,
      onClose: _ctx.onClose
    }), null, 16, ["src", "visible", "mask-closable", "closable", "actions-layout", "popup-container", "render-to-body", "onClose"])
  ], 64);
}
var ImagePreviewGroup = _export_sfc(_sfc_main102, [["render", _sfc_render102]]);

// node_modules/@arco-design/web-vue/es/image/index.js
var Image = Object.assign(_Image, {
  Preview: ImagePreview,
  PreviewGroup: ImagePreviewGroup,
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Image.name, _Image);
    app.component(componentPrefix + ImagePreview.name, ImagePreview);
    app.component(componentPrefix + ImagePreviewGroup.name, ImagePreviewGroup);
    app.component(componentPrefix + _ImagePreviewAction.name, _ImagePreviewAction);
  }
});

// node_modules/number-precision/build/index.es.js
function strip(num, precision) {
  if (precision === void 0) {
    precision = 15;
  }
  return +parseFloat(Number(num).toPrecision(precision));
}
function digitLength(num) {
  var eSplit = num.toString().split(/[eE]/);
  var len = (eSplit[0].split(".")[1] || "").length - +(eSplit[1] || 0);
  return len > 0 ? len : 0;
}
function float2Fixed(num) {
  if (num.toString().indexOf("e") === -1) {
    return Number(num.toString().replace(".", ""));
  }
  var dLen = digitLength(num);
  return dLen > 0 ? strip(Number(num) * Math.pow(10, dLen)) : Number(num);
}
function checkBoundary(num) {
  if (_boundaryCheckingState) {
    if (num > Number.MAX_SAFE_INTEGER || num < Number.MIN_SAFE_INTEGER) {
      console.warn(num + " is beyond boundary when transfer to integer, the results may not be accurate");
    }
  }
}
function createOperation(operation) {
  return function() {
    var nums = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      nums[_i] = arguments[_i];
    }
    var first = nums[0], others = nums.slice(1);
    return others.reduce(function(prev, next) {
      return operation(prev, next);
    }, first);
  };
}
var times = createOperation(function(num1, num2) {
  var num1Changed = float2Fixed(num1);
  var num2Changed = float2Fixed(num2);
  var baseNum = digitLength(num1) + digitLength(num2);
  var leftValue = num1Changed * num2Changed;
  checkBoundary(leftValue);
  return leftValue / Math.pow(10, baseNum);
});
var plus = createOperation(function(num1, num2) {
  var baseNum = Math.pow(10, Math.max(digitLength(num1), digitLength(num2)));
  return (times(num1, baseNum) + times(num2, baseNum)) / baseNum;
});
var minus = createOperation(function(num1, num2) {
  var baseNum = Math.pow(10, Math.max(digitLength(num1), digitLength(num2)));
  return (times(num1, baseNum) - times(num2, baseNum)) / baseNum;
});
var divide = createOperation(function(num1, num2) {
  var num1Changed = float2Fixed(num1);
  var num2Changed = float2Fixed(num2);
  checkBoundary(num1Changed);
  checkBoundary(num2Changed);
  return times(num1Changed / num2Changed, strip(Math.pow(10, digitLength(num2) - digitLength(num1))));
});
function round(num, decimal) {
  var base = Math.pow(10, decimal);
  var result = divide(Math.round(Math.abs(times(num, base))), base);
  if (num < 0 && result !== 0) {
    result = times(result, -1);
  }
  return result;
}
var _boundaryCheckingState = true;
function enableBoundaryChecking(flag) {
  if (flag === void 0) {
    flag = true;
  }
  _boundaryCheckingState = flag;
}
var index2 = {
  strip,
  plus,
  minus,
  times,
  divide,
  round,
  digitLength,
  float2Fixed,
  enableBoundaryChecking
};
var index_es_default = index2;

// node_modules/@arco-design/web-vue/es/icon/icon-plus/icon-plus.js
var _sfc_main103 = defineComponent({
  name: "IconPlus",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-plus`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_150 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_238 = createBaseVNode("path", { d: "M5 24h38M24 5v38" }, null, -1);
var _hoisted_335 = [
  _hoisted_238
];
function _sfc_render103(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_335, 14, _hoisted_150);
}
var _IconPlus = _export_sfc(_sfc_main103, [["render", _sfc_render103]]);

// node_modules/@arco-design/web-vue/es/icon/icon-plus/index.js
var IconPlus = Object.assign(_IconPlus, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconPlus.name, _IconPlus);
  }
});

// node_modules/@arco-design/web-vue/es/icon/icon-minus/icon-minus.js
var _sfc_main104 = defineComponent({
  name: "IconMinus",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-minus`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_151 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_239 = createBaseVNode("path", { d: "M5 24h38" }, null, -1);
var _hoisted_336 = [
  _hoisted_239
];
function _sfc_render104(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_336, 14, _hoisted_151);
}
var _IconMinus = _export_sfc(_sfc_main104, [["render", _sfc_render104]]);

// node_modules/@arco-design/web-vue/es/icon/icon-minus/index.js
var IconMinus = Object.assign(_IconMinus, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconMinus.name, _IconMinus);
  }
});

// node_modules/@arco-design/web-vue/es/input-number/input-number.js
var SPEED = 150;
index_es_default.enableBoundaryChecking(false);
var _InputNumber = defineComponent({
  name: "InputNumber",
  props: {
    modelValue: Number,
    defaultValue: Number,
    mode: {
      type: String,
      default: "embed"
    },
    precision: Number,
    step: {
      type: Number,
      default: 1
    },
    disabled: {
      type: Boolean,
      default: false
    },
    error: {
      type: Boolean,
      default: false
    },
    max: {
      type: Number,
      default: Infinity
    },
    min: {
      type: Number,
      default: -Infinity
    },
    formatter: {
      type: Function
    },
    parser: {
      type: Function
    },
    placeholder: String,
    hideButton: {
      type: Boolean,
      default: false
    },
    size: {
      type: String
    },
    allowClear: {
      type: Boolean,
      default: false
    },
    modelEvent: {
      type: String,
      default: "change"
    },
    readOnly: {
      type: Boolean,
      default: false
    }
  },
  emits: {
    "update:modelValue": (value) => true,
    "change": (value, ev) => true,
    "focus": (ev) => true,
    "blur": (ev) => true,
    "clear": (ev) => true,
    "input": (value, inputValue, ev) => true
  },
  setup(props, {
    emit,
    slots
  }) {
    var _a;
    const {
      size,
      disabled
    } = toRefs(props);
    const prefixCls = getPrefixCls("input-number");
    const inputRef = ref();
    const {
      mergedSize: _mergedSize,
      mergedDisabled,
      eventHandlers
    } = useFormItem({
      size,
      disabled
    });
    const {
      mergedSize
    } = useSize(_mergedSize);
    const mergedPrecision = computed(() => {
      if (isNumber(props.precision)) {
        const decimal = `${props.step}`.split(".")[1];
        const stepPrecision = decimal && decimal.length || 0;
        return Math.max(stepPrecision, props.precision);
      }
      return void 0;
    });
    const getStringValue = (number) => {
      var _a2, _b;
      if (!isNumber(number)) {
        return "";
      }
      const numString = mergedPrecision.value ? number.toFixed(mergedPrecision.value) : String(number);
      return (_b = (_a2 = props.formatter) == null ? void 0 : _a2.call(props, numString)) != null ? _b : numString;
    };
    const _value = ref(getStringValue((_a = props.modelValue) != null ? _a : props.defaultValue));
    const valueNumber = computed(() => {
      var _a2, _b;
      if (!_value.value) {
        return void 0;
      }
      const number = Number((_b = (_a2 = props.parser) == null ? void 0 : _a2.call(props, _value.value)) != null ? _b : _value.value);
      return Number.isNaN(number) ? void 0 : number;
    });
    const isMin = ref(isNumber(valueNumber.value) && valueNumber.value <= props.min);
    const isMax = ref(isNumber(valueNumber.value) && valueNumber.value >= props.max);
    let repeatTimer = 0;
    const clearRepeatTimer = () => {
      if (repeatTimer) {
        window.clearTimeout(repeatTimer);
        repeatTimer = 0;
      }
    };
    const getLegalValue = (value) => {
      if (isUndefined(value)) {
        return void 0;
      }
      if (isNumber(props.min) && value < props.min) {
        value = props.min;
      }
      if (isNumber(props.max) && value > props.max) {
        value = props.max;
      }
      return isNumber(mergedPrecision.value) ? index_es_default.round(value, mergedPrecision.value) : value;
    };
    const updateNumberStatus = (number) => {
      let _isMin = false;
      let _isMax = false;
      if (isNumber(number)) {
        if (number <= props.min) {
          _isMin = true;
        }
        if (number >= props.max) {
          _isMax = true;
        }
      }
      if (isMax.value !== _isMax) {
        isMax.value = _isMax;
      }
      if (isMin.value !== _isMin) {
        isMin.value = _isMin;
      }
    };
    const handleExceedRange = () => {
      const finalValue = getLegalValue(valueNumber.value);
      const stringValue = getStringValue(finalValue);
      if (finalValue !== valueNumber.value || _value.value !== stringValue) {
        _value.value = stringValue;
      }
      emit("update:modelValue", finalValue);
    };
    watch(() => props.min, (newVal) => {
      const _isMin = isNumber(valueNumber.value) && valueNumber.value <= newVal;
      if (isMin.value !== _isMin) {
        isMin.value = _isMin;
      }
      const isExceedMinValue = isNumber(valueNumber.value) && valueNumber.value < newVal;
      if (isExceedMinValue) {
        handleExceedRange();
      }
    });
    watch(() => props.max, (newVal) => {
      const _isMax = isNumber(valueNumber.value) && valueNumber.value >= newVal;
      if (isMax.value !== _isMax) {
        isMax.value = _isMax;
      }
      const isExceedMaxValue = isNumber(valueNumber.value) && valueNumber.value > newVal;
      if (isExceedMaxValue) {
        handleExceedRange();
      }
    });
    const nextStep = (method, event) => {
      if (mergedDisabled.value || method === "plus" && isMax.value || method === "minus" && isMin.value) {
        return;
      }
      let nextValue;
      if (isNumber(valueNumber.value)) {
        nextValue = getLegalValue(index_es_default[method](valueNumber.value, props.step));
      } else {
        nextValue = props.min === -Infinity ? 0 : props.min;
      }
      _value.value = getStringValue(nextValue);
      updateNumberStatus(nextValue);
      emit("update:modelValue", nextValue);
      emit("change", nextValue, event);
    };
    const handleStepButton = (event, method, needRepeat = false) => {
      var _a2;
      event.preventDefault();
      (_a2 = inputRef.value) == null ? void 0 : _a2.focus();
      nextStep(method, event);
      if (needRepeat) {
        repeatTimer = window.setTimeout(() => event.target.dispatchEvent(event), SPEED);
      }
    };
    const handleInput = (value, ev) => {
      var _a2, _b, _c, _d;
      value = value.trim().replace(/。/g, ".");
      value = (_b = (_a2 = props.parser) == null ? void 0 : _a2.call(props, value)) != null ? _b : value;
      if (isNumber(Number(value)) || /^(\.|-)$/.test(value)) {
        _value.value = (_d = (_c = props.formatter) == null ? void 0 : _c.call(props, value)) != null ? _d : value;
        updateNumberStatus(valueNumber.value);
        if (props.modelEvent === "input") {
          emit("update:modelValue", valueNumber.value);
        }
        emit("input", valueNumber.value, _value.value, ev);
      }
    };
    const handleFocus = (ev) => {
      emit("focus", ev);
    };
    const handleChange = (value, ev) => {
      const finalValue = getLegalValue(valueNumber.value);
      const stringValue = getStringValue(finalValue);
      if (finalValue !== valueNumber.value || _value.value !== stringValue) {
        _value.value = stringValue;
        updateNumberStatus(finalValue);
      }
      nextTick(() => {
        if (isNumber(props.modelValue) && props.modelValue !== finalValue) {
          _value.value = getStringValue(props.modelValue);
          updateNumberStatus(props.modelValue);
        }
      });
      emit("update:modelValue", finalValue);
      emit("change", finalValue, ev);
    };
    const handleBlur = (ev) => {
      emit("blur", ev);
    };
    const handleClear = (ev) => {
      var _a2, _b;
      _value.value = "";
      emit("update:modelValue", void 0);
      emit("change", void 0, ev);
      (_b = (_a2 = eventHandlers.value) == null ? void 0 : _a2.onChange) == null ? void 0 : _b.call(_a2, ev);
      emit("clear", ev);
    };
    const onKeyDown = getKeyDownHandler(/* @__PURE__ */ new Map([[KEYBOARD_KEY.ARROW_UP, (ev) => {
      ev.preventDefault();
      !props.readOnly && nextStep("plus", ev);
    }], [KEYBOARD_KEY.ARROW_DOWN, (ev) => {
      ev.preventDefault();
      !props.readOnly && nextStep("minus", ev);
    }]]));
    watch(() => props.modelValue, (value) => {
      if (value !== valueNumber.value) {
        _value.value = getStringValue(value);
        updateNumberStatus(value);
      }
    });
    const renderSuffix = () => {
      var _a2;
      if (props.readOnly) {
        return null;
      }
      return createVNode(Fragment, null, [(_a2 = slots.suffix) == null ? void 0 : _a2.call(slots), createVNode("div", {
        "class": `${prefixCls}-step`
      }, [createVNode("button", {
        "class": [`${prefixCls}-step-button`, {
          [`${prefixCls}-step-button-disabled`]: mergedDisabled.value || isMax.value
        }],
        "type": "button",
        "tabindex": "-1",
        "disabled": mergedDisabled.value || isMax.value,
        "onMousedown": (e2) => handleStepButton(e2, "plus", true),
        "onMouseup": clearRepeatTimer,
        "onMouseleave": clearRepeatTimer
      }, [createVNode(IconUp, null, null)]), createVNode("button", {
        "class": [`${prefixCls}-step-button`, {
          [`${prefixCls}-step-button-disabled`]: mergedDisabled.value || isMin.value
        }],
        "type": "button",
        "tabindex": "-1",
        "disabled": mergedDisabled.value || isMin.value,
        "onMousedown": (e2) => handleStepButton(e2, "minus", true),
        "onMouseup": clearRepeatTimer,
        "onMouseleave": clearRepeatTimer
      }, [createVNode(IconDown, null, null)])])]);
    };
    const cls = computed(() => [prefixCls, `${prefixCls}-mode-${props.mode}`, `${prefixCls}-size-${mergedSize.value}`, {
      [`${prefixCls}-readonly`]: props.readOnly
    }]);
    const renderPrependButton = () => {
      return createVNode(Button, {
        "size": mergedSize.value,
        "tabindex": "-1",
        "class": `${prefixCls}-step-button`,
        "disabled": mergedDisabled.value || isMin.value,
        "onMousedown": (ev) => handleStepButton(ev, "minus", true),
        "onMouseup": clearRepeatTimer,
        "onMouseleave": clearRepeatTimer
      }, {
        icon: () => createVNode(IconMinus, null, null)
      });
    };
    const renderAppendButton = () => {
      return createVNode(Button, {
        "size": mergedSize.value,
        "tabindex": "-1",
        "class": `${prefixCls}-step-button`,
        "disabled": mergedDisabled.value || isMax.value,
        "onMousedown": (ev) => handleStepButton(ev, "plus", true),
        "onMouseup": clearRepeatTimer,
        "onMouseleave": clearRepeatTimer
      }, {
        icon: () => createVNode(IconPlus, null, null)
      });
    };
    const render2 = () => {
      const _slots = props.mode === "embed" ? {
        prepend: slots.prepend,
        prefix: slots.prefix,
        suffix: props.hideButton ? slots.suffix : renderSuffix,
        append: slots.append
      } : {
        prepend: renderPrependButton,
        prefix: slots.prefix,
        suffix: slots.suffix,
        append: renderAppendButton
      };
      return createVNode(Input, {
        "key": `__arco__${props.mode}`,
        "ref": inputRef,
        "class": cls.value,
        "type": "text",
        "allowClear": props.allowClear,
        "size": mergedSize.value,
        "modelValue": _value.value,
        "placeholder": props.placeholder,
        "disabled": mergedDisabled.value,
        "readonly": props.readOnly,
        "error": props.error,
        "inputAttrs": {
          "role": "spinbutton",
          "aria-valuemax": props.max,
          "aria-valuemin": props.min,
          "aria-valuenow": _value.value
        },
        "onInput": handleInput,
        "onFocus": handleFocus,
        "onBlur": handleBlur,
        "onClear": handleClear,
        "onChange": handleChange,
        "onKeydown": onKeyDown
      }, _slots);
    };
    return {
      inputRef,
      render: render2
    };
  },
  methods: {
    focus() {
      var _a;
      (_a = this.inputRef) == null ? void 0 : _a.focus();
    },
    blur() {
      var _a;
      (_a = this.inputRef) == null ? void 0 : _a.blur();
    }
  },
  render() {
    return this.render();
  }
});

// node_modules/@arco-design/web-vue/es/input-number/index.js
var InputNumber = Object.assign(_InputNumber, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _InputNumber.name, _InputNumber);
  }
});

// node_modules/@arco-design/web-vue/es/layout/context.js
var LayoutSiderInjectionKey = Symbol("LayoutSiderInjectionKey");
var SiderInjectionKey = Symbol("SiderInjectionKey");

// node_modules/@arco-design/web-vue/es/layout/layout.vue_vue&type=script&lang.js
var _sfc_main105 = defineComponent({
  name: "Layout",
  props: {
    hasSider: {
      type: Boolean
    }
  },
  setup(props) {
    const siderIds = ref([]);
    const prefixCls = getPrefixCls("layout");
    const classNames = computed(() => [prefixCls, {
      [`${prefixCls}-has-sider`]: props.hasSider || siderIds.value.length
    }]);
    provide(LayoutSiderInjectionKey, {
      onSiderMount: (id) => siderIds.value.push(id),
      onSiderUnMount: (id) => {
        siderIds.value = siderIds.value.filter((_id) => _id !== id);
      }
    });
    return {
      classNames
    };
  }
});

// node_modules/@arco-design/web-vue/es/layout/layout.js
function _sfc_render105(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("section", {
    class: normalizeClass(_ctx.classNames)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
var _Layout = _export_sfc(_sfc_main105, [["render", _sfc_render105]]);

// node_modules/@arco-design/web-vue/es/layout/header.js
var _sfc_main106 = defineComponent({
  name: "LayoutHeader",
  setup() {
    const prefixCls = getPrefixCls("layout-header");
    const classNames = [prefixCls];
    return {
      classNames
    };
  }
});
function _sfc_render106(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("header", {
    class: normalizeClass(_ctx.classNames)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
var LayoutHeader = _export_sfc(_sfc_main106, [["render", _sfc_render106]]);

// node_modules/@arco-design/web-vue/es/layout/content.js
var _sfc_main107 = defineComponent({
  name: "LayoutContent",
  setup() {
    const prefixCls = getPrefixCls("layout-content");
    const classNames = [prefixCls];
    return {
      classNames
    };
  }
});
function _sfc_render107(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("main", {
    class: normalizeClass(_ctx.classNames)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
var LayoutContent = _export_sfc(_sfc_main107, [["render", _sfc_render107]]);

// node_modules/@arco-design/web-vue/es/layout/footer.js
var _sfc_main108 = defineComponent({
  name: "LayoutFooter",
  setup() {
    const prefixCls = getPrefixCls("layout-footer");
    const classNames = [prefixCls];
    return {
      classNames
    };
  }
});
function _sfc_render108(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("footer", {
    class: normalizeClass(_ctx.classNames)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
var LayoutFooter = _export_sfc(_sfc_main108, [["render", _sfc_render108]]);

// node_modules/@arco-design/web-vue/es/icon/icon-drag-dot/icon-drag-dot.js
var _sfc_main109 = defineComponent({
  name: "IconDragDot",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-drag-dot`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_152 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_240 = createBaseVNode("path", {
  d: "M40 17v2h-2v-2h2ZM25 17v2h-2v-2h2ZM10 17v2H8v-2h2ZM40 29v2h-2v-2h2ZM25 29v2h-2v-2h2ZM10 29v2H8v-2h2Z",
  fill: "currentColor",
  stroke: "none"
}, null, -1);
var _hoisted_337 = createBaseVNode("path", { d: "M40 17v2h-2v-2h2ZM25 17v2h-2v-2h2ZM10 17v2H8v-2h2ZM40 29v2h-2v-2h2ZM25 29v2h-2v-2h2ZM10 29v2H8v-2h2Z" }, null, -1);
var _hoisted_49 = [
  _hoisted_240,
  _hoisted_337
];
function _sfc_render109(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_49, 14, _hoisted_152);
}
var _IconDragDot = _export_sfc(_sfc_main109, [["render", _sfc_render109]]);

// node_modules/@arco-design/web-vue/es/icon/icon-drag-dot/index.js
var IconDragDot = Object.assign(_IconDragDot, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconDragDot.name, _IconDragDot);
  }
});

// node_modules/@arco-design/web-vue/es/icon/icon-drag-dot-vertical/icon-drag-dot-vertical.js
var _sfc_main110 = defineComponent({
  name: "IconDragDotVertical",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-drag-dot-vertical`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_153 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_241 = createBaseVNode("path", {
  d: "M17 8h2v2h-2V8ZM17 23h2v2h-2v-2ZM17 38h2v2h-2v-2ZM29 8h2v2h-2V8ZM29 23h2v2h-2v-2ZM29 38h2v2h-2v-2Z",
  fill: "currentColor",
  stroke: "none"
}, null, -1);
var _hoisted_338 = createBaseVNode("path", { d: "M17 8h2v2h-2V8ZM17 23h2v2h-2v-2ZM17 38h2v2h-2v-2ZM29 8h2v2h-2V8ZM29 23h2v2h-2v-2ZM29 38h2v2h-2v-2Z" }, null, -1);
var _hoisted_410 = [
  _hoisted_241,
  _hoisted_338
];
function _sfc_render110(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_410, 14, _hoisted_153);
}
var _IconDragDotVertical = _export_sfc(_sfc_main110, [["render", _sfc_render110]]);

// node_modules/@arco-design/web-vue/es/icon/icon-drag-dot-vertical/index.js
var IconDragDotVertical = Object.assign(_IconDragDotVertical, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconDragDotVertical.name, _IconDragDotVertical);
  }
});

// node_modules/@arco-design/web-vue/es/_components/resize-trigger.vue_vue&type=script&lang.js
var _sfc_main111 = defineComponent({
  name: "ResizeTrigger",
  components: {
    ResizeObserver: ResizeObserver2,
    IconDragDot,
    IconDragDotVertical
  },
  props: {
    prefixCls: {
      type: String,
      required: true
    },
    direction: {
      type: String,
      default: "horizontal"
    }
  },
  emits: ["resize"],
  setup(props, {
    emit
  }) {
    const {
      direction,
      prefixCls
    } = toRefs(props);
    const isHorizontal2 = computed(() => (direction == null ? void 0 : direction.value) === "horizontal");
    const classNames = computed(() => [prefixCls.value, {
      [`${prefixCls.value}-horizontal`]: isHorizontal2.value,
      [`${prefixCls.value}-vertical`]: !isHorizontal2.value
    }]);
    const onResize = (entry) => {
      emit("resize", entry);
    };
    return {
      classNames,
      onResize,
      isHorizontal: isHorizontal2
    };
  }
});

// node_modules/@arco-design/web-vue/es/_components/resize-trigger.js
function _sfc_render111(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_IconDragDot = resolveComponent("IconDragDot");
  const _component_IconDragDotVertical = resolveComponent("IconDragDotVertical");
  const _component_ResizeObserver = resolveComponent("ResizeObserver");
  return openBlock(), createBlock(_component_ResizeObserver, { onResize: _ctx.onResize }, {
    default: withCtx(() => [
      createBaseVNode("div", {
        class: normalizeClass(_ctx.classNames)
      }, [
        createCommentVNode(" @slot 自定义内容 "),
        renderSlot(_ctx.$slots, "default", {}, () => [
          createBaseVNode("div", {
            class: normalizeClass(`${_ctx.prefixCls}-icon-wrapper`)
          }, [
            createCommentVNode(" @slot 自定义 icon "),
            renderSlot(_ctx.$slots, "icon", {}, () => [
              _ctx.isHorizontal ? (openBlock(), createBlock(_component_IconDragDot, {
                key: 0,
                class: normalizeClass(`${_ctx.prefixCls}-icon`)
              }, null, 8, ["class"])) : (openBlock(), createBlock(_component_IconDragDotVertical, {
                key: 1,
                class: normalizeClass(`${_ctx.prefixCls}-icon`)
              }, null, 8, ["class"]))
            ])
          ], 2)
        ])
      ], 2)
    ]),
    _: 3
  }, 8, ["onResize"]);
}
var ResizeTrigger = _export_sfc(_sfc_main111, [["render", _sfc_render111]]);

// node_modules/@arco-design/web-vue/es/resize-box/resize-box.js
var __defProp38 = Object.defineProperty;
var __getOwnPropSymbols38 = Object.getOwnPropertySymbols;
var __hasOwnProp38 = Object.prototype.hasOwnProperty;
var __propIsEnum38 = Object.prototype.propertyIsEnumerable;
var __defNormalProp38 = (obj, key, value) => key in obj ? __defProp38(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues38 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp38.call(b, prop))
      __defNormalProp38(a, prop, b[prop]);
  if (__getOwnPropSymbols38)
    for (var prop of __getOwnPropSymbols38(b)) {
      if (__propIsEnum38.call(b, prop))
        __defNormalProp38(a, prop, b[prop]);
    }
  return a;
};
var DIRECTION_LEFT = "left";
var DIRECTION_RIGHT = "right";
var DIRECTION_TOP = "top";
var DIRECTION_BOTTOM = "bottom";
var allDirections = [
  DIRECTION_LEFT,
  DIRECTION_RIGHT,
  DIRECTION_TOP,
  DIRECTION_BOTTOM
];
function getRealSize(pageSize, padding) {
  if (pageSize === 0)
    return 0;
  const res = pageSize - padding;
  return res <= 0 ? 0 : res;
}
function isHorizontal(direction) {
  return [DIRECTION_TOP, DIRECTION_BOTTOM].indexOf(direction) > -1;
}
var _sfc_main112 = defineComponent({
  name: "ResizeBox",
  components: {
    ResizeTrigger
  },
  inheritAttrs: false,
  props: {
    width: {
      type: Number
    },
    height: {
      type: Number
    },
    component: {
      type: String,
      default: "div"
    },
    directions: {
      type: Array,
      default: () => ["right"]
    }
  },
  emits: {
    "update:width": (width) => true,
    "update:height": (height) => true,
    "movingStart": (ev) => true,
    "moving": (size, ev) => true,
    "movingEnd": (ev) => true
  },
  setup(props, { emit }) {
    const { height: propHeight, width: propWidth, directions } = toRefs(props);
    const [width, setWidth] = useMergeState(null, reactive({
      value: propWidth
    }));
    const [height, setHeight] = useMergeState(null, reactive({
      value: propHeight
    }));
    const wrapperRef = ref();
    const paddingStyles = reactive({});
    const prefixCls = getPrefixCls("resizebox");
    const classNames = computed(() => [prefixCls]);
    const styles = computed(() => {
      return __spreadValues38(__spreadValues38(__spreadValues38({}, isNumber(width.value) ? { width: `${width.value}px` } : {}), isNumber(height.value) ? { height: `${height.value}px` } : {}), paddingStyles);
    });
    const allowDirections = computed(() => directions.value.filter((direction) => allDirections.includes(direction)));
    const record = {
      direction: "",
      startPageX: 0,
      startPageY: 0,
      startWidth: 0,
      startHeight: 0,
      moving: false,
      padding: {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      }
    };
    function onMoving(e2) {
      if (!record.moving)
        return;
      const { startPageX, startPageY, startWidth, startHeight, direction } = record;
      let newWidth = startWidth;
      let newHeight = startHeight;
      const offsetX = e2.pageX - startPageX;
      const offsetY = e2.pageY - startPageY;
      switch (direction) {
        case DIRECTION_LEFT:
          newWidth = startWidth - offsetX;
          setWidth(newWidth);
          emit("update:width", newWidth);
          break;
        case DIRECTION_RIGHT:
          newWidth = startWidth + offsetX;
          setWidth(newWidth);
          emit("update:width", newWidth);
          break;
        case DIRECTION_TOP:
          newHeight = startHeight - offsetY;
          setHeight(newHeight);
          emit("update:height", newHeight);
          break;
        case DIRECTION_BOTTOM:
          newHeight = startHeight + offsetY;
          setHeight(newHeight);
          emit("update:height", newHeight);
          break;
      }
      emit("moving", {
        width: newWidth,
        height: newHeight
      }, e2);
    }
    function onMoveEnd(e2) {
      record.moving = false;
      off(window, "mousemove", onMoving);
      off(window, "mouseup", onMoveEnd);
      off(window, "contextmenu", onMoveEnd);
      document.body.style.cursor = "default";
      emit("movingEnd", e2);
    }
    function onMoveStart(direction, e2) {
      var _a, _b;
      emit("movingStart", e2);
      record.moving = true;
      record.startPageX = e2.pageX;
      record.startPageY = e2.pageY;
      record.direction = direction;
      const { top, left, right, bottom } = record.padding;
      record.startWidth = getRealSize(((_a = wrapperRef.value) == null ? void 0 : _a.clientWidth) || 0, left + right);
      record.startHeight = getRealSize(((_b = wrapperRef.value) == null ? void 0 : _b.clientHeight) || 0, top + bottom);
      on(window, "mousemove", onMoving);
      on(window, "mouseup", onMoveEnd);
      on(window, "contextmenu", onMoveEnd);
      document.body.style.cursor = isHorizontal(direction) ? "row-resize" : "col-resize";
    }
    function onTiggerResize(direction, entry) {
      const { width: width2, height: height2 } = entry.contentRect;
      const size = isHorizontal(direction) ? height2 : width2;
      record.padding[direction] = size;
      paddingStyles[`padding-${direction}`] = `${size}px`;
    }
    return {
      prefixCls,
      classNames,
      styles,
      wrapperRef,
      onMoveStart,
      isHorizontal,
      allowDirections,
      onTiggerResize
    };
  }
});
function _sfc_render112(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ResizeTrigger = resolveComponent("ResizeTrigger");
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.component), mergeProps({
    ref: "wrapperRef",
    class: _ctx.classNames
  }, _ctx.$attrs, { style: _ctx.styles }), {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default"),
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.allowDirections, (direction) => {
        return openBlock(), createBlock(_component_ResizeTrigger, {
          key: direction,
          "prefix-cls": `${_ctx.prefixCls}-trigger`,
          class: normalizeClass(`${_ctx.prefixCls}-direction-${direction}`),
          direction: _ctx.isHorizontal(direction) ? "horizontal" : "vertical",
          onMousedown: (e2) => {
            _ctx.onMoveStart(direction, e2);
          },
          onResize: (entry) => {
            _ctx.onTiggerResize(direction, entry);
          }
        }, createSlots({
          default: withCtx(() => [
            _ctx.$slots["resize-trigger"] ? renderSlot(_ctx.$slots, "resize-trigger", {
              key: 0,
              direction
            }) : createCommentVNode("v-if", true)
          ]),
          _: 2
        }, [
          _ctx.$slots["resize-trigger-icon"] ? {
            name: "icon",
            fn: withCtx(() => [
              renderSlot(_ctx.$slots, "resize-trigger-icon", { direction })
            ])
          } : void 0
        ]), 1032, ["prefix-cls", "class", "direction", "onMousedown", "onResize"]);
      }), 128))
    ]),
    _: 3
  }, 16, ["class", "style"]);
}
var _ResizeBox = _export_sfc(_sfc_main112, [["render", _sfc_render112]]);

// node_modules/@arco-design/web-vue/es/resize-box/index.js
var ResizeBox = Object.assign(_ResizeBox, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _ResizeBox.name, _ResizeBox);
  }
});

// node_modules/@arco-design/web-vue/es/_hooks/use-responsive.js
function useResponsive(breakpoint, callback) {
  const resultBreakpoint = computed(() => isRef(breakpoint) ? breakpoint.value : breakpoint);
  let subscribeToken = "";
  onMounted(() => {
    subscribeToken = responsiveObserve.subscribe((screens2, breakpointChecked) => {
      if (!resultBreakpoint.value)
        return;
      if (!breakpointChecked || breakpointChecked === resultBreakpoint.value) {
        callback(!!screens2[resultBreakpoint.value]);
      }
    });
  });
  onUnmounted(() => {
    if (subscribeToken) {
      responsiveObserve.unsubscribe(subscribeToken);
    }
  });
}

// node_modules/@arco-design/web-vue/es/layout/sider.vue_vue&type=script&lang.js
var generateId = (() => {
  let i2 = 0;
  return (prefix = "") => {
    i2 += 1;
    return `${prefix}${i2}`;
  };
})();
var _sfc_main113 = defineComponent({
  name: "LayoutSider",
  components: {
    IconLeft,
    IconRight,
    ResizeBox
  },
  props: {
    theme: {
      type: String,
      default: "light"
    },
    collapsed: {
      type: Boolean,
      default: void 0
    },
    defaultCollapsed: {
      type: Boolean
    },
    collapsible: {
      type: Boolean
    },
    width: {
      type: Number,
      default: 200
    },
    collapsedWidth: {
      type: Number,
      default: 48
    },
    reverseArrow: {
      type: Boolean
    },
    breakpoint: {
      type: String
    },
    resizeDirections: {
      type: Array,
      default: void 0
    },
    hideTrigger: {
      type: Boolean
    }
  },
  emits: [
    "collapse",
    "update:collapsed",
    "breakpoint"
  ],
  setup(props, {
    emit
  }) {
    const {
      theme,
      collapsed,
      defaultCollapsed,
      collapsible,
      hideTrigger,
      breakpoint,
      collapsedWidth,
      resizeDirections
    } = toRefs(props);
    const [localCollapsed, setLocalCollapsed] = useMergeState(defaultCollapsed.value, reactive({
      value: collapsed
    }));
    const componentTag = computed(() => resizeDirections.value ? "ResizeBox" : "div");
    const showTrigger = computed(() => collapsible.value && !hideTrigger.value);
    const prefixCls = getPrefixCls("layout-sider");
    const classNames = computed(() => [prefixCls, {
      [`${prefixCls}-light`]: theme.value === "light",
      [`${prefixCls}-has-trigger`]: showTrigger.value,
      [`${prefixCls}-collapsed`]: collapsed.value
    }]);
    const siderWidth = computed(() => {
      const {
        width,
        collapsedWidth: collapsedWidth2
      } = props;
      const rawWidth = localCollapsed.value ? collapsedWidth2 : width;
      return isNumber(rawWidth) ? `${rawWidth}px` : String(rawWidth);
    });
    const triggerClassNames = computed(() => [`${prefixCls}-trigger`, {
      [`${prefixCls}-trigger-light`]: theme.value === "light"
    }]);
    const toggleTrigger = () => {
      const newCollapsed = !localCollapsed.value;
      setLocalCollapsed(newCollapsed);
      emit("update:collapsed", newCollapsed);
      emit("collapse", newCollapsed, "clickTrigger");
    };
    useResponsive(breakpoint, (checked) => {
      const newCollapsed = !checked;
      if (newCollapsed !== localCollapsed.value) {
        setLocalCollapsed(newCollapsed);
        emit("update:collapsed", newCollapsed);
        emit("collapse", newCollapsed, "responsive");
        emit("breakpoint", newCollapsed);
      }
    });
    const uniqueId = generateId("__arco_layout_sider");
    const siderHook = inject(LayoutSiderInjectionKey, void 0);
    onMounted(() => {
      var _a;
      (_a = siderHook == null ? void 0 : siderHook.onSiderMount) == null ? void 0 : _a.call(siderHook, uniqueId);
    });
    onUnmounted(() => {
      var _a;
      (_a = siderHook == null ? void 0 : siderHook.onSiderUnMount) == null ? void 0 : _a.call(siderHook, uniqueId);
    });
    provide(SiderInjectionKey, reactive({
      theme,
      collapsed: localCollapsed,
      collapsedWidth
    }));
    return {
      componentTag,
      prefixCls,
      classNames,
      triggerClassNames,
      localCollapsed,
      siderWidth,
      showTrigger,
      toggleTrigger
    };
  }
});

// node_modules/@arco-design/web-vue/es/layout/sider.js
var _hoisted_154 = { key: 0 };
var _hoisted_242 = { key: 1 };
function _sfc_render113(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_IconLeft = resolveComponent("IconLeft");
  const _component_IconRight = resolveComponent("IconRight");
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.componentTag), mergeProps({
    class: _ctx.classNames,
    style: { width: _ctx.siderWidth }
  }, _ctx.resizeDirections ? { directions: _ctx.resizeDirections } : {}), {
    default: withCtx(() => [
      createBaseVNode("div", {
        class: normalizeClass(`${_ctx.prefixCls}-children`)
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 2),
      _ctx.showTrigger ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(_ctx.triggerClassNames),
        style: normalizeStyle({ width: _ctx.siderWidth }),
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.toggleTrigger && _ctx.toggleTrigger(...args))
      }, [
        renderSlot(_ctx.$slots, "trigger", { collapsed: _ctx.localCollapsed }, () => [
          !_ctx.reverseArrow ? (openBlock(), createElementBlock("div", _hoisted_154, [
            !_ctx.localCollapsed ? (openBlock(), createBlock(_component_IconLeft, { key: 0 })) : (openBlock(), createBlock(_component_IconRight, { key: 1 }))
          ])) : (openBlock(), createElementBlock("div", _hoisted_242, [
            _ctx.localCollapsed ? (openBlock(), createBlock(_component_IconLeft, { key: 0 })) : (openBlock(), createBlock(_component_IconRight, { key: 1 }))
          ]))
        ])
      ], 6)) : createCommentVNode("v-if", true)
    ]),
    _: 3
  }, 16, ["class", "style"]);
}
var LayoutSider = _export_sfc(_sfc_main113, [["render", _sfc_render113]]);

// node_modules/@arco-design/web-vue/es/layout/index.js
var Layout = Object.assign(_Layout, {
  Header: LayoutHeader,
  Content: LayoutContent,
  Footer: LayoutFooter,
  Sider: LayoutSider,
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Layout.name, _Layout);
    app.component(componentPrefix + LayoutHeader.name, LayoutHeader);
    app.component(componentPrefix + LayoutContent.name, LayoutContent);
    app.component(componentPrefix + LayoutFooter.name, LayoutFooter);
    app.component(componentPrefix + LayoutSider.name, LayoutSider);
  }
});

// node_modules/@arco-design/web-vue/es/pagination/page-item.js
var _sfc_main114 = defineComponent({
  name: "Pager",
  props: {
    pageNumber: {
      type: Number
    },
    current: {
      type: Number
    },
    disabled: {
      type: Boolean,
      default: false
    },
    style: {
      type: Object
    },
    activeStyle: {
      type: Object
    }
  },
  emits: ["click"],
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("pagination-item");
    const isActive = computed(() => props.current === props.pageNumber);
    const handleClick = (e2) => {
      if (!props.disabled) {
        emit("click", props.pageNumber, e2);
      }
    };
    const cls = computed(() => [
      prefixCls,
      {
        [`${prefixCls}-active`]: isActive.value
      }
    ]);
    const mergedStyle = computed(() => {
      return isActive.value ? props.activeStyle : props.style;
    });
    return {
      prefixCls,
      cls,
      mergedStyle,
      handleClick
    };
  }
});
function _sfc_render114(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("li", {
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.mergedStyle),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    renderSlot(_ctx.$slots, "default", { page: _ctx.pageNumber }, () => [
      createTextVNode(toDisplayString(_ctx.pageNumber), 1)
    ])
  ], 6);
}
var Pager = _export_sfc(_sfc_main114, [["render", _sfc_render114]]);

// node_modules/@arco-design/web-vue/es/pagination/utils.js
var getLegalPage = (page, { min, max }) => {
  if (page < min) {
    return min;
  }
  if (page > max) {
    return max;
  }
  return page;
};

// node_modules/@arco-design/web-vue/es/pagination/page-item-step.js
var _sfc_main115 = defineComponent({
  name: "StepPager",
  components: {
    IconLeft,
    IconRight
  },
  props: {
    pages: {
      type: Number,
      required: true
    },
    current: {
      type: Number,
      required: true
    },
    type: {
      type: String,
      required: true
    },
    disabled: {
      type: Boolean,
      default: false
    },
    simple: {
      type: Boolean,
      default: false
    }
  },
  emits: ["click"],
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("pagination-item");
    const isNext = props.type === "next";
    const mergedDisabled = computed(() => {
      if (props.disabled) {
        return props.disabled;
      }
      if (!props.pages) {
        return true;
      }
      if (isNext && props.current === props.pages) {
        return true;
      }
      return !isNext && props.current <= 1;
    });
    const nextPage = computed(() => getLegalPage(props.current + (isNext ? 1 : -1), {
      min: 1,
      max: props.pages
    }));
    const handleClick = (e2) => {
      if (!mergedDisabled.value) {
        emit("click", nextPage.value);
      }
    };
    const cls = computed(() => [
      prefixCls,
      `${prefixCls}-${props.type}`,
      {
        [`${prefixCls}-disabled`]: mergedDisabled.value
      }
    ]);
    return {
      prefixCls,
      cls,
      isNext,
      handleClick
    };
  }
});
function _sfc_render115(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_right = resolveComponent("icon-right");
  const _component_icon_left = resolveComponent("icon-left");
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.simple ? "span" : "li"), {
    class: normalizeClass(_ctx.cls),
    onClick: _ctx.handleClick
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default", {
        type: _ctx.isNext ? "next" : "previous"
      }, () => [
        _ctx.isNext ? (openBlock(), createBlock(_component_icon_right, { key: 0 })) : (openBlock(), createBlock(_component_icon_left, { key: 1 }))
      ])
    ]),
    _: 3
  }, 8, ["class", "onClick"]);
}
var StepPager = _export_sfc(_sfc_main115, [["render", _sfc_render115]]);

// node_modules/@arco-design/web-vue/es/pagination/page-item-ellipsis.js
var _sfc_main116 = defineComponent({
  name: "EllipsisPager",
  components: {
    IconMore
  },
  props: {
    current: {
      type: Number,
      required: true
    },
    step: {
      type: Number,
      default: 5
    },
    pages: {
      type: Number,
      required: true
    }
  },
  emits: ["click"],
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("pagination-item");
    const nextPage = computed(() => getLegalPage(props.current + props.step, {
      min: 1,
      max: props.pages
    }));
    const handleClick = (e2) => {
      emit("click", nextPage.value);
    };
    const cls = computed(() => [prefixCls, `${prefixCls}-ellipsis`]);
    return {
      prefixCls,
      cls,
      handleClick
    };
  }
});
function _sfc_render116(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_more = resolveComponent("icon-more");
  return openBlock(), createElementBlock("li", {
    class: normalizeClass(_ctx.cls),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    renderSlot(_ctx.$slots, "default", {}, () => [
      createVNode(_component_icon_more)
    ])
  ], 2);
}
var EllipsisPager = _export_sfc(_sfc_main116, [["render", _sfc_render116]]);

// node_modules/@arco-design/web-vue/es/pagination/page-jumper.js
var _sfc_main117 = defineComponent({
  name: "PageJumper",
  components: {
    InputNumber
  },
  props: {
    current: {
      type: Number,
      required: true
    },
    simple: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    pages: {
      type: Number,
      required: true
    },
    size: {
      type: String
    },
    onChange: {
      type: Function
    }
  },
  emits: ["change"],
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("pagination-jumper");
    const { t: t2 } = useI18n();
    const inputValue = ref(props.simple ? props.current : void 0);
    const handleFormatter = (value) => {
      const parseIntVal = parseInt(value.toString(), 10);
      return Number.isNaN(parseIntVal) ? void 0 : String(parseIntVal);
    };
    const handleChange = (value) => {
      emit("change", inputValue.value);
      nextTick(() => {
        if (!props.simple) {
          inputValue.value = void 0;
        }
      });
    };
    watch(() => props.current, (value) => {
      if (props.simple && value !== inputValue.value) {
        inputValue.value = value;
      }
    });
    const cls = computed(() => [
      prefixCls,
      {
        [`${prefixCls}-simple`]: props.simple
      }
    ]);
    return {
      prefixCls,
      cls,
      t: t2,
      inputValue,
      handleChange,
      handleFormatter
    };
  }
});
function _sfc_render117(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_input_number = resolveComponent("input-number");
  return openBlock(), createElementBlock("span", {
    class: normalizeClass(_ctx.cls)
  }, [
    !_ctx.simple ? (openBlock(), createElementBlock("span", {
      key: 0,
      class: normalizeClass([`${_ctx.prefixCls}-prepend`, `${_ctx.prefixCls}-text-goto`])
    }, [
      renderSlot(_ctx.$slots, "jumper-prepend", {}, () => [
        createTextVNode(toDisplayString(_ctx.t("pagination.goto")), 1)
      ])
    ], 2)) : createCommentVNode("v-if", true),
    createVNode(_component_input_number, {
      modelValue: _ctx.inputValue,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.inputValue = $event),
      class: normalizeClass(`${_ctx.prefixCls}-input`),
      min: 1,
      max: _ctx.pages,
      size: _ctx.size,
      disabled: _ctx.disabled,
      "hide-button": "",
      formatter: _ctx.handleFormatter,
      onChange: _ctx.handleChange
    }, null, 8, ["modelValue", "class", "max", "size", "disabled", "formatter", "onChange"]),
    _ctx.$slots["jumper-append"] ? (openBlock(), createElementBlock("span", {
      key: 1,
      class: normalizeClass(`${_ctx.prefixCls}-append`)
    }, [
      renderSlot(_ctx.$slots, "jumper-append")
    ], 2)) : createCommentVNode("v-if", true),
    _ctx.simple ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
      createBaseVNode("span", {
        class: normalizeClass(`${_ctx.prefixCls}-separator`)
      }, "/", 2),
      createBaseVNode("span", {
        class: normalizeClass(`${_ctx.prefixCls}-total-page`)
      }, toDisplayString(_ctx.pages), 3)
    ], 64)) : createCommentVNode("v-if", true)
  ], 2);
}
var PageJumper = _export_sfc(_sfc_main117, [["render", _sfc_render117]]);

// node_modules/@arco-design/web-vue/es/select/optgroup.js
var _sfc_main118 = defineComponent({
  name: "Optgroup",
  props: {
    label: {
      type: String
    }
  },
  setup() {
    const prefixCls = getPrefixCls("select-group");
    return {
      prefixCls
    };
  }
});
function _sfc_render118(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(Fragment, null, [
    createBaseVNode("li", {
      class: normalizeClass(`${_ctx.prefixCls}-title`)
    }, [
      renderSlot(_ctx.$slots, "label", {}, () => [
        createTextVNode(toDisplayString(_ctx.label), 1)
      ])
    ], 2),
    renderSlot(_ctx.$slots, "default")
  ], 64);
}
var Optgroup = _export_sfc(_sfc_main118, [["render", _sfc_render118]]);

// node_modules/@arco-design/web-vue/es/_components/virtual-list-v2/hooks/use-size.js
var useSize2 = ({
  dataKeys,
  contentRef,
  fixedSize,
  estimatedSize,
  buffer
}) => {
  const firstRangeAverageSize = ref(0);
  const sizeMap = /* @__PURE__ */ new Map();
  const total = computed(() => dataKeys.value.length);
  const start2 = ref(0);
  const end = computed(() => {
    const _end = start2.value + buffer.value * 3;
    if (_end > total.value)
      return total.value;
    return _end;
  });
  const maxStart = computed(() => {
    const max = total.value - buffer.value * 3;
    if (max < 0)
      return 0;
    return max;
  });
  const setStart = (index3) => {
    if (index3 < 0) {
      start2.value = 0;
    } else if (index3 > maxStart.value) {
      start2.value = maxStart.value;
    } else {
      start2.value = index3;
    }
  };
  const isFixed = ref(fixedSize.value);
  const _estimatedSize = computed(() => {
    if (estimatedSize.value !== 30) {
      return estimatedSize.value;
    }
    return firstRangeAverageSize.value || estimatedSize.value;
  });
  const setItemSize = (key, size) => {
    sizeMap.set(key, size);
  };
  const getItemSize = (index3) => {
    var _a;
    if (isFixed.value) {
      return _estimatedSize.value;
    }
    const _key = dataKeys.value[index3];
    return (_a = sizeMap.get(_key)) != null ? _a : _estimatedSize.value;
  };
  const hasItemSize = (key) => {
    return sizeMap.has(key);
  };
  onMounted(() => {
    const firstRangeTotalSize = Array.from(sizeMap.values()).reduce((pre, value) => pre + value, 0);
    if (firstRangeTotalSize > 0) {
      firstRangeAverageSize.value = firstRangeTotalSize / sizeMap.size;
    }
  });
  const getScrollOffset = (index3) => {
    if (isFixed.value) {
      return _estimatedSize.value * index3;
    }
    return getOffset(0, index3);
  };
  const getOffset = (start22, end2) => {
    let offset = 0;
    for (let i2 = start22; i2 < end2; i2++) {
      offset += getItemSize(i2);
    }
    return offset;
  };
  const frontPadding = computed(() => {
    if (isFixed.value) {
      return _estimatedSize.value * start2.value;
    }
    return getOffset(0, start2.value);
  });
  const getOffsetIndex = (scrollOffset) => {
    const isForward = scrollOffset >= frontPadding.value;
    let offset = Math.abs(scrollOffset - frontPadding.value);
    const _start = isForward ? start2.value : start2.value - 1;
    let offsetIndex = 0;
    while (offset > 0) {
      offset -= getItemSize(_start + offsetIndex);
      isForward ? offsetIndex++ : offsetIndex--;
    }
    return offsetIndex;
  };
  const getStartByScroll = (scrollOffset) => {
    const offsetIndex = getOffsetIndex(scrollOffset);
    const _start = start2.value + offsetIndex - buffer.value;
    if (_start < 0)
      return 0;
    if (_start > maxStart.value)
      return maxStart.value;
    return _start;
  };
  const behindPadding = computed(() => {
    if (isFixed.value) {
      return _estimatedSize.value * (total.value - end.value);
    }
    return getOffset(end.value, total.value);
  });
  return {
    frontPadding,
    behindPadding,
    start: start2,
    end,
    getStartByScroll,
    setItemSize,
    hasItemSize,
    setStart,
    getScrollOffset
  };
};

// node_modules/@arco-design/web-vue/es/_components/virtual-list-v2/virtual-list-item.js
var VirtualListItem = defineComponent({
  name: "VirtualListItem",
  props: {
    hasItemSize: {
      type: Function,
      required: true
    },
    setItemSize: {
      type: Function,
      required: true
    }
  },
  setup(props, {
    slots
  }) {
    var _a;
    const key = (_a = getCurrentInstance()) == null ? void 0 : _a.vnode.key;
    const itemRef = ref();
    const setItemSize = () => {
      var _a2, _b, _c, _d;
      const ele = (_b = (_a2 = itemRef.value) == null ? void 0 : _a2.$el) != null ? _b : itemRef.value;
      const height = (_d = (_c = ele == null ? void 0 : ele.getBoundingClientRect) == null ? void 0 : _c.call(ele).height) != null ? _d : ele == null ? void 0 : ele.offsetHeight;
      if (height) {
        props.setItemSize(key, height);
      }
    };
    onMounted(() => setItemSize());
    onBeforeUnmount(() => setItemSize());
    return () => {
      var _a2;
      const child = getFirstComponent((_a2 = slots.default) == null ? void 0 : _a2.call(slots));
      if (child) {
        return cloneVNode(child, {
          ref: itemRef
        }, true);
      }
      return null;
    };
  }
});

// node_modules/@arco-design/web-vue/es/_components/virtual-list-v2/virtual-list.js
var __defProp39 = Object.defineProperty;
var __getOwnPropSymbols39 = Object.getOwnPropertySymbols;
var __hasOwnProp39 = Object.prototype.hasOwnProperty;
var __propIsEnum39 = Object.prototype.propertyIsEnumerable;
var __defNormalProp39 = (obj, key, value) => key in obj ? __defProp39(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues39 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp39.call(b, prop))
      __defNormalProp39(a, prop, b[prop]);
  if (__getOwnPropSymbols39)
    for (var prop of __getOwnPropSymbols39(b)) {
      if (__propIsEnum39.call(b, prop))
        __defNormalProp39(a, prop, b[prop]);
    }
  return a;
};
var _sfc_main119 = defineComponent({
  name: "VirtualList",
  components: { VirtualListItem },
  props: {
    height: {
      type: [Number, String],
      default: 200
    },
    data: {
      type: Array,
      default: () => []
    },
    threshold: {
      type: Number,
      default: 0
    },
    itemKey: {
      type: String,
      default: "key"
    },
    fixedSize: {
      type: Boolean,
      default: false
    },
    estimatedSize: {
      type: Number,
      default: 30
    },
    buffer: {
      type: Number,
      default: 10
    },
    component: {
      type: [String, Object],
      default: "div"
    },
    listAttrs: {
      type: Object
    },
    contentAttrs: {
      type: Object
    },
    paddingPosition: {
      type: String,
      default: "content"
    }
  },
  emits: {
    scroll: (ev) => true,
    reachBottom: (ev) => true
  },
  setup(props, { emit }) {
    const { data, itemKey, fixedSize, estimatedSize, buffer, height } = toRefs(props);
    const prefixCls = getPrefixCls("virtual-list");
    const mergedComponent = computed(() => {
      if (isObject(props.component)) {
        return __spreadValues39({
          container: "div",
          list: "div",
          content: "div"
        }, props.component);
      }
      return {
        container: props.component,
        list: "div",
        content: "div"
      };
    });
    const containerRef = ref();
    const contentRef = ref();
    const style = computed(() => {
      return {
        height: isNumber(height.value) ? `${height.value}px` : height.value,
        overflow: "auto"
      };
    });
    const dataKeys = computed(() => data.value.map((item, index3) => {
      var _a;
      return (_a = item[itemKey.value]) != null ? _a : index3;
    }));
    const {
      frontPadding,
      behindPadding,
      start: start2,
      end,
      getStartByScroll,
      setItemSize,
      hasItemSize,
      setStart,
      getScrollOffset
    } = useSize2({
      dataKeys,
      contentRef,
      fixedSize,
      estimatedSize,
      buffer
    });
    const currentList = computed(() => {
      if (props.threshold && data.value.length <= props.threshold) {
        return data.value;
      }
      return data.value.slice(start2.value, end.value);
    });
    const onScroll = (ev) => {
      const { scrollTop, scrollHeight, offsetHeight } = ev.target;
      const _start = getStartByScroll(scrollTop);
      if (_start !== start2.value) {
        setStart(_start);
      }
      emit("scroll", ev);
      const bottom = Math.floor(scrollHeight - (scrollTop + offsetHeight));
      if (bottom <= 0) {
        emit("reachBottom", ev);
      }
    };
    const scrollTo2 = (options) => {
      var _a, _b;
      if (containerRef.value) {
        if (isNumber(options)) {
          containerRef.value.scrollTop = options;
        } else {
          const _index = (_b = options.index) != null ? _b : dataKeys.value.indexOf((_a = options.key) != null ? _a : "");
          setStart(_index - buffer.value);
          containerRef.value.scrollTop = getScrollOffset(_index);
          nextTick(() => {
            if (containerRef.value) {
              const _scrollTop = getScrollOffset(_index);
              if (_scrollTop !== containerRef.value.scrollTop) {
                containerRef.value.scrollTop = _scrollTop;
              }
            }
          });
        }
      }
    };
    return {
      prefixCls,
      containerRef,
      contentRef,
      frontPadding,
      currentList,
      behindPadding,
      onScroll,
      setItemSize,
      hasItemSize,
      start: start2,
      scrollTo: scrollTo2,
      style,
      mergedComponent
    };
  }
});
function _sfc_render119(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VirtualListItem = resolveComponent("VirtualListItem");
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.mergedComponent.container), {
    ref: "containerRef",
    class: normalizeClass(_ctx.prefixCls),
    style: normalizeStyle(_ctx.style),
    onScroll: _ctx.onScroll
  }, {
    default: withCtx(() => [
      (openBlock(), createBlock(resolveDynamicComponent(_ctx.mergedComponent.list), mergeProps(_ctx.listAttrs, {
        style: _ctx.paddingPosition === "list" ? {
          paddingTop: `${_ctx.frontPadding}px`,
          paddingBottom: `${_ctx.behindPadding}px`
        } : {}
      }), {
        default: withCtx(() => [
          (openBlock(), createBlock(resolveDynamicComponent(_ctx.mergedComponent.content), mergeProps({ ref: "contentRef" }, _ctx.contentAttrs, {
            style: _ctx.paddingPosition === "content" ? {
              paddingTop: `${_ctx.frontPadding}px`,
              paddingBottom: `${_ctx.behindPadding}px`
            } : {}
          }), {
            default: withCtx(() => [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.currentList, (item, index3) => {
                var _a;
                return openBlock(), createBlock(_component_VirtualListItem, {
                  key: (_a = item[_ctx.itemKey]) != null ? _a : _ctx.start + index3,
                  "has-item-size": _ctx.hasItemSize,
                  "set-item-size": _ctx.setItemSize
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "item", {
                      item,
                      index: _ctx.start + index3
                    })
                  ]),
                  _: 2
                }, 1032, ["has-item-size", "set-item-size"]);
              }), 128))
            ]),
            _: 3
          }, 16, ["style"]))
        ]),
        _: 3
      }, 16, ["style"]))
    ]),
    _: 3
  }, 8, ["class", "style", "onScroll"]);
}
var VirtualList = _export_sfc(_sfc_main119, [["render", _sfc_render119]]);

// node_modules/@arco-design/web-vue/es/select/select.js
var __defProp40 = Object.defineProperty;
var __defProps17 = Object.defineProperties;
var __getOwnPropDescs17 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols40 = Object.getOwnPropertySymbols;
var __hasOwnProp40 = Object.prototype.hasOwnProperty;
var __propIsEnum40 = Object.prototype.propertyIsEnumerable;
var __defNormalProp40 = (obj, key, value) => key in obj ? __defProp40(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues40 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp40.call(b, prop))
      __defNormalProp40(a, prop, b[prop]);
  if (__getOwnPropSymbols40)
    for (var prop of __getOwnPropSymbols40(b)) {
      if (__propIsEnum40.call(b, prop))
        __defNormalProp40(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps17 = (a, b) => __defProps17(a, __getOwnPropDescs17(b));
function _isSlot5(s) {
  return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
var DEFAULT_FIELD_NAMES3 = {
  value: "value",
  label: "label",
  disabled: "disabled",
  tagProps: "tagProps",
  render: "render"
};
var _Select = defineComponent({
  name: "Select",
  components: {
    Trigger,
    SelectView
  },
  inheritAttrs: false,
  props: {
    multiple: {
      type: Boolean,
      default: false
    },
    modelValue: {
      type: [String, Number, Object, Array]
    },
    defaultValue: {
      type: [String, Number, Object, Array],
      default: (props) => isUndefined(props.multiple) ? "" : []
    },
    inputValue: {
      type: String
    },
    defaultInputValue: {
      type: String,
      default: ""
    },
    size: {
      type: String
    },
    placeholder: String,
    loading: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    error: {
      type: Boolean,
      default: false
    },
    allowClear: {
      type: Boolean,
      default: false
    },
    allowSearch: {
      type: [Boolean, Object],
      default: (props) => Boolean(props.multiple)
    },
    allowCreate: {
      type: Boolean,
      default: false
    },
    maxTagCount: {
      type: Number,
      default: 0
    },
    popupContainer: {
      type: [String, Object]
    },
    bordered: {
      type: Boolean,
      default: true
    },
    defaultActiveFirstOption: {
      type: Boolean,
      default: true
    },
    popupVisible: {
      type: Boolean,
      default: void 0
    },
    defaultPopupVisible: {
      type: Boolean,
      default: false
    },
    unmountOnClose: {
      type: Boolean,
      default: false
    },
    filterOption: {
      type: [Boolean, Function],
      default: true
    },
    options: {
      type: Array,
      default: () => []
    },
    virtualListProps: {
      type: Object
    },
    triggerProps: {
      type: Object
    },
    formatLabel: {
      type: Function
    },
    fallbackOption: {
      type: [Boolean, Function],
      default: true
    },
    showExtraOptions: {
      type: Boolean,
      default: true
    },
    valueKey: {
      type: String,
      default: "value"
    },
    searchDelay: {
      type: Number,
      default: 500
    },
    limit: {
      type: Number,
      default: 0
    },
    fieldNames: {
      type: Object
    },
    scrollbar: {
      type: [Boolean, Object],
      default: true
    }
  },
  emits: {
    "update:modelValue": (value) => true,
    "update:inputValue": (inputValue) => true,
    "update:popupVisible": (visible) => true,
    "change": (value) => true,
    "inputValueChange": (inputValue) => true,
    "popupVisibleChange": (visible) => true,
    "clear": (ev) => true,
    "remove": (removed) => true,
    "search": (inputValue) => true,
    "dropdownScroll": (ev) => true,
    "dropdownReachBottom": (ev) => true,
    "exceedLimit": (value, ev) => true
  },
  setup(props, {
    slots,
    emit,
    attrs
  }) {
    const {
      size,
      disabled,
      error,
      options,
      filterOption,
      valueKey,
      multiple,
      popupVisible,
      showExtraOptions,
      modelValue,
      fieldNames,
      loading,
      defaultActiveFirstOption
    } = toRefs(props);
    const prefixCls = getPrefixCls("select");
    const {
      mergedSize,
      mergedDisabled,
      mergedError,
      eventHandlers
    } = useFormItem({
      size,
      disabled,
      error
    });
    const component = computed(() => props.virtualListProps ? "div" : "li");
    const retainInputValue = computed(() => isObject(props.allowSearch) && Boolean(props.allowSearch.retainInputValue));
    computed(() => {
      if (isFunction(props.formatLabel)) {
        return (data) => {
          const optionInfo = optionInfoMap.get(data.value);
          return props.formatLabel(optionInfo);
        };
      }
      return void 0;
    });
    const dropdownRef = ref();
    const optionRefs = ref({});
    const virtualListRef = ref();
    const {
      computedPopupVisible,
      handlePopupVisibleChange
    } = useTrigger({
      popupVisible,
      emit
    });
    const _value = ref(props.defaultValue);
    const computedValueObjects = computed(() => {
      var _a;
      const mergedValue = (_a = props.modelValue) != null ? _a : _value.value;
      const valueArray = isArray(mergedValue) ? mergedValue : mergedValue || isNumber(mergedValue) ? [mergedValue] : [];
      return valueArray.map((value) => ({
        value,
        key: getKeyFromValue(value, props.valueKey)
      }));
    });
    watch(modelValue, (value) => {
      if (isUndefined(value) || isNull(value)) {
        _value.value = multiple.value ? [] : "";
      }
    });
    const computedValueKeys = computed(() => computedValueObjects.value.map((obj) => obj.key));
    const mergedFieldNames = computed(() => __spreadValues40(__spreadValues40({}, DEFAULT_FIELD_NAMES3), fieldNames == null ? void 0 : fieldNames.value));
    const _selectedOption = ref();
    const getRawOptionFromValueKeys = (valueKeys) => {
      const optionMap = {};
      valueKeys.forEach((key) => {
        optionMap[key] = optionInfoMap.get(key);
      });
      return optionMap;
    };
    const updateSelectedOption = (valueKeys) => {
      _selectedOption.value = getRawOptionFromValueKeys(valueKeys);
    };
    const getFallBackOption = (value) => {
      if (isFunction(props.fallbackOption)) {
        return props.fallbackOption(value);
      }
      return {
        [mergedFieldNames.value.value]: value,
        [mergedFieldNames.value.label]: String(isObject(value) ? value[valueKey == null ? void 0 : valueKey.value] : value)
      };
    };
    const getExtraValueData = () => {
      const valueArray = [];
      const keyArray = [];
      if (props.allowCreate || props.fallbackOption) {
        for (const item of computedValueObjects.value) {
          if (!keyArray.includes(item.key)) {
            const optionInfo = optionInfoMap.get(item.key);
            if (!optionInfo || optionInfo.origin === "extraOptions") {
              valueArray.push(item);
              keyArray.push(item.key);
            }
          }
        }
      }
      if (props.allowCreate && computedInputValue.value) {
        const key = getKeyFromValue(computedInputValue.value);
        if (!keyArray.includes(key)) {
          const optionInfo = optionInfoMap.get(key);
          if (!optionInfo || optionInfo.origin === "extraOptions") {
            valueArray.push({
              value: computedInputValue.value,
              key
            });
          }
        }
      }
      return valueArray;
    };
    const extraValueObjects = ref([]);
    const extraOptions = computed(() => extraValueObjects.value.map((obj) => {
      var _a;
      let optionInfo = getFallBackOption(obj.value);
      const extraOptionRawInfo = (_a = _selectedOption.value) == null ? void 0 : _a[obj.key];
      if (!isUndefined(extraOptionRawInfo) && !isEmptyObject(extraOptionRawInfo)) {
        optionInfo = __spreadValues40(__spreadValues40({}, optionInfo), extraOptionRawInfo);
      }
      return optionInfo;
    }));
    nextTick(() => {
      watchEffect(() => {
        var _a;
        const valueData = getExtraValueData();
        if (valueData.length !== extraValueObjects.value.length) {
          extraValueObjects.value = valueData;
        } else if (valueData.length > 0) {
          for (let i2 = 0; i2 < valueData.length; i2++) {
            if (valueData[i2].key !== ((_a = extraValueObjects.value[i2]) == null ? void 0 : _a.key)) {
              extraValueObjects.value = valueData;
              break;
            }
          }
        }
      });
    });
    const _inputValue = ref("");
    const computedInputValue = computed(() => {
      var _a;
      return (_a = props.inputValue) != null ? _a : _inputValue.value;
    });
    watch(computedPopupVisible, (visible) => {
      if (!visible && !retainInputValue.value && computedInputValue.value) {
        updateInputValue("");
      }
    });
    const getValueFromValueKeys = (valueKeys) => {
      var _a, _b;
      if (!props.multiple) {
        return (_b = (_a = optionInfoMap.get(valueKeys[0])) == null ? void 0 : _a.value) != null ? _b : "";
      }
      return valueKeys.map((key) => {
        var _a2, _b2;
        return (_b2 = (_a2 = optionInfoMap.get(key)) == null ? void 0 : _a2.value) != null ? _b2 : "";
      });
    };
    const updateValue = (valueKeys) => {
      var _a, _b;
      const value = getValueFromValueKeys(valueKeys);
      _value.value = value;
      emit("update:modelValue", value);
      emit("change", value);
      (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onChange) == null ? void 0 : _b.call(_a);
      updateSelectedOption(valueKeys);
    };
    const updateInputValue = (inputValue) => {
      _inputValue.value = inputValue;
      emit("update:inputValue", inputValue);
      emit("inputValueChange", inputValue);
    };
    const handleSelect = (key, ev) => {
      if (props.multiple) {
        if (!computedValueKeys.value.includes(key)) {
          if (enabledOptionKeys.value.includes(key)) {
            if (props.limit > 0 && computedValueKeys.value.length >= props.limit) {
              const info = optionInfoMap.get(key);
              emit("exceedLimit", info == null ? void 0 : info.value, ev);
            } else {
              const valueKeys = computedValueKeys.value.concat(key);
              updateValue(valueKeys);
            }
          }
        } else {
          const valueKeys = computedValueKeys.value.filter((_key) => _key !== key);
          updateValue(valueKeys);
        }
        if (!retainInputValue.value) {
          updateInputValue("");
        }
      } else {
        if (key !== computedValueKeys.value[0]) {
          updateValue([key]);
        }
        if (retainInputValue.value) {
          const optionInfo = optionInfoMap.get(key);
          if (optionInfo) {
            updateInputValue(optionInfo.label);
          }
        }
        handlePopupVisibleChange(false);
      }
    };
    const handleSearch = debounce((value) => {
      emit("search", value);
    }, props.searchDelay);
    const handleInputValueChange = (inputValue) => {
      if (inputValue !== computedInputValue.value) {
        if (!computedPopupVisible.value) {
          handlePopupVisibleChange(true);
        }
        updateInputValue(inputValue);
        if (props.allowSearch) {
          handleSearch(inputValue);
        }
      }
    };
    const handleRemove = (key) => {
      const optionInfo = optionInfoMap.get(key);
      const newKeys = computedValueKeys.value.filter((_key) => _key !== key);
      updateValue(newKeys);
      emit("remove", optionInfo == null ? void 0 : optionInfo.value);
    };
    const handleClear = (e2) => {
      e2 == null ? void 0 : e2.stopPropagation();
      const newKeys = computedValueKeys.value.filter((key) => {
        var _a;
        return (_a = optionInfoMap.get(key)) == null ? void 0 : _a.disabled;
      });
      updateValue(newKeys);
      updateInputValue("");
      emit("clear", e2);
    };
    const handleDropdownScroll = (e2) => {
      emit("dropdownScroll", e2);
    };
    const handleDropdownReachBottom = (e2) => {
      emit("dropdownReachBottom", e2);
    };
    const {
      validOptions,
      optionInfoMap,
      validOptionInfos,
      enabledOptionKeys,
      handleKeyDown
    } = useSelect({
      multiple,
      options,
      extraOptions,
      inputValue: computedInputValue,
      filterOption,
      showExtraOptions,
      component,
      valueKey,
      fieldNames,
      loading,
      popupVisible: computedPopupVisible,
      valueKeys: computedValueKeys,
      dropdownRef,
      optionRefs,
      virtualListRef,
      defaultActiveFirstOption,
      onSelect: handleSelect,
      onPopupVisibleChange: handlePopupVisibleChange
    });
    const selectViewValue = computed(() => {
      var _a;
      const result = [];
      for (const item of computedValueObjects.value) {
        const optionInfo = optionInfoMap.get(item.key);
        if (optionInfo) {
          result.push(__spreadProps17(__spreadValues40({}, optionInfo), {
            value: item.key,
            label: (_a = optionInfo == null ? void 0 : optionInfo.label) != null ? _a : String(isObject(item.value) ? item.value[valueKey == null ? void 0 : valueKey.value] : item.value),
            closable: !(optionInfo == null ? void 0 : optionInfo.disabled),
            tagProps: optionInfo == null ? void 0 : optionInfo.tagProps
          }));
        }
      }
      return result;
    });
    const getOptionContentFunc = (optionInfo) => {
      if (isFunction(slots.option)) {
        const optionSlot = slots.option;
        return () => optionSlot({
          data: optionInfo.raw
        });
      }
      if (isFunction(optionInfo.render)) {
        return optionInfo.render;
      }
      return () => optionInfo.label;
    };
    const renderOption = (optionInfo) => {
      if (isGroupOptionInfo(optionInfo)) {
        let _slot;
        return createVNode(Optgroup, {
          "key": optionInfo.key,
          "label": optionInfo.label
        }, _isSlot5(_slot = optionInfo.options.map((child) => renderOption(child))) ? _slot : {
          default: () => [_slot]
        });
      }
      if (!isValidOption(optionInfo, {
        inputValue: computedInputValue.value,
        filterOption: filterOption == null ? void 0 : filterOption.value
      })) {
        return null;
      }
      return createVNode(Option, {
        "ref": (ref2) => {
          if (ref2 == null ? void 0 : ref2.$el) {
            optionRefs.value[optionInfo.key] = ref2.$el;
          }
        },
        "key": optionInfo.key,
        "value": optionInfo.value,
        "label": optionInfo.label,
        "disabled": optionInfo.disabled,
        "internal": true
      }, {
        default: getOptionContentFunc(optionInfo)
      });
    };
    const renderDropDown = () => {
      return createVNode(SelectDropdown, {
        "ref": dropdownRef,
        "loading": props.loading,
        "empty": validOptionInfos.value.length === 0,
        "virtualList": Boolean(props.virtualListProps),
        "scrollbar": props.scrollbar,
        "onScroll": handleDropdownScroll,
        "onReachBottom": handleDropdownReachBottom
      }, {
        "default": () => {
          var _a, _b;
          return [...(_b = (_a = slots.default) == null ? void 0 : _a.call(slots)) != null ? _b : [], ...validOptions.value.map(renderOption)];
        },
        "virtual-list": () => createVNode(VirtualList, mergeProps(props.virtualListProps, {
          "ref": virtualListRef,
          "data": validOptions.value
        }), {
          item: ({
            item
          }) => renderOption(item)
        }),
        "empty": slots.empty,
        "header": slots.header,
        "footer": slots.footer
      });
    };
    const renderLabel = ({
      data
    }) => {
      var _a, _b, _c, _d;
      if ((slots.label || isFunction(props.formatLabel)) && data) {
        const optionInfo = optionInfoMap.get(data.value);
        if (optionInfo == null ? void 0 : optionInfo.raw) {
          return (_c = (_a = slots.label) == null ? void 0 : _a.call(slots, {
            data: optionInfo.raw
          })) != null ? _c : (_b = props.formatLabel) == null ? void 0 : _b.call(props, optionInfo.raw);
        }
      }
      return (_d = data == null ? void 0 : data.label) != null ? _d : "";
    };
    return () => createVNode(Trigger, mergeProps({
      "trigger": "click",
      "position": "bl",
      "popupOffset": 4,
      "animationName": "slide-dynamic-origin",
      "hideEmpty": true,
      "preventFocus": true,
      "autoFitPopupWidth": true,
      "autoFitTransformOrigin": true,
      "disabled": mergedDisabled.value,
      "popupVisible": computedPopupVisible.value,
      "unmountOnClose": props.unmountOnClose,
      "clickToClose": !(props.allowSearch || props.allowCreate),
      "popupContainer": props.popupContainer,
      "onPopupVisibleChange": handlePopupVisibleChange
    }, props.triggerProps), {
      default: () => {
        var _a, _b;
        return [(_b = (_a = slots.trigger) == null ? void 0 : _a.call(slots)) != null ? _b : createVNode(SelectView, mergeProps({
          "class": prefixCls,
          "modelValue": selectViewValue.value,
          "inputValue": computedInputValue.value,
          "multiple": props.multiple,
          "disabled": mergedDisabled.value,
          "error": mergedError.value,
          "loading": props.loading,
          "allowClear": props.allowClear,
          "allowCreate": props.allowCreate,
          "allowSearch": Boolean(props.allowSearch),
          "opened": computedPopupVisible.value,
          "maxTagCount": props.maxTagCount,
          "placeholder": props.placeholder,
          "bordered": props.bordered,
          "size": mergedSize.value,
          "onInputValueChange": handleInputValueChange,
          "onRemove": handleRemove,
          "onClear": handleClear,
          "onKeydown": handleKeyDown
        }, attrs), {
          "label": renderLabel,
          "prefix": slots.prefix,
          "arrow-icon": slots["arrow-icon"],
          "loading-icon": slots["loading-icon"],
          "search-icon": slots["search-icon"]
        })];
      },
      content: renderDropDown
    });
  }
});

// node_modules/@arco-design/web-vue/es/select/index.js
var Select = Object.assign(_Select, {
  Option,
  OptGroup: Optgroup,
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Select.name, _Select);
    app.component(componentPrefix + Option.name, Option);
    app.component(componentPrefix + Optgroup.name, Optgroup);
  }
});

// node_modules/@arco-design/web-vue/es/pagination/page-options.js
var _sfc_main120 = defineComponent({
  name: "PageOptions",
  components: {
    ArcoSelect: Select
  },
  props: {
    sizeOptions: {
      type: Array,
      required: true
    },
    pageSize: Number,
    disabled: Boolean,
    size: {
      type: String
    },
    onChange: {
      type: Function
    },
    selectProps: {
      type: Object
    }
  },
  emits: ["change"],
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("pagination-options");
    const { t: t2 } = useI18n();
    const options = computed(() => props.sizeOptions.map((value) => ({
      value,
      label: `${value} ${t2("pagination.countPerPage")}`
    })));
    const handleChange = (value) => {
      emit("change", value);
    };
    return {
      prefixCls,
      options,
      handleChange
    };
  }
});
function _sfc_render120(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_arco_select = resolveComponent("arco-select");
  return openBlock(), createElementBlock("span", {
    class: normalizeClass(_ctx.prefixCls)
  }, [
    createVNode(_component_arco_select, mergeProps({
      "model-value": _ctx.pageSize,
      options: _ctx.options,
      size: _ctx.size,
      disabled: _ctx.disabled
    }, _ctx.selectProps, { onChange: _ctx.handleChange }), null, 16, ["model-value", "options", "size", "disabled", "onChange"])
  ], 2);
}
var PageOptions = _export_sfc(_sfc_main120, [["render", _sfc_render120]]);

// node_modules/@arco-design/web-vue/es/pagination/pagination.js
var _Pagination = defineComponent({
  name: "Pagination",
  props: {
    total: {
      type: Number,
      required: true
    },
    current: Number,
    defaultCurrent: {
      type: Number,
      default: 1
    },
    pageSize: Number,
    defaultPageSize: {
      type: Number,
      default: 10
    },
    disabled: {
      type: Boolean,
      default: false
    },
    hideOnSinglePage: {
      type: Boolean,
      default: false
    },
    simple: {
      type: Boolean,
      default: false
    },
    showTotal: {
      type: Boolean,
      default: false
    },
    showMore: {
      type: Boolean,
      default: false
    },
    showJumper: {
      type: Boolean,
      default: false
    },
    showPageSize: {
      type: Boolean,
      default: false
    },
    pageSizeOptions: {
      type: Array,
      default: () => [10, 20, 30, 40, 50]
    },
    pageSizeProps: {
      type: Object
    },
    size: {
      type: String
    },
    pageItemStyle: {
      type: Object
    },
    activePageItemStyle: {
      type: Object
    },
    baseSize: {
      type: Number,
      default: 6
    },
    bufferSize: {
      type: Number,
      default: 2
    },
    autoAdjust: {
      type: Boolean,
      default: true
    }
  },
  emits: {
    "update:current": (current) => true,
    "update:pageSize": (pageSize) => true,
    "change": (current) => true,
    "pageSizeChange": (pageSize) => true
  },
  setup(props, {
    emit,
    slots
  }) {
    const prefixCls = getPrefixCls("pagination");
    const {
      t: t2
    } = useI18n();
    const {
      disabled,
      pageItemStyle,
      activePageItemStyle,
      size
    } = toRefs(props);
    const {
      mergedSize
    } = useSize(size);
    const _current = ref(props.defaultCurrent);
    const _pageSize = ref(props.defaultPageSize);
    const computedCurrent = computed(() => {
      var _a;
      return (_a = props.current) != null ? _a : _current.value;
    });
    const computedPageSize = computed(() => {
      var _a;
      return (_a = props.pageSize) != null ? _a : _pageSize.value;
    });
    const pages = computed(() => Math.ceil(props.total / computedPageSize.value));
    const handleClick = (page) => {
      if (page !== computedCurrent.value && isNumber(page) && !props.disabled) {
        _current.value = page;
        emit("update:current", page);
        emit("change", page);
      }
    };
    const handlePageSizeChange = (pageSize) => {
      _pageSize.value = pageSize;
      emit("update:pageSize", pageSize);
      emit("pageSizeChange", pageSize);
    };
    const pagerProps = reactive({
      current: computedCurrent,
      pages,
      disabled,
      style: pageItemStyle,
      activeStyle: activePageItemStyle,
      onClick: handleClick
    });
    const getPageItemElement = (type, props2 = {}) => {
      if (type === "more") {
        return createVNode(EllipsisPager, mergeProps(props2, pagerProps), {
          default: slots["page-item-ellipsis"]
        });
      }
      if (type === "previous") {
        return createVNode(StepPager, mergeProps({
          "type": "previous"
        }, props2, pagerProps), {
          default: slots["page-item-step"]
        });
      }
      if (type === "next") {
        return createVNode(StepPager, mergeProps({
          "type": "next"
        }, props2, pagerProps), {
          default: slots["page-item-step"]
        });
      }
      return createVNode(Pager, mergeProps(props2, pagerProps), {
        default: slots["page-item"]
      });
    };
    const pageList = computed(() => {
      const pageList2 = [];
      if (pages.value < props.baseSize + props.bufferSize * 2) {
        for (let i2 = 1; i2 <= pages.value; i2++) {
          pageList2.push(getPageItemElement("page", {
            key: i2,
            pageNumber: i2
          }));
        }
      } else {
        let left = 1;
        let right = pages.value;
        let hasLeftEllipsis = false;
        let hasRightEllipsis = false;
        if (computedCurrent.value > 2 + props.bufferSize) {
          hasLeftEllipsis = true;
          left = Math.min(computedCurrent.value - props.bufferSize, pages.value - 2 * props.bufferSize);
        }
        if (computedCurrent.value < pages.value - (props.bufferSize + 1)) {
          hasRightEllipsis = true;
          right = Math.max(computedCurrent.value + props.bufferSize, 2 * props.bufferSize + 1);
        }
        if (hasLeftEllipsis) {
          pageList2.push(getPageItemElement("page", {
            key: 1,
            pageNumber: 1
          }));
          pageList2.push(getPageItemElement("more", {
            key: "left-ellipsis-pager",
            step: -(props.bufferSize * 2 + 1)
          }));
        }
        for (let i2 = left; i2 <= right; i2++) {
          pageList2.push(getPageItemElement("page", {
            key: i2,
            pageNumber: i2
          }));
        }
        if (hasRightEllipsis) {
          pageList2.push(getPageItemElement("more", {
            key: "right-ellipsis-pager",
            step: props.bufferSize * 2 + 1
          }));
          pageList2.push(getPageItemElement("page", {
            key: pages.value,
            pageNumber: pages.value
          }));
        }
      }
      return pageList2;
    });
    const renderPager = () => {
      if (props.simple) {
        return createVNode("span", {
          "class": `${prefixCls}-simple`
        }, [getPageItemElement("previous", {
          simple: true
        }), createVNode(PageJumper, {
          "disabled": props.disabled,
          "current": computedCurrent.value,
          "size": mergedSize.value,
          "pages": pages.value,
          "simple": true,
          "onChange": handleClick
        }, null), getPageItemElement("next", {
          simple: true
        })]);
      }
      return createVNode("ul", {
        "class": `${prefixCls}-list`
      }, [getPageItemElement("previous", {
        simple: true
      }), pageList.value, props.showMore && getPageItemElement("more", {
        key: "more",
        step: props.bufferSize * 2 + 1
      }), getPageItemElement("next", {
        simple: true
      })]);
    };
    watch(computedPageSize, (curPageSize, prePageSize) => {
      if (props.autoAdjust && curPageSize !== prePageSize && computedCurrent.value > 1) {
        const index3 = prePageSize * (computedCurrent.value - 1) + 1;
        const newPage = Math.ceil(index3 / curPageSize);
        if (newPage !== computedCurrent.value) {
          _current.value = newPage;
          emit("update:current", newPage);
          emit("change", newPage);
        }
      }
    });
    watch(pages, (curPages, prePages) => {
      if (props.autoAdjust && curPages !== prePages && computedCurrent.value > 1 && computedCurrent.value > curPages) {
        _current.value = curPages;
        emit("update:current", curPages);
        emit("change", curPages);
      }
    });
    const cls = computed(() => [prefixCls, `${prefixCls}-size-${mergedSize.value}`, {
      [`${prefixCls}-simple`]: props.simple,
      [`${prefixCls}-disabled`]: props.disabled
    }]);
    return () => {
      var _a, _b;
      if (props.hideOnSinglePage && pages.value <= 1) {
        return null;
      }
      return createVNode("div", {
        "class": cls.value
      }, [props.showTotal && createVNode("span", {
        "class": `${prefixCls}-total`
      }, [(_b = (_a = slots.total) == null ? void 0 : _a.call(slots, {
        total: props.total
      })) != null ? _b : t2("pagination.total", props.total)]), renderPager(), props.showPageSize && createVNode(PageOptions, {
        "disabled": props.disabled,
        "sizeOptions": props.pageSizeOptions,
        "pageSize": computedPageSize.value,
        "size": mergedSize.value,
        "onChange": handlePageSizeChange,
        "selectProps": props.pageSizeProps
      }, null), !props.simple && props.showJumper && createVNode(PageJumper, {
        "disabled": props.disabled,
        "current": computedCurrent.value,
        "pages": pages.value,
        "size": mergedSize.value,
        "onChange": handleClick
      }, {
        "jumper-prepend": slots["jumper-prepend"],
        "jumper-append": slots["jumper-append"]
      })]);
    };
  }
});

// node_modules/@arco-design/web-vue/es/pagination/index.js
var Pagination = Object.assign(_Pagination, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Pagination.name, _Pagination);
  }
});

// node_modules/@arco-design/web-vue/es/list/use-pagination.js
var usePagination = (props, { emit }) => {
  var _a, _b;
  const _current = ref(isObject(props.paginationProps) ? (_a = props.paginationProps.defaultCurrent) != null ? _a : 1 : 1);
  const _pageSize = ref(isObject(props.paginationProps) ? (_b = props.paginationProps.defaultPageSize) != null ? _b : 10 : 10);
  const current = computed(() => {
    var _a2;
    return isObject(props.paginationProps) ? (_a2 = props.paginationProps.current) != null ? _a2 : _current.value : _current.value;
  });
  const pageSize = computed(() => {
    var _a2;
    return isObject(props.paginationProps) ? (_a2 = props.paginationProps.pageSize) != null ? _a2 : _pageSize.value : _pageSize.value;
  });
  const handlePageChange = (page) => {
    _current.value = page;
    emit("pageChange", page);
  };
  const handlePageSizeChange = (pageSize2) => {
    _pageSize.value = pageSize2;
    emit("pageSizeChange", pageSize2);
  };
  return {
    current,
    pageSize,
    handlePageChange,
    handlePageSizeChange
  };
};

// node_modules/@arco-design/web-vue/es/list/list.js
function _isSlot6(s) {
  return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
var _List = defineComponent({
  name: "List",
  props: {
    data: {
      type: Array
    },
    size: {
      type: String,
      default: "medium"
    },
    bordered: {
      type: Boolean,
      default: true
    },
    split: {
      type: Boolean,
      default: true
    },
    loading: {
      type: Boolean,
      default: false
    },
    hoverable: {
      type: Boolean,
      default: false
    },
    paginationProps: {
      type: Object
    },
    gridProps: {
      type: Object
    },
    maxHeight: {
      type: Number,
      default: 0
    },
    bottomOffset: {
      type: Number,
      default: 0
    },
    virtualListProps: {
      type: Object
    },
    scrollbar: {
      type: [Object, Boolean],
      default: true
    }
  },
  emits: {
    scroll: () => true,
    reachBottom: () => true,
    pageChange: (page) => true,
    pageSizeChange: (pageSize) => true
  },
  setup(props, {
    emit,
    slots
  }) {
    const {
      scrollbar
    } = toRefs(props);
    const prefixCls = getPrefixCls("list");
    const {
      componentRef,
      elementRef: listRef
    } = useComponentRef("containerRef");
    const isVirtualList = computed(() => props.virtualListProps);
    const {
      displayScrollbar,
      scrollbarProps
    } = useScrollbar(scrollbar);
    const handleScroll = (e2) => {
      const {
        scrollTop,
        scrollHeight,
        offsetHeight
      } = e2.target;
      const bottom = Math.floor(scrollHeight - (scrollTop + offsetHeight));
      if (bottom <= props.bottomOffset) {
        emit("reachBottom");
      }
      emit("scroll");
    };
    onMounted(() => {
      if (listRef.value) {
        const {
          scrollTop,
          scrollHeight,
          offsetHeight
        } = listRef.value;
        if (scrollHeight <= scrollTop + offsetHeight) {
          emit("reachBottom");
        }
      }
    });
    const {
      current,
      pageSize,
      handlePageChange,
      handlePageSizeChange
    } = usePagination(props, {
      emit
    });
    const getCurrentPageItems = (data) => {
      if (!props.paginationProps) {
        return data;
      }
      const startIndex = (current.value - 1) * pageSize.value;
      return data.slice(startIndex, startIndex + pageSize.value);
    };
    const renderGridItems = (data) => {
      let _slot2;
      if (!props.gridProps) {
        return null;
      }
      const currentPageItems = getCurrentPageItems(data);
      if (props.gridProps.span) {
        const items = [];
        const rowSize = 24 / props.gridProps.span;
        for (let i2 = 0; i2 < currentPageItems.length; i2 += rowSize) {
          let _slot;
          const nextIndex = i2 + rowSize;
          const rowIndex = Math.floor(i2 / rowSize);
          items.push(createVNode(Grid.Row, {
            "key": rowIndex,
            "class": `${prefixCls}-row`,
            "gutter": props.gridProps.gutter
          }, _isSlot6(_slot = currentPageItems.slice(i2, nextIndex).map((item, index3) => {
            var _a;
            return createVNode(Grid.Col, {
              "key": `${rowIndex}-${index3}`,
              "class": `${prefixCls}-col`,
              "span": (_a = props.gridProps) == null ? void 0 : _a.span
            }, {
              default: () => {
                var _a2;
                return [isVNode(item) ? item : (_a2 = slots.item) == null ? void 0 : _a2.call(slots, {
                  item,
                  index: index3
                })];
              }
            });
          })) ? _slot : {
            default: () => [_slot]
          }));
        }
        return items;
      }
      return createVNode(Grid.Row, {
        "class": `${prefixCls}-row`,
        "gutter": props.gridProps.gutter
      }, _isSlot6(_slot2 = currentPageItems.map((item, index3) => createVNode(Grid.Col, mergeProps({
        "key": index3,
        "class": `${prefixCls}-col`
      }, omit(props.gridProps, ["gutter"])), {
        default: () => {
          var _a;
          return [isVNode(item) ? item : (_a = slots.item) == null ? void 0 : _a.call(slots, {
            item,
            index: index3
          })];
        }
      }))) ? _slot2 : {
        default: () => [_slot2]
      });
    };
    const renderListItems = (data) => {
      const currentPageItems = getCurrentPageItems(data);
      return currentPageItems.map((item, index3) => {
        var _a;
        return isVNode(item) ? item : (_a = slots.item) == null ? void 0 : _a.call(slots, {
          item,
          index: index3
        });
      });
    };
    const renderItems = () => {
      const data = slots.default ? getAllElements(slots.default()) : props.data;
      if (data && data.length > 0) {
        return props.gridProps ? renderGridItems(data) : renderListItems(data);
      }
      return renderEmpty();
    };
    const renderPagination = () => {
      if (!props.paginationProps) {
        return null;
      }
      const paginationProps = omit(props.paginationProps, ["current", "pageSize", "defaultCurrent", "defaultPageSize"]);
      return createVNode(Pagination, mergeProps({
        "class": `${prefixCls}-pagination`
      }, paginationProps, {
        "current": current.value,
        "pageSize": pageSize.value,
        "onChange": handlePageChange,
        "onPageSizeChange": handlePageSizeChange
      }), null);
    };
    const cls = computed(() => [prefixCls, `${prefixCls}-${props.size}`, {
      [`${prefixCls}-bordered`]: props.bordered,
      [`${prefixCls}-split`]: props.split,
      [`${prefixCls}-hover`]: props.hoverable
    }]);
    const contentStyle = computed(() => {
      if (props.maxHeight > 0) {
        return {
          maxHeight: `${props.maxHeight}px`,
          overflowY: "auto"
        };
      }
      return void 0;
    });
    const contentCls = computed(() => [`${prefixCls}-content`, {
      [`${prefixCls}-virtual`]: isVirtualList.value
    }]);
    const virtualListRef = ref();
    const renderVirtualList = () => {
      var _a;
      const currentPageItems = getCurrentPageItems((_a = props.data) != null ? _a : []);
      return currentPageItems.length ? createVNode(VirtualList, mergeProps({
        "ref": virtualListRef,
        "class": contentCls.value,
        "data": currentPageItems
      }, props.virtualListProps, {
        "onScroll": handleScroll
      }), {
        item: ({
          item,
          index: index3
        }) => {
          var _a2;
          return (_a2 = slots.item) == null ? void 0 : _a2.call(slots, {
            item,
            index: index3
          });
        }
      }) : renderEmpty();
    };
    const renderScrollLoading = () => {
      if (slots["scroll-loading"]) {
        return createVNode("div", {
          "class": [`${prefixCls}-item`, `${prefixCls}-scroll-loading`]
        }, [slots["scroll-loading"]()]);
      }
      return null;
    };
    const renderEmpty = () => {
      var _a, _b;
      if (slots["scroll-loading"]) {
        return null;
      }
      return (_b = (_a = slots.empty) == null ? void 0 : _a.call(slots)) != null ? _b : createVNode(Empty2, null, null);
    };
    const render2 = () => {
      const Component = displayScrollbar.value ? Scrollbar : "div";
      return createVNode("div", {
        "class": `${prefixCls}-wrapper`
      }, [createVNode(Spin, {
        "class": `${prefixCls}-spin`,
        "loading": props.loading
      }, {
        default: () => [createVNode(Component, mergeProps({
          "ref": componentRef,
          "class": cls.value,
          "style": contentStyle.value
        }, scrollbarProps.value, {
          "onScroll": handleScroll
        }), {
          default: () => [createVNode("div", {
            "class": `${prefixCls}-content-wrapper`
          }, [slots.header && createVNode("div", {
            "class": `${prefixCls}-header`
          }, [slots.header()]), isVirtualList.value && !props.gridProps ? createVNode(Fragment, null, [renderVirtualList(), renderScrollLoading()]) : createVNode("div", {
            "role": "list",
            "class": contentCls.value
          }, [renderItems(), renderScrollLoading()]), slots.footer && createVNode("div", {
            "class": `${prefixCls}-footer`
          }, [slots.footer()])])]
        }), renderPagination()]
      })]);
    };
    return {
      virtualListRef,
      render: render2
    };
  },
  methods: {
    scrollIntoView(options) {
      if (this.virtualListRef) {
        this.virtualListRef.scrollTo(options);
      }
    }
  },
  render() {
    return this.render();
  }
});

// node_modules/@arco-design/web-vue/es/list/list-item.js
var ListItem = defineComponent({
  name: "ListItem",
  props: {
    actionLayout: {
      type: String,
      default: "horizontal"
    }
  },
  setup(props, {
    slots
  }) {
    const prefixCls = getPrefixCls("list-item");
    const renderAction = () => {
      var _a;
      const actions = (_a = slots.actions) == null ? void 0 : _a.call(slots);
      if (!actions || !actions.length) {
        return null;
      }
      return createVNode("ul", {
        "class": `${prefixCls}-action`
      }, [actions.map((item, index3) => createVNode("li", {
        "key": `${prefixCls}-action-${index3}`
      }, [item]))]);
    };
    return () => {
      var _a, _b;
      return createVNode("div", {
        "role": "listitem",
        "class": prefixCls
      }, [createVNode("div", {
        "class": `${prefixCls}-main`
      }, [(_a = slots.meta) == null ? void 0 : _a.call(slots), createVNode("div", {
        "class": `${prefixCls}-content`
      }, [(_b = slots.default) == null ? void 0 : _b.call(slots)]), props.actionLayout === "vertical" && renderAction()]), props.actionLayout === "horizontal" && renderAction(), slots.extra && createVNode("div", {
        "class": `${prefixCls}-extra`
      }, [slots.extra()])]);
    };
  }
});

// node_modules/@arco-design/web-vue/es/list/list-item-meta.js
var _sfc_main121 = defineComponent({
  name: "ListItemMeta",
  props: {
    title: String,
    description: String
  },
  setup(props, { slots }) {
    const prefixCls = getPrefixCls("list-item-meta");
    const hasContent = Boolean(props.title || props.description || slots.title || slots.description);
    return {
      prefixCls,
      hasContent
    };
  }
});
function _sfc_render121(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.prefixCls)
  }, [
    _ctx.$slots.avatar ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(`${_ctx.prefixCls}-avatar`)
    }, [
      renderSlot(_ctx.$slots, "avatar")
    ], 2)) : createCommentVNode("v-if", true),
    _ctx.hasContent ? (openBlock(), createElementBlock("div", {
      key: 1,
      class: normalizeClass(`${_ctx.prefixCls}-content`)
    }, [
      _ctx.$slots.title || _ctx.title ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(`${_ctx.prefixCls}-title`)
      }, [
        renderSlot(_ctx.$slots, "title", {}, () => [
          createTextVNode(toDisplayString(_ctx.title), 1)
        ])
      ], 2)) : createCommentVNode("v-if", true),
      _ctx.$slots.description || _ctx.description ? (openBlock(), createElementBlock("div", {
        key: 1,
        class: normalizeClass(`${_ctx.prefixCls}-description`)
      }, [
        renderSlot(_ctx.$slots, "description", {}, () => [
          createTextVNode(toDisplayString(_ctx.description), 1)
        ])
      ], 2)) : createCommentVNode("v-if", true)
    ], 2)) : createCommentVNode("v-if", true)
  ], 2);
}
var ListItemMeta = _export_sfc(_sfc_main121, [["render", _sfc_render121]]);

// node_modules/@arco-design/web-vue/es/list/index.js
var List = Object.assign(_List, {
  Item: Object.assign(ListItem, {
    Meta: ListItemMeta
  }),
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _List.name, _List);
    app.component(componentPrefix + ListItem.name, ListItem);
    app.component(componentPrefix + ListItemMeta.name, ListItemMeta);
  }
});

// node_modules/@arco-design/web-vue/es/textarea/utils.js
var sizeStyles = [
  "border-width",
  "box-sizing",
  "font-family",
  "font-weight",
  "font-size",
  "font-variant",
  "letter-spacing",
  "line-height",
  "padding-top",
  "padding-bottom",
  "padding-left",
  "padding-right",
  "text-indent",
  "text-rendering",
  "text-transform",
  "white-space",
  "overflow-wrap",
  "width"
];
var getSizeStyles = (styleDeclaration) => {
  const styles = {};
  sizeStyles.forEach((item) => {
    styles[item] = styleDeclaration.getPropertyValue(item);
  });
  return styles;
};

// node_modules/@arco-design/web-vue/es/textarea/textarea.js
var _sfc_main122 = defineComponent({
  name: "Textarea",
  components: { ResizeObserver: ResizeObserver2, IconHover, IconClose },
  inheritAttrs: false,
  props: {
    modelValue: String,
    defaultValue: {
      type: String,
      default: ""
    },
    placeholder: String,
    disabled: {
      type: Boolean,
      default: false
    },
    error: {
      type: Boolean,
      default: false
    },
    maxLength: {
      type: [Number, Object],
      default: 0
    },
    showWordLimit: {
      type: Boolean,
      default: false
    },
    allowClear: {
      type: Boolean,
      default: false
    },
    autoSize: {
      type: [Boolean, Object],
      default: false
    },
    wordLength: {
      type: Function
    },
    wordSlice: {
      type: Function
    }
  },
  emits: {
    "update:modelValue": (value) => true,
    "input": (value, ev) => true,
    "change": (value, ev) => true,
    "clear": (ev) => true,
    "focus": (ev) => true,
    "blur": (ev) => true
  },
  setup(props, { emit, attrs }) {
    const { disabled, error, modelValue } = toRefs(props);
    const prefixCls = getPrefixCls("textarea");
    const {
      mergedDisabled,
      mergedError: _mergedError,
      eventHandlers
    } = useFormItem({ disabled, error });
    const textareaRef = ref();
    const textareaStyle = ref();
    const mirrorRef = ref();
    const mirrorStyle = ref();
    const _value = ref(props.defaultValue);
    const computedValue = computed(() => {
      var _a;
      return (_a = modelValue.value) != null ? _a : _value.value;
    });
    const [recordCursor, setCursor] = useCursor(textareaRef);
    watch(modelValue, (value) => {
      if (isUndefined(value) || isNull(value)) {
        _value.value = "";
      }
    });
    const maxLengthErrorOnly = computed(() => isObject(props.maxLength) && Boolean(props.maxLength.errorOnly));
    const computedMaxLength = computed(() => {
      if (isObject(props.maxLength)) {
        return props.maxLength.length;
      }
      return props.maxLength;
    });
    const getValueLength = (value) => {
      var _a;
      if (isFunction(props.wordLength)) {
        return props.wordLength(value);
      }
      return (_a = value.length) != null ? _a : 0;
    };
    const valueLength = computed(() => getValueLength(computedValue.value));
    const mergedError = computed(() => _mergedError.value || Boolean(computedMaxLength.value && maxLengthErrorOnly.value && valueLength.value > computedMaxLength.value));
    const isScroll2 = ref(false);
    const focused = ref(false);
    const showClearBtn = computed(() => props.allowClear && !mergedDisabled.value && computedValue.value);
    const isComposition = ref(false);
    const compositionValue = ref("");
    const keepControl = () => {
      recordCursor();
      nextTick(() => {
        if (textareaRef.value && computedValue.value !== textareaRef.value.value) {
          textareaRef.value.value = computedValue.value;
          setCursor();
        }
      });
    };
    const updateValue = (value, inner = true) => {
      var _a, _b;
      if (computedMaxLength.value && !maxLengthErrorOnly.value && getValueLength(value) > computedMaxLength.value) {
        value = (_b = (_a = props.wordSlice) == null ? void 0 : _a.call(props, value, computedMaxLength.value)) != null ? _b : value.slice(0, computedMaxLength.value);
      }
      _value.value = value;
      if (inner) {
        emit("update:modelValue", value);
      }
      keepControl();
    };
    let preValue = computedValue.value;
    const emitChange = (value, ev) => {
      var _a, _b;
      if (value !== preValue) {
        preValue = value;
        emit("change", value, ev);
        (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onChange) == null ? void 0 : _b.call(_a, ev);
      }
    };
    const handleFocus = (ev) => {
      var _a, _b;
      focused.value = true;
      preValue = computedValue.value;
      emit("focus", ev);
      (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onFocus) == null ? void 0 : _b.call(_a, ev);
    };
    const handleBlur = (ev) => {
      var _a, _b;
      focused.value = false;
      emit("blur", ev);
      (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onBlur) == null ? void 0 : _b.call(_a, ev);
      emitChange(computedValue.value, ev);
    };
    const handleComposition = (e2) => {
      var _a, _b;
      const { value } = e2.target;
      if (e2.type === "compositionend") {
        isComposition.value = false;
        compositionValue.value = "";
        if (computedMaxLength.value && !maxLengthErrorOnly.value && computedValue.value.length >= computedMaxLength.value && getValueLength(value) > computedMaxLength.value) {
          keepControl();
          return;
        }
        emit("input", value, e2);
        updateValue(value);
        (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onInput) == null ? void 0 : _b.call(_a, e2);
      } else {
        isComposition.value = true;
      }
    };
    const handleInput = (e2) => {
      var _a, _b;
      const { value } = e2.target;
      if (!isComposition.value) {
        if (computedMaxLength.value && !maxLengthErrorOnly.value && computedValue.value.length >= computedMaxLength.value && getValueLength(value) > computedMaxLength.value && e2.inputType === "insertText") {
          keepControl();
          return;
        }
        emit("input", value, e2);
        updateValue(value);
        (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onInput) == null ? void 0 : _b.call(_a, e2);
      } else {
        compositionValue.value = value;
      }
    };
    const handleClear = (ev) => {
      updateValue("");
      emitChange("", ev);
      emit("clear", ev);
    };
    watch(modelValue, (value) => {
      if (value !== computedValue.value) {
        updateValue(value != null ? value : "", false);
      }
    });
    const getWrapperAttrs = (attr) => omit(attrs, INPUT_EVENTS);
    const getTextareaAttrs = (attr) => pick(attrs, INPUT_EVENTS);
    const wrapperCls = computed(() => [
      `${prefixCls}-wrapper`,
      {
        [`${prefixCls}-focus`]: focused.value,
        [`${prefixCls}-disabled`]: mergedDisabled.value,
        [`${prefixCls}-error`]: mergedError.value,
        [`${prefixCls}-scroll`]: isScroll2.value
      }
    ]);
    let styleDeclaration;
    const lineHeight = ref(0);
    const outerHeight = ref(0);
    const minHeight = computed(() => {
      if (!isObject(props.autoSize) || !props.autoSize.minRows) {
        return 0;
      }
      return props.autoSize.minRows * lineHeight.value + outerHeight.value;
    });
    const maxHeight = computed(() => {
      if (!isObject(props.autoSize) || !props.autoSize.maxRows) {
        return 0;
      }
      return props.autoSize.maxRows * lineHeight.value + outerHeight.value;
    });
    const getMirrorStyle = () => {
      const styles = getSizeStyles(styleDeclaration);
      lineHeight.value = Number.parseInt(styles["line-height"] || 0, 10);
      outerHeight.value = Number.parseInt(styles["border-width"] || 0, 10) * 2 + Number.parseInt(styles["padding-top"] || 0, 10) + Number.parseInt(styles["padding-bottom"] || 0, 10);
      mirrorStyle.value = styles;
      nextTick(() => {
        var _a;
        const mirrorHeight = (_a = mirrorRef.value) == null ? void 0 : _a.offsetHeight;
        let height = mirrorHeight != null ? mirrorHeight : 0;
        let overflow = "hidden";
        if (minHeight.value && height < minHeight.value) {
          height = minHeight.value;
        }
        if (maxHeight.value && height > maxHeight.value) {
          height = maxHeight.value;
          overflow = "auto";
        }
        textareaStyle.value = {
          height: `${height}px`,
          resize: "none",
          overflow
        };
      });
    };
    onMounted(() => {
      if (textareaRef.value) {
        styleDeclaration = window.getComputedStyle(textareaRef.value);
        if (props.autoSize) {
          getMirrorStyle();
        }
      }
      computeIsScroll();
    });
    const handleResize = () => {
      if (props.autoSize && mirrorRef.value) {
        getMirrorStyle();
      }
      computeIsScroll();
    };
    const handleMousedown = (e2) => {
      if (textareaRef.value && e2.target !== textareaRef.value) {
        e2.preventDefault();
        textareaRef.value.focus();
      }
    };
    const computeIsScroll = () => {
      if (textareaRef.value) {
        if (textareaRef.value.scrollHeight > textareaRef.value.offsetHeight) {
          if (!isScroll2.value)
            isScroll2.value = true;
        } else if (isScroll2.value) {
          isScroll2.value = false;
        }
      }
    };
    watch(computedValue, () => {
      if (props.autoSize && mirrorRef.value) {
        getMirrorStyle();
      }
      computeIsScroll();
    });
    return {
      prefixCls,
      wrapperCls,
      textareaRef,
      textareaStyle,
      mirrorRef,
      mirrorStyle,
      computedValue,
      showClearBtn,
      valueLength,
      computedMaxLength,
      mergedDisabled,
      getWrapperAttrs,
      getTextareaAttrs,
      handleInput,
      handleFocus,
      handleBlur,
      handleComposition,
      handleClear,
      handleResize,
      handleMousedown
    };
  },
  methods: {
    focus() {
      var _a;
      (_a = this.$refs.textareaRef) == null ? void 0 : _a.focus();
    },
    blur() {
      var _a;
      (_a = this.$refs.textareaRef) == null ? void 0 : _a.blur();
    }
  }
});
var _hoisted_155 = ["disabled", "value", "placeholder"];
function _sfc_render122(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_resize_observer = resolveComponent("resize-observer");
  const _component_icon_close = resolveComponent("icon-close");
  const _component_icon_hover = resolveComponent("icon-hover");
  return openBlock(), createElementBlock("div", mergeProps(_ctx.getWrapperAttrs(_ctx.$attrs), {
    class: _ctx.wrapperCls,
    onMousedown: _cache[7] || (_cache[7] = (...args) => _ctx.handleMousedown && _ctx.handleMousedown(...args))
  }), [
    _ctx.autoSize ? (openBlock(), createElementBlock("div", {
      key: 0,
      ref: "mirrorRef",
      class: normalizeClass(`${_ctx.prefixCls}-mirror`),
      style: normalizeStyle(_ctx.mirrorStyle)
    }, toDisplayString(`${_ctx.computedValue}
`), 7)) : createCommentVNode("v-if", true),
    createVNode(_component_resize_observer, { onResize: _ctx.handleResize }, {
      default: withCtx(() => [
        createBaseVNode("textarea", mergeProps({ ref: "textareaRef" }, _ctx.getTextareaAttrs(_ctx.$attrs), {
          disabled: _ctx.mergedDisabled,
          class: _ctx.prefixCls,
          style: _ctx.textareaStyle,
          value: _ctx.computedValue,
          placeholder: _ctx.placeholder,
          onInput: _cache[0] || (_cache[0] = (...args) => _ctx.handleInput && _ctx.handleInput(...args)),
          onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
          onBlur: _cache[2] || (_cache[2] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
          onCompositionstart: _cache[3] || (_cache[3] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
          onCompositionupdate: _cache[4] || (_cache[4] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
          onCompositionend: _cache[5] || (_cache[5] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args))
        }), null, 16, _hoisted_155)
      ]),
      _: 1
    }, 8, ["onResize"]),
    renderSlot(_ctx.$slots, "suffix"),
    _ctx.computedMaxLength && _ctx.showWordLimit ? (openBlock(), createElementBlock("div", {
      key: 1,
      class: normalizeClass(`${_ctx.prefixCls}-word-limit`)
    }, toDisplayString(_ctx.valueLength) + "/" + toDisplayString(_ctx.computedMaxLength), 3)) : createCommentVNode("v-if", true),
    _ctx.showClearBtn ? (openBlock(), createElementBlock("div", {
      key: 2,
      class: normalizeClass(`${_ctx.prefixCls}-clear-btn`),
      onClick: _cache[6] || (_cache[6] = (...args) => _ctx.handleClear && _ctx.handleClear(...args))
    }, [
      createVNode(_component_icon_hover, null, {
        default: withCtx(() => [
          createVNode(_component_icon_close)
        ]),
        _: 1
      })
    ], 2)) : createCommentVNode("v-if", true)
  ], 16);
}
var _Textarea = _export_sfc(_sfc_main122, [["render", _sfc_render122]]);

// node_modules/@arco-design/web-vue/es/textarea/index.js
var Textarea = Object.assign(_Textarea, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Textarea.name, _Textarea);
  }
});

// node_modules/@arco-design/web-vue/es/mention/utils.js
var getTextBeforeSelection = (element) => {
  const { value, selectionStart } = element;
  return value.slice(0, selectionStart);
};
var getLastMeasureIndex = (text, prefix) => {
  const _prefix = [].concat(prefix);
  return _prefix.reduce((pre, value) => {
    const lastIndex = text.lastIndexOf(value);
    if (lastIndex > pre.location) {
      return {
        location: lastIndex,
        prefix: value
      };
    }
    return pre;
  }, {
    location: -1,
    prefix: ""
  });
};
var isValidSearch = (text, split) => {
  return !split || !text.includes(split);
};

// node_modules/@arco-design/web-vue/es/mention/mention.js
var __defProp41 = Object.defineProperty;
var __getOwnPropSymbols41 = Object.getOwnPropertySymbols;
var __hasOwnProp41 = Object.prototype.hasOwnProperty;
var __propIsEnum41 = Object.prototype.propertyIsEnumerable;
var __defNormalProp41 = (obj, key, value) => key in obj ? __defProp41(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues41 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp41.call(b, prop))
      __defNormalProp41(a, prop, b[prop]);
  if (__getOwnPropSymbols41)
    for (var prop of __getOwnPropSymbols41(b)) {
      if (__propIsEnum41.call(b, prop))
        __defNormalProp41(a, prop, b[prop]);
    }
  return a;
};
function _isSlot7(s) {
  return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
var _Mention = defineComponent({
  name: "Mention",
  inheritAttrs: false,
  props: {
    modelValue: String,
    defaultValue: {
      type: String,
      default: ""
    },
    data: {
      type: Array,
      default: () => []
    },
    prefix: {
      type: [String, Array],
      default: "@"
    },
    split: {
      type: String,
      default: " "
    },
    type: {
      type: String,
      default: "input"
    },
    disabled: {
      type: Boolean,
      default: false
    },
    allowClear: {
      type: Boolean,
      default: false
    }
  },
  emits: {
    "update:modelValue": (value) => true,
    "change": (value) => true,
    "search": (value) => true,
    "select": (value) => true,
    "clear": (ev) => true,
    "focus": (ev) => true,
    "blur": (ev) => true
  },
  setup(props, {
    emit,
    attrs,
    slots
  }) {
    const prefixCls = getPrefixCls("mention");
    let styleDeclaration;
    const {
      mergedDisabled,
      eventHandlers
    } = useFormItem({
      disabled: toRef(props, "disabled")
    });
    const {
      data,
      modelValue
    } = toRefs(props);
    const dropdownRef = ref();
    const optionRefs = ref({});
    const _value = ref(props.defaultValue);
    const computedValue = computed(() => {
      var _a;
      return (_a = props.modelValue) != null ? _a : _value.value;
    });
    watch(modelValue, (value) => {
      if (isUndefined(value) || isNull(value)) {
        _value.value = "";
      }
    });
    const computedValueKeys = computed(() => computedValue.value ? [getKeyFromValue(computedValue.value)] : []);
    const measureInfo = ref({
      measuring: false,
      location: -1,
      prefix: "",
      text: ""
    });
    const resetMeasureInfo = () => {
      measureInfo.value = {
        measuring: false,
        location: -1,
        prefix: "",
        text: ""
      };
    };
    const inputRef = ref();
    const measureText = computed(() => measureInfo.value.text);
    const filterOption = ref(true);
    const handleInput = (value, e2) => {
      var _a, _b;
      const text = getTextBeforeSelection(e2.target);
      const lastMeasure = getLastMeasureIndex(text, props.prefix);
      if (lastMeasure.location > -1) {
        const measureText2 = text.slice(lastMeasure.location + lastMeasure.prefix.length);
        if (isValidSearch(measureText2, props.split)) {
          _popupVisible.value = true;
          measureInfo.value = __spreadValues41({
            measuring: true,
            text: measureText2
          }, lastMeasure);
          emit("search", measureText2);
        } else if (measureInfo.value.location > -1) {
          resetMeasureInfo();
        }
      } else if (measureInfo.value.location > -1) {
        resetMeasureInfo();
      }
      _value.value = value;
      emit("update:modelValue", value);
      emit("change", value);
      (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onChange) == null ? void 0 : _b.call(_a);
    };
    const handleClear = (ev) => {
      var _a, _b;
      _value.value = "";
      emit("update:modelValue", "");
      emit("change", "");
      (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onChange) == null ? void 0 : _b.call(_a);
      emit("clear", ev);
    };
    const _popupVisible = ref(false);
    const computedPopupVisible = computed(() => _popupVisible.value && measureInfo.value.measuring && validOptionInfos.value.length > 0);
    const handleResize = () => {
      mirrorStyle.value = getSizeStyles(styleDeclaration);
    };
    const handlePopupVisibleChange = (popupVisible) => {
      _popupVisible.value = popupVisible;
    };
    const handleSelect = (key, e2) => {
      var _a, _b, _c;
      const {
        value
      } = (_a = optionInfoMap.get(key)) != null ? _a : {};
      const measureStart = measureInfo.value.location;
      const measureEnd = measureInfo.value.location + measureInfo.value.text.length;
      let head = _value.value.slice(0, measureStart);
      let tail = _value.value.slice(measureEnd + 1);
      head += !head || head.endsWith(props.split) || head.endsWith("\n") ? "" : props.split;
      tail = (!tail || tail.startsWith(props.split) || tail.startsWith("\n") ? "" : props.split) + tail;
      const match = `${measureInfo.value.prefix}${value}`;
      const nextValue = `${head}${match}${tail}`;
      _value.value = nextValue;
      emit("select", value);
      emit("update:modelValue", nextValue);
      emit("change", nextValue);
      resetMeasureInfo();
      (_c = (_b = eventHandlers.value) == null ? void 0 : _b.onChange) == null ? void 0 : _c.call(_b);
    };
    const {
      validOptions,
      optionInfoMap,
      validOptionInfos,
      handleKeyDown
    } = useSelect({
      options: data,
      inputValue: measureText,
      filterOption,
      popupVisible: computedPopupVisible,
      valueKeys: computedValueKeys,
      dropdownRef,
      optionRefs,
      onSelect: handleSelect,
      onPopupVisibleChange: handlePopupVisibleChange,
      enterToOpen: false
    });
    const mirrorStyle = ref();
    onMounted(() => {
      var _a;
      if (props.type === "textarea" && ((_a = inputRef.value) == null ? void 0 : _a.textareaRef)) {
        styleDeclaration = window.getComputedStyle(inputRef.value.textareaRef);
        mirrorStyle.value = getSizeStyles(styleDeclaration);
      }
    });
    const getOptionContentFunc = (item) => {
      if (isFunction(slots.option) && item.value) {
        const optionInfo = optionInfoMap.get(item.key);
        const optionSlot = slots.option;
        return () => optionSlot({
          data: optionInfo
        });
      }
      return () => item.label;
    };
    const renderOption = (item) => {
      return createVNode(Option, {
        "ref": (ref2) => {
          if (ref2 == null ? void 0 : ref2.$el) {
            optionRefs.value[item.key] = ref2.$el;
          }
        },
        "key": item.key,
        "value": item.value,
        "disabled": item.disabled,
        "internal": true
      }, {
        default: getOptionContentFunc(item)
      });
    };
    const renderDropdown = () => {
      let _slot;
      return createVNode(SelectDropdown, {
        "ref": dropdownRef
      }, _isSlot7(_slot = validOptions.value.map((info) => renderOption(info))) ? _slot : {
        default: () => [_slot]
      });
    };
    const mirrorRef = ref();
    watch(computedPopupVisible, (visible) => {
      if (props.type === "textarea" && visible) {
        nextTick(() => {
          var _a, _b;
          if (((_a = inputRef.value) == null ? void 0 : _a.textareaRef) && inputRef.value.textareaRef.scrollTop > 0) {
            (_b = mirrorRef.value) == null ? void 0 : _b.scrollTo(0, inputRef.value.textareaRef.scrollTop);
          }
        });
      }
    });
    const onFocus = (ev) => {
      emit("focus", ev);
    };
    const onBlur = (ev) => {
      emit("blur", ev);
    };
    const render2 = () => {
      var _a;
      if (props.type === "textarea") {
        return createVNode("div", {
          "class": prefixCls
        }, [createVNode(ResizeObserver2, {
          "onResize": handleResize
        }, {
          default: () => [createVNode(Textarea, mergeProps(attrs, {
            "ref": inputRef,
            "allowClear": props.allowClear,
            "modelValue": computedValue.value,
            "onInput": handleInput,
            "onClear": handleClear,
            "onFocus": onFocus,
            "onBlur": onBlur,
            "onKeydown": handleKeyDown
          }), null)]
        }), measureInfo.value.measuring && validOptionInfos.value.length > 0 && createVNode("div", {
          "ref": mirrorRef,
          "style": mirrorStyle.value,
          "class": `${prefixCls}-measure`
        }, [(_a = computedValue.value) == null ? void 0 : _a.slice(0, measureInfo.value.location), createVNode(Trigger, {
          "trigger": "focus",
          "position": "bl",
          "popupOffset": 4,
          "preventFocus": true,
          "popupVisible": computedPopupVisible.value,
          "clickToClose": false,
          "onPopupVisibleChange": handlePopupVisibleChange
        }, {
          default: () => [createVNode("span", null, [createTextVNode("@")])],
          content: renderDropdown
        })])]);
      }
      return createVNode(Trigger, {
        "trigger": "focus",
        "position": "bl",
        "animationName": "slide-dynamic-origin",
        "popupOffset": 4,
        "preventFocus": true,
        "popupVisible": computedPopupVisible.value,
        "clickToClose": false,
        "autoFitPopupWidth": true,
        "autoFitTransformOrigin": true,
        "disabled": mergedDisabled.value,
        "onPopupVisibleChange": handlePopupVisibleChange
      }, {
        default: () => [createVNode(Input, mergeProps(attrs, {
          "ref": inputRef,
          "allowClear": props.allowClear,
          "modelValue": computedValue.value,
          "disabled": mergedDisabled.value,
          "onInput": handleInput,
          "onClear": handleClear,
          "onFocus": onFocus,
          "onBlur": onBlur,
          "onKeydown": handleKeyDown
        }), slots)],
        content: renderDropdown
      });
    };
    return {
      inputRef,
      render: render2
    };
  },
  methods: {
    focus() {
      var _a;
      (_a = this.inputRef) == null ? void 0 : _a.focus();
    },
    blur() {
      var _a;
      (_a = this.inputRef) == null ? void 0 : _a.blur();
    }
  },
  render() {
    return this.render();
  }
});

// node_modules/@arco-design/web-vue/es/mention/index.js
var Mention = Object.assign(_Mention, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Mention.name, _Mention);
  }
});

// node_modules/@arco-design/web-vue/es/menu/context.js
var MenuInjectionKey = Symbol("MenuInjectionKey");
var LevelInjectionKey = Symbol("LevelInjectionKey");
var DataCollectorInjectionKey = Symbol("DataCollectorInjectionKey");

// node_modules/@arco-design/web-vue/es/icon/icon-menu-fold/icon-menu-fold.js
var _sfc_main123 = defineComponent({
  name: "IconMenuFold",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-menu-fold`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_156 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_243 = createBaseVNode("path", { d: "M42 11H6M42 24H22M42 37H6M13.66 26.912l-4.82-3.118 4.82-3.118v6.236Z" }, null, -1);
var _hoisted_339 = [
  _hoisted_243
];
function _sfc_render123(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_339, 14, _hoisted_156);
}
var _IconMenuFold = _export_sfc(_sfc_main123, [["render", _sfc_render123]]);

// node_modules/@arco-design/web-vue/es/icon/icon-menu-fold/index.js
var IconMenuFold = Object.assign(_IconMenuFold, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconMenuFold.name, _IconMenuFold);
  }
});

// node_modules/@arco-design/web-vue/es/icon/icon-menu-unfold/icon-menu-unfold.js
var _sfc_main124 = defineComponent({
  name: "IconMenuUnfold",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-menu-unfold`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_157 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_244 = createBaseVNode("path", { d: "M6 11h36M22 24h20M6 37h36M8 20.882 12.819 24 8 27.118v-6.236Z" }, null, -1);
var _hoisted_340 = [
  _hoisted_244
];
function _sfc_render124(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_340, 14, _hoisted_157);
}
var _IconMenuUnfold = _export_sfc(_sfc_main124, [["render", _sfc_render124]]);

// node_modules/@arco-design/web-vue/es/icon/icon-menu-unfold/index.js
var IconMenuUnfold = Object.assign(_IconMenuUnfold, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconMenuUnfold.name, _IconMenuUnfold);
  }
});

// node_modules/@arco-design/web-vue/es/menu/hooks/use-level.js
function provideLevel(level) {
  const computedLevel = computed(() => isRef(level) ? level.value : level);
  provide(LevelInjectionKey, reactive({
    level: computedLevel
  }));
}
function useLevel(props) {
  const { provideNextLevel } = props || {};
  const levelContext = inject(LevelInjectionKey);
  const level = computed(() => (levelContext == null ? void 0 : levelContext.level) || 1);
  if (provideNextLevel) {
    const nextLevel = computed(() => level.value + 1);
    provideLevel(nextLevel);
  }
  return {
    level
  };
}

// node_modules/@arco-design/web-vue/es/menu/hooks/use-menu-data-collector.js
function getKeys(data, condition) {
  const keys = [];
  const loop = (list) => {
    list.forEach((item) => {
      if (condition(item)) {
        keys.push(item.key);
      }
      if (item.children) {
        loop(item.children);
      }
    });
  };
  loop(data);
  return keys;
}
function useMenuDataCollectorContext(isRoot = false) {
  const menuContext = isRoot ? void 0 : inject(DataCollectorInjectionKey);
  return menuContext;
}
function useMenuDataCollector(props) {
  const { key, type } = props;
  const data = ref([]);
  const menuContext = useMenuDataCollectorContext(type === "menu");
  const provideContext = {
    collectSubMenu(key2, children, isReport = false) {
      const item = {
        key: key2,
        children
      };
      if (isReport) {
        const oldOne = data.value.find((i2) => i2.key === key2);
        if (oldOne) {
          oldOne.children = children;
        } else {
          data.value.push(item);
        }
      } else {
        data.value = [...data.value, item];
      }
      if (isReport) {
        if (type === "popupMenu") {
          menuContext == null ? void 0 : menuContext.reportMenuData(data.value);
        } else if (type === "subMenu" && !isUndefined(key2)) {
          menuContext == null ? void 0 : menuContext.collectSubMenu(key2, data.value, true);
        }
      }
    },
    removeSubMenu(key2) {
      data.value = data.value.filter((item) => item.key !== key2);
    },
    collectMenuItem(key2) {
      data.value.push({ key: key2 });
    },
    removeMenuItem(key2) {
      data.value = data.value.filter((item) => item.key !== key2);
    },
    reportMenuData(reportData) {
      data.value = reportData;
      if (type === "subMenu" && !isUndefined(key)) {
        menuContext == null ? void 0 : menuContext.collectSubMenu(key, data.value, true);
      }
    }
  };
  provide(DataCollectorInjectionKey, provideContext);
  if (type === "subMenu" && !isUndefined(key)) {
    onMounted(() => {
      menuContext == null ? void 0 : menuContext.collectSubMenu(key, data.value);
    });
    onUnmounted(() => {
      menuContext == null ? void 0 : menuContext.removeSubMenu(key);
    });
  } else if (type === "popupMenu") {
    onMounted(() => {
      menuContext == null ? void 0 : menuContext.reportMenuData(data.value);
    });
  }
  return {
    menuData: data,
    subMenuKeys: computed(() => getKeys(data.value, (item) => !!item.children)),
    menuItemKeys: computed(() => getKeys(data.value, (item) => !item.children))
  };
}

// node_modules/@arco-design/web-vue/es/menu/hooks/use-menu-open-state.js
function getPath(data, key) {
  const path = [];
  const loop = (list) => {
    for (let i2 = 0; i2 < list.length; i2++) {
      const item = list[i2];
      if (item.key === key) {
        return true;
      }
      if (item.children) {
        path.push(item.key);
        const matched = loop(item.children);
        if (matched) {
          return true;
        }
        path.pop();
      }
    }
    return false;
  };
  loop(data);
  return path;
}
function isSameKeys(keys1, keys2) {
  if (keys1.length !== keys2.length)
    return false;
  return keys1.toString() === keys2.toString();
}
function useMenuOpenState(props) {
  const {
    modelValue,
    defaultValue,
    autoOpen,
    autoOpenSelected,
    subMenuKeys,
    selectedKeys,
    menuData,
    accordion
  } = toRefs(props);
  const localValue = ref(!isUndefined(modelValue.value) ? modelValue.value : !isUndefined(defaultValue.value) ? defaultValue.value : []);
  const setLocalValue = (val) => {
    localValue.value = val;
  };
  watch(modelValue, () => {
    if (isUndefined(modelValue.value)) {
      setLocalValue([]);
    }
  });
  let mountedSubMenuKeys = [];
  onMounted(() => {
    mountedSubMenuKeys = [...subMenuKeys.value];
    let newOpenKeys = [];
    if (autoOpen.value) {
      newOpenKeys = accordion.value ? subMenuKeys.value.slice(0, 1) : [...subMenuKeys.value];
    }
    if (autoOpenSelected.value) {
      const pathList = selectedKeys.value.map((key) => getPath(menuData.value, key));
      if (pathList.length && (!autoOpen.value || accordion.value)) {
        newOpenKeys = accordion.value ? pathList[0] : [...new Set([].concat(...pathList))];
      }
    }
    if (newOpenKeys.length) {
      setLocalValue(newOpenKeys);
    }
  });
  let hasTriggered = false;
  watch(subMenuKeys, (currentKeys, prevKeys = []) => {
    if (hasTriggered || !isSameKeys(currentKeys, mountedSubMenuKeys)) {
      const newOpenKeys = openKeys.value.filter((key) => currentKeys.includes(key));
      if (autoOpen.value) {
        const keysAdded = currentKeys.filter((key) => !prevKeys.includes(key));
        newOpenKeys.push(...keysAdded);
      }
      setLocalValue(accordion.value ? newOpenKeys.slice(0, 1) : newOpenKeys);
    }
    hasTriggered = true;
  });
  const openKeys = computed(() => modelValue.value || localValue.value);
  return {
    openKeys,
    localOpenKeys: localValue,
    setOpenKeys: setLocalValue,
    open(key, level) {
      let newOpenKeys = [];
      if (openKeys.value.indexOf(key) > -1) {
        if (accordion.value && level === 1) {
          newOpenKeys = [];
        } else {
          newOpenKeys = openKeys.value.filter((i2) => i2 !== key);
        }
      } else if (accordion.value && level === 1) {
        newOpenKeys = [key];
      } else {
        newOpenKeys = openKeys.value.concat([key]);
      }
      setLocalValue(newOpenKeys);
      return newOpenKeys;
    }
  };
}

// node_modules/@arco-design/web-vue/es/menu/base-menu.js
var _sfc_main125 = defineComponent({
  name: "BaseMenu",
  components: {
    IconMenuFold,
    IconMenuUnfold
  },
  inheritAttrs: false,
  props: {
    style: {
      type: Object
    },
    theme: {
      type: String,
      default: "light"
    },
    mode: {
      type: String,
      default: "vertical"
    },
    levelIndent: {
      type: Number
    },
    autoOpen: {
      type: Boolean
    },
    collapsed: {
      type: Boolean,
      default: void 0
    },
    defaultCollapsed: {
      type: Boolean
    },
    collapsedWidth: {
      type: Number
    },
    accordion: {
      type: Boolean
    },
    autoScrollIntoView: {
      type: Boolean
    },
    showCollapseButton: {
      type: Boolean
    },
    selectedKeys: {
      type: Array
    },
    defaultSelectedKeys: {
      type: Array,
      default: () => []
    },
    openKeys: {
      type: Array
    },
    defaultOpenKeys: {
      type: Array,
      default: () => []
    },
    scrollConfig: {
      type: Object
    },
    triggerProps: {
      type: Object
    },
    tooltipProps: {
      type: Object
    },
    autoOpenSelected: {
      type: Boolean
    },
    breakpoint: {
      type: String
    },
    popupMaxHeight: {
      type: [Boolean, Number],
      default: true
    },
    prefixCls: {
      type: String
    },
    inTrigger: {
      type: Boolean
    },
    siderCollapsed: {
      type: Boolean
    },
    isRoot: {
      type: Boolean
    }
  },
  emits: [
    "update:collapsed",
    "update:selectedKeys",
    "update:openKeys",
    "collapse",
    "menu-item-click",
    "sub-menu-click"
  ],
  setup(props, { emit, slots }) {
    const {
      style,
      mode,
      theme,
      levelIndent,
      accordion,
      showCollapseButton,
      scrollConfig,
      autoScrollIntoView,
      collapsedWidth,
      autoOpen,
      collapsed: propCollapsed,
      defaultCollapsed,
      selectedKeys: propSelectedKeys,
      defaultSelectedKeys,
      openKeys: propOpenKeys,
      defaultOpenKeys,
      triggerProps,
      tooltipProps,
      autoOpenSelected,
      breakpoint,
      popupMaxHeight,
      prefixCls,
      inTrigger,
      siderCollapsed,
      isRoot
    } = toRefs(props);
    const { subMenuKeys, menuData } = useMenuDataCollector({
      type: isRoot.value ? "menu" : "popupMenu"
    });
    const [selectedKeys, setSelectedKeys] = useMergeState(defaultSelectedKeys.value, reactive({
      value: propSelectedKeys
    }));
    const { openKeys, setOpenKeys, open: open3 } = useMenuOpenState(reactive({
      modelValue: propOpenKeys,
      defaultValue: defaultOpenKeys,
      autoOpen,
      autoOpenSelected,
      selectedKeys,
      subMenuKeys,
      menuData,
      accordion
    }));
    const [collapsed, setCollapsed] = useMergeState(defaultCollapsed.value, reactive({
      value: propCollapsed
    }));
    const computedCollapsed = computed(() => siderCollapsed.value || collapsed.value || mode.value === "popButton");
    const computedHasCollapseButton = computed(() => ["horizontal", "popButton"].indexOf(mode.value) < 0 && !inTrigger.value && showCollapseButton.value);
    const changeCollapsed = (newVal, type) => {
      if (newVal === collapsed.value)
        return;
      setCollapsed(newVal);
      emit("update:collapsed", newVal);
      emit("collapse", newVal, type);
    };
    const onCollapseBtnClick = () => {
      changeCollapsed(!collapsed.value, "clickTrigger");
    };
    useResponsive(breakpoint, (checked) => {
      changeCollapsed(!checked, "responsive");
    });
    const computedPrefixCls = computed(() => (prefixCls == null ? void 0 : prefixCls.value) || getPrefixCls("menu"));
    const classNames = computed(() => [
      computedPrefixCls.value,
      `${computedPrefixCls.value}-${theme == null ? void 0 : theme.value}`,
      {
        [`${computedPrefixCls.value}-horizontal`]: mode.value === "horizontal",
        [`${computedPrefixCls.value}-vertical`]: mode.value !== "horizontal",
        [`${computedPrefixCls.value}-collapsed`]: computedCollapsed.value,
        [`${computedPrefixCls.value}-pop`]: mode.value === "pop" || computedCollapsed.value,
        [`${computedPrefixCls.value}-pop-button`]: mode.value === "popButton"
      }
    ]);
    const computedStyle = computed(() => {
      const pxCollapsedWidth = isNumber(collapsedWidth.value) ? `${collapsedWidth.value}px` : void 0;
      const objectStyle = isObject(style.value) ? style.value : void 0;
      const width = computedCollapsed.value ? pxCollapsedWidth : objectStyle == null ? void 0 : objectStyle.width;
      return [
        objectStyle ? omit(objectStyle, ["width"]) : style.value,
        { width }
      ];
    });
    const expandIconDown = usePickSlots(slots, "expand-icon-down");
    const expandIconRight = usePickSlots(slots, "expand-icon-right");
    const menuContext = reactive({
      theme,
      mode,
      levelIndent,
      autoScrollIntoView,
      selectedKeys,
      openKeys,
      prefixCls: computedPrefixCls,
      scrollConfig,
      inTrigger,
      collapsed: computedCollapsed,
      triggerProps,
      tooltipProps,
      popupMaxHeight,
      expandIconDown,
      expandIconRight,
      onMenuItemClick: (key) => {
        setSelectedKeys([key]);
        emit("update:selectedKeys", [key]);
        emit("menu-item-click", key);
      },
      onSubMenuClick: (key, level) => {
        const newOpenKeys = open3(key, level);
        setOpenKeys(newOpenKeys);
        emit("update:openKeys", newOpenKeys);
        emit("sub-menu-click", key, newOpenKeys);
      }
    });
    provide(MenuInjectionKey, menuContext);
    provideLevel(1);
    return {
      computedPrefixCls,
      classNames,
      computedStyle,
      computedCollapsed,
      computedHasCollapseButton,
      onCollapseBtnClick
    };
  }
});
function _sfc_render125(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_IconMenuUnfold = resolveComponent("IconMenuUnfold");
  const _component_IconMenuFold = resolveComponent("IconMenuFold");
  return openBlock(), createElementBlock("div", mergeProps({ class: _ctx.classNames }, _ctx.$attrs, { style: _ctx.computedStyle }), [
    createBaseVNode("div", {
      class: normalizeClass(`${_ctx.computedPrefixCls}-inner`)
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 2),
    _ctx.computedHasCollapseButton ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(`${_ctx.computedPrefixCls}-collapse-button`),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onCollapseBtnClick && _ctx.onCollapseBtnClick(...args))
    }, [
      renderSlot(_ctx.$slots, "collapse-icon", { collapsed: _ctx.computedCollapsed }, () => [
        _ctx.computedCollapsed ? (openBlock(), createBlock(_component_IconMenuUnfold, { key: 0 })) : (openBlock(), createBlock(_component_IconMenuFold, { key: 1 }))
      ])
    ], 2)) : createCommentVNode("v-if", true)
  ], 16);
}
var BaseMenu = _export_sfc(_sfc_main125, [["render", _sfc_render125]]);

// node_modules/@arco-design/web-vue/es/_utils/style.js
function getStyle(element, prop) {
  if (!element || !prop)
    return null;
  let styleName = prop;
  if (styleName === "float") {
    styleName = "cssFloat";
  }
  try {
    if (document.defaultView) {
      const computed2 = document.defaultView.getComputedStyle(element, "");
      return element.style[styleName] || computed2 ? computed2[styleName] : "";
    }
  } catch (e2) {
    return element.style[styleName];
  }
  return null;
}

// node_modules/@arco-design/web-vue/es/menu/hooks/use-menu-context.js
function useMenuContext() {
  const menuContext = inject(MenuInjectionKey);
  return menuContext || {};
}

// node_modules/@arco-design/web-vue/es/menu/hooks/use-menu.js
var generateId2 = (() => {
  let i2 = 0;
  return (prefix = "") => {
    i2 += 1;
    return `${prefix}${i2}`;
  };
})();
function useMenu() {
  const instance = getCurrentInstance();
  const key = computed(() => (instance == null ? void 0 : instance.vnode.key) || generateId2("__arco_menu"));
  return {
    key
  };
}

// node_modules/@arco-design/web-vue/es/menu/indent.js
var _sfc_main126 = defineComponent({
  name: "MenuIndent",
  props: {
    level: {
      type: Number,
      default: 1
    }
  },
  setup() {
    const prefixCls = getPrefixCls("menu");
    const menuContext = useMenuContext();
    return {
      prefixCls,
      levelIndent: toRef(menuContext, "levelIndent")
    };
  }
});
function _sfc_render126(_ctx, _cache, $props, $setup, $data, $options) {
  return _ctx.level > 1 ? (openBlock(), createElementBlock("span", {
    key: 0,
    class: normalizeClass(`${_ctx.prefixCls}-indent-list`)
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.level - 1, (index3) => {
      return openBlock(), createElementBlock("span", {
        key: index3,
        class: normalizeClass(`${_ctx.prefixCls}-indent`),
        style: normalizeStyle(`width: ${_ctx.levelIndent}px`)
      }, null, 6);
    }), 128))
  ], 2)) : createCommentVNode("v-if", true);
}
var MenuIndent = _export_sfc(_sfc_main126, [["render", _sfc_render126]]);

// node_modules/@arco-design/web-vue/es/_components/transition/expand-transition.js
var _sfc_main127 = defineComponent({
  name: "ExpandTransition",
  setup() {
    return {
      onBeforeEnter(el) {
        el.style.height = "0";
      },
      onEnter(el) {
        el.style.height = `${el.scrollHeight}px`;
      },
      onAfterEnter(el) {
        el.style.height = "";
      },
      onBeforeLeave(el) {
        el.style.height = `${el.scrollHeight}px`;
      },
      onLeave(el) {
        el.style.height = `0`;
      },
      onAfterLeave(el) {
        el.style.height = ``;
      }
    };
  }
});
function _sfc_render127(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, {
    onBeforeEnter: _ctx.onBeforeEnter,
    onEnter: _ctx.onEnter,
    onAfterEnter: _ctx.onAfterEnter,
    onBeforeLeave: _ctx.onBeforeLeave,
    onLeave: _ctx.onLeave,
    onAfterLeave: _ctx.onAfterLeave
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 8, ["onBeforeEnter", "onEnter", "onAfterEnter", "onBeforeLeave", "onLeave", "onAfterLeave"]);
}
var ExpandTransition = _export_sfc(_sfc_main127, [["render", _sfc_render127]]);

// node_modules/@arco-design/web-vue/es/menu/sub-menu-inline.js
var _sfc_main128 = defineComponent({
  name: "SubMenuInline",
  components: {
    MenuIndent,
    ExpandTransition
  },
  props: {
    title: {
      type: String
    },
    isChildrenSelected: {
      type: Boolean
    }
  },
  setup(props) {
    const { key } = useMenu();
    const { level } = useLevel({
      provideNextLevel: true
    });
    const menuContext = useMenuContext();
    const menuPrefixCls = computed(() => menuContext.prefixCls);
    const prefixCls = computed(() => `${menuPrefixCls.value}-inline`);
    const classNames = computed(() => [prefixCls.value]);
    const isSelected = computed(() => props.isChildrenSelected);
    const isOpen = computed(() => (menuContext.openKeys || []).indexOf(key.value) > -1);
    return {
      prefixCls,
      menuPrefixCls,
      classNames,
      level,
      isSelected,
      isOpen,
      onHeaderClick: () => {
        menuContext.onSubMenuClick && menuContext.onSubMenuClick(key.value, level.value);
      }
    };
  }
});
function _sfc_render128(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_MenuIndent = resolveComponent("MenuIndent");
  const _component_ExpandTransition = resolveComponent("ExpandTransition");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.classNames)
  }, [
    createBaseVNode("div", {
      class: normalizeClass([
        `${_ctx.prefixCls}-header`,
        {
          [`${_ctx.menuPrefixCls}-selected`]: _ctx.isSelected,
          [`${_ctx.menuPrefixCls}-has-icon`]: _ctx.$slots.icon
        }
      ]),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onHeaderClick && _ctx.onHeaderClick(...args))
    }, [
      createVNode(_component_MenuIndent, { level: _ctx.level }, null, 8, ["level"]),
      _ctx.$slots.icon ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        createBaseVNode("span", {
          class: normalizeClass(`${_ctx.menuPrefixCls}-icon`)
        }, [
          renderSlot(_ctx.$slots, "icon")
        ], 2),
        createBaseVNode("span", {
          class: normalizeClass(`${_ctx.menuPrefixCls}-title`)
        }, [
          renderSlot(_ctx.$slots, "title", {}, () => [
            createTextVNode(toDisplayString(_ctx.title), 1)
          ])
        ], 2)
      ], 64)) : renderSlot(_ctx.$slots, "title", { key: 1 }, () => [
        createTextVNode(toDisplayString(_ctx.title), 1)
      ]),
      createBaseVNode("span", {
        class: normalizeClass([
          `${_ctx.menuPrefixCls}-icon-suffix`,
          {
            [`is-open`]: _ctx.isOpen
          }
        ])
      }, [
        renderSlot(_ctx.$slots, "expand-icon-down")
      ], 2)
    ], 2),
    createVNode(_component_ExpandTransition, null, {
      default: withCtx(() => [
        withDirectives(createBaseVNode("div", {
          class: normalizeClass(`${_ctx.prefixCls}-content`)
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 2), [
          [vShow, _ctx.isOpen]
        ])
      ]),
      _: 3
    })
  ], 2);
}
var SubMenuInline = _export_sfc(_sfc_main128, [["render", _sfc_render128]]);

// node_modules/@arco-design/web-vue/es/menu/sub-menu-pop.js
var _sfc_main129 = defineComponent({
  name: "SubMenuPop",
  components: {
    Menu: BaseMenu,
    Trigger,
    MenuIndent,
    RenderFunction
  },
  inheritAttrs: false,
  props: {
    title: {
      type: String
    },
    selectable: {
      type: Boolean
    },
    isChildrenSelected: {
      type: Boolean
    },
    popupMaxHeight: {
      type: [Boolean, Number],
      default: void 0
    }
  },
  setup(props) {
    const { key } = useMenu();
    const { level } = useLevel();
    const { selectable, isChildrenSelected, popupMaxHeight } = toRefs(props);
    const menuContext = useMenuContext();
    const { onSubMenuClick, onMenuItemClick } = menuContext;
    const menuPrefixCls = computed(() => menuContext.prefixCls);
    const mode = computed(() => menuContext.mode);
    const selectedKeys = computed(() => menuContext.selectedKeys || []);
    const prefixCls = computed(() => `${menuPrefixCls.value}-pop`);
    const isSelected = computed(() => selectable.value && selectedKeys.value.includes(key.value) || isChildrenSelected.value);
    const classNames = computed(() => [
      `${prefixCls.value}`,
      `${prefixCls.value}-header`,
      {
        [`${menuPrefixCls.value}-selected`]: isSelected.value
      }
    ]);
    const needPopOnBottom = computed(() => mode.value === "horizontal" && !menuContext.inTrigger);
    const popVisible = ref(false);
    const setPopVisible = (val) => {
      popVisible.value = val;
    };
    const triggerPrefixCls = getPrefixCls("trigger");
    const triggerClassNames = computed(() => {
      var _a;
      return [
        `${prefixCls.value}-trigger`,
        {
          [`${prefixCls.value}-trigger-dark`]: menuContext.theme === "dark"
        },
        (_a = menuContext.triggerProps) == null ? void 0 : _a.class
      ];
    });
    const triggerProps = computed(() => omit(menuContext.triggerProps || {}, ["class"]));
    return {
      menuPrefixCls,
      mode,
      level,
      classNames,
      isSelected,
      selectedKeys,
      needPopOnBottom,
      popVisible,
      triggerPrefixCls,
      triggerClassNames,
      triggerProps,
      menuContext,
      popupMenuStyles: computed(() => {
        var _a;
        const maxHeight = (_a = popupMaxHeight.value) != null ? _a : menuContext.popupMaxHeight;
        if (isNumber(maxHeight))
          return { maxHeight: `${maxHeight}px` };
        return maxHeight ? {} : { maxHeight: "unset" };
      }),
      onClick: () => {
        onSubMenuClick && onSubMenuClick(key.value, level.value);
        selectable.value && onMenuItemClick && onMenuItemClick(key.value);
      },
      onMenuItemClick: (key2) => {
        onMenuItemClick && onMenuItemClick(key2);
        setPopVisible(false);
      },
      onVisibleChange: (visible) => {
        setPopVisible(visible);
      }
    };
  }
});
function _sfc_render129(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_MenuIndent = resolveComponent("MenuIndent");
  const _component_RenderFunction = resolveComponent("RenderFunction");
  const _component_Menu = resolveComponent("Menu");
  const _component_Trigger = resolveComponent("Trigger");
  return openBlock(), createBlock(_component_Trigger, mergeProps({
    trigger: "hover",
    class: _ctx.triggerClassNames,
    position: _ctx.needPopOnBottom ? "bl" : "rt",
    "show-arrow": "",
    "animation-class": "fade-in",
    "mouse-enter-delay": 50,
    "mouse-leave-delay": 50,
    "popup-offset": 4,
    "auto-fit-popup-min-width": true,
    duration: 100
  }, _ctx.triggerProps, {
    "unmount-on-close": false,
    "popup-visible": _ctx.popVisible,
    onPopupVisibleChange: _ctx.onVisibleChange
  }), {
    content: withCtx(() => [
      createVNode(_component_Menu, {
        "in-trigger": "",
        "prefix-cls": `${_ctx.triggerPrefixCls}-menu`,
        "selected-keys": _ctx.selectedKeys,
        theme: _ctx.menuContext.theme,
        "trigger-props": _ctx.menuContext.triggerProps,
        style: normalizeStyle(_ctx.popupMenuStyles),
        onMenuItemClick: _ctx.onMenuItemClick
      }, createSlots({
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 2
      }, [
        _ctx.menuContext.expandIconDown ? {
          name: "expand-icon-down",
          fn: withCtx(() => [
            createVNode(_component_RenderFunction, {
              "render-func": _ctx.menuContext.expandIconDown
            }, null, 8, ["render-func"])
          ])
        } : void 0,
        _ctx.menuContext.expandIconRight ? {
          name: "expand-icon-right",
          fn: withCtx(() => [
            createVNode(_component_RenderFunction, {
              "render-func": _ctx.menuContext.expandIconRight
            }, null, 8, ["render-func"])
          ])
        } : void 0
      ]), 1032, ["prefix-cls", "selected-keys", "theme", "trigger-props", "style", "onMenuItemClick"])
    ]),
    default: withCtx(() => [
      createBaseVNode("div", mergeProps({
        class: [
          _ctx.classNames,
          {
            [`${_ctx.menuPrefixCls}-has-icon`]: _ctx.$slots.icon
          }
        ],
        "aria-haspopup": "true"
      }, _ctx.$attrs, {
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
      }), [
        createCommentVNode(" header "),
        createVNode(_component_MenuIndent, { level: _ctx.level }, null, 8, ["level"]),
        _ctx.$slots.icon ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createBaseVNode("span", {
            class: normalizeClass(`${_ctx.menuPrefixCls}-icon`)
          }, [
            renderSlot(_ctx.$slots, "icon")
          ], 2),
          createBaseVNode("span", {
            class: normalizeClass(`${_ctx.menuPrefixCls}-title`)
          }, [
            renderSlot(_ctx.$slots, "title", {}, () => [
              createTextVNode(toDisplayString(_ctx.title), 1)
            ])
          ], 2)
        ], 64)) : renderSlot(_ctx.$slots, "title", { key: 1 }, () => [
          createTextVNode(toDisplayString(_ctx.title), 1)
        ]),
        createCommentVNode(" suffix "),
        createBaseVNode("span", {
          class: normalizeClass(`${_ctx.menuPrefixCls}-icon-suffix`)
        }, [
          _ctx.needPopOnBottom ? renderSlot(_ctx.$slots, "expand-icon-down", { key: 0 }) : renderSlot(_ctx.$slots, "expand-icon-right", { key: 1 })
        ], 2),
        _ctx.isSelected && _ctx.mode === "horizontal" ? (openBlock(), createElementBlock("div", {
          key: 2,
          class: normalizeClass(`${_ctx.menuPrefixCls}-selected-label`)
        }, null, 2)) : createCommentVNode("v-if", true)
      ], 16)
    ]),
    _: 3
  }, 16, ["class", "position", "popup-visible", "onPopupVisibleChange"]);
}
var SubMenuPop = _export_sfc(_sfc_main129, [["render", _sfc_render129]]);

// node_modules/@arco-design/web-vue/es/menu/sub-menu.js
var __defProp42 = Object.defineProperty;
var __defProps18 = Object.defineProperties;
var __getOwnPropDescs18 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols42 = Object.getOwnPropertySymbols;
var __hasOwnProp42 = Object.prototype.hasOwnProperty;
var __propIsEnum42 = Object.prototype.propertyIsEnumerable;
var __defNormalProp42 = (obj, key, value) => key in obj ? __defProp42(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues42 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp42.call(b, prop))
      __defNormalProp42(a, prop, b[prop]);
  if (__getOwnPropSymbols42)
    for (var prop of __getOwnPropSymbols42(b)) {
      if (__propIsEnum42.call(b, prop))
        __defNormalProp42(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps18 = (a, b) => __defProps18(a, __getOwnPropDescs18(b));
var SubMenu = defineComponent({
  name: "SubMenu",
  props: {
    key: {
      type: String
    },
    title: {
      type: String
    },
    selectable: {
      type: Boolean
    },
    popup: {
      type: [Boolean, Function],
      default: false
    },
    popupMaxHeight: {
      type: [Boolean, Number],
      default: void 0
    }
  },
  setup(props, {
    attrs
  }) {
    const {
      key
    } = useMenu();
    const {
      level
    } = useLevel();
    const {
      popup
    } = toRefs(props);
    const menuContext = useMenuContext();
    const computedPopup = computed(() => {
      const {
        mode,
        collapsed,
        inTrigger
      } = menuContext;
      const forcePopup = !!(typeof popup.value === "function" ? popup.value(level.value) : popup.value);
      return forcePopup || collapsed || inTrigger || mode !== "vertical";
    });
    const {
      subMenuKeys,
      menuItemKeys
    } = useMenuDataCollector({
      key: key.value,
      type: "subMenu"
    });
    const isChildrenSelected = computed(() => {
      const selectedKeys = menuContext.selectedKeys || [];
      const checkSelected = (menuKeys) => {
        for (let i2 = 0; i2 < selectedKeys.length; i2++) {
          const selectedKey = selectedKeys[i2];
          if (menuKeys.includes(selectedKey)) {
            return true;
          }
        }
        return false;
      };
      return checkSelected(subMenuKeys.value) || checkSelected(menuItemKeys.value);
    });
    return {
      subMenuKeys,
      menuItemKeys,
      isChildrenSelected,
      props,
      attrs,
      computedKey: key,
      computedPopup,
      expandIconDown: toRef(menuContext, "expandIconDown"),
      expandIconRight: toRef(menuContext, "expandIconRight")
    };
  },
  render() {
    const {
      props,
      attrs,
      computedKey,
      computedPopup,
      expandIconDown,
      expandIconRight,
      isChildrenSelected
    } = this;
    const _slots = __spreadProps18(__spreadValues42({}, this.$slots), {
      "expand-icon-down": this.$slots["expand-icon-down"] || expandIconDown || (() => [createVNode(IconDown, null, null)]),
      "expand-icon-right": this.$slots["expand-icon-right"] || expandIconRight || (() => [createVNode(IconRight, null, null)])
    });
    return computedPopup ? createVNode(SubMenuPop, mergeProps({
      "key": computedKey,
      "title": props.title,
      "selectable": props.selectable,
      "isChildrenSelected": isChildrenSelected,
      "popupMaxHeight": props.popupMaxHeight
    }, attrs), _slots) : createVNode(SubMenuInline, mergeProps({
      "key": computedKey,
      "title": props.title,
      "isChildrenSelected": isChildrenSelected
    }, attrs), _slots);
  }
});

// node_modules/@arco-design/web-vue/es/menu/overflow-wrap.js
var OVERFLOW_THRESHOLD = 10;
function getNodeWidth(el) {
  return el && +el.getBoundingClientRect().width.toFixed(2);
}
function translatePxToNumber(str) {
  const result = Number(str.replace("px", ""));
  return Number.isNaN(result) ? 0 : result;
}
var OverflowWrap = defineComponent({
  name: "MenuOverflowWrap",
  setup(_, {
    slots
  }) {
    const menuContext = useMenuContext();
    const overflowPrefixCls = `${menuContext.prefixCls}-overflow`;
    const overflowSubMenuClass = `${overflowPrefixCls}-sub-menu`;
    const overflowMenuItemClass = `${overflowPrefixCls}-hidden-menu-item`;
    const overflowSubMenuMirrorClass = `${overflowPrefixCls}-sub-menu-mirror`;
    const refWrapper = ref();
    const lastVisibleIndex = ref(null);
    const refResizeObserver = ref();
    function computeLastVisibleIndex() {
      const wrapperElement = refWrapper.value;
      const wrapperWidth = getNodeWidth(wrapperElement);
      const childNodeList = [].slice.call(wrapperElement.children);
      let menuItemIndex = 0;
      let currentRightWidth = 0;
      let overflowSubMenuWidth = 0;
      for (let i2 = 0; i2 < childNodeList.length; i2++) {
        const node = childNodeList[i2];
        const classNames = node.className.split(" ");
        const isOverflowSubMenu = classNames.indexOf(overflowSubMenuClass) > -1;
        const isOverflowSubMenuMirror = classNames.indexOf(overflowSubMenuMirrorClass) > -1;
        if (isOverflowSubMenu) {
          continue;
        }
        const nodeWidth = getNodeWidth(node) + translatePxToNumber(getStyle(node, "marginLeft")) + translatePxToNumber(getStyle(node, "marginRight"));
        if (isOverflowSubMenuMirror) {
          overflowSubMenuWidth = nodeWidth;
          continue;
        }
        currentRightWidth += nodeWidth;
        if (currentRightWidth + overflowSubMenuWidth + OVERFLOW_THRESHOLD > wrapperWidth) {
          lastVisibleIndex.value = menuItemIndex - 1;
          return;
        }
        menuItemIndex++;
      }
      lastVisibleIndex.value = null;
    }
    onMounted(() => {
      computeLastVisibleIndex();
      refResizeObserver.value = new ResizeObserver_es_default((entries) => {
        entries.forEach(computeLastVisibleIndex);
      });
      if (refWrapper.value) {
        refResizeObserver.value.observe(refWrapper.value);
      }
    });
    onUnmounted(() => {
      refResizeObserver.value && refResizeObserver.value.disconnect();
    });
    return () => {
      const renderSubMenu = (children, options) => {
        const {
          isMirror = false,
          props = {}
        } = options || {};
        return createVNode(SubMenu, mergeProps({
          "key": `__arco-menu-overflow-sub-menu${isMirror ? "-mirror" : ""}`,
          "class": isMirror ? overflowSubMenuMirrorClass : overflowSubMenuClass
        }, props), {
          title: () => createVNode("span", null, [createTextVNode("...")]),
          default: () => children
        });
      };
      const renderChildren = () => {
        var _a;
        const originChildren = ((_a = slots.default) == null ? void 0 : _a.call(slots)) || [];
        const children = unFragment(originChildren);
        let overflowSubMenu = null;
        const overflowSubMenuMirror = renderSubMenu(null, {
          isMirror: true
        });
        const menuItems = children.map((child, index3) => {
          const item = cloneVNode(child, lastVisibleIndex.value !== null && index3 > lastVisibleIndex.value ? {
            class: overflowMenuItemClass
          } : {
            class: ""
          });
          if (lastVisibleIndex.value !== null && index3 === lastVisibleIndex.value + 1) {
            const overflowMenuItems = children.slice(index3).map((child2) => cloneVNode(child2));
            overflowSubMenu = renderSubMenu(overflowMenuItems);
          }
          return item;
        });
        return [overflowSubMenuMirror, ...menuItems, overflowSubMenu];
      };
      return createVNode("div", {
        "class": `${overflowPrefixCls}-wrap`,
        "ref": refWrapper
      }, [renderChildren()]);
    };
  }
});

// node_modules/@arco-design/web-vue/es/menu/menu.js
var __defProp43 = Object.defineProperty;
var __defProps19 = Object.defineProperties;
var __getOwnPropDescs19 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols43 = Object.getOwnPropertySymbols;
var __hasOwnProp43 = Object.prototype.hasOwnProperty;
var __propIsEnum43 = Object.prototype.propertyIsEnumerable;
var __defNormalProp43 = (obj, key, value) => key in obj ? __defProp43(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues43 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp43.call(b, prop))
      __defNormalProp43(a, prop, b[prop]);
  if (__getOwnPropSymbols43)
    for (var prop of __getOwnPropSymbols43(b)) {
      if (__propIsEnum43.call(b, prop))
        __defNormalProp43(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps19 = (a, b) => __defProps19(a, __getOwnPropDescs19(b));
var _Menu = defineComponent({
  name: "Menu",
  components: {
    BaseMenu
  },
  inheritAttrs: false,
  props: {
    theme: {
      type: String
    },
    mode: {
      type: String,
      default: "vertical"
    }
  },
  setup(props, {
    attrs,
    slots
  }) {
    const {
      theme: propTheme,
      mode
    } = toRefs(props);
    const siderContext = inject(SiderInjectionKey, void 0);
    const siderCollapsed = computed(() => (siderContext == null ? void 0 : siderContext.collapsed) || false);
    const theme = computed(() => (propTheme == null ? void 0 : propTheme.value) || (siderContext == null ? void 0 : siderContext.theme) || "light");
    provide(MenuInjectionKey, void 0);
    provide(LevelInjectionKey, void 0);
    return () => createVNode(BaseMenu, mergeProps(props, attrs, {
      "theme": theme.value,
      "inTrigger": false,
      "siderCollapsed": siderCollapsed.value,
      "isRoot": true
    }), __spreadProps19(__spreadValues43({}, slots), {
      default: mode.value === "horizontal" && slots.default ? () => createVNode(OverflowWrap, null, {
        default: () => {
          var _a;
          return [(_a = slots.default) == null ? void 0 : _a.call(slots)];
        }
      }) : slots.default
    }));
  }
});

// node_modules/scroll-into-view-if-needed/es/index.js
function isOptionsObject(options) {
  return options === Object(options) && Object.keys(options).length !== 0;
}
function defaultBehavior(actions, behavior) {
  if (behavior === void 0) {
    behavior = "auto";
  }
  var canSmoothScroll = "scrollBehavior" in document.body.style;
  actions.forEach(function(_ref) {
    var el = _ref.el, top = _ref.top, left = _ref.left;
    if (el.scroll && canSmoothScroll) {
      el.scroll({
        top,
        left,
        behavior
      });
    } else {
      el.scrollTop = top;
      el.scrollLeft = left;
    }
  });
}
function getOptions(options) {
  if (options === false) {
    return {
      block: "end",
      inline: "nearest"
    };
  }
  if (isOptionsObject(options)) {
    return options;
  }
  return {
    block: "start",
    inline: "nearest"
  };
}
function scrollIntoView(target3, options) {
  var isTargetAttached = target3.isConnected || target3.ownerDocument.documentElement.contains(target3);
  if (isOptionsObject(options) && typeof options.behavior === "function") {
    return options.behavior(isTargetAttached ? i(target3, options) : []);
  }
  if (!isTargetAttached) {
    return;
  }
  var computeOptions = getOptions(options);
  return defaultBehavior(i(target3, computeOptions), computeOptions.behavior);
}
var es_default = scrollIntoView;

// node_modules/@arco-design/web-vue/es/menu/item.js
var __defProp44 = Object.defineProperty;
var __getOwnPropSymbols44 = Object.getOwnPropertySymbols;
var __hasOwnProp44 = Object.prototype.hasOwnProperty;
var __propIsEnum44 = Object.prototype.propertyIsEnumerable;
var __defNormalProp44 = (obj, key, value) => key in obj ? __defProp44(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues44 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp44.call(b, prop))
      __defNormalProp44(a, prop, b[prop]);
  if (__getOwnPropSymbols44)
    for (var prop of __getOwnPropSymbols44(b)) {
      if (__propIsEnum44.call(b, prop))
        __defNormalProp44(a, prop, b[prop]);
    }
  return a;
};
var MenuItem = defineComponent({
  name: "MenuItem",
  inheritAttrs: false,
  props: {
    key: {
      type: String
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  emits: ["click"],
  setup(props, {
    emit
  }) {
    const {
      key
    } = useMenu();
    const {
      level
    } = useLevel();
    const menuContext = useMenuContext();
    const refItemElement = ref();
    const isSelected = computed(() => (menuContext.selectedKeys || []).indexOf(key.value) > -1);
    const menuDataCollector = useMenuDataCollectorContext();
    onMounted(() => {
      menuDataCollector == null ? void 0 : menuDataCollector.collectMenuItem(key.value);
    });
    onUnmounted(() => {
      menuDataCollector == null ? void 0 : menuDataCollector.removeMenuItem(key.value);
    });
    function scrollTo2() {
      if (menuContext.autoScrollIntoView && refItemElement.value && isSelected.value) {
        es_default(refItemElement.value, __spreadValues44({
          behavior: "smooth",
          block: "nearest",
          scrollMode: "if-needed",
          boundary: document.documentElement
        }, menuContext.scrollConfig || {}));
      }
    }
    let timer;
    onMounted(() => {
      timer = setTimeout(() => {
        scrollTo2();
      }, 500);
    });
    onUnmounted(() => {
      clearTimeout(timer);
    });
    watch([isSelected], () => {
      scrollTo2();
    });
    return {
      menuContext,
      level,
      isSelected,
      refItemElement,
      onClick(e2) {
        if (props.disabled)
          return;
        menuContext.onMenuItemClick && menuContext.onMenuItemClick(key.value);
        emit("click", e2);
      }
    };
  },
  render() {
    var _a, _b;
    const {
      level,
      menuContext,
      disabled,
      isSelected,
      onClick
    } = this;
    const {
      prefixCls,
      collapsed,
      inTrigger,
      mode,
      tooltipProps
    } = menuContext;
    const needTooltip = collapsed && !inTrigger && level === 1;
    const needTextIndent = mode === "vertical" && level > 1;
    const children = ((_b = (_a = this.$slots).default) == null ? void 0 : _b.call(_a)) || [];
    const showIndent = needTextIndent && !inTrigger && !collapsed;
    const iconElement = this.$slots.icon && this.$slots.icon();
    const content = [showIndent && createVNode(MenuIndent, {
      "level": level
    }, null), iconElement && createVNode("span", {
      "class": `${prefixCls}-icon`
    }, [iconElement]), showIndent || iconElement ? createVNode("span", {
      "class": [`${prefixCls}-item-inner`, {
        [`${prefixCls}-title`]: iconElement
      }]
    }, [children]) : children].filter(Boolean);
    const itemElement = createVNode("div", mergeProps({
      "ref": "refItemElement",
      "class": [`${prefixCls}-item`, {
        [`${prefixCls}-disabled`]: disabled,
        [`${prefixCls}-selected`]: isSelected,
        [`${prefixCls}-has-icon`]: iconElement
      }]
    }, this.$attrs, {
      "onClick": onClick
    }), [content, isSelected && mode === "horizontal" && createVNode("div", {
      "class": `${prefixCls}-selected-label`
    }, null)]);
    if (needTooltip) {
      const tooltipClassNames = [`${prefixCls}-item-tooltip`, tooltipProps == null ? void 0 : tooltipProps.class];
      return createVNode(Tooltip, mergeProps({
        "trigger": "hover",
        "position": "right",
        "class": tooltipClassNames
      }, omit(tooltipProps || {}, ["class"])), {
        default: () => itemElement,
        content: () => children
      });
    }
    return itemElement;
  }
});

// node_modules/@arco-design/web-vue/es/menu/item-group.js
var _sfc_main130 = defineComponent({
  name: "MenuItemGroup",
  components: {
    MenuIndent
  },
  props: {
    title: {
      type: String
    }
  },
  setup() {
    const { level } = useLevel();
    const nextLevel = computed(() => level.value === 1 ? level.value + 1 : level.value);
    provideLevel(nextLevel);
    const menuContext = useMenuContext();
    const prefixCls = computed(() => menuContext.prefixCls);
    const classNames = computed(() => [`${prefixCls.value}-group`]);
    return {
      prefixCls,
      classNames,
      level
    };
  }
});
function _sfc_render130(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_MenuIndent = resolveComponent("MenuIndent");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.classNames)
  }, [
    createBaseVNode("div", {
      class: normalizeClass(`${_ctx.prefixCls}-group-title`)
    }, [
      createVNode(_component_MenuIndent, { level: _ctx.level }, null, 8, ["level"]),
      renderSlot(_ctx.$slots, "title", {}, () => [
        createTextVNode(toDisplayString(_ctx.title), 1)
      ])
    ], 2),
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
var MenuItemGroup = _export_sfc(_sfc_main130, [["render", _sfc_render130]]);

// node_modules/@arco-design/web-vue/es/menu/index.js
var Menu = Object.assign(_Menu, {
  Item: MenuItem,
  ItemGroup: MenuItemGroup,
  SubMenu,
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Menu.name, _Menu);
    app.component(componentPrefix + MenuItem.name, MenuItem);
    app.component(componentPrefix + MenuItemGroup.name, MenuItemGroup);
    app.component(componentPrefix + SubMenu.name, SubMenu);
  }
});

// node_modules/@arco-design/web-vue/es/message/message.js
var _sfc_main131 = defineComponent({
  name: "Message",
  components: {
    AIconHover: IconHover,
    IconInfoCircleFill,
    IconCheckCircleFill,
    IconExclamationCircleFill,
    IconCloseCircleFill,
    IconClose,
    IconLoading
  },
  props: {
    type: {
      type: String,
      default: "info"
    },
    closable: {
      type: Boolean,
      default: false
    },
    showIcon: {
      type: Boolean,
      default: true
    },
    duration: {
      type: Number,
      default: 3e3
    },
    resetOnUpdate: {
      type: Boolean,
      default: false
    },
    resetOnHover: {
      type: Boolean,
      default: false
    }
  },
  emits: ["close"],
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("message");
    let timer = 0;
    const handleClose = () => {
      emit("close");
    };
    const startTimer = () => {
      if (props.duration > 0) {
        timer = window.setTimeout(handleClose, props.duration);
      }
    };
    const clearTimer = () => {
      if (timer) {
        window.clearTimeout(timer);
        timer = 0;
      }
    };
    onMounted(() => {
      startTimer();
    });
    onUpdated(() => {
      if (props.resetOnUpdate) {
        clearTimer();
        startTimer();
      }
    });
    onUnmounted(() => {
      clearTimer();
    });
    const handleMouseEnter = () => {
      if (props.resetOnHover) {
        clearTimer();
      }
    };
    const handleMouseLeave = () => {
      if (props.resetOnHover) {
        startTimer();
      }
    };
    return {
      handleMouseEnter,
      handleMouseLeave,
      prefixCls,
      handleClose
    };
  }
});
function _sfc_render131(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_info_circle_fill = resolveComponent("icon-info-circle-fill");
  const _component_icon_check_circle_fill = resolveComponent("icon-check-circle-fill");
  const _component_icon_exclamation_circle_fill = resolveComponent("icon-exclamation-circle-fill");
  const _component_icon_close_circle_fill = resolveComponent("icon-close-circle-fill");
  const _component_icon_loading = resolveComponent("icon-loading");
  const _component_icon_close = resolveComponent("icon-close");
  const _component_a_icon_hover = resolveComponent("a-icon-hover");
  return openBlock(), createElementBlock("li", {
    role: "alert",
    class: normalizeClass([
      _ctx.prefixCls,
      `${_ctx.prefixCls}-${_ctx.type}`,
      { [`${_ctx.prefixCls}-closable`]: _ctx.closable }
    ]),
    onMouseenter: _cache[1] || (_cache[1] = (...args) => _ctx.handleMouseEnter && _ctx.handleMouseEnter(...args)),
    onMouseleave: _cache[2] || (_cache[2] = (...args) => _ctx.handleMouseLeave && _ctx.handleMouseLeave(...args))
  }, [
    _ctx.showIcon && !(_ctx.type === "normal" && !_ctx.$slots.icon) ? (openBlock(), createElementBlock("span", {
      key: 0,
      class: normalizeClass(`${_ctx.prefixCls}-icon`)
    }, [
      renderSlot(_ctx.$slots, "icon", {}, () => [
        _ctx.type === "info" ? (openBlock(), createBlock(_component_icon_info_circle_fill, { key: 0 })) : _ctx.type === "success" ? (openBlock(), createBlock(_component_icon_check_circle_fill, { key: 1 })) : _ctx.type === "warning" ? (openBlock(), createBlock(_component_icon_exclamation_circle_fill, { key: 2 })) : _ctx.type === "error" ? (openBlock(), createBlock(_component_icon_close_circle_fill, { key: 3 })) : _ctx.type === "loading" ? (openBlock(), createBlock(_component_icon_loading, { key: 4 })) : createCommentVNode("v-if", true)
      ])
    ], 2)) : createCommentVNode("v-if", true),
    createBaseVNode("span", {
      class: normalizeClass(`${_ctx.prefixCls}-content`)
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 2),
    _ctx.closable ? (openBlock(), createElementBlock("span", {
      key: 1,
      class: normalizeClass(`${_ctx.prefixCls}-close-btn`),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClose && _ctx.handleClose(...args))
    }, [
      createVNode(_component_a_icon_hover, null, {
        default: withCtx(() => [
          createVNode(_component_icon_close)
        ]),
        _: 1
      })
    ], 2)) : createCommentVNode("v-if", true)
  ], 34);
}
var Message = _export_sfc(_sfc_main131, [["render", _sfc_render131]]);

// node_modules/@arco-design/web-vue/es/message/message-list.js
function _isSlot8(s) {
  return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
var MessageList = defineComponent({
  name: "MessageList",
  props: {
    messages: {
      type: Array,
      default: () => []
    },
    position: {
      type: String,
      default: "top"
    }
  },
  emits: ["close", "afterClose"],
  setup(props, context) {
    const prefixCls = getPrefixCls("message-list");
    const {
      zIndex
    } = usePopupManager("message", {
      runOnMounted: true
    });
    return () => {
      let _slot;
      return createVNode(TransitionGroup, {
        "class": [prefixCls, `${prefixCls}-${props.position}`],
        "name": "fade-message",
        "tag": "ul",
        "style": {
          zIndex: zIndex.value
        },
        "onAfterLeave": () => context.emit("afterClose")
      }, _isSlot8(_slot = props.messages.map((item) => {
        const slots = {
          default: getSlotFunction(item.content),
          icon: getSlotFunction(item.icon)
        };
        return createVNode(Message, {
          "key": item.id,
          "type": item.type,
          "duration": item.duration,
          "closable": item.closable,
          "resetOnUpdate": item.resetOnUpdate,
          "resetOnHover": item.resetOnHover,
          "onClose": () => context.emit("close", item.id)
        }, slots);
      })) ? _slot : {
        default: () => [_slot]
      });
    };
  }
});

// node_modules/@arco-design/web-vue/es/message/index.js
var __defProp45 = Object.defineProperty;
var __defProps20 = Object.defineProperties;
var __getOwnPropDescs20 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols45 = Object.getOwnPropertySymbols;
var __hasOwnProp45 = Object.prototype.hasOwnProperty;
var __propIsEnum45 = Object.prototype.propertyIsEnumerable;
var __defNormalProp45 = (obj, key, value) => key in obj ? __defProp45(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues45 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp45.call(b, prop))
      __defNormalProp45(a, prop, b[prop]);
  if (__getOwnPropSymbols45)
    for (var prop of __getOwnPropSymbols45(b)) {
      if (__propIsEnum45.call(b, prop))
        __defNormalProp45(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps20 = (a, b) => __defProps20(a, __getOwnPropDescs20(b));
var MessageManger = class {
  constructor(config, appContext) {
    this.messageCount = 0;
    this.add = (config2) => {
      var _a;
      this.messageCount++;
      const id = (_a = config2.id) != null ? _a : `__arco_message_${this.messageCount}`;
      if (this.messageIds.has(id)) {
        return this.update(id, config2);
      }
      const message2 = reactive(__spreadValues45({ id }, config2));
      this.messages.value.push(message2);
      this.messageIds.add(id);
      return {
        close: () => this.remove(id)
      };
    };
    this.update = (id, config2) => {
      for (let i2 = 0; i2 < this.messages.value.length; i2++) {
        if (this.messages.value[i2].id === id) {
          const resetOnUpdate = !isUndefined(config2.duration);
          Object.assign(this.messages.value[i2], __spreadProps20(__spreadValues45({}, config2), { id, resetOnUpdate }));
          break;
        }
      }
      return {
        close: () => this.remove(id)
      };
    };
    this.remove = (id) => {
      for (let i2 = 0; i2 < this.messages.value.length; i2++) {
        const item = this.messages.value[i2];
        if (item.id === id) {
          if (isFunction(item.onClose)) {
            item.onClose(id);
          }
          this.messages.value.splice(i2, 1);
          this.messageIds.delete(id);
          break;
        }
      }
    };
    this.clear = () => {
      this.messages.value.splice(0);
    };
    this.destroy = () => {
      if (this.messages.value.length === 0 && this.container) {
        render(null, this.container);
        document.body.removeChild(this.container);
        this.container = null;
        messageInstance[this.position] = void 0;
      }
    };
    const { position = "top" } = config;
    this.container = getOverlay("message");
    this.messageIds = /* @__PURE__ */ new Set();
    this.messages = ref([]);
    this.position = position;
    const vm = createVNode(MessageList, {
      messages: this.messages.value,
      position,
      onClose: this.remove,
      onAfterClose: this.destroy
    });
    if (appContext != null ? appContext : Message2._context) {
      vm.appContext = appContext != null ? appContext : Message2._context;
    }
    render(vm, this.container);
    document.body.appendChild(this.container);
  }
};
var messageInstance = {};
var types = [...MESSAGE_TYPES, "loading", "normal"];
var message = types.reduce((pre, value) => {
  pre[value] = (config, appContext) => {
    if (isString(config)) {
      config = { content: config };
    }
    const _config = __spreadValues45({ type: value }, config);
    const { position = "top" } = _config;
    if (!messageInstance[position]) {
      messageInstance[position] = new MessageManger(_config, appContext);
    }
    return messageInstance[position].add(_config);
  };
  return pre;
}, {});
message.clear = (position) => {
  var _a;
  if (position) {
    (_a = messageInstance[position]) == null ? void 0 : _a.clear();
  } else {
    Object.values(messageInstance).forEach((item) => item == null ? void 0 : item.clear());
  }
};
var Message2 = __spreadProps20(__spreadValues45({}, message), {
  install: (app) => {
    const _message = {
      clear: message.clear
    };
    for (const key of types) {
      _message[key] = (config, appContext = app._context) => message[key](config, appContext);
    }
    app.config.globalProperties.$message = _message;
  },
  _context: null
});

// node_modules/@arco-design/web-vue/es/modal/hooks/use-draggable.js
var useDraggable = ({
  modalRef,
  wrapperRef,
  draggable
}) => {
  const isDragging = ref(false);
  const startMouse = ref([0, 0]);
  const diffMouse = ref([0, 0]);
  const initialPosition = ref([0, 0]);
  const position = ref();
  const maxPosition = ref([0, 0]);
  const getInitialPosition = () => {
    var _a, _b;
    if (wrapperRef.value && modalRef.value) {
      const { top: wrapperTop, left: wrapperLeft } = wrapperRef.value.getBoundingClientRect();
      const { clientWidth: wrapperWidth, clientHeight: wrapperHeight } = wrapperRef.value;
      const { top, left, width, height } = modalRef.value.getBoundingClientRect();
      const initialX = left - wrapperLeft;
      const initialY = top - wrapperTop;
      if (initialX !== ((_a = initialPosition.value) == null ? void 0 : _a[0]) || initialY !== ((_b = initialPosition.value) == null ? void 0 : _b[1])) {
        initialPosition.value = [initialX, initialY];
      }
      const maxX = wrapperWidth > width ? wrapperWidth - width : 0;
      const maxY = wrapperHeight > height ? wrapperHeight - height : 0;
      if (maxX !== maxPosition.value[0] || maxY !== maxPosition.value[1]) {
        maxPosition.value = [maxX, maxY];
      }
    }
  };
  const handleMoveDown = (ev) => {
    if (draggable.value) {
      ev.preventDefault();
      isDragging.value = true;
      getInitialPosition();
      startMouse.value = [ev.x, ev.y];
      diffMouse.value = [0, 0];
      on(window, "mousemove", handleMouseMove);
      on(window, "mouseup", handleMouseUp);
      on(window, "contextmenu", handleMouseUp);
    }
  };
  const handleMouseMove = (ev) => {
    if (isDragging.value) {
      const diffX = ev.x - startMouse.value[0];
      const diffY = ev.y - startMouse.value[1];
      let x = initialPosition.value[0] + diffX;
      let y = initialPosition.value[1] + diffY;
      if (x < 0)
        x = 0;
      if (x > maxPosition.value[0])
        x = maxPosition.value[0];
      if (y < 0)
        y = 0;
      if (y > maxPosition.value[1])
        y = maxPosition.value[1];
      position.value = [x, y];
    }
  };
  const handleMouseUp = () => {
    isDragging.value = false;
    off(window, "mousemove", handleMouseMove);
    off(window, "mouseup", handleMouseUp);
  };
  return {
    position,
    handleMoveDown
  };
};

// node_modules/@arco-design/web-vue/es/modal/modal.vue_vue&type=script&lang.js
var __defProp46 = Object.defineProperty;
var __getOwnPropSymbols46 = Object.getOwnPropertySymbols;
var __hasOwnProp46 = Object.prototype.hasOwnProperty;
var __propIsEnum46 = Object.prototype.propertyIsEnumerable;
var __defNormalProp46 = (obj, key, value) => key in obj ? __defProp46(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues46 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp46.call(b, prop))
      __defNormalProp46(a, prop, b[prop]);
  if (__getOwnPropSymbols46)
    for (var prop of __getOwnPropSymbols46(b)) {
      if (__propIsEnum46.call(b, prop))
        __defNormalProp46(a, prop, b[prop]);
    }
  return a;
};
var _sfc_main132 = defineComponent({
  name: "Modal",
  components: {
    ClientOnly,
    ArcoButton: Button,
    IconHover,
    IconClose,
    IconInfoCircleFill,
    IconCheckCircleFill,
    IconExclamationCircleFill,
    IconCloseCircleFill
  },
  inheritAttrs: false,
  props: {
    visible: {
      type: Boolean,
      default: void 0
    },
    defaultVisible: {
      type: Boolean,
      default: false
    },
    width: {
      type: [Number, String]
    },
    top: {
      type: [Number, String]
    },
    mask: {
      type: Boolean,
      default: true
    },
    title: {
      type: String
    },
    titleAlign: {
      type: String,
      default: "center"
    },
    alignCenter: {
      type: Boolean,
      default: true
    },
    unmountOnClose: Boolean,
    maskClosable: {
      type: Boolean,
      default: true
    },
    hideCancel: {
      type: Boolean,
      default: false
    },
    simple: {
      type: Boolean,
      default: (props) => {
        return props.notice;
      }
    },
    closable: {
      type: Boolean,
      default: true
    },
    okText: String,
    cancelText: String,
    okLoading: {
      type: Boolean,
      default: false
    },
    okButtonProps: {
      type: Object
    },
    cancelButtonProps: {
      type: Object
    },
    footer: {
      type: Boolean,
      default: true
    },
    renderToBody: {
      type: Boolean,
      default: true
    },
    popupContainer: {
      type: [String, Object],
      default: "body"
    },
    maskStyle: {
      type: Object
    },
    modalClass: {
      type: [String, Array]
    },
    modalStyle: {
      type: Object
    },
    onBeforeOk: {
      type: Function
    },
    onBeforeCancel: {
      type: Function
    },
    escToClose: {
      type: Boolean,
      default: true
    },
    draggable: {
      type: Boolean,
      default: false
    },
    fullscreen: {
      type: Boolean,
      default: false
    },
    maskAnimationName: {
      type: String,
      default: (props) => {
        if (props.fullscreen) {
          return "fade-in-standard";
        }
        return "fade-modal";
      }
    },
    modalAnimationName: {
      type: String,
      default: (props) => {
        if (props.fullscreen) {
          return "zoom-in";
        }
        return "zoom-modal";
      }
    },
    bodyClass: {
      type: [String, Array]
    },
    bodyStyle: {
      type: [String, Object, Array]
    },
    messageType: {
      type: String
    }
  },
  emits: [
    "update:visible",
    "ok",
    "cancel",
    "open",
    "close",
    "beforeOpen",
    "beforeClose"
  ],
  setup(props, {
    emit
  }) {
    const {
      fullscreen,
      popupContainer
    } = toRefs(props);
    const prefixCls = getPrefixCls("modal");
    const {
      t: t2
    } = useI18n();
    const wrapperRef = ref();
    const modalRef = ref();
    const _visible = ref(props.defaultVisible);
    const computedVisible = computed(() => {
      var _a;
      return (_a = props.visible) != null ? _a : _visible.value;
    });
    const _okLoading = ref(false);
    const mergedOkLoading = computed(() => props.okLoading || _okLoading.value);
    const mergedDraggable = computed(() => props.draggable && !props.fullscreen);
    const {
      teleportContainer,
      containerRef
    } = useTeleportContainer({
      popupContainer,
      visible: computedVisible
    });
    const mounted = ref(computedVisible.value);
    const okDisplayText = computed(() => props.okText || t2("modal.okText"));
    const cancelDisplayText = computed(() => props.cancelText || t2("modal.cancelText"));
    const {
      zIndex,
      isLastDialog
    } = usePopupManager("dialog", {
      visible: computedVisible
    });
    let globalKeyDownListener = false;
    const handleGlobalKeyDown = (ev) => {
      if (props.escToClose && ev.key === KEYBOARD_KEY.ESC && isLastDialog()) {
        handleCancel();
      }
    };
    const addGlobalKeyDownListener = () => {
      if (props.escToClose && !globalKeyDownListener) {
        globalKeyDownListener = true;
        on(document.documentElement, "keydown", handleGlobalKeyDown);
      }
    };
    const removeGlobalKeyDownListener = () => {
      globalKeyDownListener = false;
      off(document.documentElement, "keydown", handleGlobalKeyDown);
    };
    let promiseNumber = 0;
    const {
      position,
      handleMoveDown
    } = useDraggable({
      wrapperRef,
      modalRef,
      draggable: mergedDraggable
    });
    const close = () => {
      promiseNumber++;
      if (_okLoading.value) {
        _okLoading.value = false;
      }
      _visible.value = false;
      emit("update:visible", false);
    };
    const handleOk = async () => {
      const currentPromiseNumber = promiseNumber;
      const closed = await new Promise(async (resolve) => {
        var _a;
        if (isFunction(props.onBeforeOk)) {
          let result = props.onBeforeOk((closed2 = true) => resolve(closed2));
          if (isPromise(result) || !isBoolean(result)) {
            _okLoading.value = true;
          }
          if (isPromise(result)) {
            try {
              result = (_a = await result) != null ? _a : true;
            } catch (error) {
              result = false;
            }
          }
          if (isBoolean(result)) {
            resolve(result);
          }
        } else {
          resolve(true);
        }
      });
      if (currentPromiseNumber === promiseNumber) {
        if (closed) {
          emit("ok");
          close();
        } else if (_okLoading.value) {
          _okLoading.value = false;
        }
      }
    };
    const handleCancel = () => {
      var _a;
      let result = true;
      if (isFunction(props.onBeforeCancel)) {
        result = (_a = props.onBeforeCancel()) != null ? _a : false;
      }
      if (result) {
        emit("cancel");
        close();
      }
    };
    const currentIsMask = ref(false);
    const handleMaskMouseDown = (ev) => {
      if (ev.target === wrapperRef.value) {
        currentIsMask.value = true;
      }
    };
    const handleMaskClick = () => {
      if (props.mask && props.maskClosable && currentIsMask.value) {
        handleCancel();
      }
    };
    const handleOpen = () => {
      if (computedVisible.value) {
        if (!contains(wrapperRef.value, document.activeElement) && document.activeElement instanceof HTMLElement) {
          document.activeElement.blur();
        }
        emit("open");
      }
    };
    const handleClose = () => {
      if (!computedVisible.value) {
        if (mergedDraggable.value) {
          position.value = void 0;
        }
        mounted.value = false;
        resetOverflow();
        emit("close");
      }
    };
    const {
      setOverflowHidden,
      resetOverflow
    } = useOverflow(containerRef);
    onMounted(() => {
      containerRef.value = getElement(props.popupContainer);
      if (computedVisible.value) {
        setOverflowHidden();
        if (props.escToClose) {
          addGlobalKeyDownListener();
        }
      }
    });
    onBeforeUnmount(() => {
      resetOverflow();
      removeGlobalKeyDownListener();
    });
    watch(computedVisible, (value) => {
      if (_visible.value !== value) {
        _visible.value = value;
      }
      if (value) {
        emit("beforeOpen");
        mounted.value = true;
        currentIsMask.value = false;
        setOverflowHidden();
        addGlobalKeyDownListener();
      } else {
        emit("beforeClose");
        removeGlobalKeyDownListener();
      }
    });
    watch(fullscreen, () => {
      if (position.value) {
        position.value = void 0;
      }
    });
    const wrapperCls = computed(() => [`${prefixCls}-wrapper`, {
      [`${prefixCls}-wrapper-align-center`]: props.alignCenter && !props.fullscreen,
      [`${prefixCls}-wrapper-moved`]: Boolean(position.value)
    }]);
    const modalCls = computed(() => [`${prefixCls}`, props.modalClass, {
      [`${prefixCls}-simple`]: props.simple,
      [`${prefixCls}-draggable`]: mergedDraggable.value,
      [`${prefixCls}-fullscreen`]: props.fullscreen
    }]);
    const mergedModalStyle = computed(() => {
      var _a;
      const style = __spreadValues46({}, (_a = props.modalStyle) != null ? _a : {});
      if (props.width) {
        style.width = isNumber(props.width) ? `${props.width}px` : props.width;
      }
      if (!props.alignCenter && props.top) {
        style.top = isNumber(props.top) ? `${props.top}px` : props.top;
      }
      if (position.value) {
        style.transform = `translate(${position.value[0]}px, ${position.value[1]}px)`;
      }
      return style;
    });
    return {
      prefixCls,
      mounted,
      computedVisible,
      containerRef,
      wrapperRef,
      mergedModalStyle,
      okDisplayText,
      cancelDisplayText,
      zIndex,
      handleOk,
      handleCancel,
      handleMaskClick,
      handleMaskMouseDown,
      handleOpen,
      handleClose,
      mergedOkLoading,
      modalRef,
      wrapperCls,
      modalCls,
      teleportContainer,
      handleMoveDown
    };
  }
});

// node_modules/@arco-design/web-vue/es/modal/modal.js
function _sfc_render132(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_info_circle_fill = resolveComponent("icon-info-circle-fill");
  const _component_icon_check_circle_fill = resolveComponent("icon-check-circle-fill");
  const _component_icon_exclamation_circle_fill = resolveComponent("icon-exclamation-circle-fill");
  const _component_icon_close_circle_fill = resolveComponent("icon-close-circle-fill");
  const _component_icon_close = resolveComponent("icon-close");
  const _component_icon_hover = resolveComponent("icon-hover");
  const _component_arco_button = resolveComponent("arco-button");
  const _component_client_only = resolveComponent("client-only");
  return openBlock(), createBlock(_component_client_only, null, {
    default: withCtx(() => [
      (openBlock(), createBlock(Teleport, {
        to: _ctx.teleportContainer,
        disabled: !_ctx.renderToBody
      }, [
        !_ctx.unmountOnClose || _ctx.computedVisible || _ctx.mounted ? withDirectives((openBlock(), createElementBlock("div", mergeProps({
          key: 0,
          class: `${_ctx.prefixCls}-container`,
          style: { zIndex: _ctx.zIndex }
        }, _ctx.$attrs), [
          createVNode(Transition, {
            name: _ctx.maskAnimationName,
            appear: ""
          }, {
            default: withCtx(() => [
              _ctx.mask ? withDirectives((openBlock(), createElementBlock("div", {
                key: 0,
                ref: "maskRef",
                class: normalizeClass(`${_ctx.prefixCls}-mask`),
                style: normalizeStyle(_ctx.maskStyle)
              }, null, 6)), [
                [vShow, _ctx.computedVisible]
              ]) : createCommentVNode("v-if", true)
            ]),
            _: 1
          }, 8, ["name"]),
          createBaseVNode("div", {
            ref: "wrapperRef",
            class: normalizeClass(_ctx.wrapperCls),
            onClick: _cache[2] || (_cache[2] = withModifiers((...args) => _ctx.handleMaskClick && _ctx.handleMaskClick(...args), ["self"])),
            onMousedown: _cache[3] || (_cache[3] = withModifiers((...args) => _ctx.handleMaskMouseDown && _ctx.handleMaskMouseDown(...args), ["self"]))
          }, [
            createVNode(Transition, {
              name: _ctx.modalAnimationName,
              appear: "",
              onAfterEnter: _ctx.handleOpen,
              onAfterLeave: _ctx.handleClose
            }, {
              default: withCtx(() => [
                withDirectives(createBaseVNode("div", {
                  ref: "modalRef",
                  class: normalizeClass(_ctx.modalCls),
                  style: normalizeStyle(_ctx.mergedModalStyle)
                }, [
                  _ctx.$slots.title || _ctx.title || _ctx.closable ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    class: normalizeClass(`${_ctx.prefixCls}-header`),
                    onMousedown: _cache[1] || (_cache[1] = (...args) => _ctx.handleMoveDown && _ctx.handleMoveDown(...args))
                  }, [
                    _ctx.$slots.title || _ctx.title ? (openBlock(), createElementBlock("div", {
                      key: 0,
                      class: normalizeClass([
                        `${_ctx.prefixCls}-title`,
                        `${_ctx.prefixCls}-title-align-${_ctx.titleAlign}`
                      ])
                    }, [
                      _ctx.messageType ? (openBlock(), createElementBlock("div", {
                        key: 0,
                        class: normalizeClass(`${_ctx.prefixCls}-title-icon`)
                      }, [
                        _ctx.messageType === "info" ? (openBlock(), createBlock(_component_icon_info_circle_fill, { key: 0 })) : createCommentVNode("v-if", true),
                        _ctx.messageType === "success" ? (openBlock(), createBlock(_component_icon_check_circle_fill, { key: 1 })) : createCommentVNode("v-if", true),
                        _ctx.messageType === "warning" ? (openBlock(), createBlock(_component_icon_exclamation_circle_fill, { key: 2 })) : createCommentVNode("v-if", true),
                        _ctx.messageType === "error" ? (openBlock(), createBlock(_component_icon_close_circle_fill, { key: 3 })) : createCommentVNode("v-if", true)
                      ], 2)) : createCommentVNode("v-if", true),
                      renderSlot(_ctx.$slots, "title", {}, () => [
                        createTextVNode(toDisplayString(_ctx.title), 1)
                      ])
                    ], 2)) : createCommentVNode("v-if", true),
                    !_ctx.simple && _ctx.closable ? (openBlock(), createElementBlock("div", {
                      key: 1,
                      tabindex: "-1",
                      role: "button",
                      "aria-label": "Close",
                      class: normalizeClass(`${_ctx.prefixCls}-close-btn`),
                      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleCancel && _ctx.handleCancel(...args))
                    }, [
                      createVNode(_component_icon_hover, null, {
                        default: withCtx(() => [
                          createVNode(_component_icon_close)
                        ]),
                        _: 1
                      })
                    ], 2)) : createCommentVNode("v-if", true)
                  ], 34)) : createCommentVNode("v-if", true),
                  createBaseVNode("div", {
                    class: normalizeClass([`${_ctx.prefixCls}-body`, _ctx.bodyClass]),
                    style: normalizeStyle(_ctx.bodyStyle)
                  }, [
                    renderSlot(_ctx.$slots, "default")
                  ], 6),
                  _ctx.footer ? (openBlock(), createElementBlock("div", {
                    key: 1,
                    class: normalizeClass(`${_ctx.prefixCls}-footer`)
                  }, [
                    renderSlot(_ctx.$slots, "footer", {}, () => [
                      !_ctx.hideCancel ? (openBlock(), createBlock(_component_arco_button, mergeProps({ key: 0 }, _ctx.cancelButtonProps, { onClick: _ctx.handleCancel }), {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(_ctx.cancelDisplayText), 1)
                        ]),
                        _: 1
                      }, 16, ["onClick"])) : createCommentVNode("v-if", true),
                      createVNode(_component_arco_button, mergeProps({ type: "primary" }, _ctx.okButtonProps, {
                        loading: _ctx.mergedOkLoading,
                        onClick: _ctx.handleOk
                      }), {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(_ctx.okDisplayText), 1)
                        ]),
                        _: 1
                      }, 16, ["loading", "onClick"])
                    ])
                  ], 2)) : createCommentVNode("v-if", true)
                ], 6), [
                  [vShow, _ctx.computedVisible]
                ])
              ]),
              _: 3
            }, 8, ["name", "onAfterEnter", "onAfterLeave"])
          ], 34)
        ], 16)), [
          [vShow, _ctx.computedVisible || _ctx.mounted]
        ]) : createCommentVNode("v-if", true)
      ], 8, ["to", "disabled"]))
    ]),
    _: 3
  });
}
var _Modal = _export_sfc(_sfc_main132, [["render", _sfc_render132]]);

// node_modules/@arco-design/web-vue/es/modal/index.js
var __defProp47 = Object.defineProperty;
var __defProps21 = Object.defineProperties;
var __getOwnPropDescs21 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols47 = Object.getOwnPropertySymbols;
var __hasOwnProp47 = Object.prototype.hasOwnProperty;
var __propIsEnum47 = Object.prototype.propertyIsEnumerable;
var __defNormalProp47 = (obj, key, value) => key in obj ? __defProp47(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues47 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp47.call(b, prop))
      __defNormalProp47(a, prop, b[prop]);
  if (__getOwnPropSymbols47)
    for (var prop of __getOwnPropSymbols47(b)) {
      if (__propIsEnum47.call(b, prop))
        __defNormalProp47(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps21 = (a, b) => __defProps21(a, __getOwnPropDescs21(b));
var open2 = (config, appContext) => {
  let container2 = getOverlay("modal");
  const handleOk = () => {
    if (vm.component) {
      vm.component.props.visible = false;
    }
    if (isFunction(config.onOk)) {
      config.onOk();
    }
  };
  const handleCancel = () => {
    if (vm.component) {
      vm.component.props.visible = false;
    }
    if (isFunction(config.onCancel)) {
      config.onCancel();
    }
  };
  const handleClose = async () => {
    await nextTick();
    if (container2) {
      render(null, container2);
      document.body.removeChild(container2);
    }
    container2 = null;
    if (isFunction(config.onClose)) {
      config.onClose();
    }
  };
  const handleReturnClose = () => {
    if (vm.component) {
      vm.component.props.visible = false;
    }
  };
  const defaultConfig = {
    visible: true,
    renderToBody: false,
    unmountOnClose: true,
    onOk: handleOk,
    onCancel: handleCancel,
    onClose: handleClose
  };
  const vm = createVNode(_Modal, __spreadValues47(__spreadValues47(__spreadValues47({}, defaultConfig), omit(config, ["content", "title", "footer", "visible", "unmountOnClose", "onOk", "onCancel", "onClose"])), {
    footer: typeof config.footer === "boolean" ? config.footer : void 0
  }), {
    default: getSlotFunction(config.content),
    title: getSlotFunction(config.title),
    footer: typeof config.footer !== "boolean" ? getSlotFunction(config.footer) : void 0
  });
  if (appContext != null ? appContext : Modal._context) {
    vm.appContext = appContext != null ? appContext : Modal._context;
  }
  render(vm, container2);
  document.body.appendChild(container2);
  return {
    close: handleReturnClose
  };
};
var modal = __spreadValues47({
  open: open2,
  confirm: (config, appContext) => {
    const _config = __spreadValues47({
      simple: true
    }, config);
    return open2(_config, appContext);
  }
}, MESSAGE_TYPES.reduce((pre, value) => {
  pre[value] = (config, appContext) => {
    const _config = __spreadValues47({
      simple: true,
      hideCancel: true,
      messageType: value
    }, config);
    return open2(_config, appContext);
  };
  return pre;
}, {}));
var Modal = Object.assign(_Modal, __spreadProps21(__spreadValues47({}, modal), {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Modal.name, _Modal);
    const modalWithContext = {};
    for (const key of Object.keys(modal)) {
      modalWithContext[key] = (config, appContext = app._context) => modal[key](config, appContext);
    }
    app.config.globalProperties.$modal = modalWithContext;
  },
  _context: null
}));

// node_modules/@arco-design/web-vue/es/_utils/convert-case.js
var toKebabCase = (string) => {
  return string.replace(/\B([A-Z])/g, "-$1").toLowerCase();
};

// node_modules/@arco-design/web-vue/es/notification/notification.js
var _sfc_main133 = defineComponent({
  name: "Notification",
  components: {
    AIconHover: IconHover,
    IconInfoCircleFill,
    IconCheckCircleFill,
    IconExclamationCircleFill,
    IconCloseCircleFill,
    IconClose
  },
  props: {
    type: {
      type: String,
      default: "info"
    },
    showIcon: {
      type: Boolean,
      default: true
    },
    closable: {
      type: Boolean,
      default: false
    },
    duration: {
      type: Number,
      default: 3e3
    },
    resetOnUpdate: {
      type: Boolean,
      default: false
    }
  },
  emits: ["close"],
  setup(props, context) {
    const prefixCls = getPrefixCls("notification");
    let timer = 0;
    const handleClose = () => {
      context.emit("close");
    };
    onMounted(() => {
      if (props.duration > 0) {
        timer = window.setTimeout(handleClose, props.duration);
      }
    });
    onUpdated(() => {
      if (props.resetOnUpdate) {
        if (timer) {
          window.clearTimeout(timer);
          timer = 0;
        }
        if (props.duration > 0) {
          timer = window.setTimeout(handleClose, props.duration);
        }
      }
    });
    onUnmounted(() => {
      if (timer) {
        window.clearTimeout(timer);
      }
    });
    return {
      prefixCls,
      handleClose
    };
  }
});
function _sfc_render133(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_info_circle_fill = resolveComponent("icon-info-circle-fill");
  const _component_icon_check_circle_fill = resolveComponent("icon-check-circle-fill");
  const _component_icon_exclamation_circle_fill = resolveComponent("icon-exclamation-circle-fill");
  const _component_icon_close_circle_fill = resolveComponent("icon-close-circle-fill");
  const _component_icon_close = resolveComponent("icon-close");
  const _component_a_icon_hover = resolveComponent("a-icon-hover");
  return openBlock(), createElementBlock("li", {
    role: "alert",
    class: normalizeClass([
      _ctx.prefixCls,
      `${_ctx.prefixCls}-${_ctx.type}`,
      { [`${_ctx.prefixCls}-closable`]: _ctx.closable }
    ])
  }, [
    _ctx.showIcon ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(`${_ctx.prefixCls}-left`)
    }, [
      createBaseVNode("div", {
        class: normalizeClass(`${_ctx.prefixCls}-icon`)
      }, [
        renderSlot(_ctx.$slots, "icon", {}, () => [
          _ctx.type === "info" ? (openBlock(), createBlock(_component_icon_info_circle_fill, { key: 0 })) : _ctx.type === "success" ? (openBlock(), createBlock(_component_icon_check_circle_fill, { key: 1 })) : _ctx.type === "warning" ? (openBlock(), createBlock(_component_icon_exclamation_circle_fill, { key: 2 })) : _ctx.type === "error" ? (openBlock(), createBlock(_component_icon_close_circle_fill, { key: 3 })) : createCommentVNode("v-if", true)
        ])
      ], 2)
    ], 2)) : createCommentVNode("v-if", true),
    createBaseVNode("div", {
      class: normalizeClass(`${_ctx.prefixCls}-right`)
    }, [
      _ctx.$slots.default ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(`${_ctx.prefixCls}-title`)
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 2)) : createCommentVNode("v-if", true),
      _ctx.$slots.content ? (openBlock(), createElementBlock("div", {
        key: 1,
        class: normalizeClass(`${_ctx.prefixCls}-content`)
      }, [
        renderSlot(_ctx.$slots, "content")
      ], 2)) : createCommentVNode("v-if", true),
      _ctx.$slots.footer ? (openBlock(), createElementBlock("div", {
        key: 2,
        class: normalizeClass(`${_ctx.prefixCls}-footer`)
      }, [
        renderSlot(_ctx.$slots, "footer")
      ], 2)) : createCommentVNode("v-if", true)
    ], 2),
    _ctx.closable ? (openBlock(), createElementBlock("div", {
      key: 1,
      class: normalizeClass(`${_ctx.prefixCls}-close-btn`),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClose && _ctx.handleClose(...args))
    }, [
      renderSlot(_ctx.$slots, "closeIconElement", {}, () => [
        createVNode(_component_a_icon_hover, null, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "closeIcon", {}, () => [
              createVNode(_component_icon_close)
            ])
          ]),
          _: 3
        })
      ])
    ], 2)) : createCommentVNode("v-if", true)
  ], 2);
}
var Notification = _export_sfc(_sfc_main133, [["render", _sfc_render133]]);

// node_modules/@arco-design/web-vue/es/notification/interface.js
var NOTIFICATION_POSITION = [
  "topLeft",
  "topRight",
  "bottomLeft",
  "bottomRight"
];

// node_modules/@arco-design/web-vue/es/notification/notification-list.js
function _isSlot9(s) {
  return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
var NotificationList = defineComponent({
  name: "NotificationList",
  props: {
    notifications: {
      type: Array,
      default: () => []
    },
    position: {
      type: String,
      default: "topRight",
      validator: (value) => {
        return NOTIFICATION_POSITION.includes(value);
      }
    }
  },
  emits: ["close", "afterClose"],
  setup(props, context) {
    const prefixCls = getPrefixCls("notification-list");
    const kebabPosition = toKebabCase(props.position);
    const {
      zIndex
    } = usePopupManager("message", {
      runOnMounted: true
    });
    const isRight = props.position.includes("Right");
    return () => {
      let _slot;
      return createVNode(TransitionGroup, {
        "class": [prefixCls, `${prefixCls}-${kebabPosition}`],
        "style": {
          zIndex: zIndex.value
        },
        "name": `slide-${isRight ? "right" : "left"}-notification`,
        "onAfterLeave": () => context.emit("afterClose"),
        "tag": "ul"
      }, _isSlot9(_slot = props.notifications.map((item) => {
        const slots = {
          default: getSlotFunction(item.title),
          content: getSlotFunction(item.content),
          icon: getSlotFunction(item.icon),
          footer: getSlotFunction(item.footer),
          closeIcon: getSlotFunction(item.closeIcon),
          closeIconElement: getSlotFunction(item.closeIconElement)
        };
        return createVNode(Notification, {
          "key": item.id,
          "type": item.type,
          "style": item.style,
          "class": item.class,
          "duration": item.duration,
          "closable": item.closable,
          "showIcon": item.showIcon,
          "resetOnUpdate": item.resetOnUpdate,
          "onClose": () => context.emit("close", item.id)
        }, slots);
      })) ? _slot : {
        default: () => [_slot]
      });
    };
  }
});

// node_modules/@arco-design/web-vue/es/notification/index.js
var __defProp48 = Object.defineProperty;
var __defProps22 = Object.defineProperties;
var __getOwnPropDescs22 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols48 = Object.getOwnPropertySymbols;
var __hasOwnProp48 = Object.prototype.hasOwnProperty;
var __propIsEnum48 = Object.prototype.propertyIsEnumerable;
var __defNormalProp48 = (obj, key, value) => key in obj ? __defProp48(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues48 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp48.call(b, prop))
      __defNormalProp48(a, prop, b[prop]);
  if (__getOwnPropSymbols48)
    for (var prop of __getOwnPropSymbols48(b)) {
      if (__propIsEnum48.call(b, prop))
        __defNormalProp48(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps22 = (a, b) => __defProps22(a, __getOwnPropDescs22(b));
var NotificationManger = class {
  constructor(config, appContext) {
    this.notificationCount = 0;
    this.add = (config2) => {
      var _a;
      this.notificationCount++;
      const id = (_a = config2.id) != null ? _a : `__arco_notification_${this.notificationCount}`;
      if (this.notificationIds.has(id)) {
        return this.update(id, config2);
      }
      const notification2 = reactive(__spreadValues48({ id }, config2));
      this.notifications.value.push(notification2);
      this.notificationIds.add(id);
      return {
        close: () => this.remove(id)
      };
    };
    this.update = (id, config2) => {
      for (let i2 = 0; i2 < this.notifications.value.length; i2++) {
        if (this.notifications.value[i2].id === id) {
          const resetOnUpdate = !isUndefined(config2.duration);
          Object.assign(this.notifications.value[i2], __spreadProps22(__spreadValues48({}, config2), {
            id,
            resetOnUpdate
          }));
          break;
        }
      }
      return {
        close: () => this.remove(id)
      };
    };
    this.remove = (id) => {
      for (let i2 = 0; i2 < this.notifications.value.length; i2++) {
        const item = this.notifications.value[i2];
        if (item.id === id) {
          if (isFunction(item.onClose)) {
            item.onClose(id);
          }
          this.notifications.value.splice(i2, 1);
          this.notificationIds.delete(id);
          break;
        }
      }
    };
    this.clear = () => {
      this.notifications.value.splice(0);
    };
    this.destroy = () => {
      if (this.notifications.value.length === 0 && this.container) {
        render(null, this.container);
        document.body.removeChild(this.container);
        this.container = null;
        notificationInstance[this.position] = void 0;
      }
    };
    const { position = "topRight" } = config;
    this.container = getOverlay("notification");
    this.notificationIds = /* @__PURE__ */ new Set();
    this.notifications = ref([]);
    this.position = position;
    const vm = createVNode(NotificationList, {
      notifications: this.notifications.value,
      position,
      onClose: this.remove,
      onAfterClose: this.destroy
    });
    if (appContext != null ? appContext : Notification2._context) {
      vm.appContext = appContext != null ? appContext : Notification2._context;
    }
    render(vm, this.container);
    document.body.appendChild(this.container);
  }
};
var notificationInstance = {};
var notification = MESSAGE_TYPES.reduce((pre, value) => {
  pre[value] = (config, appContext) => {
    if (isString(config)) {
      config = { content: config };
    }
    const _config = __spreadValues48({ type: value }, config);
    const { position = "topRight" } = _config;
    if (!notificationInstance[position]) {
      notificationInstance[position] = new NotificationManger(_config, appContext);
    }
    return notificationInstance[position].add(_config);
  };
  return pre;
}, {});
notification.remove = (id) => {
  if (id) {
    Object.values(notificationInstance).forEach((item) => item == null ? void 0 : item.remove(id));
  }
};
notification.clear = (position) => {
  var _a;
  if (position) {
    (_a = notificationInstance[position]) == null ? void 0 : _a.clear();
  } else {
    Object.values(notificationInstance).forEach((item) => item == null ? void 0 : item.clear());
  }
};
var Notification2 = __spreadProps22(__spreadValues48({}, notification), {
  install: (app) => {
    const _notification = {
      clear: notification.clear
    };
    for (const key of MESSAGE_TYPES) {
      _notification[key] = (config, appContext = app._context) => notification[key](config, appContext);
    }
    app.config.globalProperties.$notification = _notification;
  },
  _context: null
});

// node_modules/@arco-design/web-vue/es/page-header/page-header.js
var _sfc_main134 = defineComponent({
  name: "PageHeader",
  components: { AIconHover: IconHover, IconLeft },
  props: {
    title: String,
    subtitle: String,
    showBack: {
      type: Boolean,
      default: true
    }
  },
  emits: [
    "back"
  ],
  setup(props, { emit, slots }) {
    const prefixCls = getPrefixCls("page-header");
    const handleBack = (e2) => {
      emit("back", e2);
    };
    const cls = computed(() => [
      prefixCls,
      {
        [`${prefixCls}-with-breadcrumb`]: Boolean(slots.breadcrumb),
        [`${prefixCls}-with-content`]: Boolean(slots.default)
      }
    ]);
    return {
      prefixCls,
      cls,
      handleBack
    };
  }
});
function _sfc_render134(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_left = resolveComponent("icon-left");
  const _component_a_icon_hover = resolveComponent("a-icon-hover");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.cls)
  }, [
    createBaseVNode("div", {
      class: normalizeClass(`${_ctx.prefixCls}-wrapper`)
    }, [
      _ctx.$slots.breadcrumb ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(`${_ctx.prefixCls}-breadcrumb`)
      }, [
        renderSlot(_ctx.$slots, "breadcrumb")
      ], 2)) : createCommentVNode("v-if", true),
      createBaseVNode("div", {
        class: normalizeClass(`${_ctx.prefixCls}-header`)
      }, [
        createBaseVNode("span", {
          class: normalizeClass(`${_ctx.prefixCls}-main`)
        }, [
          _ctx.showBack ? (openBlock(), createBlock(_component_a_icon_hover, {
            key: 0,
            class: normalizeClass(`${_ctx.prefixCls}-back-btn`),
            prefix: _ctx.prefixCls,
            onClick: _ctx.handleBack
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "back-icon", {}, () => [
                createVNode(_component_icon_left)
              ])
            ]),
            _: 3
          }, 8, ["class", "prefix", "onClick"])) : createCommentVNode("v-if", true),
          createBaseVNode("span", {
            class: normalizeClass(`${_ctx.prefixCls}-title`)
          }, [
            renderSlot(_ctx.$slots, "title", {}, () => [
              createTextVNode(toDisplayString(_ctx.title), 1)
            ])
          ], 2),
          _ctx.$slots.subtitle || _ctx.subtitle ? (openBlock(), createElementBlock("span", {
            key: 1,
            class: normalizeClass(`${_ctx.prefixCls}-divider`)
          }, null, 2)) : createCommentVNode("v-if", true),
          _ctx.$slots.subtitle || _ctx.subtitle ? (openBlock(), createElementBlock("span", {
            key: 2,
            class: normalizeClass(`${_ctx.prefixCls}-subtitle`)
          }, [
            renderSlot(_ctx.$slots, "subtitle", {}, () => [
              createTextVNode(toDisplayString(_ctx.subtitle), 1)
            ])
          ], 2)) : createCommentVNode("v-if", true)
        ], 2),
        _ctx.$slots.extra ? (openBlock(), createElementBlock("span", {
          key: 0,
          class: normalizeClass(`${_ctx.prefixCls}-extra`)
        }, [
          renderSlot(_ctx.$slots, "extra")
        ], 2)) : createCommentVNode("v-if", true)
      ], 2)
    ], 2),
    _ctx.$slots.default ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(`${_ctx.prefixCls}-content`)
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 2)) : createCommentVNode("v-if", true)
  ], 2);
}
var _PageHeader = _export_sfc(_sfc_main134, [["render", _sfc_render134]]);

// node_modules/@arco-design/web-vue/es/page-header/index.js
var PageHeader = Object.assign(_PageHeader, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _PageHeader.name, _PageHeader);
  }
});

// node_modules/@arco-design/web-vue/es/popconfirm/popconfirm.js
var _sfc_main135 = defineComponent({
  name: "Popconfirm",
  components: {
    ArcoButton: Button,
    Trigger,
    IconInfoCircleFill,
    IconCheckCircleFill,
    IconExclamationCircleFill,
    IconCloseCircleFill
  },
  props: {
    content: String,
    position: {
      type: String,
      default: "top"
    },
    popupVisible: {
      type: Boolean,
      default: void 0
    },
    defaultPopupVisible: {
      type: Boolean,
      default: false
    },
    type: {
      type: String,
      default: "info"
    },
    okText: String,
    cancelText: String,
    okLoading: {
      type: Boolean,
      default: false
    },
    okButtonProps: {
      type: Object
    },
    cancelButtonProps: {
      type: Object
    },
    contentClass: {
      type: [String, Array, Object]
    },
    contentStyle: {
      type: Object
    },
    arrowClass: {
      type: [String, Array, Object]
    },
    arrowStyle: {
      type: Object
    },
    popupContainer: {
      type: [String, Object]
    },
    onBeforeOk: {
      type: Function
    },
    onBeforeCancel: {
      type: Function
    }
  },
  emits: {
    "update:popupVisible": (visible) => true,
    "popupVisibleChange": (visible) => true,
    "ok": () => true,
    "cancel": () => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("popconfirm");
    const { t: t2 } = useI18n();
    const _popupVisible = ref(props.defaultPopupVisible);
    const computedPopupVisible = computed(() => {
      var _a;
      return (_a = props.popupVisible) != null ? _a : _popupVisible.value;
    });
    const _okLoading = ref(false);
    const mergedOkLoading = computed(() => props.okLoading || _okLoading.value);
    let promiseNumber = 0;
    const close = () => {
      promiseNumber++;
      if (_okLoading.value) {
        _okLoading.value = false;
      }
      _popupVisible.value = false;
      emit("update:popupVisible", false);
      emit("popupVisibleChange", false);
    };
    const handlePopupVisibleChange = (visible) => {
      if (!visible) {
        close();
      } else {
        _popupVisible.value = visible;
        emit("update:popupVisible", visible);
        emit("popupVisibleChange", visible);
      }
    };
    const handleOk = async () => {
      const currentPromiseNumber = promiseNumber;
      const closed = await new Promise(async (resolve) => {
        var _a;
        if (isFunction(props.onBeforeOk)) {
          let result = props.onBeforeOk((closed2 = true) => resolve(closed2));
          if (isPromise(result) || !isBoolean(result)) {
            _okLoading.value = true;
          }
          if (isPromise(result)) {
            try {
              result = (_a = await result) != null ? _a : true;
            } catch (error) {
              result = false;
            }
          }
          if (isBoolean(result)) {
            resolve(result);
          }
        } else {
          resolve(true);
        }
      });
      if (currentPromiseNumber === promiseNumber) {
        if (closed) {
          emit("ok");
          close();
        } else if (_okLoading.value) {
          _okLoading.value = false;
        }
      }
    };
    const handleCancel = () => {
      var _a;
      let result = true;
      if (isFunction(props.onBeforeCancel)) {
        result = (_a = props.onBeforeCancel()) != null ? _a : false;
      }
      if (result) {
        emit("cancel");
        close();
      }
    };
    const contentCls = computed(() => [
      `${prefixCls}-popup-content`,
      props.contentClass
    ]);
    const arrowCls = computed(() => [
      `${prefixCls}-popup-arrow`,
      props.arrowClass
    ]);
    return {
      prefixCls,
      contentCls,
      arrowCls,
      computedPopupVisible,
      mergedOkLoading,
      handlePopupVisibleChange,
      handleOk,
      handleCancel,
      t: t2
    };
  }
});
function _sfc_render135(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_info_circle_fill = resolveComponent("icon-info-circle-fill");
  const _component_icon_check_circle_fill = resolveComponent("icon-check-circle-fill");
  const _component_icon_exclamation_circle_fill = resolveComponent("icon-exclamation-circle-fill");
  const _component_icon_close_circle_fill = resolveComponent("icon-close-circle-fill");
  const _component_arco_button = resolveComponent("arco-button");
  const _component_trigger = resolveComponent("trigger");
  return openBlock(), createBlock(_component_trigger, {
    class: normalizeClass(_ctx.prefixCls),
    trigger: "click",
    position: _ctx.position,
    "show-arrow": "",
    "popup-visible": _ctx.computedPopupVisible,
    "popup-offset": 10,
    "popup-container": _ctx.popupContainer,
    "content-class": _ctx.contentCls,
    "content-style": _ctx.contentStyle,
    "arrow-class": _ctx.arrowCls,
    "arrow-style": _ctx.arrowStyle,
    "animation-name": "zoom-in-fade-out",
    "auto-fit-transform-origin": "",
    onPopupVisibleChange: _ctx.handlePopupVisibleChange
  }, {
    content: withCtx(() => [
      createBaseVNode("div", {
        class: normalizeClass(`${_ctx.prefixCls}-body`)
      }, [
        createBaseVNode("span", {
          class: normalizeClass(`${_ctx.prefixCls}-icon`)
        }, [
          renderSlot(_ctx.$slots, "icon", {}, () => [
            _ctx.type === "info" ? (openBlock(), createBlock(_component_icon_info_circle_fill, { key: 0 })) : _ctx.type === "success" ? (openBlock(), createBlock(_component_icon_check_circle_fill, { key: 1 })) : _ctx.type === "warning" ? (openBlock(), createBlock(_component_icon_exclamation_circle_fill, { key: 2 })) : _ctx.type === "error" ? (openBlock(), createBlock(_component_icon_close_circle_fill, { key: 3 })) : createCommentVNode("v-if", true)
          ])
        ], 2),
        createBaseVNode("span", {
          class: normalizeClass(`${_ctx.prefixCls}-content`)
        }, [
          renderSlot(_ctx.$slots, "content", {}, () => [
            createTextVNode(toDisplayString(_ctx.content), 1)
          ])
        ], 2)
      ], 2),
      createBaseVNode("div", {
        class: normalizeClass(`${_ctx.prefixCls}-footer`)
      }, [
        createVNode(_component_arco_button, mergeProps({ size: "mini" }, _ctx.cancelButtonProps, { onClick: _ctx.handleCancel }), {
          default: withCtx(() => [
            createTextVNode(toDisplayString(_ctx.cancelText || _ctx.t("popconfirm.cancelText")), 1)
          ]),
          _: 1
        }, 16, ["onClick"]),
        createVNode(_component_arco_button, mergeProps({
          type: "primary",
          size: "mini"
        }, _ctx.okButtonProps, {
          loading: _ctx.mergedOkLoading,
          onClick: _ctx.handleOk
        }), {
          default: withCtx(() => [
            createTextVNode(toDisplayString(_ctx.okText || _ctx.t("popconfirm.okText")), 1)
          ]),
          _: 1
        }, 16, ["loading", "onClick"])
      ], 2)
    ]),
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 8, ["class", "position", "popup-visible", "popup-container", "content-class", "content-style", "arrow-class", "arrow-style", "onPopupVisibleChange"]);
}
var _Popconfirm = _export_sfc(_sfc_main135, [["render", _sfc_render135]]);

// node_modules/@arco-design/web-vue/es/popconfirm/index.js
var Popconfirm = Object.assign(_Popconfirm, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Popconfirm.name, _Popconfirm);
  }
});

// node_modules/@arco-design/web-vue/es/progress/line.js
var __defProp49 = Object.defineProperty;
var __getOwnPropSymbols49 = Object.getOwnPropertySymbols;
var __hasOwnProp49 = Object.prototype.hasOwnProperty;
var __propIsEnum49 = Object.prototype.propertyIsEnumerable;
var __defNormalProp49 = (obj, key, value) => key in obj ? __defProp49(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues49 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp49.call(b, prop))
      __defNormalProp49(a, prop, b[prop]);
  if (__getOwnPropSymbols49)
    for (var prop of __getOwnPropSymbols49(b)) {
      if (__propIsEnum49.call(b, prop))
        __defNormalProp49(a, prop, b[prop]);
    }
  return a;
};
var DEFAULT_STROKE_WIDTH = {
  small: 3,
  medium: 4,
  large: 8
};
var getBackground = (color) => {
  if (!color) {
    return void 0;
  }
  if (isObject(color)) {
    const val = Object.keys(color).map((key) => `${color[key]} ${key}`).join(",");
    return {
      backgroundImage: `linear-gradient(to right, ${val})`
    };
  }
  return {
    backgroundColor: color
  };
};
var _sfc_main136 = defineComponent({
  name: "ProgressLine",
  components: {
    IconExclamationCircleFill
  },
  props: {
    percent: {
      type: Number,
      default: 0
    },
    animation: {
      type: Boolean,
      default: false
    },
    size: {
      type: String,
      default: "medium"
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    width: {
      type: [Number, String],
      default: "100%"
    },
    color: {
      type: [String, Object],
      default: void 0
    },
    trackColor: String,
    formatText: {
      type: Function,
      default: void 0
    },
    status: {
      type: String
    },
    showText: Boolean
  },
  setup(props) {
    const prefixCls = getPrefixCls("progress-line");
    const strokeWidth = computed(() => {
      if (props.strokeWidth !== 4) {
        return props.strokeWidth;
      }
      return DEFAULT_STROKE_WIDTH[props.size];
    });
    const text = computed(() => `${index_es_default.times(props.percent, 100)}%`);
    const style = computed(() => ({
      width: props.width,
      height: `${strokeWidth.value}px`,
      backgroundColor: props.trackColor
    }));
    const barStyle = computed(() => __spreadValues49({
      width: `${props.percent * 100}%`
    }, getBackground(props.color)));
    return {
      prefixCls,
      style,
      barStyle,
      text
    };
  }
});
var _hoisted_158 = ["aria-valuenow"];
function _sfc_render136(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_exclamation_circle_fill = resolveComponent("icon-exclamation-circle-fill");
  return openBlock(), createElementBlock("div", {
    role: "progressbar",
    "aria-valuemin": "0",
    "aria-valuemax": "100",
    "aria-valuenow": _ctx.percent,
    class: normalizeClass(`${_ctx.prefixCls}-wrapper`)
  }, [
    createBaseVNode("div", {
      class: normalizeClass(_ctx.prefixCls),
      style: normalizeStyle(_ctx.style)
    }, [
      createBaseVNode("div", {
        class: normalizeClass(`${_ctx.prefixCls}-bar-buffer`)
      }, null, 2),
      createBaseVNode("div", {
        class: normalizeClass([`${_ctx.prefixCls}-bar`]),
        style: normalizeStyle(_ctx.barStyle)
      }, null, 6)
    ], 6),
    _ctx.showText ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(`${_ctx.prefixCls}-text`)
    }, [
      renderSlot(_ctx.$slots, "text", { percent: _ctx.percent }, () => [
        createTextVNode(toDisplayString(_ctx.text) + " ", 1),
        _ctx.status === "danger" ? (openBlock(), createBlock(_component_icon_exclamation_circle_fill, { key: 0 })) : createCommentVNode("v-if", true)
      ])
    ], 2)) : createCommentVNode("v-if", true)
  ], 10, _hoisted_158);
}
var ProgressLine = _export_sfc(_sfc_main136, [["render", _sfc_render136]]);

// node_modules/@arco-design/web-vue/es/icon/icon-exclamation/icon-exclamation.js
var _sfc_main137 = defineComponent({
  name: "IconExclamation",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-exclamation`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_159 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_245 = createBaseVNode("path", { d: "M23 9h2v21h-2z" }, null, -1);
var _hoisted_341 = createBaseVNode("path", {
  fill: "currentColor",
  stroke: "none",
  d: "M23 9h2v21h-2z"
}, null, -1);
var _hoisted_411 = createBaseVNode("path", { d: "M23 37h2v2h-2z" }, null, -1);
var _hoisted_52 = createBaseVNode("path", {
  fill: "currentColor",
  stroke: "none",
  d: "M23 37h2v2h-2z"
}, null, -1);
var _hoisted_6 = [
  _hoisted_245,
  _hoisted_341,
  _hoisted_411,
  _hoisted_52
];
function _sfc_render137(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_6, 14, _hoisted_159);
}
var _IconExclamation = _export_sfc(_sfc_main137, [["render", _sfc_render137]]);

// node_modules/@arco-design/web-vue/es/icon/icon-exclamation/index.js
var IconExclamation = Object.assign(_IconExclamation, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconExclamation.name, _IconExclamation);
  }
});

// node_modules/@arco-design/web-vue/es/icon/icon-check/icon-check.js
var _sfc_main138 = defineComponent({
  name: "IconCheck",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-check`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_160 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_246 = createBaseVNode("path", { d: "M41.678 11.05 19.05 33.678 6.322 20.95" }, null, -1);
var _hoisted_342 = [
  _hoisted_246
];
function _sfc_render138(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_342, 14, _hoisted_160);
}
var _IconCheck = _export_sfc(_sfc_main138, [["render", _sfc_render138]]);

// node_modules/@arco-design/web-vue/es/icon/icon-check/index.js
var IconCheck2 = Object.assign(_IconCheck, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconCheck.name, _IconCheck);
  }
});

// node_modules/@arco-design/web-vue/es/progress/circle.js
var __ARCO_PROGRESS_SEED = 0;
var DEFAULT_WIDTH = {
  mini: 16,
  small: 48,
  medium: 64,
  large: 80
};
var DEFAULT_STROKE_WIDTH2 = {
  mini: 4,
  small: 3,
  medium: 4,
  large: 4
};
var _sfc_main139 = defineComponent({
  name: "ProgressCircle",
  components: {
    IconExclamation,
    IconCheck: IconCheck2
  },
  props: {
    percent: {
      type: Number,
      default: 0
    },
    type: {
      type: String
    },
    size: {
      type: String,
      default: "medium"
    },
    strokeWidth: {
      type: Number
    },
    width: {
      type: Number,
      default: void 0
    },
    color: {
      type: [String, Object],
      default: void 0
    },
    trackColor: String,
    status: {
      type: String,
      default: void 0
    },
    showText: {
      type: Boolean,
      default: true
    },
    pathStrokeWidth: {
      type: Number
    }
  },
  setup(props) {
    const prefixCls = getPrefixCls("progress-circle");
    const isLinearGradient = isObject(props.color);
    const mergedWidth = computed(() => {
      var _a;
      return (_a = props.width) != null ? _a : DEFAULT_WIDTH[props.size];
    });
    const mergedStrokeWidth = computed(() => {
      var _a;
      return (_a = props.strokeWidth) != null ? _a : props.size === "mini" ? mergedWidth.value / 2 : DEFAULT_STROKE_WIDTH2[props.size];
    });
    const mergedPathStrokeWidth = computed(() => {
      var _a;
      return (_a = props.pathStrokeWidth) != null ? _a : props.size === "mini" ? mergedStrokeWidth.value : Math.max(2, mergedStrokeWidth.value - 2);
    });
    const radius = computed(() => (mergedWidth.value - mergedStrokeWidth.value) / 2);
    const perimeter = computed(() => Math.PI * 2 * radius.value);
    const center = computed(() => mergedWidth.value / 2);
    const linearGradientId = computed(() => {
      __ARCO_PROGRESS_SEED += 1;
      return `${prefixCls}-linear-gradient-${__ARCO_PROGRESS_SEED}`;
    });
    const text = computed(() => `${index_es_default.times(props.percent, 100)}%`);
    return {
      prefixCls,
      isLinearGradient,
      radius,
      text,
      perimeter,
      center,
      mergedWidth,
      mergedStrokeWidth,
      mergedPathStrokeWidth,
      linearGradientId
    };
  }
});
var _hoisted_161 = ["aria-valuenow"];
var _hoisted_247 = ["viewBox"];
var _hoisted_343 = { key: 0 };
var _hoisted_412 = ["id"];
var _hoisted_53 = ["offset", "stop-color"];
var _hoisted_62 = ["cx", "cy", "r", "stroke-width"];
var _hoisted_72 = ["cx", "cy", "r", "stroke-width"];
function _sfc_render139(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_check = resolveComponent("icon-check");
  const _component_icon_exclamation = resolveComponent("icon-exclamation");
  return openBlock(), createElementBlock("div", {
    role: "progressbar",
    "aria-valuemin": "0",
    "aria-valuemax": "100",
    "aria-valuenow": _ctx.percent,
    class: normalizeClass(`${_ctx.prefixCls}-wrapper`),
    style: normalizeStyle({ width: `${_ctx.mergedWidth}px`, height: `${_ctx.mergedWidth}px` })
  }, [
    _ctx.type === "circle" && _ctx.size === "mini" && _ctx.status === "success" ? (openBlock(), createBlock(_component_icon_check, {
      key: 0,
      style: normalizeStyle({ fontSize: _ctx.mergedWidth - 2, color: _ctx.color })
    }, null, 8, ["style"])) : (openBlock(), createElementBlock("svg", {
      key: 1,
      viewBox: `0 0 ${_ctx.mergedWidth} ${_ctx.mergedWidth}`,
      class: normalizeClass(`${_ctx.prefixCls}-svg`)
    }, [
      _ctx.isLinearGradient ? (openBlock(), createElementBlock("defs", _hoisted_343, [
        createBaseVNode("linearGradient", {
          id: _ctx.linearGradientId,
          x1: "0",
          y1: "1",
          x2: "0",
          y2: "0"
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(Object.keys(_ctx.color), (key) => {
            return openBlock(), createElementBlock("stop", {
              key,
              offset: key,
              "stop-color": _ctx.color[key]
            }, null, 8, _hoisted_53);
          }), 128))
        ], 8, _hoisted_412)
      ])) : createCommentVNode("v-if", true),
      createBaseVNode("circle", {
        class: normalizeClass(`${_ctx.prefixCls}-bg`),
        fill: "none",
        cx: _ctx.center,
        cy: _ctx.center,
        r: _ctx.radius,
        "stroke-width": _ctx.mergedPathStrokeWidth,
        style: normalizeStyle({
          stroke: _ctx.trackColor
        })
      }, null, 14, _hoisted_62),
      createBaseVNode("circle", {
        class: normalizeClass(`${_ctx.prefixCls}-bar`),
        fill: "none",
        cx: _ctx.center,
        cy: _ctx.center,
        r: _ctx.radius,
        "stroke-width": _ctx.mergedStrokeWidth,
        style: normalizeStyle({
          stroke: _ctx.isLinearGradient ? `url(#${_ctx.linearGradientId})` : _ctx.color,
          strokeDasharray: _ctx.perimeter,
          strokeDashoffset: (_ctx.percent >= 1 ? 0 : 1 - _ctx.percent) * _ctx.perimeter
        })
      }, null, 14, _hoisted_72)
    ], 10, _hoisted_247)),
    _ctx.showText && _ctx.size !== "mini" ? (openBlock(), createElementBlock("div", {
      key: 2,
      class: normalizeClass(`${_ctx.prefixCls}-text`)
    }, [
      renderSlot(_ctx.$slots, "text", { percent: _ctx.percent }, () => [
        _ctx.status === "danger" ? (openBlock(), createBlock(_component_icon_exclamation, { key: 0 })) : _ctx.status === "success" ? (openBlock(), createBlock(_component_icon_check, { key: 1 })) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
          createTextVNode(toDisplayString(_ctx.text), 1)
        ], 2112))
      ])
    ], 2)) : createCommentVNode("v-if", true)
  ], 14, _hoisted_161);
}
var ProgressCircle = _export_sfc(_sfc_main139, [["render", _sfc_render139]]);

// node_modules/@arco-design/web-vue/es/progress/steps.js
var _sfc_main140 = defineComponent({
  name: "ProgressSteps",
  components: {
    IconExclamationCircleFill
  },
  props: {
    steps: {
      type: Number,
      default: 0
    },
    percent: {
      type: Number,
      default: 0
    },
    size: {
      type: String
    },
    color: {
      type: [String, Object],
      default: void 0
    },
    trackColor: String,
    strokeWidth: {
      type: Number
    },
    status: {
      type: String,
      default: void 0
    },
    showText: {
      type: Boolean,
      default: true
    }
  },
  setup(props) {
    const prefixCls = getPrefixCls("progress-steps");
    const mergedStrokeWidth = computed(() => {
      var _a;
      return ((_a = props.strokeWidth) != null ? _a : props.size === "small") ? 8 : 4;
    });
    const stepList = computed(() => [...Array(props.steps)].map((_, index3) => {
      return props.percent > 0 && props.percent > 1 / props.steps * index3;
    }));
    const text = computed(() => `${index_es_default.times(props.percent, 100)}%`);
    return {
      prefixCls,
      stepList,
      mergedStrokeWidth,
      text
    };
  }
});
var _hoisted_162 = ["aria-valuenow"];
function _sfc_render140(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_exclamation_circle_fill = resolveComponent("icon-exclamation-circle-fill");
  return openBlock(), createElementBlock("div", {
    role: "progressbar",
    "aria-valuemin": "0",
    "aria-valuemax": "100",
    "aria-valuenow": _ctx.percent,
    class: normalizeClass(`${_ctx.prefixCls}-wrapper`)
  }, [
    createBaseVNode("div", {
      class: normalizeClass(_ctx.prefixCls),
      style: normalizeStyle({ height: `${_ctx.mergedStrokeWidth}px` })
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.stepList, (active, index3) => {
        return openBlock(), createElementBlock("div", {
          key: index3,
          class: normalizeClass([
            `${_ctx.prefixCls}-item`,
            {
              [`${_ctx.prefixCls}-item-active`]: active
            }
          ]),
          style: normalizeStyle({
            backgroundColor: active ? _ctx.color : _ctx.trackColor
          })
        }, null, 6);
      }), 128))
    ], 6),
    _ctx.showText ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(`${_ctx.prefixCls}-text`)
    }, [
      renderSlot(_ctx.$slots, "text", { percent: _ctx.percent }, () => [
        createTextVNode(toDisplayString(_ctx.text) + " ", 1),
        _ctx.status === "danger" ? (openBlock(), createBlock(_component_icon_exclamation_circle_fill, { key: 0 })) : createCommentVNode("v-if", true)
      ])
    ], 2)) : createCommentVNode("v-if", true)
  ], 10, _hoisted_162);
}
var ProgressSteps = _export_sfc(_sfc_main140, [["render", _sfc_render140]]);

// node_modules/@arco-design/web-vue/es/progress/progress.js
var _sfc_main141 = defineComponent({
  name: "Progress",
  components: {
    ProgressLine,
    ProgressCircle,
    ProgressSteps
  },
  props: {
    type: {
      type: String,
      default: "line"
    },
    size: {
      type: String
    },
    percent: {
      type: Number,
      default: 0
    },
    steps: {
      type: Number,
      default: 0
    },
    animation: {
      type: Boolean,
      default: false
    },
    strokeWidth: {
      type: Number
    },
    width: {
      type: [Number, String]
    },
    color: {
      type: [String, Object]
    },
    trackColor: String,
    bufferColor: {
      type: [String, Object]
    },
    showText: {
      type: Boolean,
      default: true
    },
    status: {
      type: String
    }
  },
  setup(props) {
    const prefixCls = getPrefixCls("progress");
    const { size } = toRefs(props);
    const type = computed(() => props.steps > 0 ? "steps" : props.type);
    const computedStatus = computed(() => {
      return props.status || (props.percent >= 1 ? "success" : "normal");
    });
    const { mergedSize } = useSize(size);
    const cls = computed(() => [
      prefixCls,
      `${prefixCls}-type-${type.value}`,
      `${prefixCls}-size-${mergedSize.value}`,
      `${prefixCls}-status-${computedStatus.value}`
    ]);
    return {
      cls,
      computedStatus,
      mergedSize
    };
  }
});
function _sfc_render141(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_progress_steps = resolveComponent("progress-steps");
  const _component_progress_line = resolveComponent("progress-line");
  const _component_progress_circle = resolveComponent("progress-circle");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.cls)
  }, [
    _ctx.steps > 0 ? (openBlock(), createBlock(_component_progress_steps, {
      key: 0,
      "stroke-width": _ctx.strokeWidth,
      percent: _ctx.percent,
      color: _ctx.color,
      "track-color": _ctx.trackColor,
      width: _ctx.width,
      steps: _ctx.steps,
      size: _ctx.mergedSize,
      "show-text": _ctx.showText
    }, createSlots({ _: 2 }, [
      _ctx.$slots.text ? {
        name: "text",
        fn: withCtx((scope) => [
          renderSlot(_ctx.$slots, "text", normalizeProps(guardReactiveProps(scope)))
        ])
      } : void 0
    ]), 1032, ["stroke-width", "percent", "color", "track-color", "width", "steps", "size", "show-text"])) : _ctx.type === "line" && _ctx.mergedSize !== "mini" ? (openBlock(), createBlock(_component_progress_line, {
      key: 1,
      "stroke-width": _ctx.strokeWidth,
      animation: _ctx.animation,
      percent: _ctx.percent,
      color: _ctx.color,
      "track-color": _ctx.trackColor,
      size: _ctx.mergedSize,
      "buffer-color": _ctx.bufferColor,
      width: _ctx.width,
      "show-text": _ctx.showText,
      status: _ctx.computedStatus
    }, createSlots({ _: 2 }, [
      _ctx.$slots.text ? {
        name: "text",
        fn: withCtx((scope) => [
          renderSlot(_ctx.$slots, "text", normalizeProps(guardReactiveProps(scope)))
        ])
      } : void 0
    ]), 1032, ["stroke-width", "animation", "percent", "color", "track-color", "size", "buffer-color", "width", "show-text", "status"])) : (openBlock(), createBlock(_component_progress_circle, {
      key: 2,
      type: _ctx.type,
      "stroke-width": _ctx.type === "line" ? _ctx.strokeWidth || 4 : _ctx.strokeWidth,
      "path-stroke-width": _ctx.type === "line" ? _ctx.strokeWidth || 4 : _ctx.strokeWidth,
      width: _ctx.width,
      percent: _ctx.percent,
      color: _ctx.color,
      "track-color": _ctx.trackColor,
      size: _ctx.mergedSize,
      "show-text": _ctx.showText,
      status: _ctx.computedStatus
    }, createSlots({ _: 2 }, [
      _ctx.$slots.text ? {
        name: "text",
        fn: withCtx((scope) => [
          renderSlot(_ctx.$slots, "text", normalizeProps(guardReactiveProps(scope)))
        ])
      } : void 0
    ]), 1032, ["type", "stroke-width", "path-stroke-width", "width", "percent", "color", "track-color", "size", "show-text", "status"]))
  ], 2);
}
var _Progress = _export_sfc(_sfc_main141, [["render", _sfc_render141]]);

// node_modules/@arco-design/web-vue/es/progress/index.js
var Progress = Object.assign(_Progress, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Progress.name, _Progress);
  }
});

// node_modules/@arco-design/web-vue/es/icon/icon-star-fill/icon-star-fill.js
var _sfc_main142 = defineComponent({
  name: "IconStarFill",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-star-fill`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_163 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_248 = createBaseVNode("path", {
  d: "M22.683 5.415c.568-1.043 2.065-1.043 2.634 0l5.507 10.098a1.5 1.5 0 0 0 1.04.756l11.306 2.117c1.168.219 1.63 1.642.814 2.505l-7.902 8.359a1.5 1.5 0 0 0-.397 1.223l1.48 11.407c.153 1.177-1.058 2.057-2.131 1.548l-10.391-4.933a1.5 1.5 0 0 0-1.287 0l-10.39 4.933c-1.073.51-2.284-.37-2.131-1.548l1.48-11.407a1.5 1.5 0 0 0-.398-1.223L4.015 20.89c-.816-.863-.353-2.286.814-2.505l11.306-2.117a1.5 1.5 0 0 0 1.04-.756l5.508-10.098Z",
  fill: "currentColor",
  stroke: "none"
}, null, -1);
var _hoisted_344 = [
  _hoisted_248
];
function _sfc_render142(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_344, 14, _hoisted_163);
}
var _IconStarFill = _export_sfc(_sfc_main142, [["render", _sfc_render142]]);

// node_modules/@arco-design/web-vue/es/icon/icon-star-fill/index.js
var IconStarFill = Object.assign(_IconStarFill, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconStarFill.name, _IconStarFill);
  }
});

// node_modules/@arco-design/web-vue/es/icon/icon-face-meh-fill/icon-face-meh-fill.js
var _sfc_main143 = defineComponent({
  name: "IconFaceMehFill",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-face-meh-fill`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_164 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_249 = createBaseVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4 4 12.954 4 24s8.954 20 20 20Zm7.321-26.873a2.625 2.625 0 1 1 0 5.25 2.625 2.625 0 0 1 0-5.25Zm-14.646 0a2.625 2.625 0 1 1 0 5.25 2.625 2.625 0 0 1 0-5.25ZM15.999 30a2 2 0 0 1 2-2h12a2 2 0 1 1 0 4H18a2 2 0 0 1-2-2Z",
  fill: "currentColor",
  stroke: "none"
}, null, -1);
var _hoisted_345 = [
  _hoisted_249
];
function _sfc_render143(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_345, 14, _hoisted_164);
}
var _IconFaceMehFill = _export_sfc(_sfc_main143, [["render", _sfc_render143]]);

// node_modules/@arco-design/web-vue/es/icon/icon-face-meh-fill/index.js
var IconFaceMehFill = Object.assign(_IconFaceMehFill, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconFaceMehFill.name, _IconFaceMehFill);
  }
});

// node_modules/@arco-design/web-vue/es/icon/icon-face-smile-fill/icon-face-smile-fill.js
var _sfc_main144 = defineComponent({
  name: "IconFaceSmileFill",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-face-smile-fill`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_165 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_250 = createBaseVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4 4 12.954 4 24s8.954 20 20 20Zm7.321-26.873a2.625 2.625 0 1 1 0 5.25 2.625 2.625 0 0 1 0-5.25Zm-14.646 0a2.625 2.625 0 1 1 0 5.25 2.625 2.625 0 0 1 0-5.25Zm-.355 9.953a1.91 1.91 0 0 1 2.694.177 6.66 6.66 0 0 0 5.026 2.279c1.918 0 3.7-.81 4.961-2.206a1.91 1.91 0 0 1 2.834 2.558 10.476 10.476 0 0 1-7.795 3.466 10.477 10.477 0 0 1-7.897-3.58 1.91 1.91 0 0 1 .177-2.694Z",
  fill: "currentColor",
  stroke: "none"
}, null, -1);
var _hoisted_346 = [
  _hoisted_250
];
function _sfc_render144(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_346, 14, _hoisted_165);
}
var _IconFaceSmileFill = _export_sfc(_sfc_main144, [["render", _sfc_render144]]);

// node_modules/@arco-design/web-vue/es/icon/icon-face-smile-fill/index.js
var IconFaceSmileFill = Object.assign(_IconFaceSmileFill, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconFaceSmileFill.name, _IconFaceSmileFill);
  }
});

// node_modules/@arco-design/web-vue/es/icon/icon-face-frown-fill/icon-face-frown-fill.js
var _sfc_main145 = defineComponent({
  name: "IconFaceFrownFill",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-face-frown-fill`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_166 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_251 = createBaseVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4 4 12.954 4 24s8.954 20 20 20Zm7.322-26.873a2.625 2.625 0 1 1 0 5.25 2.625 2.625 0 0 1 0-5.25Zm-14.646 0a2.625 2.625 0 1 1 0 5.25 2.625 2.625 0 0 1 0-5.25ZM31.68 32.88a1.91 1.91 0 0 1-2.694-.176 6.66 6.66 0 0 0-5.026-2.28c-1.918 0-3.701.81-4.962 2.207a1.91 1.91 0 0 1-2.834-2.559 10.476 10.476 0 0 1 7.796-3.465c3.063 0 5.916 1.321 7.896 3.58a1.909 1.909 0 0 1-.176 2.693Z",
  fill: "currentColor",
  stroke: "none"
}, null, -1);
var _hoisted_347 = [
  _hoisted_251
];
function _sfc_render145(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_347, 14, _hoisted_166);
}
var _IconFaceFrownFill = _export_sfc(_sfc_main145, [["render", _sfc_render145]]);

// node_modules/@arco-design/web-vue/es/icon/icon-face-frown-fill/index.js
var IconFaceFrownFill = Object.assign(_IconFaceFrownFill, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconFaceFrownFill.name, _IconFaceFrownFill);
  }
});

// node_modules/@arco-design/web-vue/es/rate/rate.js
var _Rate = defineComponent({
  name: "Rate",
  props: {
    count: {
      type: Number,
      default: 5
    },
    modelValue: {
      type: Number,
      default: void 0
    },
    defaultValue: {
      type: Number,
      default: 0
    },
    allowHalf: {
      type: Boolean,
      default: false
    },
    allowClear: {
      type: Boolean,
      default: false
    },
    grading: {
      type: Boolean,
      default: false
    },
    readonly: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    color: {
      type: [String, Object]
    }
  },
  emits: {
    "update:modelValue": (value) => true,
    "change": (value) => true,
    "hoverChange": (value) => true
  },
  setup(props, {
    emit,
    slots
  }) {
    const {
      modelValue
    } = toRefs(props);
    const prefixCls = getPrefixCls("rate");
    const {
      mergedDisabled: _mergedDisabled,
      eventHandlers
    } = useFormItem({
      disabled: toRef(props, "disabled")
    });
    const _value = ref(props.defaultValue);
    const animation = ref(false);
    watch(modelValue, (value) => {
      if (isUndefined(value) || isNull(value)) {
        _value.value = 0;
      }
    });
    const hoverIndex = ref(0);
    const computedValue = computed(() => {
      var _a;
      return (_a = props.modelValue) != null ? _a : _value.value;
    });
    const displayIndex = computed(() => {
      const fixedValue = props.allowHalf ? index_es_default.times(index_es_default.round(index_es_default.divide(computedValue.value, 0.5), 0), 0.5) : Math.round(computedValue.value);
      return hoverIndex.value || fixedValue;
    });
    const mergedDisabled = computed(() => _mergedDisabled.value || props.readonly);
    const indexArray = computed(() => [...Array(props.grading ? 5 : props.count)]);
    const customColor = computed(() => {
      var _a;
      if (isString(props.color)) {
        return indexArray.value.map(() => props.color);
      }
      if (isObject(props.color)) {
        const sortedKeys = Object.keys(props.color).map((key) => Number(key)).sort((a, b) => b - a);
        let threshold = (_a = sortedKeys.pop()) != null ? _a : indexArray.value.length;
        return indexArray.value.map((_, index3) => {
          var _a2;
          if (index3 + 1 > threshold) {
            threshold = (_a2 = sortedKeys.pop()) != null ? _a2 : threshold;
          }
          return props.color[String(threshold)];
        });
      }
      return void 0;
    });
    const resetHoverIndex = () => {
      if (hoverIndex.value) {
        hoverIndex.value = 0;
        emit("hoverChange", 0);
      }
    };
    const handleMouseEnter = (index3, isHalf) => {
      const newHoverIndex = isHalf && props.allowHalf ? index3 + 0.5 : index3 + 1;
      if (newHoverIndex !== hoverIndex.value) {
        hoverIndex.value = newHoverIndex;
        emit("hoverChange", newHoverIndex);
      }
    };
    const handleClick = (index3, isHalf) => {
      var _a, _b, _c, _d;
      const newValue = isHalf && props.allowHalf ? index3 + 0.5 : index3 + 1;
      animation.value = true;
      if (newValue !== computedValue.value) {
        _value.value = newValue;
        emit("update:modelValue", newValue);
        emit("change", newValue);
        (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onChange) == null ? void 0 : _b.call(_a);
      } else if (props.allowClear) {
        _value.value = 0;
        emit("update:modelValue", 0);
        emit("change", 0);
        (_d = (_c = eventHandlers.value) == null ? void 0 : _c.onChange) == null ? void 0 : _d.call(_c);
      }
    };
    const handleAnimationEnd = (index3) => {
      if (animation.value && index3 + 1 >= computedValue.value - 1) {
        animation.value = false;
      }
    };
    const renderGradingCharacter = (index3, displayIndex2) => {
      if (index3 > displayIndex2) {
        return createVNode(IconFaceMehFill, null, null);
      }
      if (displayIndex2 <= 2) {
        return createVNode(IconFaceFrownFill, null, null);
      }
      if (displayIndex2 <= 3) {
        return createVNode(IconFaceMehFill, null, null);
      }
      return createVNode(IconFaceSmileFill, null, null);
    };
    const getAriaProps = (index3, isHalf = false) => {
      return {
        "role": "radio",
        "aria-checked": index3 + (isHalf ? 0.5 : 1) <= computedValue.value,
        "aria-setsize": indexArray.value.length,
        "aria-posinset": index3 + (isHalf ? 0.5 : 1)
      };
    };
    const renderCharacter = (index3) => {
      var _a, _b;
      const displayCharacter = props.grading ? renderGradingCharacter(index3, displayIndex.value) : (_b = (_a = slots.character) == null ? void 0 : _a.call(slots, {
        index: index3
      })) != null ? _b : createVNode(IconStarFill, null, null);
      const leftProps = mergedDisabled.value ? {} : {
        onMouseenter: () => handleMouseEnter(index3, true),
        onClick: () => handleClick(index3, true)
      };
      const rightProps = mergedDisabled.value ? {} : {
        onMouseenter: () => handleMouseEnter(index3, false),
        onClick: () => handleClick(index3, false)
      };
      const style = animation.value ? {
        animationDelay: `${50 * index3}ms`
      } : void 0;
      const parseDisplayIndex = Math.ceil(displayIndex.value) - 1;
      const leftStyle = customColor.value && props.allowHalf && index3 + 0.5 === displayIndex.value ? {
        color: customColor.value[parseDisplayIndex]
      } : void 0;
      const rightStyle = customColor.value && index3 + 1 <= displayIndex.value ? {
        color: customColor.value[parseDisplayIndex]
      } : void 0;
      const cls2 = [`${prefixCls}-character`, {
        [`${prefixCls}-character-half`]: props.allowHalf && index3 + 0.5 === displayIndex.value,
        [`${prefixCls}-character-full`]: index3 + 1 <= displayIndex.value,
        [`${prefixCls}-character-scale`]: animation.value && index3 + 1 < computedValue.value
      }];
      return createVNode("div", mergeProps({
        "class": cls2,
        "style": style
      }, !props.allowHalf ? getAriaProps(index3) : void 0, {
        "onAnimationend": () => handleAnimationEnd(index3)
      }), [createVNode("div", mergeProps({
        "class": `${prefixCls}-character-left`,
        "style": leftStyle
      }, leftProps, props.allowHalf ? getAriaProps(index3, true) : void 0), [displayCharacter]), createVNode("div", mergeProps({
        "class": `${prefixCls}-character-right`,
        "style": rightStyle
      }, rightProps, props.allowHalf ? getAriaProps(index3) : void 0), [displayCharacter])]);
    };
    const cls = computed(() => [prefixCls, {
      [`${prefixCls}-readonly`]: props.readonly,
      [`${prefixCls}-disabled`]: _mergedDisabled.value
    }]);
    return () => createVNode("div", {
      "class": cls.value,
      "onMouseleave": resetHoverIndex
    }, [indexArray.value.map((_, index3) => renderCharacter(index3))]);
  }
});

// node_modules/@arco-design/web-vue/es/rate/index.js
var Rate = Object.assign(_Rate, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Rate.name, _Rate);
  }
});

// node_modules/@arco-design/web-vue/es/icon/icon-info/icon-info.js
var _sfc_main146 = defineComponent({
  name: "IconInfo",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-info`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_167 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_252 = createBaseVNode("path", { d: "M25 39h-2V18h2z" }, null, -1);
var _hoisted_348 = createBaseVNode("path", {
  fill: "currentColor",
  stroke: "none",
  d: "M25 39h-2V18h2z"
}, null, -1);
var _hoisted_413 = createBaseVNode("path", { d: "M25 11h-2V9h2z" }, null, -1);
var _hoisted_54 = createBaseVNode("path", {
  fill: "currentColor",
  stroke: "none",
  d: "M25 11h-2V9h2z"
}, null, -1);
var _hoisted_63 = [
  _hoisted_252,
  _hoisted_348,
  _hoisted_413,
  _hoisted_54
];
function _sfc_render146(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_63, 14, _hoisted_167);
}
var _IconInfo = _export_sfc(_sfc_main146, [["render", _sfc_render146]]);

// node_modules/@arco-design/web-vue/es/icon/icon-info/index.js
var IconInfo = Object.assign(_IconInfo, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconInfo.name, _IconInfo);
  }
});

// node_modules/@arco-design/web-vue/es/result/403.js
var ResultForbidden = defineComponent({
  name: "ResultForbidden",
  render() {
    return createVNode("svg", {
      "viewBox": "0 0 213 213",
      "height": "100%",
      "width": "100%",
      "style": {
        fillRule: "evenodd",
        clipRule: "evenodd",
        strokeLinejoin: "round",
        strokeMiterlimit: 2
      }
    }, [createVNode("g", {
      "transform": "matrix(1,0,0,1,-871.485,-445.62)"
    }, [createVNode("g", null, [createVNode("g", {
      "transform": "matrix(1,0,0,1,-75.2684,-87.3801)"
    }, [createVNode("circle", {
      "cx": "1053.23",
      "cy": "639.477",
      "r": "106.477",
      "style": {
        fill: "rgb(235, 238, 246)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(1,0,0,1,246.523,295.575)"
    }, [createVNode("g", {
      "transform": "matrix(0.316667,0,0,0.316667,277.545,71.0298)"
    }, [createVNode("g", {
      "transform": "matrix(0.989011,-0.571006,1.14201,0.659341,-335.171,81.4498)"
    }, [createVNode("rect", {
      "x": "495.52",
      "y": "1057.87",
      "width": "105.078",
      "height": "91",
      "style": {
        fill: "rgb(253, 243, 228)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.164835,-0.0951676,1.14201,0.659341,116.224,-179.163)"
    }, [createVNode("rect", {
      "x": "495.52",
      "y": "1057.87",
      "width": "105.078",
      "height": "91",
      "style": {
        fill: "rgb(202, 174, 136)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.978261,-0.564799,1.26804e-16,1.30435,-337.046,42.0327)"
    }, [createVNode("rect", {
      "x": "1844.06",
      "y": "1192.54",
      "width": "106.232",
      "height": "92",
      "style": {
        fill: "rgb(196, 173, 142)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.267591,-0.154493,3.46856e-17,0.356787,992.686,475.823)"
    }, [createVNode("rect", {
      "x": "1844.06",
      "y": "1192.54",
      "width": "106.232",
      "height": "92",
      "style": {
        fill: "rgb(102, 102, 102)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(1.28257,-0.740494,1.23317e-16,1.7101,1501.14,624.071)"
    }, [createVNode("g", {
      "transform": "matrix(1,0,0,1,-6,-6)"
    }, [createVNode("path", {
      "d": "M2.25,10.5C2.25,10.5 1.5,10.5 1.5,9.75C1.5,9 2.25,6.75 6,6.75C9.75,6.75 10.5,9 10.5,9.75C10.5,10.5 9.75,10.5 9.75,10.5L2.25,10.5ZM6,6C7.234,6 8.25,4.984 8.25,3.75C8.25,2.516 7.234,1.5 6,1.5C4.766,1.5 3.75,2.516 3.75,3.75C3.75,4.984 4.766,6 6,6Z",
      "style": {
        fill: "white"
      }
    }, null)])]), createVNode("g", {
      "transform": "matrix(0.725806,0.419045,1.75755e-17,1.01444,155.314,212.138)"
    }, [createVNode("rect", {
      "x": "1663.92",
      "y": "-407.511",
      "width": "143.183",
      "height": "118.292",
      "style": {
        fill: "rgb(240, 218, 183)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(1.58977,-0.917857,1.15976e-16,2.2425,-1270.46,-614.379)"
    }, [createVNode("rect", {
      "x": "1748.87",
      "y": "1226.67",
      "width": "10.895",
      "height": "13.378",
      "style": {
        fill: "rgb(132, 97, 0)"
      }
    }, null)])]), createVNode("g", {
      "transform": "matrix(0.182997,0.105653,-0.494902,0.285732,814.161,66.3087)"
    }, [createVNode("rect", {
      "x": "657.012",
      "y": "404.643",
      "width": "198.586",
      "height": "145.08",
      "style": {
        fillOpacity: 0.1
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.316667,0,0,0.316667,237.301,94.2647)"
    }, [createVNode("g", {
      "transform": "matrix(0.989011,-0.571006,1.14201,0.659341,-335.171,81.4498)"
    }, [createVNode("rect", {
      "x": "495.52",
      "y": "1057.87",
      "width": "105.078",
      "height": "91",
      "style": {
        fill: "rgb(253, 243, 228)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.164835,-0.0951676,1.14201,0.659341,116.224,-179.163)"
    }, [createVNode("rect", {
      "x": "495.52",
      "y": "1057.87",
      "width": "105.078",
      "height": "91",
      "style": {
        fill: "rgb(202, 174, 136)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.978261,-0.564799,1.26804e-16,1.30435,-337.046,42.0327)"
    }, [createVNode("rect", {
      "x": "1844.06",
      "y": "1192.54",
      "width": "106.232",
      "height": "92",
      "style": {
        fill: "rgb(196, 173, 142)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.267591,-0.154493,3.46856e-17,0.356787,992.686,475.823)"
    }, [createVNode("rect", {
      "x": "1844.06",
      "y": "1192.54",
      "width": "106.232",
      "height": "92",
      "style": {
        fill: "rgb(102, 102, 102)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(1.28257,-0.740494,1.23317e-16,1.7101,1501.14,624.071)"
    }, [createVNode("g", {
      "transform": "matrix(1,0,0,1,-6,-6)"
    }, [createVNode("path", {
      "d": "M2.25,10.5C2.25,10.5 1.5,10.5 1.5,9.75C1.5,9 2.25,6.75 6,6.75C9.75,6.75 10.5,9 10.5,9.75C10.5,10.5 9.75,10.5 9.75,10.5L2.25,10.5ZM6,6C7.234,6 8.25,4.984 8.25,3.75C8.25,2.516 7.234,1.5 6,1.5C4.766,1.5 3.75,2.516 3.75,3.75C3.75,4.984 4.766,6 6,6Z",
      "style": {
        fill: "white"
      }
    }, null)])]), createVNode("g", {
      "transform": "matrix(0.725806,0.419045,1.75755e-17,1.01444,155.314,212.138)"
    }, [createVNode("rect", {
      "x": "1663.92",
      "y": "-407.511",
      "width": "143.183",
      "height": "118.292",
      "style": {
        fill: "rgb(240, 218, 183)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(1.58977,-0.917857,1.15976e-16,2.2425,-1270.46,-614.379)"
    }, [createVNode("rect", {
      "x": "1748.87",
      "y": "1226.67",
      "width": "10.895",
      "height": "13.378",
      "style": {
        fill: "rgb(132, 97, 0)"
      }
    }, null)])]), createVNode("g", {
      "transform": "matrix(0.474953,0,0,0.474953,538.938,8.95289)"
    }, [createVNode("g", {
      "transform": "matrix(0.180615,0.104278,-0.973879,0.562269,790.347,286.159)"
    }, [createVNode("rect", {
      "x": "657.012",
      "y": "404.643",
      "width": "198.586",
      "height": "145.08",
      "style": {
        fillOpacity: 0.1
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.473356,0,0,0.473356,294.481,129.741)"
    }, [createVNode("g", null, [createVNode("g", {
      "transform": "matrix(0.1761,-0.101671,1.73518e-16,1.22207,442.564,7.31508)"
    }, [createVNode("rect", {
      "x": "202.62",
      "y": "575.419",
      "width": "124.002",
      "height": "259.402",
      "style": {
        fill: "rgb(235, 235, 235)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.0922781,0.0532768,2.03964e-16,2.20569,405.236,-248.842)"
    }, [createVNode("rect", {
      "x": "657.012",
      "y": "404.643",
      "width": "198.586",
      "height": "145.08",
      "style": {
        fill: "rgb(34, 34, 34)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.147541,-0.0851831,1.52371e-16,1.23446,454.294,-3.8127)"
    }, [createVNode("rect", {
      "x": "202.62",
      "y": "575.419",
      "width": "124.002",
      "height": "259.402",
      "style": {
        fill: "rgb(51, 51, 51)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.0921286,0.0531905,-0.126106,0.0728076,474.688,603.724)"
    }, [createVNode("rect", {
      "x": "657.012",
      "y": "404.643",
      "width": "198.586",
      "height": "145.08",
      "style": {
        fill: "rgb(102, 102, 102)"
      }
    }, null)])])]), createVNode("g", {
      "transform": "matrix(0.473356,0,0,0.473356,192.621,188.549)"
    }, [createVNode("g", null, [createVNode("g", {
      "transform": "matrix(0.1761,-0.101671,1.73518e-16,1.22207,442.564,7.31508)"
    }, [createVNode("rect", {
      "x": "202.62",
      "y": "575.419",
      "width": "124.002",
      "height": "259.402",
      "style": {
        fill: "rgb(235, 235, 235)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.0922781,0.0532768,2.03964e-16,2.20569,405.236,-248.842)"
    }, [createVNode("rect", {
      "x": "657.012",
      "y": "404.643",
      "width": "198.586",
      "height": "145.08",
      "style": {
        fill: "rgb(34, 34, 34)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.147541,-0.0851831,1.52371e-16,1.23446,454.294,-3.8127)"
    }, [createVNode("rect", {
      "x": "202.62",
      "y": "575.419",
      "width": "124.002",
      "height": "259.402",
      "style": {
        fill: "rgb(51, 51, 51)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.0921286,0.0531905,-0.126106,0.0728076,474.688,603.724)"
    }, [createVNode("rect", {
      "x": "657.012",
      "y": "404.643",
      "width": "198.586",
      "height": "145.08",
      "style": {
        fill: "rgb(102, 102, 102)"
      }
    }, null)])])]), createVNode("g", {
      "transform": "matrix(0.668111,0,0,0.668111,-123.979,-49.2109)"
    }, [createVNode("g", {
      "transform": "matrix(0.0349225,0.0201625,1.81598e-17,0.220789,974.758,729.412)"
    }, [createVNode("rect", {
      "x": "657.012",
      "y": "404.643",
      "width": "198.586",
      "height": "145.08",
      "style": {
        fill: "rgb(235, 235, 235)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(1.1164,-0.644557,0,0.220789,42.5091,1294.14)"
    }, [createVNode("rect", {
      "x": "657.012",
      "y": "404.643",
      "width": "198.586",
      "height": "145.08",
      "style": {
        fill: "rgb(235, 235, 235)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.0349225,0.0201625,-1.52814,0.882275,1593.11,461.746)"
    }, [createVNode("rect", {
      "x": "657.012",
      "y": "404.643",
      "width": "198.586",
      "height": "145.08",
      "style": {
        fill: "rgb(102, 102, 102)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(1.1164,-0.644557,0,0.220789,49.4442,1298.14)"
    }, [createVNode("rect", {
      "x": "657.012",
      "y": "404.643",
      "width": "198.586",
      "height": "145.08",
      "style": {
        fill: "rgb(51, 51, 51)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.0349225,0.0201625,1.81598e-17,0.220789,753.056,857.412)"
    }, [createVNode("rect", {
      "x": "657.012",
      "y": "404.643",
      "width": "198.586",
      "height": "145.08",
      "style": {
        fill: "rgb(34, 34, 34)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.142968,-0.0825428,-0.207261,0.478709,898.874,529.479)"
    }, [createVNode("rect", {
      "x": "831",
      "y": "1023.79",
      "width": "89.214",
      "height": "89.214",
      "style": {
        fill: "rgb(255, 125, 0)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.142968,-0.0825428,-0.207261,0.478709,930.12,511.44)"
    }, [createVNode("rect", {
      "x": "831",
      "y": "1023.79",
      "width": "89.214",
      "height": "89.214",
      "style": {
        fill: "rgb(255, 125, 0)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.142968,-0.0825428,-0.207261,0.478709,961.365,493.4)"
    }, [createVNode("rect", {
      "x": "831",
      "y": "1023.79",
      "width": "89.214",
      "height": "89.214",
      "style": {
        fill: "rgb(248, 248, 248)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.142968,-0.0825428,-0.207261,0.478709,992.61,475.361)"
    }, [createVNode("rect", {
      "x": "831",
      "y": "1023.79",
      "width": "89.214",
      "height": "89.214",
      "style": {
        fill: "rgb(248, 248, 248)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.142968,-0.0825428,-0.207261,0.478709,1023.86,457.321)"
    }, [createVNode("rect", {
      "x": "831",
      "y": "1023.79",
      "width": "89.214",
      "height": "89.214",
      "style": {
        fill: "rgb(248, 248, 248)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.142968,-0.0825428,-0.207261,0.478709,1056.25,438.617)"
    }, [createVNode("rect", {
      "x": "831",
      "y": "1023.79",
      "width": "89.214",
      "height": "89.214",
      "style": {
        fill: "rgb(255, 125, 0)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.142968,-0.0825428,-0.207261,0.478709,1085.74,421.589)"
    }, [createVNode("rect", {
      "x": "831",
      "y": "1023.79",
      "width": "89.214",
      "height": "89.214",
      "style": {
        fill: "rgb(255, 125, 0)"
      }
    }, null)])]), createVNode("g", {
      "transform": "matrix(0.668111,0,0,0.668111,-123.979,-91.97)"
    }, [createVNode("g", {
      "transform": "matrix(0.0349225,0.0201625,1.81598e-17,0.220789,974.758,729.412)"
    }, [createVNode("rect", {
      "x": "657.012",
      "y": "404.643",
      "width": "198.586",
      "height": "145.08",
      "style": {
        fill: "rgb(235, 235, 235)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(1.1164,-0.644557,0,0.220789,42.5091,1294.14)"
    }, [createVNode("rect", {
      "x": "657.012",
      "y": "404.643",
      "width": "198.586",
      "height": "145.08",
      "style": {
        fill: "rgb(235, 235, 235)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.0349225,0.0201625,-1.52814,0.882275,1593.11,461.746)"
    }, [createVNode("rect", {
      "x": "657.012",
      "y": "404.643",
      "width": "198.586",
      "height": "145.08",
      "style": {
        fill: "rgb(102, 102, 102)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(1.1164,-0.644557,0,0.220789,49.4442,1298.14)"
    }, [createVNode("rect", {
      "x": "657.012",
      "y": "404.643",
      "width": "198.586",
      "height": "145.08",
      "style": {
        fill: "rgb(51, 51, 51)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.0349225,0.0201625,1.81598e-17,0.220789,753.056,857.412)"
    }, [createVNode("rect", {
      "x": "657.012",
      "y": "404.643",
      "width": "198.586",
      "height": "145.08",
      "style": {
        fill: "rgb(34, 34, 34)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.142968,-0.0825428,-0.207261,0.478709,898.874,529.479)"
    }, [createVNode("rect", {
      "x": "831",
      "y": "1023.79",
      "width": "89.214",
      "height": "89.214",
      "style": {
        fill: "rgb(255, 125, 0)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.142968,-0.0825428,-0.207261,0.478709,930.12,511.44)"
    }, [createVNode("rect", {
      "x": "831",
      "y": "1023.79",
      "width": "89.214",
      "height": "89.214",
      "style": {
        fill: "rgb(255, 125, 0)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.142968,-0.0825428,-0.207261,0.478709,961.365,493.4)"
    }, [createVNode("rect", {
      "x": "831",
      "y": "1023.79",
      "width": "89.214",
      "height": "89.214",
      "style": {
        fill: "rgb(248, 248, 248)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.142968,-0.0825428,-0.207261,0.478709,992.61,475.361)"
    }, [createVNode("rect", {
      "x": "831",
      "y": "1023.79",
      "width": "89.214",
      "height": "89.214",
      "style": {
        fill: "rgb(248, 248, 248)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.142968,-0.0825428,-0.207261,0.478709,1023.86,457.321)"
    }, [createVNode("rect", {
      "x": "831",
      "y": "1023.79",
      "width": "89.214",
      "height": "89.214",
      "style": {
        fill: "rgb(248, 248, 248)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.142968,-0.0825428,-0.207261,0.478709,1056.25,438.617)"
    }, [createVNode("rect", {
      "x": "831",
      "y": "1023.79",
      "width": "89.214",
      "height": "89.214",
      "style": {
        fill: "rgb(255, 125, 0)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.142968,-0.0825428,-0.207261,0.478709,1085.74,421.589)"
    }, [createVNode("rect", {
      "x": "831",
      "y": "1023.79",
      "width": "89.214",
      "height": "89.214",
      "style": {
        fill: "rgb(255, 125, 0)"
      }
    }, null)])]), createVNode("g", {
      "transform": "matrix(0.701585,5.16096e-35,-5.16096e-35,0.701585,-546.219,-21.3487)"
    }, [createVNode("g", {
      "transform": "matrix(0.558202,-0.322278,0,0.882275,1033.27,615.815)"
    }, [createVNode("path", {
      "d": "M855.598,410.446C855.598,407.244 852.515,404.643 848.718,404.643L663.891,404.643C660.094,404.643 657.012,407.244 657.012,410.446L657.012,543.92C657.012,547.123 660.094,549.723 663.891,549.723L848.718,549.723C852.515,549.723 855.598,547.123 855.598,543.92L855.598,410.446Z",
      "style": {
        fill: "white"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.558202,-0.322278,0,0.882275,1035.25,616.977)"
    }, [createVNode("path", {
      "d": "M855.598,410.446C855.598,407.244 852.515,404.643 848.718,404.643L663.891,404.643C660.094,404.643 657.012,407.244 657.012,410.446L657.012,543.92C657.012,547.123 660.094,549.723 663.891,549.723L848.718,549.723C852.515,549.723 855.598,547.123 855.598,543.92L855.598,410.446Z",
      "style": {
        fill: "white"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(1,0,0,1,418.673,507.243)"
    }, [createVNode("path", {
      "d": "M1088.34,192.063C1089.79,191.209 1090.78,191.821 1090.78,191.821L1092.71,192.944C1092.71,192.944 1092.29,192.721 1091.7,192.763C1090.99,192.813 1090.34,193.215 1090.34,193.215C1090.34,193.215 1088.85,192.362 1088.34,192.063Z",
      "style": {
        fill: "rgb(248, 248, 248)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(1,0,0,1,235.984,-39.1315)"
    }, [createVNode("path", {
      "d": "M1164.02,805.247C1164.05,802.517 1165.64,799.379 1167.67,798.118L1169.67,799.272C1167.58,800.648 1166.09,803.702 1166.02,806.402L1164.02,805.247Z",
      "style": {
        fill: "url(#_Linear1)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.396683,0,0,0.396683,1000.22,516.921)"
    }, [createVNode("path", {
      "d": "M1011.2,933.14C1009.31,932.075 1008.05,929.696 1007.83,926.324L1012.87,929.235C1012.87,929.235 1012.96,930.191 1013.04,930.698C1013.16,931.427 1013.42,932.344 1013.62,932.845C1013.79,933.255 1014.59,935.155 1016.22,936.046C1015.83,935.781 1011.19,933.139 1011.19,933.139L1011.2,933.14Z",
      "style": {
        fill: "rgb(238, 238, 238)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.253614,-0.146424,4.87691e-17,0.338152,1209.98,830.02)"
    }, [createVNode("circle", {
      "cx": "975.681",
      "cy": "316.681",
      "r": "113.681",
      "style": {
        fill: "rgb(245, 63, 63)"
      }
    }, null), createVNode("g", {
      "transform": "matrix(1.08844,0,0,0.61677,-99.9184,125.436)"
    }, [createVNode("path", {
      "d": "M1062,297.556C1062,296.697 1061.61,296 1061.12,296L915.882,296C915.395,296 915,296.697 915,297.556L915,333.356C915,334.215 915.395,334.912 915.882,334.912L1061.12,334.912C1061.61,334.912 1062,334.215 1062,333.356L1062,297.556Z",
      "style": {
        fill: "white"
      }
    }, null)])]), createVNode("g", {
      "transform": "matrix(5.57947,-3.22131,0.306277,0.176829,-6260.71,4938.32)"
    }, [createVNode("rect", {
      "x": "1335.54",
      "y": "694.688",
      "width": "18.525",
      "height": "6.511",
      "style": {
        fill: "rgb(248, 248, 248)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.10726,0.0619268,-1.83335e-14,18.1609,1256.76,-11932.8)"
    }, [createVNode("rect", {
      "x": "1335.54",
      "y": "694.688",
      "width": "18.525",
      "height": "6.511",
      "style": {
        fill: "rgb(238, 238, 238)"
      }
    }, null)])])]), createVNode("g", {
      "transform": "matrix(0.316667,0,0,0.316667,269.139,37.8829)"
    }, [createVNode("g", {
      "transform": "matrix(0.989011,-0.571006,1.14201,0.659341,-335.171,81.4498)"
    }, [createVNode("rect", {
      "x": "495.52",
      "y": "1057.87",
      "width": "105.078",
      "height": "91",
      "style": {
        fill: "rgb(253, 243, 228)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.164835,-0.0951676,1.14201,0.659341,116.224,-179.163)"
    }, [createVNode("rect", {
      "x": "495.52",
      "y": "1057.87",
      "width": "105.078",
      "height": "91",
      "style": {
        fill: "rgb(202, 174, 136)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.978261,-0.564799,1.26804e-16,1.30435,-337.046,42.0327)"
    }, [createVNode("rect", {
      "x": "1844.06",
      "y": "1192.54",
      "width": "106.232",
      "height": "92",
      "style": {
        fill: "rgb(196, 173, 142)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.267591,-0.154493,3.46856e-17,0.356787,992.686,475.823)"
    }, [createVNode("rect", {
      "x": "1844.06",
      "y": "1192.54",
      "width": "106.232",
      "height": "92",
      "style": {
        fill: "rgb(102, 102, 102)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(1.28257,-0.740494,1.23317e-16,1.7101,1501.14,624.071)"
    }, [createVNode("g", {
      "transform": "matrix(1,0,0,1,-6,-6)"
    }, [createVNode("path", {
      "d": "M2.25,10.5C2.25,10.5 1.5,10.5 1.5,9.75C1.5,9 2.25,6.75 6,6.75C9.75,6.75 10.5,9 10.5,9.75C10.5,10.5 9.75,10.5 9.75,10.5L2.25,10.5ZM6,6C7.234,6 8.25,4.984 8.25,3.75C8.25,2.516 7.234,1.5 6,1.5C4.766,1.5 3.75,2.516 3.75,3.75C3.75,4.984 4.766,6 6,6Z",
      "style": {
        fill: "white"
      }
    }, null)])]), createVNode("g", {
      "transform": "matrix(0.725806,0.419045,1.75755e-17,1.01444,155.314,212.138)"
    }, [createVNode("rect", {
      "x": "1663.92",
      "y": "-407.511",
      "width": "143.183",
      "height": "118.292",
      "style": {
        fill: "rgb(240, 218, 183)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(1.58977,-0.917857,1.15976e-16,2.2425,-1270.46,-614.379)"
    }, [createVNode("rect", {
      "x": "1748.87",
      "y": "1226.67",
      "width": "10.895",
      "height": "13.378",
      "style": {
        fill: "rgb(132, 97, 0)"
      }
    }, null)])])])])]), createVNode("defs", null, [createVNode("linearGradient", {
      "id": "_Linear1",
      "x1": "0",
      "y1": "0",
      "x2": "1",
      "y2": "0",
      "gradientUnits": "userSpaceOnUse",
      "gradientTransform": "matrix(-2.64571,4.04098,-4.04098,-2.64571,1167.67,799.269)"
    }, [createVNode("stop", {
      "offset": "0",
      "style": {
        stopColor: "rgb(248, 248, 248)",
        stopOpacity: 1
      }
    }, null), createVNode("stop", {
      "offset": "1",
      "style": {
        stopColor: "rgb(248, 248, 248)",
        stopOpacity: 1
      }
    }, null)])])]);
  }
});

// node_modules/@arco-design/web-vue/es/result/404.js
var ResultNotFound = defineComponent({
  name: "ResultNotFound",
  render() {
    return createVNode("svg", {
      "width": "100%",
      "height": "100%",
      "viewBox": "0 0 213 213",
      "style": {
        fillRule: "evenodd",
        clipRule: "evenodd",
        strokeLinejoin: "round",
        strokeMiterlimit: 2
      }
    }, [createVNode("g", {
      "transform": "matrix(1,0,0,1,-1241.95,-445.62)"
    }, [createVNode("g", null, [createVNode("g", {
      "transform": "matrix(1,0,0,1,295.2,-87.3801)"
    }, [createVNode("circle", {
      "cx": "1053.23",
      "cy": "639.477",
      "r": "106.477",
      "style": {
        fill: "rgb(235, 238, 246)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.38223,0,0,0.38223,1126.12,238.549)"
    }, [createVNode("g", {
      "transform": "matrix(0.566536,0.327089,-1.28774,0.74348,763.4,317.171)"
    }, [createVNode("rect", {
      "x": "657.012",
      "y": "404.643",
      "width": "198.586",
      "height": "145.08",
      "style": {
        fillOpacity: 0.1
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.29595,0.170867,-0.91077,0.525833,873.797,588.624)"
    }, [createVNode("rect", {
      "x": "657.012",
      "y": "404.643",
      "width": "198.586",
      "height": "145.08",
      "style": {
        fillOpacity: 0.1
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(1,0,0,1,275,-15)"
    }, [createVNode("path", {
      "d": "M262.077,959.012L276.923,959.012L273.388,1004.01C273.388,1004.59 273.009,1005.16 272.25,1005.6C270.732,1006.48 268.268,1006.48 266.75,1005.6C265.991,1005.16 265.612,1004.59 265.612,1004.01L262.077,959.012Z",
      "style": {
        fill: "rgb(196, 173, 142)"
      }
    }, null), createVNode("g", {
      "transform": "matrix(0.866025,-0.5,1,0.57735,0,-45)"
    }, [createVNode("ellipse", {
      "cx": "-848.416",
      "cy": "1004.25",
      "rx": "6.062",
      "ry": "5.25",
      "style": {
        fill: "rgb(255, 125, 0)"
      }
    }, null)])]), createVNode("g", {
      "transform": "matrix(1,0,0,1,183.952,-67.5665)"
    }, [createVNode("path", {
      "d": "M262.077,959.012L276.923,959.012L273.388,1004.01C273.388,1004.59 273.009,1005.16 272.25,1005.6C270.732,1006.48 268.268,1006.48 266.75,1005.6C265.991,1005.16 265.612,1004.59 265.612,1004.01L262.077,959.012Z",
      "style": {
        fill: "rgb(196, 173, 142)"
      }
    }, null), createVNode("g", {
      "transform": "matrix(0.866025,-0.5,1,0.57735,0,-45)"
    }, [createVNode("ellipse", {
      "cx": "-848.416",
      "cy": "1004.25",
      "rx": "6.062",
      "ry": "5.25",
      "style": {
        fill: "rgb(255, 125, 0)"
      }
    }, null)])]), createVNode("g", {
      "transform": "matrix(1,0,0,1,414,-95.2517)"
    }, [createVNode("path", {
      "d": "M262.077,959.012L276.923,959.012L273.388,1004.01C273.388,1004.59 273.009,1005.16 272.25,1005.6C270.732,1006.48 268.268,1006.48 266.75,1005.6C265.991,1005.16 265.612,1004.59 265.612,1004.01L262.077,959.012Z",
      "style": {
        fill: "rgb(196, 173, 142)"
      }
    }, null), createVNode("g", {
      "transform": "matrix(0.866025,-0.5,1,0.57735,0,-45)"
    }, [createVNode("ellipse", {
      "cx": "-848.416",
      "cy": "1004.25",
      "rx": "6.062",
      "ry": "5.25",
      "style": {
        fill: "rgb(255, 125, 0)"
      }
    }, null)])]), createVNode("g", {
      "transform": "matrix(1,0,0,1,322.952,-147.818)"
    }, [createVNode("path", {
      "d": "M262.077,959.012L276.923,959.012L273.388,1004.01C273.388,1004.59 273.009,1005.16 272.25,1005.6C270.732,1006.48 268.268,1006.48 266.75,1005.6C265.991,1005.16 265.612,1004.59 265.612,1004.01L262.077,959.012Z",
      "style": {
        fill: "rgb(196, 173, 142)"
      }
    }, null), createVNode("g", {
      "transform": "matrix(0.866025,-0.5,1,0.57735,0,-45)"
    }, [createVNode("ellipse", {
      "cx": "-848.416",
      "cy": "1004.25",
      "rx": "6.062",
      "ry": "5.25",
      "style": {
        fill: "rgb(255, 125, 0)"
      }
    }, null)])]), createVNode("g", null, [createVNode("g", {
      "transform": "matrix(1.42334,-0.821763,1.11271,0.642426,-1439.64,459.621)"
    }, [createVNode("rect", {
      "x": "495.52",
      "y": "1057.87",
      "width": "105.078",
      "height": "91",
      "style": {
        fill: "rgb(253, 243, 228)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(1.40786,-0.812831,6.60237e-16,1.99081,-2052.17,-84.7286)"
    }, [createVNode("rect", {
      "x": "1844.06",
      "y": "1192.54",
      "width": "106.232",
      "height": "92",
      "style": {
        fill: "rgb(196, 173, 142)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(1.26159,-0.728382,5.91642e-16,1.78397,-1774.67,11.2303)"
    }, [createVNode("path", {
      "d": "M1950.29,1194.38C1950.29,1193.37 1949.41,1192.54 1948.34,1192.54L1846.01,1192.54C1844.93,1192.54 1844.06,1193.37 1844.06,1194.38L1844.06,1282.7C1844.06,1283.72 1844.93,1284.54 1846.01,1284.54L1948.34,1284.54C1949.41,1284.54 1950.29,1283.72 1950.29,1282.7L1950.29,1194.38Z",
      "style": {
        fill: "rgb(132, 97, 51)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(1.2198,-0.704254,5.72043e-16,1.72488,-1697.6,37.2103)"
    }, [createVNode("path", {
      "d": "M1950.29,1194.38C1950.29,1193.37 1949.41,1192.54 1948.34,1192.54L1846.01,1192.54C1844.93,1192.54 1844.06,1193.37 1844.06,1194.38L1844.06,1282.7C1844.06,1283.72 1844.93,1284.54 1846.01,1284.54L1948.34,1284.54C1949.41,1284.54 1950.29,1283.72 1950.29,1282.7L1950.29,1194.38Z",
      "style": {
        fill: "rgb(196, 173, 142)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.707187,0.408295,9.06119e-17,1.54833,-733.949,683.612)"
    }, [createVNode("rect", {
      "x": "1663.92",
      "y": "-407.511",
      "width": "143.183",
      "height": "118.292",
      "style": {
        fill: "rgb(240, 218, 183)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(1.64553,-0.950049,1.17482,0.678285,-1632.45,473.879)"
    }, [createVNode("rect", {
      "x": "495.52",
      "y": "1057.87",
      "width": "105.078",
      "height": "91",
      "style": {
        fill: "rgb(253, 243, 228)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.74666,0.431085,2.3583e-17,0.135259,-816.63,57.1397)"
    }, [createVNode("rect", {
      "x": "1663.92",
      "y": "-407.511",
      "width": "143.183",
      "height": "118.292",
      "style": {
        fill: "rgb(240, 218, 183)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(1.64553,-0.950049,1.17482,0.678285,-1632.45,473.879)"
    }, [createVNode("rect", {
      "x": "495.52",
      "y": "1057.87",
      "width": "105.078",
      "height": "91",
      "style": {
        fill: "rgb(253, 243, 228)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.750082,0,0,0.750082,163.491,354.191)"
    }, [createVNode("g", {
      "transform": "matrix(1.75943,-1.01581,1.75879e-16,0.632893,-2721.54,1876.43)"
    }, [createVNode("rect", {
      "x": "1844.06",
      "y": "1192.54",
      "width": "106.232",
      "height": "92",
      "style": {
        fill: "rgb(196, 173, 142)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.290956,-0.167984,2.90849e-17,0.104661,69.4195,919.311)"
    }, [createVNode("path", {
      "d": "M1950.29,1238.54C1950.29,1213.15 1944.73,1192.54 1937.88,1192.54L1856.47,1192.54C1849.62,1192.54 1844.06,1213.15 1844.06,1238.54C1844.06,1263.93 1849.62,1284.54 1856.47,1284.54L1937.88,1284.54C1944.73,1284.54 1950.29,1263.93 1950.29,1238.54Z",
      "style": {
        fill: "rgb(132, 97, 51)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.262716,-0.151679,8.27418e-18,0.0364999,121.496,970.53)"
    }, [createVNode("path", {
      "d": "M1950.29,1238.54C1950.29,1213.15 1948.14,1192.54 1945.5,1192.54L1848.85,1192.54C1846.2,1192.54 1844.06,1213.15 1844.06,1238.54C1844.06,1263.93 1846.2,1284.54 1848.85,1284.54L1945.5,1284.54C1948.14,1284.54 1950.29,1263.93 1950.29,1238.54Z",
      "style": {
        fill: "rgb(246, 220, 185)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(1.77877,-1.02697,0.0581765,0.0335882,-425.293,1228.27)"
    }, [createVNode("rect", {
      "x": "495.52",
      "y": "1057.87",
      "width": "105.078",
      "height": "91",
      "style": {
        fill: "rgb(240, 218, 183)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.0369741,0.021347,4.72735e-17,0.492225,456.143,919.985)"
    }, [createVNode("rect", {
      "x": "1663.92",
      "y": "-407.511",
      "width": "143.183",
      "height": "118.292",
      "style": {
        fill: "rgb(240, 218, 183)"
      }
    }, null)])]), createVNode("g", {
      "transform": "matrix(0.750082,0,0,0.750082,163.491,309.191)"
    }, [createVNode("g", {
      "transform": "matrix(1.75943,-1.01581,1.75879e-16,0.632893,-2721.54,1876.43)"
    }, [createVNode("rect", {
      "x": "1844.06",
      "y": "1192.54",
      "width": "106.232",
      "height": "92",
      "style": {
        fill: "rgb(196, 173, 142)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.290956,-0.167984,2.90849e-17,0.104661,69.4195,919.311)"
    }, [createVNode("path", {
      "d": "M1950.29,1238.54C1950.29,1213.15 1944.73,1192.54 1937.88,1192.54L1856.47,1192.54C1849.62,1192.54 1844.06,1213.15 1844.06,1238.54C1844.06,1263.93 1849.62,1284.54 1856.47,1284.54L1937.88,1284.54C1944.73,1284.54 1950.29,1263.93 1950.29,1238.54Z",
      "style": {
        fill: "rgb(132, 97, 51)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.262716,-0.151679,8.27418e-18,0.0364999,121.496,970.53)"
    }, [createVNode("path", {
      "d": "M1950.29,1238.54C1950.29,1213.15 1948.14,1192.54 1945.5,1192.54L1848.85,1192.54C1846.2,1192.54 1844.06,1213.15 1844.06,1238.54C1844.06,1263.93 1846.2,1284.54 1848.85,1284.54L1945.5,1284.54C1948.14,1284.54 1950.29,1263.93 1950.29,1238.54Z",
      "style": {
        fill: "rgb(246, 220, 185)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(1.77877,-1.02697,0.0581765,0.0335882,-425.293,1228.27)"
    }, [createVNode("rect", {
      "x": "495.52",
      "y": "1057.87",
      "width": "105.078",
      "height": "91",
      "style": {
        fill: "rgb(240, 218, 183)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.0369741,0.021347,4.72735e-17,0.492225,456.143,919.985)"
    }, [createVNode("rect", {
      "x": "1663.92",
      "y": "-407.511",
      "width": "143.183",
      "height": "118.292",
      "style": {
        fill: "rgb(240, 218, 183)"
      }
    }, null)])]), createVNode("g", {
      "transform": "matrix(0.750082,0,0,0.750082,163.491,263.931)"
    }, [createVNode("g", {
      "transform": "matrix(1.75943,-1.01581,1.75879e-16,0.632893,-2721.54,1876.43)"
    }, [createVNode("rect", {
      "x": "1844.06",
      "y": "1192.54",
      "width": "106.232",
      "height": "92",
      "style": {
        fill: "rgb(196, 173, 142)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.290956,-0.167984,2.90849e-17,0.104661,69.4195,919.311)"
    }, [createVNode("path", {
      "d": "M1950.29,1238.54C1950.29,1213.15 1944.73,1192.54 1937.88,1192.54L1856.47,1192.54C1849.62,1192.54 1844.06,1213.15 1844.06,1238.54C1844.06,1263.93 1849.62,1284.54 1856.47,1284.54L1937.88,1284.54C1944.73,1284.54 1950.29,1263.93 1950.29,1238.54Z",
      "style": {
        fill: "rgb(132, 97, 51)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.262716,-0.151679,8.27418e-18,0.0364999,121.496,970.53)"
    }, [createVNode("path", {
      "d": "M1950.29,1238.54C1950.29,1213.15 1948.14,1192.54 1945.5,1192.54L1848.85,1192.54C1846.2,1192.54 1844.06,1213.15 1844.06,1238.54C1844.06,1263.93 1846.2,1284.54 1848.85,1284.54L1945.5,1284.54C1948.14,1284.54 1950.29,1263.93 1950.29,1238.54Z",
      "style": {
        fill: "rgb(246, 220, 185)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(1.77877,-1.02697,0.0581765,0.0335882,-425.293,1228.27)"
    }, [createVNode("rect", {
      "x": "495.52",
      "y": "1057.87",
      "width": "105.078",
      "height": "91",
      "style": {
        fill: "rgb(240, 218, 183)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.0369741,0.021347,4.72735e-17,0.492225,456.143,919.985)"
    }, [createVNode("rect", {
      "x": "1663.92",
      "y": "-407.511",
      "width": "143.183",
      "height": "118.292",
      "style": {
        fill: "rgb(240, 218, 183)"
      }
    }, null)])]), createVNode("path", {
      "d": "M555.753,832.474L555.753,921.408L630.693,878.141L630.693,789.207L555.753,832.474Z",
      "style": {
        fillOpacity: 0.1
      }
    }, null), createVNode("g", {
      "transform": "matrix(0.750082,0,0,0.750082,236.431,272.852)"
    }, [createVNode("g", {
      "transform": "matrix(1.64553,-0.950049,1.14552,0.661368,-1606.78,467.933)"
    }, [createVNode("rect", {
      "x": "495.52",
      "y": "1057.87",
      "width": "105.078",
      "height": "91",
      "style": {
        fill: "rgb(253, 243, 228)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(1.54477,-0.891873,1.05847,0.611108,-1456.84,490.734)"
    }, [createVNode("rect", {
      "x": "495.52",
      "y": "1057.87",
      "width": "105.078",
      "height": "91",
      "style": {
        fill: "rgb(132, 97, 51)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(1.27607,-0.736739,0.751435,0.433841,-970.952,617.519)"
    }, [createVNode("rect", {
      "x": "495.52",
      "y": "1057.87",
      "width": "105.078",
      "height": "91",
      "style": {
        fill: "rgb(240, 218, 183)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(1.62765,-0.939723,1.42156e-16,0.5,-2476.81,1893.62)"
    }, [createVNode("rect", {
      "x": "1844.06",
      "y": "1192.54",
      "width": "106.232",
      "height": "92",
      "style": {
        fill: "rgb(196, 173, 142)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(1.62765,-0.939723,1.42156e-16,0.5,-2476.81,1893.62)"
    }, [createVNode("rect", {
      "x": "1844.06",
      "y": "1192.54",
      "width": "106.232",
      "height": "92",
      "style": {
        fill: "rgb(196, 173, 142)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.728038,0.420333,3.52595e-17,0.377589,-790.978,151.274)"
    }, [createVNode("rect", {
      "x": "1663.92",
      "y": "-407.511",
      "width": "143.183",
      "height": "118.292",
      "style": {
        fill: "rgb(240, 218, 183)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(1.75943,-1.01581,1.75879e-16,0.632893,-2726.83,1873.38)"
    }, [createVNode("rect", {
      "x": "1844.06",
      "y": "1192.54",
      "width": "106.232",
      "height": "92",
      "style": {
        fill: "rgb(196, 173, 142)"
      }
    }, null)]), createVNode("g", null, [createVNode("g", {
      "transform": "matrix(1.75943,-1.01581,1.75879e-16,0.632893,-2721.54,1876.43)"
    }, [createVNode("rect", {
      "x": "1844.06",
      "y": "1192.54",
      "width": "106.232",
      "height": "92",
      "style": {
        fill: "rgb(196, 173, 142)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.290956,-0.167984,2.90849e-17,0.104661,69.4195,919.311)"
    }, [createVNode("path", {
      "d": "M1950.29,1238.54C1950.29,1213.15 1944.73,1192.54 1937.88,1192.54L1856.47,1192.54C1849.62,1192.54 1844.06,1213.15 1844.06,1238.54C1844.06,1263.93 1849.62,1284.54 1856.47,1284.54L1937.88,1284.54C1944.73,1284.54 1950.29,1263.93 1950.29,1238.54Z",
      "style": {
        fill: "rgb(132, 97, 51)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.262716,-0.151679,8.27418e-18,0.0364999,121.496,970.53)"
    }, [createVNode("path", {
      "d": "M1950.29,1238.54C1950.29,1213.15 1948.14,1192.54 1945.5,1192.54L1848.85,1192.54C1846.2,1192.54 1844.06,1213.15 1844.06,1238.54C1844.06,1263.93 1846.2,1284.54 1848.85,1284.54L1945.5,1284.54C1948.14,1284.54 1950.29,1263.93 1950.29,1238.54Z",
      "style": {
        fill: "rgb(246, 220, 185)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(1.77877,-1.02697,0.0581765,0.0335882,-425.293,1228.27)"
    }, [createVNode("rect", {
      "x": "495.52",
      "y": "1057.87",
      "width": "105.078",
      "height": "91",
      "style": {
        fill: "rgb(240, 218, 183)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.0369741,0.021347,4.72735e-17,0.492225,456.143,919.985)"
    }, [createVNode("rect", {
      "x": "1663.92",
      "y": "-407.511",
      "width": "143.183",
      "height": "118.292",
      "style": {
        fill: "rgb(240, 218, 183)"
      }
    }, null)])])]), createVNode("g", {
      "transform": "matrix(1.62765,-0.939723,4.80984e-17,0.173913,-2468.81,2307.87)"
    }, [createVNode("rect", {
      "x": "1844.06",
      "y": "1192.54",
      "width": "106.232",
      "height": "92",
      "style": {
        fill: "rgb(196, 173, 142)"
      }
    }, null)])]), createVNode("g", null, [createVNode("g", {
      "transform": "matrix(0.479077,0.276595,-0.564376,0.325843,598.357,-129.986)"
    }, [createVNode("path", {
      "d": "M1776.14,1326C1776.14,1321.19 1772.15,1317.28 1767.24,1317.28L1684.37,1317.28C1679.46,1317.28 1675.47,1321.19 1675.47,1326L1675.47,1395.75C1675.47,1400.56 1679.46,1404.46 1684.37,1404.46L1767.24,1404.46C1772.15,1404.46 1776.14,1400.56 1776.14,1395.75L1776.14,1326Z",
      "style": {
        fill: "white"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(2.61622,0,0,2.61622,-2305.73,162.161)"
    }, [createVNode("g", {
      "transform": "matrix(1.09915,-0.634597,1.26919,0.73277,-299.167,-62.4615)"
    }, [createVNode("ellipse", {
      "cx": "412.719",
      "cy": "770.575",
      "rx": "6.303",
      "ry": "5.459",
      "style": {
        fill: "rgb(255, 125, 0)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.238212,-0.137532,0.178659,0.103149,875.064,207.93)"
    }, [createVNode("text", {
      "x": "413.474px",
      "y": "892.067px",
      "style": {
        fontFamily: "NunitoSans-Bold, Nunito Sans",
        fontWeight: 700,
        fontSize: 41.569,
        fill: "white"
      }
    }, [createTextVNode("?")])])])])])])])]);
  }
});

// node_modules/@arco-design/web-vue/es/result/500.js
var ResultServerError = defineComponent({
  name: "ResultServerError",
  render() {
    return createVNode("svg", {
      "width": "100%",
      "height": "100%",
      "viewBox": "0 0 213 213",
      "style": {
        fillRule: "evenodd",
        clipRule: "evenodd",
        strokeLinejoin: "round",
        strokeMiterlimit: 2
      }
    }, [createVNode("g", {
      "transform": "matrix(1,0,0,1,-483.054,-445.448)"
    }, [createVNode("g", null, [createVNode("g", {
      "transform": "matrix(1,0,0,1,-463.699,-87.5516)"
    }, [createVNode("circle", {
      "cx": "1053.23",
      "cy": "639.477",
      "r": "106.477",
      "style": {
        fill: "rgb(235, 238, 246)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.384532,-0.222009,0.444019,0.256354,-0.569781,260.021)"
    }, [createVNode("path", {
      "d": "M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z",
      "style": {
        fillOpacity: 0.1
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.384532,-0.222009,0.444019,0.256354,-0.569781,218.845)"
    }, [createVNode("path", {
      "d": "M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z",
      "style": {
        fill: "rgb(64, 128, 255)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.361496,-0.20871,0.41742,0.240997,34.7805,238.807)"
    }, [createVNode("path", {
      "d": "M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z",
      "style": {
        fill: "rgb(0, 85, 255)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.341853,-0.197369,0.394738,0.227902,64.9247,257.804)"
    }, [createVNode("path", {
      "d": "M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z",
      "style": {
        fill: "rgb(29, 105, 255)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.428916,0,0,0.428916,19.0588,329.956)"
    }, [createVNode("clipPath", {
      "id": "_clip1"
    }, [createVNode("path", {
      "d": "M1461.07,528.445C1461.07,530.876 1459.6,533.196 1456.6,534.928L1342.04,601.072C1335.41,604.896 1323.83,604.415 1316.18,600L1205.33,536C1201.14,533.585 1199,530.489 1199,527.555L1199,559.555C1199,562.489 1201.14,565.585 1205.33,568L1316.18,632C1323.83,636.415 1335.41,636.896 1342.04,633.072L1456.6,566.928C1459.6,565.196 1461.07,562.876 1461.07,560.445L1461.07,528.445Z"
    }, null)]), createVNode("g", {
      "clipPath": "url(#_clip1)"
    }, [createVNode("g", {
      "transform": "matrix(2.33146,-0,-0,2.33146,1081.79,269.266)"
    }, [createVNode("use", {
      "href": "#_Image2",
      "x": "50.54",
      "y": "112.301",
      "width": "112.406px",
      "height": "46.365px",
      "transform": "matrix(0.99474,0,0,0.98649,0,0)"
    }, null)])])]), createVNode("g", {
      "transform": "matrix(0.347769,0.200785,3.44852e-18,0.545466,52.0929,265.448)"
    }, [createVNode("path", {
      "d": "M1480.33,34.813C1480.33,34.162 1479.7,33.634 1478.94,33.634L1396.27,33.634C1395.5,33.634 1394.88,34.162 1394.88,34.813C1394.88,35.464 1395.5,35.993 1396.27,35.993L1478.94,35.993C1479.7,35.993 1480.33,35.464 1480.33,34.813Z",
      "style": {
        fill: "white"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.347769,0.200785,3.44852e-18,0.545466,52.0929,268.45)"
    }, [createVNode("path", {
      "d": "M1480.33,34.813C1480.33,34.162 1479.7,33.634 1478.94,33.634L1396.27,33.634C1395.5,33.634 1394.88,34.162 1394.88,34.813C1394.88,35.464 1395.5,35.993 1396.27,35.993L1478.94,35.993C1479.7,35.993 1480.33,35.464 1480.33,34.813Z",
      "style": {
        fill: "white"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.347769,0.200785,3.44852e-18,0.545466,52.0929,271.452)"
    }, [createVNode("path", {
      "d": "M1480.33,34.813C1480.33,34.162 1479.7,33.634 1478.94,33.634L1396.27,33.634C1395.5,33.634 1394.88,34.162 1394.88,34.813C1394.88,35.464 1395.5,35.993 1396.27,35.993L1478.94,35.993C1479.7,35.993 1480.33,35.464 1480.33,34.813Z",
      "style": {
        fill: "white"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.360289,-0.208013,-4.39887e-18,0.576941,37.5847,124.262)"
    }, [createVNode("rect", {
      "x": "1621.2",
      "y": "1370.57",
      "width": "57.735",
      "height": "5.947",
      "style": {
        fill: "rgb(106, 161, 255)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,307.505,420.796)"
    }, [createVNode("ellipse", {
      "cx": "1566.31",
      "cy": "1372.3",
      "rx": "4",
      "ry": "3.464",
      "style": {
        fill: "rgb(64, 128, 255)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,310.507,419.062)"
    }, [createVNode("ellipse", {
      "cx": "1566.31",
      "cy": "1372.3",
      "rx": "4",
      "ry": "3.464",
      "style": {
        fill: "rgb(64, 128, 255)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,313.509,417.329)"
    }, [createVNode("ellipse", {
      "cx": "1566.31",
      "cy": "1372.3",
      "rx": "4",
      "ry": "3.464",
      "style": {
        fill: "white"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,316.512,415.595)"
    }, [createVNode("ellipse", {
      "cx": "1566.31",
      "cy": "1372.3",
      "rx": "4",
      "ry": "3.464",
      "style": {
        fill: "rgb(64, 128, 255)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,319.514,413.862)"
    }, [createVNode("ellipse", {
      "cx": "1566.31",
      "cy": "1372.3",
      "rx": "4",
      "ry": "3.464",
      "style": {
        fill: "rgb(64, 128, 255)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.384532,-0.222009,0.444019,0.256354,-0.569781,196.542)"
    }, [createVNode("clipPath", {
      "id": "_clip3"
    }, [createVNode("path", {
      "d": "M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z"
    }, null)]), createVNode("g", {
      "clipPath": "url(#_clip3)"
    }, [createVNode("g", {
      "transform": "matrix(1.30028,1.12608,-2.25216,1.95042,68.2716,1030.07)"
    }, [createVNode("use", {
      "href": "#_Image4",
      "x": "50.54",
      "y": "56.312",
      "width": "112.406px",
      "height": "64.897px",
      "transform": "matrix(0.99474,0,0,0.998422,0,0)"
    }, null)])])]), createVNode("g", {
      "transform": "matrix(0.361496,-0.20871,0.41742,0.240997,34.7805,216.764)"
    }, [createVNode("path", {
      "d": "M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z",
      "style": {
        fill: "rgb(0, 85, 255)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.341853,-0.197369,0.394738,0.227902,64.9247,235.762)"
    }, [createVNode("path", {
      "d": "M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z",
      "style": {
        fill: "rgb(29, 105, 255)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.428916,0,0,0.428916,19.0588,307.652)"
    }, [createVNode("clipPath", {
      "id": "_clip5"
    }, [createVNode("path", {
      "d": "M1461.07,528.445C1461.07,530.876 1459.6,533.196 1456.6,534.928L1342.04,601.072C1335.41,604.896 1323.83,604.415 1316.18,600L1205.33,536C1201.14,533.585 1199,530.489 1199,527.555L1199,559.555C1199,562.489 1201.14,565.585 1205.33,568L1316.18,632C1323.83,636.415 1335.41,636.896 1342.04,633.072L1456.6,566.928C1459.6,565.196 1461.07,562.876 1461.07,560.445L1461.07,528.445Z"
    }, null)]), createVNode("g", {
      "clipPath": "url(#_clip5)"
    }, [createVNode("g", {
      "transform": "matrix(2.33146,-0,-0,2.33146,1081.79,321.266)"
    }, [createVNode("use", {
      "href": "#_Image2",
      "x": "50.54",
      "y": "89.692",
      "width": "112.406px",
      "height": "46.365px",
      "transform": "matrix(0.99474,0,0,0.98649,0,0)"
    }, null)])])]), createVNode("g", {
      "transform": "matrix(0.347769,0.200785,3.44852e-18,0.545466,52.0929,243.144)"
    }, [createVNode("path", {
      "d": "M1480.33,34.813C1480.33,34.162 1479.7,33.634 1478.94,33.634L1396.27,33.634C1395.5,33.634 1394.88,34.162 1394.88,34.813C1394.88,35.464 1395.5,35.993 1396.27,35.993L1478.94,35.993C1479.7,35.993 1480.33,35.464 1480.33,34.813Z",
      "style": {
        fill: "white"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.347769,0.200785,3.44852e-18,0.545466,52.0929,246.146)"
    }, [createVNode("path", {
      "d": "M1480.33,34.813C1480.33,34.162 1479.7,33.634 1478.94,33.634L1396.27,33.634C1395.5,33.634 1394.88,34.162 1394.88,34.813C1394.88,35.464 1395.5,35.993 1396.27,35.993L1478.94,35.993C1479.7,35.993 1480.33,35.464 1480.33,34.813Z",
      "style": {
        fill: "white"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.347769,0.200785,3.44852e-18,0.545466,52.0929,249.149)"
    }, [createVNode("path", {
      "d": "M1480.33,34.813C1480.33,34.162 1479.7,33.634 1478.94,33.634L1396.27,33.634C1395.5,33.634 1394.88,34.162 1394.88,34.813C1394.88,35.464 1395.5,35.993 1396.27,35.993L1478.94,35.993C1479.7,35.993 1480.33,35.464 1480.33,34.813Z",
      "style": {
        fill: "white"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.360289,-0.208013,-4.39887e-18,0.576941,37.5847,101.958)"
    }, [createVNode("rect", {
      "x": "1621.2",
      "y": "1370.57",
      "width": "57.735",
      "height": "5.947",
      "style": {
        fill: "rgb(106, 161, 255)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,307.505,398.492)"
    }, [createVNode("ellipse", {
      "cx": "1566.31",
      "cy": "1372.3",
      "rx": "4",
      "ry": "3.464",
      "style": {
        fill: "rgb(64, 128, 255)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,310.507,396.759)"
    }, [createVNode("ellipse", {
      "cx": "1566.31",
      "cy": "1372.3",
      "rx": "4",
      "ry": "3.464",
      "style": {
        fill: "white"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,313.509,395.025)"
    }, [createVNode("ellipse", {
      "cx": "1566.31",
      "cy": "1372.3",
      "rx": "4",
      "ry": "3.464",
      "style": {
        fill: "rgb(64, 128, 255)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,316.512,393.292)"
    }, [createVNode("ellipse", {
      "cx": "1566.31",
      "cy": "1372.3",
      "rx": "4",
      "ry": "3.464",
      "style": {
        fill: "rgb(64, 128, 255)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,319.514,391.558)"
    }, [createVNode("ellipse", {
      "cx": "1566.31",
      "cy": "1372.3",
      "rx": "4",
      "ry": "3.464",
      "style": {
        fill: "rgb(64, 128, 255)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.384532,-0.222009,0.444019,0.256354,-0.569781,171.832)"
    }, [createVNode("clipPath", {
      "id": "_clip6"
    }, [createVNode("path", {
      "d": "M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z"
    }, null)]), createVNode("g", {
      "clipPath": "url(#_clip6)"
    }, [createVNode("g", {
      "transform": "matrix(1.30028,1.12608,-2.25216,1.95042,12.6215,1078.27)"
    }, [createVNode("use", {
      "href": "#_Image7",
      "x": "50.54",
      "y": "31.563",
      "width": "112.406px",
      "height": "64.897px",
      "transform": "matrix(0.99474,0,0,0.998422,0,0)"
    }, null)])])]), createVNode("g", {
      "transform": "matrix(0.361496,-0.20871,0.41742,0.240997,34.7805,192.055)"
    }, [createVNode("path", {
      "d": "M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z",
      "style": {
        fill: "rgb(0, 85, 255)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.341853,-0.197369,0.394738,0.227902,64.9247,211.052)"
    }, [createVNode("path", {
      "d": "M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z",
      "style": {
        fill: "rgb(29, 105, 255)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.428916,0,0,0.428916,19.0588,282.943)"
    }, [createVNode("clipPath", {
      "id": "_clip8"
    }, [createVNode("path", {
      "d": "M1461.07,528.445C1461.07,530.876 1459.6,533.196 1456.6,534.928L1342.04,601.072C1335.41,604.896 1323.83,604.415 1316.18,600L1205.33,536C1201.14,533.585 1199,530.489 1199,527.555L1199,559.555C1199,562.489 1201.14,565.585 1205.33,568L1316.18,632C1323.83,636.415 1335.41,636.896 1342.04,633.072L1456.6,566.928C1459.6,565.196 1461.07,562.876 1461.07,560.445L1461.07,528.445Z"
    }, null)]), createVNode("g", {
      "clipPath": "url(#_clip8)"
    }, [createVNode("g", {
      "transform": "matrix(2.33146,-0,-0,2.33146,1081.79,378.876)"
    }, [createVNode("use", {
      "href": "#_Image2",
      "x": "50.54",
      "y": "64.644",
      "width": "112.406px",
      "height": "46.365px",
      "transform": "matrix(0.99474,0,0,0.98649,0,0)"
    }, null)])])]), createVNode("g", {
      "transform": "matrix(0.347769,0.200785,3.44852e-18,0.545466,52.0929,218.434)"
    }, [createVNode("path", {
      "d": "M1480.33,34.813C1480.33,34.162 1479.7,33.634 1478.94,33.634L1396.27,33.634C1395.5,33.634 1394.88,34.162 1394.88,34.813C1394.88,35.464 1395.5,35.993 1396.27,35.993L1478.94,35.993C1479.7,35.993 1480.33,35.464 1480.33,34.813Z",
      "style": {
        fill: "white"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.347769,0.200785,3.44852e-18,0.545466,52.0929,221.437)"
    }, [createVNode("path", {
      "d": "M1480.33,34.813C1480.33,34.162 1479.7,33.634 1478.94,33.634L1396.27,33.634C1395.5,33.634 1394.88,34.162 1394.88,34.813C1394.88,35.464 1395.5,35.993 1396.27,35.993L1478.94,35.993C1479.7,35.993 1480.33,35.464 1480.33,34.813Z",
      "style": {
        fill: "white"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.347769,0.200785,3.44852e-18,0.545466,52.0929,224.439)"
    }, [createVNode("path", {
      "d": "M1480.33,34.813C1480.33,34.162 1479.7,33.634 1478.94,33.634L1396.27,33.634C1395.5,33.634 1394.88,34.162 1394.88,34.813C1394.88,35.464 1395.5,35.993 1396.27,35.993L1478.94,35.993C1479.7,35.993 1480.33,35.464 1480.33,34.813Z",
      "style": {
        fill: "white"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.360289,-0.208013,-4.39887e-18,0.576941,37.5847,77.2484)"
    }, [createVNode("rect", {
      "x": "1621.2",
      "y": "1370.57",
      "width": "57.735",
      "height": "5.947",
      "style": {
        fill: "rgb(106, 161, 255)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,307.505,373.782)"
    }, [createVNode("ellipse", {
      "cx": "1566.31",
      "cy": "1372.3",
      "rx": "4",
      "ry": "3.464",
      "style": {
        fill: "white"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,310.507,372.049)"
    }, [createVNode("ellipse", {
      "cx": "1566.31",
      "cy": "1372.3",
      "rx": "4",
      "ry": "3.464",
      "style": {
        fill: "rgb(64, 128, 255)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,313.509,370.316)"
    }, [createVNode("ellipse", {
      "cx": "1566.31",
      "cy": "1372.3",
      "rx": "4",
      "ry": "3.464",
      "style": {
        fill: "rgb(64, 128, 255)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,316.512,368.582)"
    }, [createVNode("ellipse", {
      "cx": "1566.31",
      "cy": "1372.3",
      "rx": "4",
      "ry": "3.464",
      "style": {
        fill: "rgb(64, 128, 255)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.185726,-0.107229,-1.84168e-18,0.247635,319.514,366.849)"
    }, [createVNode("ellipse", {
      "cx": "1566.31",
      "cy": "1372.3",
      "rx": "4",
      "ry": "3.464",
      "style": {
        fill: "rgb(64, 128, 255)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.365442,-0.210988,0.421976,0.243628,28.7259,185.45)"
    }, [createVNode("clipPath", {
      "id": "_clip9"
    }, [createVNode("path", {
      "d": "M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z"
    }, null)]), createVNode("g", {
      "clipPath": "url(#_clip9)"
    }, [createVNode("g", {
      "transform": "matrix(1.36821,1.1849,-2.36981,2.05231,5.46929,1071.93)"
    }, [createVNode("use", {
      "href": "#_Image10",
      "x": "53.151",
      "y": "30.14",
      "width": "106.825px",
      "height": "61.676px",
      "transform": "matrix(0.998367,0,0,0.994768,0,0)"
    }, null)])])]), createVNode("g", {
      "transform": "matrix(0.365442,-0.210988,0.421976,0.243628,28.7259,183.729)"
    }, [createVNode("path", {
      "d": "M84.299,1269.38C84.299,1261.99 78.301,1256 70.913,1256L-56.874,1256C-64.261,1256 -70.259,1261.99 -70.259,1269.38L-70.259,1376.46C-70.259,1383.85 -64.261,1389.85 -56.874,1389.85L70.913,1389.85C78.301,1389.85 84.299,1383.85 84.299,1376.46L84.299,1269.38Z",
      "style": {
        fill: "url(#_Linear11)"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.407622,0,0,0.407622,47.38,278)"
    }, [createVNode("clipPath", {
      "id": "_clip12"
    }, [createVNode("path", {
      "d": "M1461.07,554.317C1461.07,556.747 1459.6,559.067 1456.6,560.8L1342.04,626.943C1335.41,630.767 1323.83,630.287 1316.18,625.871L1205.33,561.871C1201.14,559.456 1199,556.361 1199,553.426L1199,559.555C1199,562.489 1201.14,565.585 1205.33,568L1316.18,632C1323.83,636.415 1335.41,636.896 1342.04,633.072L1456.6,566.928C1459.6,565.196 1461.07,562.876 1461.07,560.445L1461.07,554.317Z"
    }, null)]), createVNode("g", {
      "clipPath": "url(#_clip12)"
    }, [createVNode("g", {
      "transform": "matrix(2.45325,-0,-0,2.45325,1068.82,410.793)"
    }, [createVNode("use", {
      "href": "#_Image13",
      "x": "53.151",
      "y": "58.978",
      "width": "106.825px",
      "height": "33.517px",
      "transform": "matrix(0.998367,0,0,0.985808,0,0)"
    }, null)])])]), createVNode("g", {
      "transform": "matrix(0.371452,-0.214458,2.38096e-17,0.495269,-19.3677,248.256)"
    }, [createVNode("clipPath", {
      "id": "_clip14"
    }, [createVNode("path", {
      "d": "M1776.14,1326C1776.14,1321.19 1772.23,1317.28 1767.42,1317.28L1684.19,1317.28C1679.38,1317.28 1675.47,1321.19 1675.47,1326L1675.47,1395.75C1675.47,1400.56 1679.38,1404.46 1684.19,1404.46L1767.42,1404.46C1772.23,1404.46 1776.14,1400.56 1776.14,1395.75L1776.14,1326Z"
    }, null)]), createVNode("g", {
      "clipPath": "url(#_clip14)"
    }, [createVNode("g", {
      "transform": "matrix(2.69214,1.16573,-1.29422e-16,2.0191,1352.59,983.841)"
    }, [createVNode("use", {
      "href": "#_Image15",
      "x": "121.882",
      "y": "76.034",
      "width": "37.393px",
      "height": "61.803px",
      "transform": "matrix(0.984021,0,0,0.996825,0,0)"
    }, null)])])]), createVNode("g", {
      "transform": "matrix(0.371452,-0.214458,2.38096e-17,0.495269,-15.0786,249.972)"
    }, [createVNode("path", {
      "d": "M1776.14,1326C1776.14,1321.19 1772.23,1317.28 1767.42,1317.28L1684.19,1317.28C1679.38,1317.28 1675.47,1321.19 1675.47,1326L1675.47,1395.75C1675.47,1400.56 1679.38,1404.46 1684.19,1404.46L1767.42,1404.46C1772.23,1404.46 1776.14,1400.56 1776.14,1395.75L1776.14,1326Z",
      "style": {
        fill: "white",
        stopOpacity: 0.9
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.220199,-0.127132,1.41145e-17,0.293599,339.708,327.53)"
    }, [createVNode("path", {
      "d": "M1306.5,1286.73C1307.09,1285.72 1308.6,1285.48 1310.36,1286.12C1312.13,1286.76 1313.84,1288.16 1314.73,1289.7C1326.44,1309.98 1355.4,1360.15 1363.73,1374.57C1364.33,1375.61 1364.49,1376.61 1364.18,1377.35C1363.87,1378.09 1363.11,1378.5 1362.07,1378.5C1346.41,1378.5 1288.17,1378.5 1264.07,1378.5C1262.42,1378.5 1260.37,1377.48 1258.9,1375.94C1257.44,1374.41 1256.88,1372.67 1257.5,1371.6C1268.1,1353.25 1296.8,1303.53 1306.5,1286.73Z",
      "style": {
        fill: "rgb(245, 63, 63) ;fill-opacity:0.9"
      }
    }, null)]), createVNode("g", {
      "transform": "matrix(0.254264,-0.1468,1.22235e-17,0.254264,329.57,364.144)"
    }, [createVNode("text", {
      "x": "1170.88px",
      "y": "1451.42px",
      "style": {
        fontFamily: "NunitoSans-Bold, Nunito Sans",
        fontWeight: 700,
        fontSize: 41.569,
        fill: "white",
        fillOpacity: 0.9
      }
    }, [createTextVNode("!")])])])]), createVNode("defs", null, [createVNode("image", {
      "id": "_Image2",
      "width": "113px",
      "height": "47px",
      "href": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHEAAAAvCAYAAADU+iVXAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABVUlEQVR4nO2aQRKCMAxFxUN4O+9/DNw4CoiTliZN8vPfQlm00ykvP3aQ5fFc11sjy/L+/nx8r3ffm7Fn845jz+aJa23XOJvfs9Zh7NBawv3YrSGtdbj+x10egkFzpRrNt+SSxMgbqkiZJCJDiQDoSmSfdYFJ3JD18GMmcXhDTHUzNZIIXhA1JIJDib0MptqiKbhKzHqQiAaT6IlSFVIiAJQIACUGpLfLhpfIw49Ml8T2v4/JTPySyIJQI3w7JTIYEp2fong3FXWJ3huqCEYSNUlYhZRoyaSCoEQAKHESlqF0kZj9NBgNJhEASgSAEgNx9WfCTmLxpygzYRIBmCORsTIlXxJZED/kk0h+KC1x9E2FKG86qEkMsh8/HG9A6SSGYqAIKDEinUIpUSDDYXiqxAw3JCNMIgDXJTIWYdBJIvukK2ynARit4XASUZ6izCScRFWKCH0BfLM84oTw1Z8AAAAASUVORK5CYII="
    }, null), createVNode("image", {
      "id": "_Image4",
      "width": "113px",
      "height": "65px",
      "href": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHEAAABBCAYAAADmBEt9AAAACXBIWXMAAA7EAAAOxAGVKw4bAAASeElEQVR4nN2d6ZbcNpKFL5cs9UN1W5bntWxr6XmsWTzLQ7mSJDA/gh/iApWyLalUy+AcnypVJkEAsd24EaQn/T8Yb9+XKknrOuk4pOM4tCyLpkkqpWpZJu170TzPKqVoWWZJUq3Sbx+m6VkX/wjjVW/gH7/sdZ5nTacc5lkqJT6rtWqaJtVaVUrRNE26XGbd3+9alkW1Vi3LrFKq/uvj/KrP4dUu/t3HWkupmuepWVspIcjrddc8z1qWWcdRTusLwc3z3Cz1OA5dLouOo+o4Dv3vv15e5Xm8ukX//eetTtOkdV20bWFVkrQsk+ZZOo74Xq3SNMVPqXextYal1lq1rrNqlfb90LrGXP/5/nW52Fez2B8/1FpPiSxLLLsUaV2lfZdKiZiHkHCtuFWPj/73cvpfLDQseNJxvB43++IX+cOvR5WkZQkBbdsh4uCySNtWWkxEuLVKx1HOuLecFjdp3/NnWiYKUbSuAXiOIwR8HIf+55/riz+jF73Anz7VWkq4RSkEI+m0Fun+ftflsra/r+usfY/fATVY3DzP2ratCe3Nm7UhWawv3KzO69PtllJetDBf5MJ++hRHWWu4QCkOm1h4HH2agJuVpHme2ufHUXS5zLpeQ1B8Ns9zu2ZdU3gAJdwxFh3zxjUv0cW+qAX9+KFWhMV/Urg6kCUWcxzpRvlsmno3ehwBVhDKcWRMZQ6uQ4D7HsgI1MrcDIT/koT5IhaC28T17fuudV0bWAmhTJ0QpN56ti1cq4MXSR1wiWv6+ChJ12ukGpJaunG5rJpnad9rm+NyWVRKgqiXQhQ8+yI87pEicDQIRApAg3US60gvPPYhbBceqYTH17DEo8VLSVqWTFGmKdKOZVm0LDKlqIaEQ+GeO798tpu/fV/qPE+nCwwLiwNVi1FhCaUJIFxbury7uxAiwrled0k6Dz6F78J2FgcBk2qs66J9T/QrpRt2MoH7RX6ZXuO/Py3Pcp5PftMffj0qdBeHF4AlXJwU4ETSGavUMSsAD1AlqYDHvut1P61y6QRPMg/g2bbSudnJvCNCgmsFQKEE8Z2p+1x6Hi72SW/47mPk6/u+txwNa4vfpw4hYi3Lok7AHBiHCfjArTr6ZE4Sfr+W+aVAqQgVpUCJJBQq1kas7FFxAqTLZdK//fx0wnySG/3LP2sl1uEKU4uX9r1Siu7uliYwhHwctR0y1zmz4gwO80gp3OM4dHe3NqIAy3R36kjX4yvVj31P4OR0HYJluPVOk/Qfv35/YX7XG/z4IVSVQ8d11lp1ucydsNxlLsukbQth4zLnWQ8sA85zWZYm7LCiiFEp7J6O477rOul6TU5VUpdHjgJmL4QDKiGxzmSP3OqJ8d+Tj/0uE//w61EBI57jSWldUk+hxWc9OR1Wk+4WYWNNaD2jlNKsxdMOEnZJ7dC3bTcFmZpQSimNzXHl81ok7tndvAOlW8KXvl9u+eiTAlyoIozuB4DhrAt/w6qkdL3kb1Jymli0xzSH/Vi153QcLqmJX0t6c70erTqyrusfKhPEggOjmGvqANAIxNZ10r//8rhW+WiTkTI4iCDuOGAZ+U8osXWddH+/twMn5iEIeFEswasRkroir49l4cDVhM/Bcshc44LwCkcKZD6tfW75JHN6jRJlQnld+NzzOB4vJfnmSd59rHWMTwEkFh3HeDBxDVaIwB1JjlxofhZCj0pG7bQ9508rIH+bJq6JU/eaYsybaczd3dJVRXCZpajVLhEMua2j5VueIeZxAqNXnlrrNwvzqy/+6VP1s+6Sdnpd/LAYxJ1lWbTv+2mpc8ekeOz5XJINkPEknbSABN/dIfFrniddr9uZm65tPudsGS4gLyqzX9ZTSgIq9iipoWfQKyGm1qyDxn2+DcV+1YU/faqVxbEZL8Iy3AURV0Z2Bgjv8aPW2iyJgbDcejk4YiCQnwEH6gpGuuHxknV5GAApe+rhjBIM0Zs362dJAwTM2uNzNWAnPQRtX1Py+qILEJ4kXS6Tfv89ER6D2ITLjEPpSWjiCL8DXvhezrO0eIhuJILNQ6IqUUqS2lJAfikQKWi01tq5enJBXKQn/SiK57LO3XrvDvdxZgfSAC+xbXvjat3K2a+fyZe42L/0RfI94sO+H11S7ptzwDFCbQcKHuTTitVZhR+g/x13u+/HGaPWJtBucwZOGNQXmddjl9cYr9fjjIlzQ6EolO9vjIHM4Yo65o6+L1CuK76j2b+SlvzhF959rBWEySY9r/IWBxeapJsxgs9gP9y6cHlj99q+9zwow8tRzIFr4l4jqHJkPOaAzOFzOnjy3z3ZZw73HJwRQM/PZZzLz5bwdH+/6e7ucirDnxeiP/shqPN63U1rMo5J6nI/YgiaD9IbUahX19mwI1dHp+6SRvDgBzIWbaHvIu7VB4dIHCwly09es8TF46JZH6AJl4i18H2KyMuS83tbpSvXuk4nKs70ybGBnwWe4XPx8sEf//7zVtd17YAKNJgjPrSNSjqCy5bBjBmx+FyUC5IxghyPM1w75nMIxF0v6yVmjqzQmJT7YaKYYdUJtCQ1ZaKjwNMPZ4ig+dwlxv6mdi2CJm0ZvYafnYcg1jNWSto/3r4v9ZZms/HRlTjKQ0ggMQcCXhPctiwZObr0+7iC8D0npEHCgBuGu0f+/ebN2oTh1ZFQjhAUwvBiMMriB+kpTwi1z1P9++wF0OSAB4HggpkDz+WKFF6uV2z3fljm5IgTM0ZjRqQ2ukKPDSzO3aa7orHhyGONI8FsR8wD8Prfus5dh/donX4PDjYtZ+q8ixecHUl6l/jIf8LYcOC33Dnu2lOQEEAqsKPymPchNnDBj/2yDnwmmnK9h2WEzLhWhifcnvDimm5B5xH0eFwZEah/lw2wMdryuX6sMKTVBnrl87E7oFZ1uagDHPZIDuzC2/eoF+57368z5pPUTDGMUaHhjdnPSNXhacbvO4BrBoNWQEthUQ7NXSNCcHHQYSnxtzjgZFxG7eU+6S5n0856WmJfaOXacKHTef/ZWJ4ERB4BYv0xN4IJ96fu4CC5Y/299W7b3pRx33cdx9GUwKszpFnpVQL8ZQpTT4XILvTLJWuRtVZdLuvpcY4GchAg3wnsQdf7fLJiZ7nucoleTvpViEfRbLurlKJ9P0R9zjcQ2l5PTcxDpIgaLjc/QFvRqlLKqWW90gSY6asBbNoJ5/QYcd3lMneQnYNIIAQhjkLoTAVK21+eQWrF5bI2yO9rZB8BpNxT8GwITExt3kuKpmcPJft+nCEj8QHnOU2TLpelU7JQdhR60gzHSWCPw4kvRNse6Cpb58NNhN/3+MXNp4lmpfk8uIxzjiyzWiCt63JuPONcBPjpVCSaoJhrOQ+otPgUrj3dZ+ynnGWp0lkTQMsbo6KaklYFmYBFuXsOoKS2/rT+uSl74Ae8SQhynjPnDYusZwpVTmFmTJXCC4T7zHXFd0u754zv9aQ6hJDawE1i0nrGtNHNzp3Gx3dDMwJKT6ebqJ2WpSstLb5SPkLYcbhrs66Ma7W7p1sdG5+mqeV2d3f5eFsp0UcKp5nxWuf9lnbYXjCutbbQwz7dK3C4t/7tqBdwlLhj7lgkUheUi/RlXRMLtNDkQuDQ2EwejE6Txh0Gyrpe9xYj0MrrdWtaFDeSKcbcDrBPvp2P7BXBlQPrgtlY16nrYNu2ox22K1Ek7rV5m5hD5uZAxulmM16lN7hcLlpXd9mJavEarBe37fGbGOasUn/mx2mpkPJHM6DoWCgNaHEPSZoxSQIrpr8sKcTQjocVgiAFKPMEyPnb3y7NbXiciU7qkTlJITT/PmM5STaQNzn4Oo6qbStdyoOg2XgSErWzOD+MzHOnM/bXbn2wOl4uC1DUK7S7PI/5/MTL8W/iIvdGwblH/7SXt3hSgMjcc/7twzQFsKhnHOu7zxws3mIWvM/kONRATghy7jbM4XBAaDNaz+/ExQQ2vav0DjMs7+5ubRZfStWbN+tpFRmTwhVu56GGJUfYANpHQTs9TD1jYW3MET2trCNqolCEEXe3bX8Q23wsy3KS9tNZ2chqTICsuB8MkbNEefY6UfCUjA09oeR+TjPBRDhMJj/yZHesQLjvHvnDyHcOcz+525HKg3DgQBB23BNSvafFXPHCivdWe/T0BCKBkEDO5wfrMZ690k7iBLfv2+/Nnih3ZZqVzV6eQ2ca1VOfyAVlpYPuAXf6w69HRTDOSUJ1OUODK4VJyUCftUQqERRnnTz3p47CctON4Ipo9/BnIjzPQ3mc2+WQ6d9hH5DiHJz37XDIsf5UNhTTFQY35uuE4QqFedgoxVhX6f4+FS7z2KPjSsdaLGSF9Afc6Tho+B0tKm6Q7A6jTzN6rXRqzVGVL9gZDRTBm4wkDe0cbm09COO7zsZwyM6lIhj3QOMenT1yxiisI1MtUD50JHO612B/sz04RGbg/UCu3G6lnytJfVaIDIhxKUtPvmkHFH6QuLVbLfmOEhGCF0bd/2MJY/u+Wyqbj8/yIFAsn+9WYXp0b27NiQbVXR/INSx726L+xx5w3azLH/Rx78Y8biBO03nnwB/VFP9UiFI+N4/b+1wNzA8AV0Tux8K8y8sJdCeV4T1HlwPmwn07F+oCxI17DB3LQAyvdXa51/A01Gjld3fe/9P3lUaumUqO1/E+G+ZBuM6fEo+lv9Zw/JeEyHj7vtSE6KW5tlhYDwhwB+5SvGDsKYs3XAVK7J+7cMDi7i0P0d9Tk4/Lcf3Y+uCIGqGS81FZGEEE8SnnDJxwf7+1RN2TeI+3faGgXzfM0RiyvqRb/IuEyPAne/0gvGbn8XAM0qNFjMjSEaWDFag7Ns3fYo5wYR5fODzosh6mZ58se0iXP3VKABd8qyls7FCgQoM38aIwrvXubhXPjYT1hiAvl+WrWhe/SoiMdx9r3ba9FYcdsPATq0MLSV04SEeCoE93yxyAIzxHjMsy6XpNAQaAWdr3cYNYqb/ACEXyZzWSe+1flcKAfPBWjFt9SCPwGoGUdyIg/K99Q8c3CVFK4DPmiuNz8xRzqbGND7k4MMFyvJHJEWBel+4JZcLaoarI/WLusWUkrdJDgIMdVybAjyNp0iLQqgvM+2K5npqkM1ff+qDNNwuRwZNQkiO51OQR+IyFUM+r+mfk+2Ymb5kYXVm3MQMitxDo+HQVa/Jiredmjh79+35fqvUoknce4GkgSEopj/as/6MJkfH2faluhYAF75qT+ke66TDzxByXOLpD4qbnpWPq4vkWvUDjsxOOHhGw9w8FNTbdtGLefeO4AKtjnW6hxHvW+tiPhD+6EBkgWafi0NxMqLMxV1JzO/nSvRDMSGUx3NW5sBwZ8293Y2Mvq6PbsbKQCHlurNDIEI05rOefTliU8n3eTPXdhCipPXQDqPEOs/FgsB7i3mGMgLfCe46aaDIZfY9rntLwaJv0UHnGFAIheC+QP3rnDE78VKsNEoOdTqz1+76Q4bsKkfHjh3z8jYP2eIF78u4zb8N482bV/X0++CllY7ET0t7z6k1bWA6oOL4TPz2mpkt/yBG7O7/VsXeLbXqqF/w9iRAZvCk4qyL9YUk9HUZMcsAwHhYgyHNCrMU5Tql3dQjM06Jb77FhjZ97xM4JArzIND3tO1OfVIgM3tntVsWIikc0JXkJa3y2A+33vM+tydkbKd359Rrm+rlccryPs0kjIxPr7b2HpCd/KdGzCFGKlCRLTA9fTuSVhs/1nYIo/ZAdaY6v9fL6IDVLYh41O3JcrIoOB2I3aQgx1K99ited3BrPJkSGv0k/QU1SXaBIJwPGOOYpRyLTqfs+sdObgD1l8WqL1yoldUwQXgHhS8//xsVnFyLjxw+13mJn/O1Okk5O9eGrouuNup2/+MgRqZeaHAzxXQTtL2tAOUh7njru/dG40QHyPOO3D9ME6EGAPUUWLvH337cmJBJorwyEi0xrTlaIZuVDNCtfr4fot6EXKB9Xyw6+7FxLxXopApRekCX6ePexVtzc+MZhSc1KnEgAzUpZb/SHVp3IdvLZLXPsOhgrM4/Bc36P8eIW5IP/9wWW5+S354hSz6z4+25IJ2BzmCuuiZ+AFn9x4EiKv5QX1N4aL3ZhPqDwvN/H63vENqe6kgbrCXAHObcq+k504w1eovX5eNGL8/GPX4KJBpXi4oh/lLrGd7tRdIUsx7L89SjEv/EFuS9deIxXsUgf8LF9p3a+o3TsO3UOk1eQSLQY5iulqXpIz58yfOl4VYv14awPeZ0XpEnE+Y7Hwuw4ry33k16f8BivctE+/H8/5IBkfLmfv2Wf3NIF/ZKBy5+NV7twH2OVRPJH1fp3vsG0IMTnevn6Y47/AxX1K5XSf237AAAAAElFTkSuQmCC"
    }, null), createVNode("image", {
      "id": "_Image7",
      "width": "113px",
      "height": "65px",
      "href": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHEAAABBCAYAAADmBEt9AAAACXBIWXMAAA7EAAAOxAGVKw4bAAAMrklEQVR4nOVdW2LbNhAcUD5Xkl4scXqxpr0XiX7AQwwGu7Rj2RLV7o8lknjtc3YBygX/Afr2XOu2bQCAZVkAALVWlFJQClAr9mvLUrBt7R4A/Hp++fDA9NAL+PpjqwBQSkF9kVQkOBIFx2vLUlDr4wvyYSf/7blJghanglFLc9q2DZfLgnXddqvl9X/+vDwkPx5u0l9/bFWtTf+q8Hidwt22DaWUXYCtj3H5bPNolvkwk2Xc05hHcjep1yk8Fy4tksSmfH5ZCv768RjCPP0k3W3ysxKFtSwLaq0vAGYZXC2vtefHmKn9Lkv7TKt+BKs89QT/+FnrtnVECYwghuRukfcpOL1N4fgzrZ/umgHsbvfsVnnKiX35vlYFHUpMJQAMwMQtqpSCdV3x9HTBujbXSUUAZmVQa876A84ZL081oS/f1+qAQwGLusx+vz/rSNUtbk5FZvccpSuOdmut+PvnchrenWIidJvAKJRIaPpZY6B+Z/6nAlBrisjjp4KezKWfRZB3n8QfP2tlKuBWAHS0SMZqOFSAwu+R1QA9sVdhupA5riNapUjY946Xdxv823OtHnfIFGp+lv+pZSiaZH/e1gVIlmseCXRBk1SBFO26i6fA7xUvbz4oS2UABoaua699ZjFK25CJ/NzajukBgMmNerzUNuyD1Rw2U6XR/ihAzhu4D/C56YDM+QAMDMqScrUiYMzjiDjVmjT2aTLvlhtZLeOvI9RufWWyRCUt9906Xt5kIFpf5uaUKarlR0jUy2p+X2Nh62+2bi3faaxz1JoBInf1nr/WWm9Sj/3UAb7+2KrHo6hC4gJ0kAOMwMSf0RwwSgu8isNrDpSU1KIVBY9zX+Rz9xAaP3n/My3zUzrWOqdbhLpGPqMuFMhjkGu8pxZRKuE5H0ljYFaC0z60b8ZNutllAbatC1PdcxurPftZgvzwTnWDFuhJdSlzHFOozudGsHBsxeMYc5xiHxm6jdyx11mVojHVkt2zaJ/6+aOF+WGdffm+7hu0zrB9sCC2ULiRNUUF6fa5l9H0GjCX4nRsF9BRPsj2kVC8fyofx88KC5/lYq/uhPt7zni6FFoetZaCjQU2okPgWBBqtXrfXbczmP2qmz7a5oqAVwR6Mkv1Zz3eXpuWvLux7jBwog7bIyKTNaboEjQ+7ZMUl+RQnvdVYTKE6S48AiD6LOepwMmVTfs6Qsw+P1/XNVb5roaa7wFjzIqAgloHidaoRyUiVOruz9MOIE4ZpoVapcfben9ODpAyC9M+dc1UWmCuDGnb9wjztxqo65wXNqcNUVDXeBmdc4kWqsKLQBL78zIcx6U71aMZfa6xW86uOeKOarU6R3fZ6n2y3Bj4vcrPmx789lyrx7QsH9OFXC4F6xqnGBHo0aqJCihzpa+hV33OEWpk/ZGFkJWeh0YVI953ZSU+UIGyzeVSQDDvHgF4m2UePsAiNRmoNUXX9NcOIDkTyJhs0R782/PxZzLAtZ3XNYXxeKhMzRivfbW1XlKX/1oakn3XsVyxXtslSW+q61QNjayv1oqnp+VlMnGVxRnnwEKFQAaocFQx9BkHPWSIV1OyfUUfb2KQeRnPL13wJHWrkedyZY3auSfKrHK6mIEW7YyTd2txbVbw0vuL9/1GxvXPtG510W3xs6X4wtXyiJo9Trml6jo1vqqCaHvOVcd1AWdgz/FFBu6cTx4v9y9R3BsZO2uPCkM1Xl1vhvwi16j967PKKP0cxTMFFC4k9umxl8r2lvlmTPa4TXIBet+RG414wvbqrVhcL9xZ10Hcuo6OO0QD8/MoiNnqdIKZ4pB8AY4ql4VKNQ0zzU3XGrlgjdk6F80ds3VxHd6vto3G8fyTc4x2ftimlLYRXfx9Bg/+RxoRAYMIYUX3IxfdJz6fOHPGt+8Yis9jSjDHnAzRcj56cDg686NziEALKQNdLhQKg89oKVHvR25+2BPVCXECOvkuVGWyl7fmZF7jUCljfNB2nem8P277aIzhuG0BdJ0ag0bm6PEKlQX7dNR6uSwTCGLb7gEU0I0xMFJQzoHt13Xb16BEdE8Z1NpPOyiPW1/kbVOUJy6+MaUMGuaW1jvE3hlJNYptIhfZJ6CId0aL/XhEmdqy7yjuRrlnmz+ZU3amKVCJ5sO+lZlRESFCvbyuSuHgiXzkGN3tLnt7kuIN9zBPFIpqfktkL4NAI4TlVRXVDk6ScYBMIXEBbMt9RUd8ruVdaGXoT4Wsa1ENZ36nCkjk7IwZ4/Wcv+l1pVHZ66R4kZtuAtKxxudU4I7qSylYdHK8p9pNBvRFjh3rgtpkutvRwTtYKnJPraYrQ3OF82I5R3V1zlB3b02Rln1MjtUtYi4ucA0zSi7Wd//chD4K0EOClyL7sx2YqWA7Nhnz4a7kbdyFDSh9jxMx7MYuMHdZFAQnNrYru4A4MQBD+SqD8XroieMrc3Ujms9qfFXLJwP6urcpduv8KVi9766xucMYuLkSjC61DoqrMX/Mr0fF7Ir24k5ZBxy1I/bxbn1uGRHkBub9ui60Lnx+VjfJ/hXWKyR3N6fITZmpcZ9/+wszfc9ThcM41ePQnMwreFJBUYk0DXIBdtc5sGxYp7r+plTtu26PLb+eS9Fis1pes6hZc2gFZEhHq8s+GLWTWtMtaazAaL9kJEmhvgZ7R6M9PleJf8uLhVe48ilq1O+cqwqBHqqHmrIrjzJdleNy6crl6+acPZy4B+S6xnl2DzEAOH7gyywKWrzyoaiwI7h8OyY6/qBWM2rtnJvRerLjGGOs7Qm0H0T2Z9RiIytRiqzHrU7bRWiXbfnXT+dpH17A8KOd6g32io1PmoVvAFjX1VxbXAgYAUpvq2hQ6WhfLXc5M9DxcSOXFjGabfW6CjUqcGTz8XU3IY3u1wERkKc4vn72rWN6IXxWvRfSQngWrFWjfTG+aPZ2lFtFWsrJ6zjqLbQUxTFG1DimGmq97hK1LRALVj2HMz1atyuok3o8XU+0qZ5tFKdCJOm7EzqZyGqUGdGiIgaxjbpMzS3VYltfnEd3tRq7FOFqnOHzylivZWZzzcKB3su8hc5TQ4saQOQu3WCOdvpfFSLQD0VlKCsThPrvvtjxJRqPmd6nMydihraL4mAkkGynnVbrrjD6q3OLGD8x+6AvnyObv+W1uTcJkcSd/sjslZFR3Iqq+srQ6Liiotr2fY4vc/yMT75pm+hsaCk9pXDhZ3E5U+bIUx3FPi+8v2U3X+m3hEji9pW6uKOJRxpHxmg88A1gXfDR+ZouiDnuaLw8iu0TY4LrPjb78L5UOTxsRHxQPr3nDOq7hEjyHwaKDjpFsTJzJZGL3Cdaeo7Fw1fRM1FKQWUBxkIC73Hu0Y8zeExrfcRbVUcuNVN4Heu9h4ivEiLQUawDhkAOALRgsEzxTZ9xrScz94kbkFGA47sb6g5Lab+q0Sw9Pi7ZxxjzP68kqTVyHvxOPmTHULgPClz/YurVQiTpu/fDAAkQcMa6Fkcbq15XVQFGxwd53wGIx0udBxAXFzxdorJkz+kcVMBt7e3vR73r/2FCJPm7GRkgIJGpwJhAq9D8tJ3qicdHLbpHqNaF6CAt3hQe88kIWPn61KXrXwAf/uLphwuR5O/mAzEIUe1u17XwO8Y1t1rdQPb+dQwlzw0jhJmVHCNAlYGkTMCf8U7/pwkRGH+XDRhztAhgROhTBaUC8SqNWjzHygBTlgY4ZejV+1aX6aiT1x7uTWGn6PW3iMmkjBEeWzLk6y7TyWObu9YobrZ2CEt3fN7jfa23+TWNmwiRpL9dE0HwaOdbGeIC6e44P2LpVSG3IHePfiSQlBUAVNDX5nvvpZsKkURhZpYF5AXpKN3gcx6TFDkeKU0Elvg3eukGiBWOz9/6t2zuIkRgfFknQoJRhUaL4wo6nDKAEVWAvBzom9aRq492VIDrXhS9hu4mRJL+LKaDE1IE+9vz84azu9hIgBHAigCOWqgKj6+j8dr/9rfdnHzLi+Qul9eAectHD3rpfbf43maOi442gX5kg5vcFOZZfmUx/mXYO5AyRC3MXWP0mbLUE3BKUWrCds1ix+OPHLe3WXC5XNL53ptOMxElLaz7ybUsufadBY9/fu4mugZgf7vZx6SQz/hvF043ISX/Mdsoz9QYmCX8fMYL0hEqzXLWM1me02knpuRbXsC8tdM+x7vmWmrrQh/P7mgMVGU4A3B5jU49OaXX/i8Gy3N+iizKEbPKkVvsma1P6SEmqeRVH2U8CwGa/wHjXqG++KPWrHniGePeET3UZJX05VhgLouR/H526uxWdc7PoIectBJ/a8B3872yoxvHwHxu51EFCPwHhAjMv/gBzNUYIP5duEeJe0f0L+D749HrhKeLAAAAAElFTkSuQmCC"
    }, null), createVNode("image", {
      "id": "_Image10",
      "width": "107px",
      "height": "62px",
      "href": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGsAAAA+CAYAAAAs/OVIAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAgAElEQVR4nN2dWa8saXaWn5jnzMjMPZ5T1V3tsrGR+TNIvjAgC+y2uw22bIONzB/gBgkEAowZJbiBCyR+CzdIIHDX0Gfvs4fMjHmO+LhYEbGrrabdQw2nCKl0ztlDROQ3rPWu933XVxpf0+vn/0CpplEAeJ7G83MBQByHmCaczzVx7GEYMI7QtjAMA/f/1tK+yvf+Wa6v5Yt/4+8olWU5YRgCYJoawyATZxgargtVBZoGZVlhWRamaeJ5Gl0HRVFx/I/B1+6zf61e+Ju/o1TXDTw/P3N7e4NhQN8rbFujaUY0TSMMdU6nhjh2GUfoezBN+a/rIM9LLi8DHh8LNpuQj/+l9rUZg6/Fi17+eq00TaNpGjabDZ6noesyEY4jk2BZUBQKTdPQNIgiyHMYx4lpmnh+fiaKIq6vAz799MxmsyEMDboOlOJrMWnv9Au++s6gLMvgeDxzc7Pj+Tnn4iICIElqLMvCMAxcV2MYoOtGdF0HoOs6NhuH47HAMAw8z0PXIQyhruHx8cwHH+zo+2Wi4aN/8W5P2Dv7cq+/OyrL0jFNAQhl2RIEDtMEwzDRNA2GYWCaJrZtcDwm7PcxVdXQdR37/Ya2HTFNg7bt6LqOi4uQpoEggGGQnFYUA45jzvcdiWOD//GP3s1Je+de6uf/QKkkqXFdlzDUyLKR/d7g+bmfJ0Yjy+T7fd8DEAQ2AIYhIbGqGkzTpCxLttstcSwTrhSk6YjrGuS5THZZllxcxOg6uK6EzjiWifzv//DdmrR35mVuf6tXlmUyTYqqqthuAwxDBm0YBCBoGjw9CURXSrHbRUyT/P4wTLiujq5DWY4YhsHbt2/58MMbHh4KXr8OOZ8nlFJM04TnWVRVh67r6LqO7+u8fZsQxzGGAUVREwTeO5XL3okX+cU/VCpNe7quw3VdbNtgmmQnBAGkqYSq5+czV1e7dVeM40gQuOuEdV2P61r0vXzBsnSaRnZkVVVomkbXdWiaxmazwTDk44+jQinFOI64rkXXCbLUdZ0ggKendwPqf6Uv8Oo7gxrHkf3eJk0FHBiGhmVJ2Hp6EmBR1xPavMCTJMGyLDRNIwgC6rpmHEeUUmy3EXXdst87VBV4HhTFhOPo1PVAFJn0Pei63B9kxyoFeS45sW1Hmqbh/fcD2lZ28+Njxe2tT5Iovv+n+lc2Zl/Jg3e/lisAwzC4ufFmiK0wTY2qahnHEd/3sSxBba7rMk0Tr14FVJUMcF0LPO86uWffy78fH1s8z1mfVVWyC+PYommgrjtc10bXwbbh+bnC932qqsLzPDRNI0kSwjDEtk0sS+6tafJf3yt8X+N//ZMvPzx+qQ/8xt9RCgR1WZZBVTW4rouuQ123dF3H9XXE+dxydeXQdTIxaTphWfoKApJEQMfpNLLdSsh8fq4YxxHLstjvXepaQmieK6JIo65hGGRBLGiwaWQyHcdhGAa2W4tpetl1SVLiui5ZlrHb7VBKYRgamw0cjyN3/8b8UsdP/7IedPG3KrXdwjQp2ralLGvC0GW3g+0WqqqawxlomsbxOFCWE30vNVPT9HSdoq5hszE4HgeCwJjBwIRpmrx+HXFx4ZIkHY4jfGDXdYyj1FKGIbTU+TzO7MbIxYVLHGsMw0Cej+i6TFLfw/vvB2y3Bo7jEEl5R5YVvH3bSH77lUe1/Rup+rLG8AtfGX/p7yk1jpAkFWHoM00CsR1HcsfjY0UQ+KRpNoceHcOQHVUUijjWqCqYJil6o8jANOGTTxLeey+maaDrJrquw/Nc2rbDcWyKouT6OkDTIMvkPkmi2Gw0jsduDXv7vUNZQlEUbLchj49HXr8+rCVA27YEQYBpmozjOIdUeHrqmaYJy7IA2G71L7w++8Ju/kt/pFTfQ12P9H2PruvEsY1SMlF3dxWvXvlkGWw28uGVUvi+jWHA8SiDl+cVjiM5KAyNleuzrIVOGpkmgeS2bWOazPBdBvPyUn738VFyl6ZpuK5J3yssS8P3hfRdCuhpUniexjRBUXQz+2GsTMeSv2ybmd3vsW2ZsGGQ+PlFhcfPPQxef7tVv/zHStU1pGlNFBlEkQtInkjTjrKE/d7n/r7G8+D+vp4LXpthgKoaiaKQYVDouo6maWy3BgB13VPXik8+OdO2LUmSsNtZTJNwgAtpOwwDYejQNHA6DTPMt+j7nr5XpGmK5wlQUUrAjiwkYebbVhFFNk3ToJSE7+MxZxwnum7g/v5MVUEUWXRdTxDAdmuQ5znv/231hYTGz3WyXn93VI5j07ZwOiV4nkdZKrKsZr+3CUPwfZtxhDzvKYqC47HB9z0MQxJ/FMlAx7Hcs65r+r7n8bECIAyteSJCuk6K2rKUwfZ9naIYaBrwfY++l/DbdR1RFOA4cH3tsdlInfX01OD7EpYNQ547DLKDhmGgaRS+73M+SyE+DAOapnE4mDNDUtP3cHtr0XWQJAPvvy9F9eavJ+qD3/18J+1z2a7X324VgOMI7XM6nQHQdZ3NZoNlCYL63vdSXr3aUlUSMmzboGl6qqpis9lgmhpJkq/E636vkabQdVIUN00/k7fQNBJa27YlDP0VtpumCcjAWpZFGOqkac9mYzEMzEVuz25nUZbQNO2aj2zbRinZdZeX8VqTLXVf0wwYhuxw09RwHAmhris5tW0VYaiRJBLSlVJ4nkPTdDz8e+dnHuuf6Qa7X8vV9XWIZcFHHyVzYbrFdfWVfTif1YzIRnY7n7aVAQCJ/a4Lb9/mRFFEXdd4nkdVCejoup793sKy4HhU6LrIH6dTwqtXMVk24Lom4whFUc7PD9E0Zgguz7ZtG8PQqKqGvu85HCK6DsqyxDRNHMdZ0eMCfJoG+n7g6srk6UlykYANH5CclSQ1tm0TBAZv30qxHscBXSclwgI3TFNy3c/K6v/Uv3z567WKY3fl4ZqmIQhc6rrjcLDpe3h4SLm93a4F7MIqZJmiLEssS0Ka7/szoRry9JQTx4KTpwnqull3y7ID0jTl9es9b9+m2LaNZVl0XUcY+tR1y/W1gIqylHukqYSxzSZkHBXDMNC27TyJBpZlcDolXF7GaJrsEAmJA77vEYbyzn3fs9lImJ8m+bfr2uu7Sn6THRVFPmEoIGgYhIGxLA3DgP/9T3+6SfuJc1b0187qm7+j1OWly/lcs9sJlHYchywrVz2p72G/3zIM8nt5Ln+ezwNxrKGUwjRN4jjgcNB4770Qz4M4juYBG5gmNSNEk67r6Pue3c7A9/05pAXYto1tm/PPQRg6HI8jeS7vUNcdnucRxyF9/8L5tW3LdmvTdR2GARcXMVXVUxQdti1j+eqVx/Pzcf3sSikeHzMA0jRlu7Vpmo7n5xOmCRcXLlHkYZomeV5xOo0YhnCURVHg+/JOr74zqJvf7H7ifPZjz/B7vz0ppdScrF2Uku3dNPIhNE2jqiouLnzGUVZaWUrN07YdFxf2al4ZRzgeG4Zh4OYm5OGhJAwDxlF4vDR9get5nrPbCdooipKLi4Dz+QWGT9PEdmtTlhNBoK9C4kIPCZID3xdC+HAwub+v5h1lEQQ6SdLOSHSYw6KEsK57uUfbdrNtwMJx5BllKWHQ9405Cgzouo5t63TdRBjKwjVNuL8v8TyPpmnWksVxZPw++ZMfb6f9hTvrw99X6hf+rlJZlqFpGp7nkqYVVdXx9JSTpikguSeKfE6nBtuWiYoim74fmKaJuoaHh448Z4buAufrGrbbYKaREspSapv9XuqbwyGmKEpME3zfp2nkd7MsI45Ntlt7DrM6x2PFOC6c4Uhd9+i6TPLjY8luZ/LxxwkAlmWRpum8++p5UGWH6jo8PCSM40RZ1ozjRBjKLpSwquj7kcPBmxeMLEDPM2fKC8JQ5/4+pSwVaarYbAKqShbhQoVlWU/X9T821P+Rk/X6u6MaR6mPvvWtLbouRSSI4HdzExGGIaapMY4yQI7j8OmnCZqmEUWsVX8Uwc2NvSZw4flcum6kbUf6njnW27RtS9+/cHSO49A0I0GgMU2KcYT9fr8O0jAMdB3Ytk3XQZoKEnVdi6YZub2VcFmWsNvFXF0Jcbvb7ajrnutr2bmbjYZl6bQt3N7GGIbOxYXH4aBTliK1TJP8XF3XGIY8p+tk8ppmxLYtzueGuoY43hIEkqvO52z+2W7O5xVKKW5vLTQNfu73lFpQ9f/r+qHbz/qr9+rDD28YBkE8mqZxdeVyd1dwcRFi27K6hmHAcSzOZwESDw9iD3McDaUkPrvuwihIQnYcG8+TuibLFK6rkeeyC7tOVNokEUjteQ6nk8j1SskOCYIAXRdEeDjEKyNSVeJyenqS+s5xnJmyknDrui5RZFJVijzP2W43lGU112cOeV6x3/v0vYTMtoXHxwTf99ls7DXcPzw88OrVDUVRYds24zhS1zWHQzwvnhc5x/MEUCyFN8i96/olvC6k8v19MpcvOn3/w0niH/hC+KsntdvtZugrDPM4KrZbjTyXAZYQJ1SNhBjxN3zwQcgwvEB1WTUuZSmUU1EU7HbbFY3VdU0cb6iqBt93KQqB63kuyO2zxpcoivB9g2GQiX96+qym5dP3gmIOB5OyhCQRm5llQV1PxLHO42OzcodRZK8KdJIUKKUIw5BhGFZRU9O0dZJlMQitFcfCzJ9O9fw9bd79gnYXrWwcX+ist28rdjt//nvLdisLqSwlFwpQkXquqiRvRpF8/7NKtQbwwe8q5TiQpsJzaZo8XOCo1AwgyEoEQgPL0lY+7XxOuLqKSdMa3xcXkePA8VgzTRPX18G6A85ncRgdjx2bjXCFCwgYBlkMS6gcR7i/zzFNk7Zt8TyP16+FQioKIV89z8OyjHWVlqXcbwm/4ziuueLy0uajj8SGJpKIQ12rVb8KQ4u2lR0kphsHTRP+b7+3yHN5pmVZc8h2sW1517Zd0GdDXYvzStd1HMdhuzXWiWzbkTA0SFPR1dq2xzAM0jTl1asdZTlhmjrjqKjrGsdx1l2m/ZV/oFSWsdq08lyI1ft7QTq6rs+eBYHowj4M+L6JbcPp1BEENlUlrECWTUSRzt1dShxvGQZRgPu+ZxxHwtADpPa5vAxnmkaK4jiGLBPpQrg84Qo9j3kXy4TI7pYdGwQGeS6DWZby/U8/TbBtmzj2ybKGsizZ7/fzhLtkmTwvyzJev96QptOsWcV0nZhwltJCPBpwPqdcX285nSo2G5++V+tOdBydthXH1cWFT1lKydE0DTc3AooELcoY6LrOMAwcDj739xJql5C6eBkXt1YQyOe2bdAXo6Ss4oq6btcJCQKDYRjYbAzGcVFoayzLpK7HWSey6Hvh7N68STEMna4Tri7LcnRdRylFENhEkYemycDHcbjunu02IgzhdJrWWmgphA1DVm2ajmgavHmT8NFHKboutU6evyT+/V5W99VVjO/7KAW+73I4HCjLcg1pcRyhlMJxnBnF6ViWhW0LMXt5abHbCdAR24Di8nJLnvdcXvqcz1I0TtOEbctkmqbObuevoXu71TkcfO7uCqZJFGZRqxtcVxaSbcN778WM40iWZRiGweOj3PvqKp69IRIeTRP0slQUxTCHPmf2IahVCGya5geS7n7vMU0KxzE4nxsBJJaEy/1+S98PZFm91jGyKwUxDQNkWUWeN2voEGGx43zu15eWUKtTlt2cv8A0DYZhJIoibm+3WBYcDvsZTWmczx2nk8T2cZQoIQ0JPZoGFxfhCsuXLOB5Ds/PFedzRRAEPD1l1LWi70VLMwyDIBB4Lova4ulJgIXjaBwODsMgu2ah0IZBFnRdy9d3u5CybHFdjdOp5fXreJVXJMf3OI6DrutEkcyBUswLRyPLJpSSn9Vlpk08T1ZKkkiCD8OQtpU/01TY5b6XxBqGGk0zcHUl3ogXWM3skHWpqgrXdbm8NGYxUQrNqyufw8FlGCR+L+Kd48ifu91uDpkTrmtTVR1ZVmNZsNsJrVUUE3kOux3c3QmYsSwLz5OFs4Tn8znFdS2mSdgNIWtllSdJQt+PRJE/85Adt7cbgkCjKCRP931P2/Zst3A+J2ga3Nz4aJpGWfZzflQURTtrW6IMbLfbWcHuOR4z4tjh8VGose9//8zpVJGm/ZyrRYv7xjdC7u8lH55OCXUNd3fZLP0IwNEOf7NUC+sgtY7krDRlVVOXLg2ZWBddXxjnabV3Lbxd3/c0TUMcx0SRwfEoqElW3UCWZWw2G+LY4nwWVsC2rRni9mRZNsvoIUEgFb5hvDAiS/ja7eDP/uzFmqaU4vra4/m5m8OnQd/3DMMw+wJ9np6eME0TTdP45jdjigKyTJiFKNLpe1nBS+gRH7wiy7LZpxjT98PMZBjc3yfz38MZlhtomoyLMBmSb9++fSF8FyI7z8Woo2lSpvR9z8VFyPlcz5KRLOZpmnAcWYjaYlNumn71zJ1OJ25uLgHW9plFUZWXkUnbbGQwxxEeH4/s93tsW3ZQmopJMgjg7dty5vVi6loMKotnT9fh+VlI1CU0+v4LU11VkqzP5zOO43A4hOS5wF0pxGVAl8vztJmz9DidxEL25k1BEAT4vsbxWBFF/uqL3++1Wf4QdTkIRErx/UUsbZmmadbHBmzbZBgkVzXNsOZWXWeWbsY53ztUVTfbDTxc18B1hRsVf6KzSi+uK97EIPDRdXn2w0M1q+sueT4DE8PQGQaF686zp2lcXFzQNBLrP/nkiK7LRNV1MwuELuM4znWCmgFDPPsbsjlceLRtP/Nr2oy+cm5uXA4Hjb4fqev2MywFc64oSJKONFWzu0m6R0zTxHVdDEPYk9Oppm3VHIYbDEPD8zSSRMwsAqV7qkpCeRRpFMU452XZBV3XkSSyQNpWEQQWx2NOlhXzTh7nWs6b84hJ28rAdd1EURQ4juSoMISuU+vC6bppLTeapqHrFEky4jgmwzBg26xCZ9PA7a1ocraQ+Fxe+nPBrdjvLbZbV+imzUabfd6KoijQdY3NxqIoGl6/PpDn1Sp9C3qCKDJ4fj6jaRrPz+lniladp6eMqoI4lrpFaKBOaoa7isfHgSgy2G4lmb56FVOWzDkkpKoqTFOjrru5PnN49WqLpmmzaRMuLz0cR4jc3c7j6em4vuP1tWha2+2WPJe6pyjAsowZaUqxfH3tEMfw+Jiy2Whz2PJo23ZGlwKSzueUNE1xXbBtsQbYtr7SW+M48sknCXGsURTFHLrElp1l2Spquq4xRzB3DrkTRTFwPCYkiXCIadpxPIr14fY2mEsIyX9rdfxLf6RUUYjOdHkZkiQtUeTMiGrAssw11CxajoQRk/N5XF9sAQy7nb+WBOKulXadZcX7vkWaVtzc+PNASjhI08U2JtJ/HFsoBff36YzCHJqmYZomwjCc2fF+VYa3W5MkEfV5yVXDMHBxIS7d+fVoGoH+oiZL7ghDef5CChyPJZtNQBiymkvzfFhFUssyOZ3OxHFMWZa8ehXy8CAOYc/z8H2Dh4eE29uYtoWm6fA8e65XpUYUEfOFohJ0LX+vKvn5PBf79g/QTe/99qQ8TyPP+1WgE1len7sw1JwIhR5ZFFnPg48/lmTfdWrt/kiShIuLA1mWc3sbUVXC6d3cxNS18ILCM76Ic54nAzkMwp6/fSsTKsWyTHKSlPK+7wWzfCE5482bZGYWIjYbE8OA+/uCOA5n4CBq89L8YNs2fd/jeR5ZlnF1teV0KmeNzJpRsZhKNxuDspR8soAe8XgkXFzEFIV0W3adjIfY7xr2e5eqkp/b72NcVxbMxx9L4f76tc+bNxXTNHE4hLMFrub62qMsf1Bd/qFE7vW3W3VxYfPxx0LNyPaVVhmxNBe4rsswDFxfuzw8CL8nu47ZFqZxPhc4joPrWivddDxWbLc+VSXU1uKB2O8NkkTNZpiXnxeXVMnNTUCWiXVZdkU2W6xNsixnv49WC/WnnyazsBnSNOJxf3jIuLraoGmQJC23tw53d/Le0/RS4I6jLELDWDzwNZuNmG+macIw9BURGoZBXQuYEZpKJsX3fS4v7bWrsusk5IHoc9/85pb7e6lFw9CmbcX+JjRagW3bP9Sz8SNFL/dXHtXFxcUqyi3EbpIk3N7ueHrKORwimuZlGxuGwPrvfe8tH3xwQ1VJK87iim0aOJ/Pcy2i43mQJB2WZeE4Ur9EkbUW0GHoE8fw/Cwf1vd1hmGRRl6oLN+3aZqBvu8JAo9xlETvuhpFIQtjATFSZE6z1yOY/YUG9/fC9KephOyFXpP7QFGM+L6B5wlhLbltWkGI9IcpLi+liBZ7tlBISdICzKDE4fY2pCggzwt0Xef2VqLHjxIif6Se1fzXK+37f6prCyEq6rA228BEjxKI3X8GlS3o5oY8l0Q8lyFzp2GBaZr0fc/5nJDnQrhO08T5XHJxYVHXiq6bCAIfzxOzzOEgWlBRDKRpObMZxsyE27guM1vt0TQdbdtSVRVVNVKW5QyH09nvLjWk7/trC1CaCqMxjmr2lKjZONNiGHB3dyYM5et3dxVBoLHdujiOQxx7zAgeXdf45JNqNd90XUdVKaLImZVpcfem6UTX9VxdhbP/Uf2FivGPLevf/lavxnEkihzqesRxDLpOGOKlvgBmuf1Fspa6TAq9um6wLIu2bbm99TmdFh5Q53xOef16uxLBDw/CpARBgKaJ1CCrmzVESn0npGwQQJL0lGXJbhdTltXqbNrv/dVSIMy/7Ib9XuPTTyWnWZaE8PNZdvMwCPQW86m1cppZJnJHUfT0fc9+768O3cfHdmbahWfsOmZILwtFhFoBFVnWcnHhkKYTb/618WPNw0/ssvm531OqqiRUSfErjMF2a/P0VHB9HfL8XHN15VFVUFXtHJqCub5Y6jl4eCjm5jkhYpcicRzVGtocB56f61lM1ElTETiXGL+gvsUDcn29o20FvLx9K/1dWSbhCiCOPaZJNDEhdh1cV6Np1ErcfvjhjtNJ7h2GPlXVEIYuWVZxOPgUxThbD2TXAytRvKgLi3NqYdilTpTnOI5GXf/kXSg/tRXt6jcatds5ZNlAGJorKmuaht3OpW2XLvh+RjpCej495VxeRiRJQxRJu8/xWLDbhZzPBVEkMdOy4HyWMytAEr4UlQZl2a4OJSmUDYpCWArD0EnTjJubzbxYRNJYitRhGNjtIvJcdjvIbhP/vRhy7u7On+EoRzzPJQzh6amZuU/xMmZZtxpbF5/7QjjbtsEwCHBoW1G5bdvm+tr6qXuVf2aX6F/++0rJJEnyrSoRJIXYlGTq+xZdJ6v9fK7mVWYTRfDmjfzMxYXFRx+d125GOadCm3WrmosLj/NZtLOuU7MPQpiCpTkhihzKsl9lGYA4Nueww9pDLMYWKcLD0FgprbaVRSCuX52yrFYuse97osinqgRJns/LCTYiNEoXypY0TWeUKnLI5aXH83OzaoOf/quf3uj5udinf/mPpWPk6Unif5IUvP9+SJqKRLEgSduWvJAkFXHs0zQCl/v+Bbm1LatAB5Kg5XvCNhgGPD2p2e+3AB9h3S3LWOX052epa8TTCHd3+SxDBKv7Vu4riK8opEl8IV2X0LrbidD58HAmiiK6ruPmxl89KEFgzfodlKUYXZUS/tTz3PUZn0en5OfamvLeb09KQp5BnktCXpqzP2tpLsuSzSbkdEpm352P677UJGUpk1nXUowuRPLiUxgGGYAsm6jrmv0+4HgsOBzEzHN/L+1Ci1IQRUIoPz8LUfvmzRO6rnN9fZhbTyXnSDuQuy6WIDBWqJ9lEqIti1VvWkJ9WU6cz2cuLw+AfEbZ6Qb/8x9/fj1bX0gf0TJpfd8Thu6aH3xfEJthGGuN9fwsSXwcpZAWL4bi+fmZ/X6PruszMdtyOATkeT9bzPrZhLOjLKVoXgjZaRKJ4nQ68fr1AcuSfKfrOufzmffe2895pCaKPBwH8nyakZzk0JubkDwXXUuUXmHcXfflqIdPPz3yC79w4O5OdpGgYvHfT9Pnf8TQF9ZMd/UbjdpuRQZ4eKhm+O3N/cPdipSyLOP997eMI5zP3bqq+75fm+kuLvx1hy6QuG1lwNp2YrvV5w5IxX4vH0kpePtWlOzt1uXhQSxqfd/zjW9IiO77ic1G5/m54fLS5XTqubiw1ibyYZAdE8/9R8LMmPT9uDq0ttvt6nHf7Xy67sd32P6k1xfepvr6u6NaTCdNs8j0+io3RJGF6wqt1PfM9ZI0iKdpznYrTQrL15cmiO3W5XgsaNuWq6vDLOP0q74kjXVyFBC85MHbW4ePP5b7iggou35RbTVNI4417u7KuRbzSVOZvLIUoFOWi7G0WwXEsvziz8r40rrNlxNklILj8cirV4f1WATTlB2T5xO+r5PnPYeDWL/O5wTDMNhsIoZhXLs0tltr3lmsNdrzsyjbck9Rt4W81Wcm5AWJ1nWL4zgrk7H0MS8uX8mfPZ5n0bbjeqCKlCbe7NUQ0+oXtZP+/PWln+Xw4e8rlSQyQHVdz40A1mxFlhDXdf0s95ukqdRlZSmtPldX+zUkLpY1zxPTpijHclLNe+8Fs2AquXMxhcqgO6sBaJFFhkHAzCITXV+Hs/dBmPoFVb55I7LK0qZ0+k/hlzaGX8mhJT//B0qlabNyi0tH4vEo0FfafWRGgsBeqaCyHFe/uFILdA6wLI00FWu1uGuFSLVtGVzf9/E8a0Wjcp6FPnNzFlUFed4xTRP7vYvrwsODyDHLwsiyksMhIE2lFnv77+z/vw8t+fNX+Ksntd/vVmtY2/azVGHjujLgi4zuOA6bjRTJYfiieS1HNeS5eBjKUsBM0zR861s7zmcpxstSjKnzQWozky8F/HYr/vqlt3ix4rVtSxQFNE1HGNqUZf+VTNJyfWmHlvywq/gve+2TP9E0yQ8DRVGsO0aI4A7ft9ak//QkHpCPPz7PTW/Mztd+1paa+SxcjziOOZ/FmZTn3Xw24dLoPc4yy4jvC7sh8jucTvIOeZ6vB0q6rs3/+Wea9lVOFLwjp6It1y/+oTzw8moAAAHYSURBVFJl+cJOLBrZZmOQ52IWTVOxQ4vxJVhdUkqJoadtWyzL4nDw1zZWOWjEnk+gfhH6kkSOrNM0+V3fd9fifQE9bQvf++df/jlNP+x6J17is9f1t1slsNtc/eJRFK2+jEWUXPyMy0Eii31rYfhBmtsk1y07zqTr5J6CEB36fmS3M+beXykZyrKmbVvy/7x7p8bnnXqZz17f/B2lmqabpXRhuhf6yLZt8jxns9ng+8I6LKzC6TSujLznuSuh7Hketm3MLMo4d+2LMzjPO4ZhmPWp7Tt7Vu47+VKfvV59Z1B1Xa/Iz/etGVio9biE5aihpVuy7wWG17XkvcPB5u4un21rW5qmY7ezubtL567MkGmSXPlV56Ufdb2zL/bZ6+Y3O+W6FmXZrAJfFFkUxbDmryhyZxVYWAyhgnyaZlxNKLe3Huezms0uL4eN/CRN2F/l9c6/4GevX/ojpapKitMX1gPyXDjA5WyLxUMoNmWXzcbg8bFkuw3WBkA5zvXLPzPwZ7m+Ni/62Wv5/5Asx4W7rs3pJK2rV1fB3GB9nifKo22Fxlr8hVXV8vgf3K/dZ//avfBnr8tfr9UC1a+u/PXM9udnYc+zbPH+vfx/Sx4eHuj/2+3X8nP/X8+jjAy2QdiEAAAAAElFTkSuQmCC"
    }, null), createVNode("linearGradient", {
      "id": "_Linear11",
      "x1": "0",
      "y1": "0",
      "x2": "1",
      "y2": "0",
      "gradientUnits": "userSpaceOnUse",
      "gradientTransform": "matrix(-118.47,-106.79,210.785,-180.125,69.2121,1372.7)"
    }, [createVNode("stop", {
      "offset": "0",
      "style": {
        stopColor: "rgb(64, 128, 255)",
        stopOpacity: 1
      }
    }, null), createVNode("stop", {
      "offset": "1",
      "style": {
        stopColor: "rgb(64, 128, 255)",
        stopOpacity: 1
      }
    }, null)]), createVNode("image", {
      "id": "_Image13",
      "width": "107px",
      "height": "34px",
      "href": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGsAAAAiCAYAAABY6CeoAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABFElEQVRoge2aQRKDMAhFmx6it/P+x7Ab64xOmaAG8vnwFnWhiOGFOG3TPsu6vpS0djpuH61zXoz5F3s6r4rRxipiftddeUbp3t18QozEu3/JfdSzgCy5VWpTWcVYSlaPqcvDEUpZQPUdCqUsSAbMoJIViJIVCBNZrO+MHtbjrs4KRMkKBJUs9uXXTxZ7JR2g6ix27sly6BIxReIOHdpZWevoNe68y2DAmTVXFmDBAB9pJ29nBYRCln5jgkVyv1QUsrIAJyvtvg1F7iGykF/KlniPG66zKDCyWLI2IqwOJSsQz2URbqZEpTorEDCypn6xnciVYT+SlbS+08Zt01lJfv7xBmYZLPpgy6p/pA9gyxIArKMLXxexLNiBCThLAAAAAElFTkSuQmCC"
    }, null), createVNode("image", {
      "id": "_Image15",
      "width": "38px",
      "height": "62px",
      "href": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACYAAAA+CAYAAABHuGlYAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAGaElEQVRogcVZSWLjOAwsblIu+oD+/zZ/YC4di8sc7IKLsJzJdCdpXGxLXIACUADpgL8oIYR9jKG/wd/hL+m080uMEb33pwHpR9UBkFLaU7ptW0rBGAOKGgAsy/KjiO3Aw105Z4wx0FpDSgmtNVPqer0if7c2Oee91oqUEsYY5rZaK5ZlQYwRx3HY+J+IsSmOQghPqKhwTO8dIYRvU8yU0kzzEmPEGGNSiGO/Ovh3ABtwQ4UI5ZxRSjEFKBprYwyUUtB7v6H3hQqhlGIb1loRY0RKCcdxIKWE3rshUkqZYsvLHykWQthjjJZZGtwqpRS01ia3MaZCCKi1cj2MMZBS+n1XhhB2brKuK2qtj/hIyeJHkVEypft678g5I+c8uf53FNsBbLoJF6RwU800kirjinM18HXcpxULIewANi5KyDWT1nWd3KquXZbF5tGVmq2qXO/9UzG2f/SSyK3rivf395e1T5/TmBAClmXB+/u7AnBD+7NK5fwoEiE822OM7d7lnBFjtIwlmkSMga97hBBelqRdraTf1SIvnsm1/gEwVBgCfMfPpwQ6UWgj0XGQxgrfeUWJFIO7tYacs20WYzRDPbqkDcZs790U25dl2ai9xoKK+V+oQFEhspzvWZ4kC2DKTK6tCRBjjDtd4RVZlgVvb2/T4lqMj+Ow9yRaRU/Xi/E5nIkUjWLMpZSQxhibn8C6dhyHlRZa6Ru73jtKKbYgDeBmWor8PN2LLmf8JdyLrsKrlV7hp+XeRa01G+/jjaj4hGE49N6ngm/vVakQgqU1N9c2uPc+pTdLjyqpn7qOFz6PMU48RjBsVcaHr/hqPZVZ13XKMn3v+U4zmiWKhur6mpm994diDDwN2BDCxD80wD9TZWqttimfE1lPQYyndV2n32OMW4xp6jI7vGi80CqSr48PRZGGkttSShO/sV9b19XHcjSkmEWKmP5mcKsiipaXs/hjCFCUO1ncASDFGLdXmxJBjRFFk4VbfxNVpRi6h/F2tgfBoRdiaw3LshifeCGPsW3hQsCj/lER5T1SCN3nWd76rhehk0IIGxVQC7iAh3xZlmksUVQC1eMaS5gqRve/OoXXWm/Br0jwANFas3aFStFNuomlt7iZ2aeErUox8Espxp9U1GomgJ0WTec6l23+HcvIWWPIHoytkM7lfYWi7ue21hBZ/9TiUsqUPWcMT746U6rWOvVnOvdVJaAYjeScNwYorSeFeDL0LO838W5WQ/S7ZZ4klc/4eL1eLViZsrVW8z39f9a2eKR8u8Mg93NpZGsNx3FMBxTzEoDt7KCqCcFNtTNVK1+dK1trljxKEWyVfDfLLM05I7Fz1c191tVarbPwLlXOMjecKKWbMtEo/s6s945IjWutBq1apxbpUR94JAkX00Kv8aSuZDZynWVZTCltNs2VHikN/DP+okvOEsCHA68BPFLa3XoujZqFKlqctRx5BfQsSI7iHACWeeoySmvt6eDDsmaIeSF18PbPu5ZjtCroe7+mP01pS+T3tZM4G7uzWGCvpNZpdhExZqx2ptpRKPX47oJoszMG7j2/xoIqx8DU1oYLcxwTxbfkPl5jjFN4MAP53p8nIsmV15G+9yICXIyKcNHjOKY5KjqXY6kc6yzXbK0ZkjFGhFLKzoH2UG75xIIP6xzT3X8HHg3B2TGOzabe+/PiblOfn8UEn3MToqnI6R0GjfOJoOXNcx7r552CLmmMsem1NjdX7uGiSqa6IUWPa2eZzoOtntBVeu8XAP8AuF1D5ZytmKoVFH/0OpNX79St/lMo5uLnJdzvUzXwpk5SiFTpwlv9qnfXYm8F+jHPEPJiaUR21gzTf8fUytba1E2Qw/TcSdECzaS6U8sTShPS/MKOk27T9FXxqKirSBetNby9veHXr182XrL0Q4UokVdInnO0vj1Zc+ciJUV2HloVXON4+axSAJDJ2F4Bn+p6tD9rhbkGkZee//JR0rySlHPelLfOWhUqqH966gFFKYRz7p+fRuhJsRDCaWtNJf1JiJvqkf6E4y6999Ns+6xkbVtIE2enZ0XKX4VzPP5HDP2XGI8B81W5lhTlOZYiV3YuY4w/QshLVJeR/TVOBA0TF49fhpJKptXaT/mSoZlLRa/X67coRAkAdt+OnP2ZLvKtClEy8Bz4L5T6EYUoU2utqGm9+2mlAMz/vunfxHda+HGFKP8C6wW6ett+DK8AAAAASUVORK5CYII="
    }, null)])]);
  }
});

// node_modules/@arco-design/web-vue/es/result/result.js
var RESULT_STATUS = [
  "info",
  "success",
  "warning",
  "error",
  "403",
  "404",
  "500",
  null
];
var _sfc_main147 = defineComponent({
  name: "Result",
  components: {
    IconInfo,
    IconCheck: IconCheck2,
    IconExclamation,
    IconClose,
    ResultForbidden,
    ResultNotFound,
    ResultServerError
  },
  props: {
    status: {
      type: String,
      default: "info",
      validator: (value) => {
        return RESULT_STATUS.includes(value);
      }
    },
    title: String,
    subtitle: String
  },
  setup() {
    const prefixCls = getPrefixCls("result");
    return {
      prefixCls
    };
  }
});
function _sfc_render147(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_info = resolveComponent("icon-info");
  const _component_icon_check = resolveComponent("icon-check");
  const _component_icon_exclamation = resolveComponent("icon-exclamation");
  const _component_icon_close = resolveComponent("icon-close");
  const _component_result_forbidden = resolveComponent("result-forbidden");
  const _component_result_not_found = resolveComponent("result-not-found");
  const _component_result_server_error = resolveComponent("result-server-error");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.prefixCls)
  }, [
    createBaseVNode("div", {
      class: normalizeClass([
        `${_ctx.prefixCls}-icon`,
        {
          [`${_ctx.prefixCls}-icon-${_ctx.status}`]: _ctx.status,
          [`${_ctx.prefixCls}-icon-custom`]: _ctx.status === null
        }
      ])
    }, [
      createBaseVNode("div", {
        class: normalizeClass(`${_ctx.prefixCls}-icon-tip`)
      }, [
        renderSlot(_ctx.$slots, "icon", {}, () => [
          _ctx.status === "info" ? (openBlock(), createBlock(_component_icon_info, { key: 0 })) : _ctx.status === "success" ? (openBlock(), createBlock(_component_icon_check, { key: 1 })) : _ctx.status === "warning" ? (openBlock(), createBlock(_component_icon_exclamation, { key: 2 })) : _ctx.status === "error" ? (openBlock(), createBlock(_component_icon_close, { key: 3 })) : _ctx.status === "403" ? (openBlock(), createBlock(_component_result_forbidden, { key: 4 })) : _ctx.status === "404" ? (openBlock(), createBlock(_component_result_not_found, { key: 5 })) : _ctx.status === "500" ? (openBlock(), createBlock(_component_result_server_error, { key: 6 })) : createCommentVNode("v-if", true)
        ])
      ], 2)
    ], 2),
    _ctx.title || _ctx.$slots.title ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(`${_ctx.prefixCls}-title`)
    }, [
      renderSlot(_ctx.$slots, "title", {}, () => [
        createTextVNode(toDisplayString(_ctx.title), 1)
      ])
    ], 2)) : createCommentVNode("v-if", true),
    _ctx.subtitle || _ctx.$slots.subtitle ? (openBlock(), createElementBlock("div", {
      key: 1,
      class: normalizeClass(`${_ctx.prefixCls}-subtitle`)
    }, [
      renderSlot(_ctx.$slots, "subtitle", {}, () => [
        createTextVNode(toDisplayString(_ctx.subtitle), 1)
      ])
    ], 2)) : createCommentVNode("v-if", true),
    _ctx.$slots.extra ? (openBlock(), createElementBlock("div", {
      key: 2,
      class: normalizeClass(`${_ctx.prefixCls}-extra`)
    }, [
      renderSlot(_ctx.$slots, "extra")
    ], 2)) : createCommentVNode("v-if", true),
    _ctx.$slots.default ? (openBlock(), createElementBlock("div", {
      key: 3,
      class: normalizeClass(`${_ctx.prefixCls}-content`)
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 2)) : createCommentVNode("v-if", true)
  ], 2);
}
var _Result = _export_sfc(_sfc_main147, [["render", _sfc_render147]]);

// node_modules/@arco-design/web-vue/es/result/index.js
var Result = Object.assign(_Result, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Result.name, _Result);
  }
});

// node_modules/@arco-design/web-vue/es/skeleton/skeleton.js
var _sfc_main148 = defineComponent({
  name: "Skeleton",
  props: {
    loading: {
      type: Boolean,
      default: true
    },
    animation: {
      type: Boolean,
      default: false
    }
  },
  setup(props) {
    const prefixCls = getPrefixCls("skeleton");
    const cls = computed(() => [
      prefixCls,
      {
        [`${prefixCls}-animation`]: props.animation
      }
    ]);
    return {
      prefixCls,
      cls
    };
  }
});
function _sfc_render148(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.cls)
  }, [
    _ctx.loading ? renderSlot(_ctx.$slots, "default", { key: 0 }) : renderSlot(_ctx.$slots, "content", { key: 1 })
  ], 2);
}
var _Skeleton = _export_sfc(_sfc_main148, [["render", _sfc_render148]]);

// node_modules/@arco-design/web-vue/es/skeleton/line.js
var _sfc_main149 = defineComponent({
  name: "SkeletonLine",
  props: {
    rows: {
      type: Number,
      default: 1
    },
    widths: {
      type: Array,
      default: () => []
    },
    lineHeight: {
      type: Number,
      default: 20
    },
    lineSpacing: {
      type: Number,
      default: 15
    }
  },
  setup(props) {
    const prefixCls = getPrefixCls("skeleton-line");
    const lines = [];
    for (let i2 = 0; i2 < props.rows; i2++) {
      const style = {};
      if (isNumber(props.widths[i2])) {
        style.width = `${props.widths[i2]}px`;
      } else if (isString(props.widths[i2])) {
        style.width = String(props.widths[i2]);
      }
      style.height = `${props.lineHeight}px`;
      if (i2 > 0) {
        style.marginTop = `${props.lineSpacing}px`;
      }
      lines.push(style);
    }
    return {
      prefixCls,
      lines
    };
  }
});
function _sfc_render149(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.lines, (style, index3) => {
    return openBlock(), createElementBlock("ul", {
      key: index3,
      class: normalizeClass(_ctx.prefixCls)
    }, [
      createBaseVNode("li", {
        class: normalizeClass(`${_ctx.prefixCls}-row`),
        style: normalizeStyle(style)
      }, null, 6)
    ], 2);
  }), 128);
}
var SkeletonLine = _export_sfc(_sfc_main149, [["render", _sfc_render149]]);

// node_modules/@arco-design/web-vue/es/skeleton/shape.js
var _sfc_main150 = defineComponent({
  name: "SkeletonShape",
  props: {
    shape: {
      type: String,
      default: "square"
    },
    size: {
      type: String,
      default: "medium"
    }
  },
  setup(props) {
    const prefixCls = getPrefixCls("skeleton-shape");
    const cls = computed(() => [
      prefixCls,
      `${prefixCls}-${props.shape}`,
      `${prefixCls}-${props.size}`
    ]);
    return {
      prefixCls,
      cls
    };
  }
});
function _sfc_render150(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.cls)
  }, null, 2);
}
var SkeletonShape = _export_sfc(_sfc_main150, [["render", _sfc_render150]]);

// node_modules/@arco-design/web-vue/es/skeleton/index.js
var Skeleton = Object.assign(_Skeleton, {
  Line: SkeletonLine,
  Shape: SkeletonShape,
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Skeleton.name, _Skeleton);
    app.component(componentPrefix + SkeletonLine.name, SkeletonLine);
    app.component(componentPrefix + SkeletonShape.name, SkeletonShape);
  }
});

// node_modules/@arco-design/web-vue/es/slider/slider-button.js
var _sfc_main151 = defineComponent({
  name: "SliderButton",
  components: {
    Tooltip
  },
  inheritAttrs: false,
  props: {
    direction: {
      type: String,
      default: "horizontal"
    },
    disabled: {
      type: Boolean,
      default: false
    },
    min: {
      type: Number,
      required: true
    },
    max: {
      type: Number,
      required: true
    },
    formatTooltip: {
      type: Function
    },
    value: [String, Number],
    tooltipPosition: {
      type: String
    },
    showTooltip: {
      type: Boolean,
      default: true
    }
  },
  emits: ["movestart", "moving", "moveend"],
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("slider-btn");
    const isDragging = ref(false);
    const handleMouseDown = (e2) => {
      if (props.disabled) {
        return;
      }
      e2.preventDefault();
      isDragging.value = true;
      on(window, "mousemove", handleMouseMove);
      on(window, "mouseup", handleMouseUp);
      on(window, "contextmenu", handleMouseUp);
      emit("movestart");
    };
    const handleMouseMove = (e2) => {
      emit("moving", e2.clientX, e2.clientY);
    };
    const handleMouseUp = () => {
      isDragging.value = false;
      off(window, "mousemove", handleMouseMove);
      off(window, "mouseup", handleMouseUp);
      emit("moveend");
    };
    const cls = computed(() => [prefixCls]);
    const mergedTooltipPosition = computed(() => {
      var _a;
      return ((_a = props.tooltipPosition) != null ? _a : props.direction === "vertical") ? "right" : "top";
    });
    const tooltipContent = computed(() => {
      var _a, _b;
      return (_b = (_a = props.formatTooltip) == null ? void 0 : _a.call(props, props.value)) != null ? _b : `${props.value}`;
    });
    const popupVisible = computed(() => props.showTooltip ? isDragging.value ? true : void 0 : false);
    return {
      prefixCls,
      cls,
      tooltipContent,
      mergedTooltipPosition,
      popupVisible,
      handleMouseDown
    };
  }
});
var _hoisted_168 = ["aria-disabled", "aria-valuemax", "aria-valuemin", "aria-valuenow", "aria-valuetext"];
function _sfc_render151(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_tooltip = resolveComponent("tooltip");
  return openBlock(), createBlock(_component_tooltip, {
    "popup-visible": _ctx.popupVisible,
    position: _ctx.mergedTooltipPosition,
    content: _ctx.tooltipContent
  }, {
    default: withCtx(() => [
      createBaseVNode("div", mergeProps(_ctx.$attrs, {
        tabindex: "0",
        role: "slider",
        "aria-disabled": _ctx.disabled,
        "aria-valuemax": _ctx.max,
        "aria-valuemin": _ctx.min,
        "aria-valuenow": _ctx.value,
        "aria-valuetext": _ctx.tooltipContent,
        class: _ctx.cls,
        onMousedown: _cache[0] || (_cache[0] = (...args) => _ctx.handleMouseDown && _ctx.handleMouseDown(...args)),
        onClick: _cache[1] || (_cache[1] = withModifiers(() => {
        }, ["stop"]))
      }), null, 16, _hoisted_168)
    ]),
    _: 1
  }, 8, ["popup-visible", "position", "content"]);
}
var SliderButton = _export_sfc(_sfc_main151, [["render", _sfc_render151]]);

// node_modules/@arco-design/web-vue/es/slider/utils.js
var getOffsetPercent = (value, [min, max]) => {
  const percent = Math.max((value - min) / (max - min), 0);
  return `${index_es_default.round(percent * 100, 2)}%`;
};
var getPositionStyle = (offset, direction) => {
  return direction === "vertical" ? { bottom: offset } : { left: offset };
};

// node_modules/@arco-design/web-vue/es/slider/slider-dots.js
var _sfc_main152 = defineComponent({
  name: "SliderDots",
  props: {
    data: {
      type: Array,
      required: true
    },
    min: {
      type: Number,
      required: true
    },
    max: {
      type: Number,
      required: true
    },
    direction: {
      type: String,
      default: "horizontal"
    }
  },
  setup(props) {
    const prefixCls = getPrefixCls("slider");
    const getStyle3 = (value) => getPositionStyle(getOffsetPercent(value, [props.min, props.max]), props.direction);
    return {
      prefixCls,
      getStyle: getStyle3
    };
  }
});
function _sfc_render152(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(`${_ctx.prefixCls}-dots`)
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.data, (item, index3) => {
      return openBlock(), createElementBlock("div", {
        key: index3,
        class: normalizeClass(`${_ctx.prefixCls}-dot-wrapper`),
        style: normalizeStyle(_ctx.getStyle(item.key))
      }, [
        createBaseVNode("div", {
          class: normalizeClass([
            `${_ctx.prefixCls}-dot`,
            { [`${_ctx.prefixCls}-dot-active`]: item.isActive }
          ])
        }, null, 2)
      ], 6);
    }), 128))
  ], 2);
}
var SliderDots = _export_sfc(_sfc_main152, [["render", _sfc_render152]]);

// node_modules/@arco-design/web-vue/es/slider/slider-marks.js
var _sfc_main153 = defineComponent({
  name: "SliderMarks",
  props: {
    data: {
      type: Array,
      required: true
    },
    min: {
      type: Number,
      required: true
    },
    max: {
      type: Number,
      required: true
    },
    direction: {
      type: String,
      default: "horizontal"
    }
  },
  setup(props) {
    const prefixCls = getPrefixCls("slider");
    const getStyle3 = (value) => getPositionStyle(getOffsetPercent(value, [props.min, props.max]), props.direction);
    return {
      prefixCls,
      getStyle: getStyle3
    };
  }
});
function _sfc_render153(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(`${_ctx.prefixCls}-marks`)
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.data, (item, index3) => {
      return openBlock(), createElementBlock("div", {
        key: index3,
        "aria-hidden": "true",
        class: normalizeClass(`${_ctx.prefixCls}-mark`),
        style: normalizeStyle(_ctx.getStyle(item.key))
      }, toDisplayString(item.content), 7);
    }), 128))
  ], 2);
}
var SliderMarks = _export_sfc(_sfc_main153, [["render", _sfc_render153]]);

// node_modules/@arco-design/web-vue/es/slider/slider-ticks.js
var _sfc_main154 = defineComponent({
  name: "SliderTicks",
  props: {
    value: {
      type: Array,
      required: true
    },
    step: {
      type: Number,
      required: true
    },
    min: {
      type: Number,
      required: true
    },
    max: {
      type: Number,
      required: true
    },
    direction: {
      type: String,
      default: "horizontal"
    }
  },
  setup(props) {
    const prefixCls = getPrefixCls("slider");
    const steps = computed(() => {
      const steps2 = [];
      const stepsLength = Math.floor((props.max - props.min) / props.step);
      for (let i2 = 0; i2 <= stepsLength; i2++) {
        const stepVal = index_es_default.plus(i2 * props.step, props.min);
        if (stepVal <= props.min || stepVal >= props.max)
          continue;
        steps2.push({
          key: stepVal,
          isActive: stepVal >= props.value[0] && stepVal <= props.value[1]
        });
      }
      return steps2;
    });
    const getStyle3 = (value) => getPositionStyle(getOffsetPercent(value, [props.min, props.max]), props.direction);
    return {
      prefixCls,
      steps,
      getStyle: getStyle3
    };
  }
});
function _sfc_render154(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(`${_ctx.prefixCls}-ticks`)
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.steps, (item, index3) => {
      return openBlock(), createElementBlock("div", {
        key: index3,
        class: normalizeClass([
          `${_ctx.prefixCls}-tick`,
          { [`${_ctx.prefixCls}-tick-active`]: item.isActive }
        ]),
        style: normalizeStyle(_ctx.getStyle(item.key))
      }, null, 6);
    }), 128))
  ], 2);
}
var SliderTicks = _export_sfc(_sfc_main154, [["render", _sfc_render154]]);

// node_modules/@arco-design/web-vue/es/slider/slider-input.js
var _sfc_main155 = defineComponent({
  name: "SliderInput",
  components: {
    InputNumber
  },
  props: {
    modelValue: {
      type: Array,
      required: true
    },
    min: {
      type: Number
    },
    max: {
      type: Number
    },
    step: {
      type: Number
    },
    disabled: {
      type: Boolean
    },
    range: {
      type: Boolean
    }
  },
  emits: ["startChange", "endChange"],
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("slider");
    return {
      prefixCls
    };
  }
});
function _sfc_render155(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_input_number = resolveComponent("input-number");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(`${_ctx.prefixCls}-input`)
  }, [
    _ctx.range ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
      createVNode(_component_input_number, {
        min: _ctx.min,
        max: _ctx.max,
        step: _ctx.step,
        disabled: _ctx.disabled,
        "model-value": _ctx.modelValue[0],
        "hide-button": "",
        onChange: _cache[0] || (_cache[0] = (value) => _ctx.$emit("startChange", value))
      }, null, 8, ["min", "max", "step", "disabled", "model-value"]),
      createBaseVNode("div", {
        class: normalizeClass(`${_ctx.prefixCls}-input-hyphens`)
      }, null, 2)
    ], 64)) : createCommentVNode("v-if", true),
    createVNode(_component_input_number, {
      min: _ctx.min,
      max: _ctx.max,
      step: _ctx.step,
      disabled: _ctx.disabled,
      "model-value": _ctx.modelValue[1],
      "hide-button": "",
      onChange: _cache[1] || (_cache[1] = (value) => _ctx.$emit("endChange", value))
    }, null, 8, ["min", "max", "step", "disabled", "model-value"])
  ], 2);
}
var SliderInput = _export_sfc(_sfc_main155, [["render", _sfc_render155]]);

// node_modules/@arco-design/web-vue/es/slider/slider.js
var _sfc_main156 = defineComponent({
  name: "Slider",
  components: {
    SliderButton,
    SliderDots,
    SliderMarks,
    SliderTicks,
    SliderInput
  },
  props: {
    modelValue: {
      type: [Number, Array],
      default: void 0
    },
    defaultValue: {
      type: [Number, Array],
      default: 0
    },
    step: {
      type: Number,
      default: 1
    },
    min: {
      type: Number,
      default: 0
    },
    marks: {
      type: Object
    },
    max: {
      type: Number,
      default: 100
    },
    direction: {
      type: String,
      default: "horizontal"
    },
    disabled: {
      type: Boolean,
      default: false
    },
    showTicks: {
      type: Boolean,
      default: false
    },
    showInput: {
      type: Boolean,
      default: false
    },
    range: {
      type: Boolean,
      default: false
    },
    formatTooltip: {
      type: Function
    },
    showTooltip: {
      type: Boolean,
      default: true
    }
  },
  emits: {
    "update:modelValue": (value) => true,
    "change": (value) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("slider");
    const { mergedDisabled, eventHandlers } = useFormItem({
      disabled: toRef(props, "disabled")
    });
    const trackRef = ref(null);
    const trackRect = ref();
    const startValue = ref(isArray(props.defaultValue) ? props.defaultValue[0] : 0);
    const endValue = ref(isArray(props.defaultValue) ? props.defaultValue[1] : props.defaultValue);
    const handleChange = () => {
      var _a, _b;
      if (props.range) {
        emit("update:modelValue", [startValue.value, endValue.value]);
        emit("change", [startValue.value, endValue.value]);
      } else {
        emit("update:modelValue", endValue.value);
        emit("change", endValue.value);
      }
      (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onChange) == null ? void 0 : _b.call(_a);
    };
    const handleStartChange = (value) => {
      value = value != null ? value : props.min;
      startValue.value = value;
      handleChange();
    };
    const handleEndChange = (value) => {
      value = value != null ? value : props.min;
      endValue.value = value;
      handleChange();
    };
    const computedValue = computed(() => {
      var _a, _b, _c;
      if (props.range) {
        if (isArray(props.modelValue)) {
          return props.modelValue;
        }
        return [startValue.value, (_a = props.modelValue) != null ? _a : endValue.value];
      }
      if (isUndefined(props.modelValue)) {
        return [startValue.value, endValue.value];
      }
      if (isArray(props.modelValue)) {
        return [(_b = props.min) != null ? _b : 0, props.modelValue[1]];
      }
      return [(_c = props.min) != null ? _c : 0, props.modelValue];
    });
    const markList = computed(() => Object.keys(props.marks || {}).map((index3) => {
      var _a;
      const key = Number(index3);
      return {
        key,
        content: (_a = props.marks) == null ? void 0 : _a[key],
        isActive: key >= computedValue.value[0] && key <= computedValue.value[1]
      };
    }));
    const getBtnStyle = (value) => getPositionStyle(getOffsetPercent(value, [props.min, props.max]), props.direction);
    const isDragging = ref(false);
    const handleMoveStart = () => {
      isDragging.value = true;
      if (trackRef.value) {
        trackRect.value = trackRef.value.getBoundingClientRect();
      }
    };
    function getValueByCoords(x, y) {
      if (!trackRect.value) {
        return 0;
      }
      const { left, top, width, height } = trackRect.value;
      const trackLength = props.direction === "horizontal" ? width : height;
      const stepLength = trackLength * props.step / (props.max - props.min);
      let diff = props.direction === "horizontal" ? x - left : top + height - y;
      if (diff < 0)
        diff = 0;
      if (diff > trackLength)
        diff = trackLength;
      const steps = Math.round(diff / stepLength);
      return index_es_default.plus(props.min, index_es_default.times(steps, props.step));
    }
    const handleEndMoving = (x, y) => {
      endValue.value = getValueByCoords(x, y);
      handleChange();
    };
    const handleClick = (e2) => {
      if (mergedDisabled.value) {
        return;
      }
      const { clientX, clientY } = e2;
      if (trackRef.value) {
        trackRect.value = trackRef.value.getBoundingClientRect();
      }
      endValue.value = getValueByCoords(clientX, clientY);
      handleChange();
    };
    function getBarStyle([start2, end]) {
      if (start2 > end) {
        [start2, end] = [end, start2];
      }
      return props.direction === "vertical" ? {
        bottom: getOffsetPercent(start2, [props.min, props.max]),
        top: getOffsetPercent(props.max + props.min - end, [
          props.min,
          props.max
        ])
      } : {
        left: getOffsetPercent(start2, [props.min, props.max]),
        right: getOffsetPercent(props.max + props.min - end, [
          props.min,
          props.max
        ])
      };
    }
    const handleStartMoving = (x, y) => {
      startValue.value = getValueByCoords(x, y);
      handleChange();
    };
    const handleMoveEnd = () => {
      isDragging.value = false;
    };
    const cls = computed(() => [
      prefixCls,
      {
        [`${prefixCls}-vertical`]: props.direction === "vertical",
        [`${prefixCls}-with-marks`]: Boolean(props.marks)
      }
    ]);
    const trackCls = computed(() => [
      `${prefixCls}-track`,
      {
        [`${prefixCls}-track-disabled`]: mergedDisabled.value,
        [`${prefixCls}-track-vertical`]: props.direction === "vertical"
      }
    ]);
    return {
      prefixCls,
      cls,
      trackCls,
      trackRef,
      computedValue,
      mergedDisabled,
      markList,
      getBtnStyle,
      getBarStyle,
      handleClick,
      handleMoveStart,
      handleEndMoving,
      handleMoveEnd,
      handleStartMoving,
      handleStartChange,
      handleEndChange
    };
  }
});
function _sfc_render156(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_slider_ticks = resolveComponent("slider-ticks");
  const _component_slider_dots = resolveComponent("slider-dots");
  const _component_slider_marks = resolveComponent("slider-marks");
  const _component_slider_button = resolveComponent("slider-button");
  const _component_slider_input = resolveComponent("slider-input");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.cls)
  }, [
    createBaseVNode("div", {
      ref: "trackRef",
      class: normalizeClass(_ctx.trackCls),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
    }, [
      createBaseVNode("div", {
        class: normalizeClass(`${_ctx.prefixCls}-bar`),
        style: normalizeStyle(_ctx.getBarStyle(_ctx.computedValue))
      }, null, 6),
      _ctx.showTicks ? (openBlock(), createBlock(_component_slider_ticks, {
        key: 0,
        value: _ctx.computedValue,
        step: _ctx.step,
        min: _ctx.min,
        max: _ctx.max,
        direction: _ctx.direction
      }, null, 8, ["value", "step", "min", "max", "direction"])) : createCommentVNode("v-if", true),
      _ctx.marks ? (openBlock(), createBlock(_component_slider_dots, {
        key: 1,
        data: _ctx.markList,
        min: _ctx.min,
        max: _ctx.max,
        direction: _ctx.direction
      }, null, 8, ["data", "min", "max", "direction"])) : createCommentVNode("v-if", true),
      _ctx.marks ? (openBlock(), createBlock(_component_slider_marks, {
        key: 2,
        data: _ctx.markList,
        min: _ctx.min,
        max: _ctx.max,
        direction: _ctx.direction
      }, null, 8, ["data", "min", "max", "direction"])) : createCommentVNode("v-if", true),
      _ctx.range ? (openBlock(), createBlock(_component_slider_button, {
        key: 3,
        style: normalizeStyle(_ctx.getBtnStyle(_ctx.computedValue[0])),
        value: _ctx.computedValue[0],
        direction: _ctx.direction,
        disabled: _ctx.mergedDisabled,
        min: _ctx.min,
        max: _ctx.max,
        "format-tooltip": _ctx.formatTooltip,
        "show-tooltip": _ctx.showTooltip,
        onMovestart: _ctx.handleMoveStart,
        onMoving: _ctx.handleStartMoving,
        onMoveend: _ctx.handleMoveEnd
      }, null, 8, ["style", "value", "direction", "disabled", "min", "max", "format-tooltip", "show-tooltip", "onMovestart", "onMoving", "onMoveend"])) : createCommentVNode("v-if", true),
      createVNode(_component_slider_button, {
        style: normalizeStyle(_ctx.getBtnStyle(_ctx.computedValue[1])),
        value: _ctx.computedValue[1],
        direction: _ctx.direction,
        disabled: _ctx.mergedDisabled,
        min: _ctx.min,
        max: _ctx.max,
        "format-tooltip": _ctx.formatTooltip,
        "show-tooltip": _ctx.showTooltip,
        onMovestart: _ctx.handleMoveStart,
        onMoving: _ctx.handleEndMoving,
        onMoveend: _ctx.handleMoveEnd
      }, null, 8, ["style", "value", "direction", "disabled", "min", "max", "format-tooltip", "show-tooltip", "onMovestart", "onMoving", "onMoveend"])
    ], 2),
    _ctx.showInput ? (openBlock(), createBlock(_component_slider_input, {
      key: 0,
      "model-value": _ctx.computedValue,
      min: _ctx.min,
      max: _ctx.max,
      step: _ctx.step,
      range: _ctx.range,
      disabled: _ctx.disabled,
      onStartChange: _ctx.handleStartChange,
      onEndChange: _ctx.handleEndChange
    }, null, 8, ["model-value", "min", "max", "step", "range", "disabled", "onStartChange", "onEndChange"])) : createCommentVNode("v-if", true)
  ], 2);
}
var _Slider = _export_sfc(_sfc_main156, [["render", _sfc_render156]]);

// node_modules/@arco-design/web-vue/es/slider/index.js
var Slider = Object.assign(_Slider, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Slider.name, _Slider);
  }
});

// node_modules/@arco-design/web-vue/es/space/space.js
var _Space = defineComponent({
  name: "Space",
  props: {
    align: {
      type: String
    },
    direction: {
      type: String,
      default: "horizontal"
    },
    size: {
      type: [Number, String, Array],
      default: "small"
    },
    wrap: {
      type: Boolean
    },
    fill: {
      type: Boolean
    }
  },
  setup(props, {
    slots
  }) {
    const prefixCls = getPrefixCls("space");
    const mergedAlign = computed(() => {
      var _a;
      return (_a = props.align) != null ? _a : props.direction === "horizontal" ? "center" : "";
    });
    const cls = computed(() => [prefixCls, {
      [`${prefixCls}-${props.direction}`]: props.direction,
      [`${prefixCls}-align-${mergedAlign.value}`]: mergedAlign.value,
      [`${prefixCls}-wrap`]: props.wrap,
      [`${prefixCls}-fill`]: props.fill
    }]);
    function getMargin(size) {
      if (isNumber(size)) {
        return size;
      }
      switch (size) {
        case "mini":
          return 4;
        case "small":
          return 8;
        case "medium":
          return 16;
        case "large":
          return 24;
        default:
          return 8;
      }
    }
    const getMarginStyle = (isLast) => {
      const style = {};
      const marginRight = `${getMargin(isArray(props.size) ? props.size[0] : props.size)}px`;
      const marginBottom = `${getMargin(isArray(props.size) ? props.size[1] : props.size)}px`;
      if (isLast) {
        return props.wrap ? {
          marginBottom
        } : {};
      }
      if (props.direction === "horizontal") {
        style.marginRight = marginRight;
      }
      if (props.direction === "vertical" || props.wrap) {
        style.marginBottom = marginBottom;
      }
      return style;
    };
    return () => {
      var _a;
      const children = getAllElements((_a = slots.default) == null ? void 0 : _a.call(slots), true).filter((item) => item.type !== Comment);
      return createVNode("div", {
        "class": cls.value
      }, [children.map((child, index3) => {
        var _a2, _b;
        const shouldRenderSplit = slots.split && index3 > 0;
        return createVNode(Fragment, {
          "key": (_a2 = child.key) != null ? _a2 : `item-${index3}`
        }, [shouldRenderSplit && createVNode("div", {
          "class": `${prefixCls}-item-split`,
          "style": getMarginStyle(false)
        }, [(_b = slots.split) == null ? void 0 : _b.call(slots)]), createVNode("div", {
          "class": `${prefixCls}-item`,
          "style": getMarginStyle(index3 === children.length - 1)
        }, [child])]);
      })]);
    };
  }
});

// node_modules/@arco-design/web-vue/es/space/index.js
var Space = Object.assign(_Space, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Space.name, _Space);
  }
});

// node_modules/@arco-design/web-vue/es/split/split.js
function getSizeConfig(size) {
  const numberSize = isString(size) ? parseFloat(size) : size;
  let unit = "";
  if (isNumber(size) || String(numberSize) === size) {
    unit = numberSize > 1 ? "px" : "%";
  } else {
    unit = "px";
  }
  return {
    size: numberSize,
    unit,
    isPx: unit === "px"
  };
}
function getPxSize({
  size,
  defaultSize,
  containerSize
}) {
  const config = getSizeConfig(size != null ? size : defaultSize);
  if (config.isPx) {
    return config.size;
  }
  return config.size * containerSize;
}
function px2percent(numerator, denominator) {
  return parseFloat(numerator) / parseFloat(denominator);
}
var _sfc_main157 = defineComponent({
  name: "Split",
  components: {
    ResizeTrigger
  },
  props: {
    component: {
      type: String,
      default: "div"
    },
    direction: {
      type: String,
      default: "horizontal"
    },
    size: {
      type: [Number, String],
      default: void 0
    },
    defaultSize: {
      type: [Number, String],
      default: 0.5
    },
    min: {
      type: [Number, String]
    },
    max: {
      type: [Number, String]
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  emits: {
    "moveStart": (ev) => true,
    "moving": (ev) => true,
    "moveEnd": (ev) => true,
    "update:size": (size) => true
  },
  setup(props, { emit }) {
    const { direction, size: propSize, defaultSize, min, max } = toRefs(props);
    const triggerSize = ref(0);
    const wrapperRef = ref();
    const prefixCls = getPrefixCls("split");
    const [size, setSize] = useMergeState(defaultSize.value, reactive({
      value: propSize
    }));
    const sizeConfig = computed(() => getSizeConfig(size.value));
    const isHorizontal2 = computed(() => direction.value === "horizontal");
    const classNames = computed(() => [
      prefixCls,
      {
        [`${prefixCls}-horizontal`]: isHorizontal2.value,
        [`${prefixCls}-vertical`]: !isHorizontal2.value
      }
    ]);
    const firstPaneStyles = computed(() => {
      const { size: numberSize, unit, isPx } = sizeConfig.value;
      const baseVal = isPx ? numberSize : numberSize * 100;
      return {
        flex: `0 0 calc(${baseVal}${unit} - ${triggerSize.value / 2}px)`
      };
    });
    const record = {
      startPageX: 0,
      startPageY: 0,
      startContainerSize: 0,
      startSize: 0
    };
    async function getContainerSize() {
      const getSize = () => {
        var _a, _b;
        return isHorizontal2.value ? (_a = wrapperRef.value) == null ? void 0 : _a.clientWidth : ((_b = wrapperRef.value) == null ? void 0 : _b.clientHeight) || 0;
      };
      if (!wrapperRef.value || getSize()) {
        await nextTick();
      }
      return getSize();
    }
    function updateSize(newPxSize, containerSize) {
      if (!containerSize) {
        return;
      }
      const newSize = sizeConfig.value.isPx ? `${newPxSize}px` : px2percent(newPxSize, containerSize);
      if (size.value === newSize)
        return;
      setSize(newSize);
      emit("update:size", newSize);
    }
    function getLegalPxSize(size2, containerSize) {
      const pxSize = getPxSize({
        size: size2,
        containerSize
      });
      const minPxSize = getPxSize({
        size: min.value,
        defaultSize: "0px",
        containerSize
      });
      const maxPxSize = getPxSize({
        size: max.value,
        defaultSize: `${containerSize}px`,
        containerSize
      });
      let legalPxSize = pxSize;
      legalPxSize = Math.max(legalPxSize, minPxSize);
      legalPxSize = Math.min(legalPxSize, maxPxSize);
      return legalPxSize;
    }
    function getNewPxSize({
      startContainerSize,
      startSize,
      startPosition,
      endPosition
    }) {
      const startPxSize = getPxSize({
        size: startSize,
        containerSize: startContainerSize
      });
      return getLegalPxSize(`${startPxSize + (endPosition - startPosition)}px`, startContainerSize);
    }
    function onMoving(e2) {
      emit("moving", e2);
      const newPxSize = isHorizontal2.value ? getNewPxSize({
        startContainerSize: record.startContainerSize,
        startSize: record.startSize,
        startPosition: record.startPageX,
        endPosition: e2.pageX
      }) : getNewPxSize({
        startContainerSize: record.startContainerSize,
        startSize: record.startSize,
        startPosition: record.startPageY,
        endPosition: e2.pageY
      });
      updateSize(newPxSize, record.startContainerSize);
    }
    function onMovingEnd(e2) {
      off(window, "mousemove", onMoving);
      off(window, "mouseup", onMovingEnd);
      off(window, "contextmenu", onMovingEnd);
      document.body.style.cursor = "default";
      emit("moveEnd", e2);
    }
    async function onMoveStart(e2) {
      emit("moveStart", e2);
      record.startPageX = e2.pageX;
      record.startPageY = e2.pageY;
      record.startContainerSize = await getContainerSize();
      record.startSize = size.value;
      on(window, "mousemove", onMoving);
      on(window, "mouseup", onMovingEnd);
      on(window, "contextmenu", onMovingEnd);
      document.body.style.cursor = isHorizontal2.value ? "col-resize" : "row-resize";
    }
    function onTriggerResize(entry) {
      const { width, height } = entry.contentRect;
      triggerSize.value = isHorizontal2.value ? width : height;
    }
    onMounted(async () => {
      const containerSize = await getContainerSize();
      const fixedPxSize = getLegalPxSize(size.value, containerSize);
      updateSize(fixedPxSize, containerSize);
    });
    return {
      prefixCls,
      classNames,
      isHorizontal: isHorizontal2,
      wrapperRef,
      onMoveStart,
      onTriggerResize,
      firstPaneStyles
    };
  }
});
function _sfc_render157(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ResizeTrigger = resolveComponent("ResizeTrigger");
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.component), {
    ref: "wrapperRef",
    class: normalizeClass(_ctx.classNames)
  }, {
    default: withCtx(() => [
      createBaseVNode("div", {
        class: normalizeClass([`${_ctx.prefixCls}-pane`, `${_ctx.prefixCls}-pane-first`]),
        style: normalizeStyle(_ctx.firstPaneStyles)
      }, [
        renderSlot(_ctx.$slots, "first")
      ], 6),
      !_ctx.disabled ? (openBlock(), createBlock(_component_ResizeTrigger, {
        key: 0,
        "prefix-cls": `${_ctx.prefixCls}-trigger`,
        direction: _ctx.isHorizontal ? "vertical" : "horizontal",
        onMousedown: _ctx.onMoveStart,
        onResize: _ctx.onTriggerResize
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "resize-trigger")
        ]),
        icon: withCtx(() => [
          renderSlot(_ctx.$slots, "resize-trigger-icon")
        ]),
        _: 3
      }, 8, ["prefix-cls", "direction", "onMousedown", "onResize"])) : createCommentVNode("v-if", true),
      createBaseVNode("div", {
        class: normalizeClass([`${_ctx.prefixCls}-pane`, `${_ctx.prefixCls}-pane-second`])
      }, [
        renderSlot(_ctx.$slots, "second")
      ], 2)
    ]),
    _: 3
  }, 8, ["class"]);
}
var _Split = _export_sfc(_sfc_main157, [["render", _sfc_render157]]);

// node_modules/@arco-design/web-vue/es/split/index.js
var Split = Object.assign(_Split, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Split.name, _Split);
  }
});

// node_modules/@arco-design/web-vue/es/statistic/statistic.js
var import_dayjs2 = __toESM(require_dayjs_min());
var _sfc_main158 = defineComponent({
  name: "Statistic",
  props: {
    title: String,
    value: {
      type: [Number, Object]
    },
    format: {
      type: String,
      default: "HH:mm:ss"
    },
    extra: String,
    start: {
      type: Boolean,
      default: true
    },
    precision: {
      type: Number,
      default: 0
    },
    separator: String,
    showGroupSeparator: {
      type: Boolean,
      default: false
    },
    animation: {
      type: Boolean,
      default: false
    },
    animationDuration: {
      type: Number,
      default: 2e3
    },
    valueFrom: {
      type: Number,
      default: void 0
    },
    placeholder: {
      type: String
    },
    valueStyle: {
      type: Object
    }
  },
  setup(props) {
    var _a;
    const prefixCls = getPrefixCls("statistic");
    const numberValue = computed(() => {
      if (isNumber(props.value)) {
        return props.value;
      }
      return 0;
    });
    const innerValue = ref((_a = props.valueFrom) != null ? _a : props.value);
    const tween = ref(null);
    const { value } = toRefs(props);
    const showPlaceholder = computed(() => isUndefined(props.value));
    const animation = (from = ((_b) => (_b = props.valueFrom) != null ? _b : 0)(), to = numberValue.value) => {
      var _a2;
      if (from !== to) {
        tween.value = new b_tween_es_default({
          from: {
            value: from
          },
          to: {
            value: to
          },
          duration: props.animationDuration,
          easing: "quartOut",
          onUpdate: (keys) => {
            innerValue.value = keys.value;
          },
          onFinish: () => {
            innerValue.value = to;
          }
        });
        (_a2 = tween.value) == null ? void 0 : _a2.start();
      }
    };
    const formatValue = computed(() => {
      let _value = innerValue.value;
      if (isNumber(_value)) {
        if (isNumber(props.precision)) {
          _value = index_es_default.round(_value, props.precision).toFixed(props.precision);
        }
        const splitValue = String(_value).split(".");
        const integer = props.showGroupSeparator ? Number(splitValue[0]).toLocaleString("en-US") : splitValue[0];
        const decimal = splitValue[1];
        return {
          isNumber: true,
          integer,
          decimal
        };
      }
      if (props.format) {
        _value = (0, import_dayjs2.default)(_value).format(props.format);
      }
      return {
        isNumber: false,
        value: _value
      };
    });
    onMounted(() => {
      if (props.animation && props.start) {
        animation();
      }
    });
    watch(() => props.start, (value2) => {
      if (value2 && props.animation && !tween.value) {
        animation();
      }
    });
    watch(value, (value2) => {
      var _a2;
      if (tween.value) {
        (_a2 = tween.value) == null ? void 0 : _a2.stop();
        tween.value = null;
      }
      innerValue.value = value2;
      if (props.animation && props.start) {
        animation();
      }
    });
    return {
      prefixCls,
      showPlaceholder,
      formatValue
    };
  }
});
var _hoisted_169 = { key: 0 };
function _sfc_render158(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.prefixCls)
  }, [
    _ctx.title || _ctx.$slots.title ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(`${_ctx.prefixCls}-title`)
    }, [
      renderSlot(_ctx.$slots, "title", {}, () => [
        createTextVNode(toDisplayString(_ctx.title), 1)
      ])
    ], 2)) : createCommentVNode("v-if", true),
    createBaseVNode("div", {
      class: normalizeClass(`${_ctx.prefixCls}-content`)
    }, [
      createBaseVNode("div", {
        class: normalizeClass(`${_ctx.prefixCls}-value`),
        style: normalizeStyle(_ctx.valueStyle)
      }, [
        _ctx.showPlaceholder ? (openBlock(), createElementBlock("span", _hoisted_169, toDisplayString(_ctx.placeholder), 1)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          _ctx.$slots.prefix ? (openBlock(), createElementBlock("span", {
            key: 0,
            class: normalizeClass(`${_ctx.prefixCls}-prefix`)
          }, [
            renderSlot(_ctx.$slots, "prefix")
          ], 2)) : createCommentVNode("v-if", true),
          _ctx.formatValue.isNumber ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            createBaseVNode("span", {
              class: normalizeClass(`${_ctx.prefixCls}-value-integer`)
            }, toDisplayString(_ctx.formatValue.integer), 3),
            _ctx.formatValue.decimal ? (openBlock(), createElementBlock("span", {
              key: 0,
              class: normalizeClass(`${_ctx.prefixCls}-value-decimal`)
            }, " ." + toDisplayString(_ctx.formatValue.decimal), 3)) : createCommentVNode("v-if", true)
          ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
            createTextVNode(toDisplayString(_ctx.formatValue.value), 1)
          ], 2112)),
          _ctx.$slots.suffix ? (openBlock(), createElementBlock("span", {
            key: 3,
            class: normalizeClass(`${_ctx.prefixCls}-suffix`)
          }, [
            renderSlot(_ctx.$slots, "suffix")
          ], 2)) : createCommentVNode("v-if", true)
        ], 64))
      ], 6),
      _ctx.extra || _ctx.$slots.extra ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(`${_ctx.prefixCls}-extra`)
      }, [
        renderSlot(_ctx.$slots, "extra", {}, () => [
          createTextVNode(toDisplayString(_ctx.extra), 1)
        ])
      ], 2)) : createCommentVNode("v-if", true)
    ], 2)
  ], 2);
}
var _Statistic = _export_sfc(_sfc_main158, [["render", _sfc_render158]]);

// node_modules/@arco-design/web-vue/es/statistic/countdown.js
var import_dayjs3 = __toESM(require_dayjs_min());

// node_modules/@arco-design/web-vue/es/statistic/utils.js
var units = [
  ["Y", 1e3 * 60 * 60 * 24 * 365],
  ["M", 1e3 * 60 * 60 * 24 * 30],
  ["D", 1e3 * 60 * 60 * 24],
  ["H", 1e3 * 60 * 60],
  ["m", 1e3 * 60],
  ["s", 1e3],
  ["S", 1]
];
function getDateString(millisecond, format) {
  let leftMillisecond = millisecond;
  return units.reduce((current, [name, unit]) => {
    if (current.indexOf(name) !== -1) {
      const value = Math.floor(leftMillisecond / unit);
      leftMillisecond -= value * unit;
      return current.replace(new RegExp(`${name}+`, "g"), (match) => {
        const len = match.length;
        return String(value).padStart(len, "0");
      });
    }
    return current;
  }, format);
}

// node_modules/@arco-design/web-vue/es/statistic/countdown.js
var _sfc_main159 = defineComponent({
  name: "Countdown",
  props: {
    title: String,
    value: {
      type: Number,
      default: () => Date.now() + 3e5
    },
    now: {
      type: Number,
      default: () => Date.now()
    },
    format: {
      type: String,
      default: "HH:mm:ss"
    },
    start: {
      type: Boolean,
      default: true
    },
    valueStyle: {
      type: Object
    }
  },
  emits: {
    finish: () => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("statistic");
    const { start: start2, value, now, format } = toRefs(props);
    const displayValue = ref(getDateString(Math.max((0, import_dayjs3.default)(props.value).diff((0, import_dayjs3.default)(props.now), "millisecond"), 0), props.format));
    watch([value, now, format], () => {
      const _value = getDateString(Math.max((0, import_dayjs3.default)(props.value).diff((0, import_dayjs3.default)(props.now), "millisecond"), 0), props.format);
      if (_value !== displayValue.value) {
        displayValue.value = _value;
      }
    });
    const timer = ref(0);
    const stopTimer = () => {
      if (timer.value) {
        window.clearInterval(timer.value);
        timer.value = 0;
      }
    };
    const startTimer = () => {
      if ((0, import_dayjs3.default)(props.value).valueOf() < Date.now()) {
        return;
      }
      timer.value = window.setInterval(() => {
        const _value = (0, import_dayjs3.default)(props.value).diff((0, import_dayjs3.default)(), "millisecond");
        if (_value <= 0) {
          stopTimer();
          emit("finish");
        }
        displayValue.value = getDateString(Math.max(_value, 0), props.format);
      }, 1e3 / 30);
    };
    onMounted(() => {
      if (props.start) {
        startTimer();
      }
    });
    onBeforeUnmount(() => {
      stopTimer();
    });
    watch(start2, (value2) => {
      if (value2 && !timer.value) {
        startTimer();
      }
    });
    return {
      prefixCls,
      displayValue
    };
  }
});
function _sfc_render159(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass([`${_ctx.prefixCls}`, `${_ctx.prefixCls}-countdown`])
  }, [
    _ctx.title || _ctx.$slots.title ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(`${_ctx.prefixCls}-title`)
    }, [
      renderSlot(_ctx.$slots, "title", {}, () => [
        createTextVNode(toDisplayString(_ctx.title), 1)
      ])
    ], 2)) : createCommentVNode("v-if", true),
    createBaseVNode("div", {
      class: normalizeClass(`${_ctx.prefixCls}-content`)
    }, [
      createBaseVNode("div", {
        class: normalizeClass(`${_ctx.prefixCls}-value`),
        style: normalizeStyle(_ctx.valueStyle)
      }, toDisplayString(_ctx.displayValue), 7)
    ], 2)
  ], 2);
}
var Countdown = _export_sfc(_sfc_main159, [["render", _sfc_render159]]);

// node_modules/@arco-design/web-vue/es/statistic/index.js
var Statistic = Object.assign(_Statistic, {
  Countdown,
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Statistic.name, _Statistic);
    app.component(componentPrefix + Countdown.name, Countdown);
  }
});

// node_modules/@arco-design/web-vue/es/steps/context.js
var stepsInjectionKey = Symbol("ArcoSteps");

// node_modules/@arco-design/web-vue/es/steps/steps.js
var _sfc_main160 = defineComponent({
  name: "Steps",
  props: {
    type: {
      type: String,
      default: "default"
    },
    direction: {
      type: String,
      default: "horizontal"
    },
    labelPlacement: {
      type: String,
      default: "horizontal"
    },
    current: {
      type: Number,
      default: void 0
    },
    defaultCurrent: {
      type: Number,
      default: 1
    },
    status: {
      type: String,
      default: "process"
    },
    lineLess: {
      type: Boolean,
      default: false
    },
    small: {
      type: Boolean,
      default: false
    },
    changeable: {
      type: Boolean,
      default: false
    }
  },
  emits: {
    "update:current": (step) => true,
    "change": (step, ev) => true
  },
  setup(props, { emit, slots }) {
    const { type, lineLess } = toRefs(props);
    const prefixCls = getPrefixCls("steps");
    const _current = ref(props.defaultCurrent);
    const computedCurrent = computed(() => {
      var _a;
      return (_a = props.current) != null ? _a : _current.value;
    });
    const direction = computed(() => ["navigation", "arrow"].includes(props.type) ? "horizontal" : props.direction);
    const labelPlacement = computed(() => {
      if (props.type === "dot") {
        return direction.value === "vertical" ? "horizontal" : "vertical";
      }
      if (props.type === "navigation") {
        return "horizontal";
      }
      return props.labelPlacement;
    });
    const getStatus = (step) => {
      if (step < computedCurrent.value) {
        return "finish";
      }
      if (step > computedCurrent.value) {
        return "wait";
      }
      return props.status;
    };
    const handleClick = (step, e2) => {
      if (props.changeable) {
        _current.value = step;
        emit("update:current", step);
        emit("change", step, e2);
      }
    };
    const stepMap = reactive(/* @__PURE__ */ new Map());
    const errorSteps = computed(() => Array.from(stepMap.values()).filter((item) => item.status === "error").map((item) => item.step));
    const addItem = (step, data) => {
      stepMap.set(step, data);
    };
    const removeItem = (step) => {
      stepMap.delete(step);
    };
    const cls = computed(() => [
      prefixCls,
      `${prefixCls}-${direction.value}`,
      `${prefixCls}-label-${labelPlacement.value}`,
      `${prefixCls}-mode-${type.value}`,
      {
        [`${prefixCls}-changeable`]: props.changeable,
        [`${prefixCls}-size-small`]: props.small && props.type !== "dot",
        [`${prefixCls}-line-less`]: lineLess.value
      }
    ]);
    provide(stepsInjectionKey, reactive({
      type,
      direction,
      labelPlacement,
      lineLess,
      current: computedCurrent,
      errorSteps,
      getStatus,
      addItem,
      removeItem,
      onClick: handleClick,
      parentCls: prefixCls
    }));
    return {
      cls
    };
  }
});
function _sfc_render160(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.cls)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
var _Steps = _export_sfc(_sfc_main160, [["render", _sfc_render160]]);

// node_modules/@arco-design/web-vue/es/steps/step.js
var _sfc_main161 = defineComponent({
  name: "Step",
  components: {
    IconCheck: IconCheck2,
    IconClose
  },
  props: {
    title: String,
    description: String,
    status: {
      type: String
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  setup(props) {
    const prefixCls = getPrefixCls("steps-item");
    const instance = getCurrentInstance();
    const iconCls = getPrefixCls("steps-icon");
    const stepsCtx = inject(stepsInjectionKey, void 0);
    const type = computed(() => {
      var _a;
      return (_a = stepsCtx == null ? void 0 : stepsCtx.type) != null ? _a : "default";
    });
    const itemRef = ref();
    const { computedIndex } = useIndex({
      itemRef,
      selector: `.${prefixCls}`,
      parentClassName: stepsCtx == null ? void 0 : stepsCtx.parentCls
    });
    const stepNumber = computed(() => computedIndex.value + 1);
    const computedStatus = computed(() => {
      var _a, _b;
      return (_b = (_a = props.status) != null ? _a : stepsCtx == null ? void 0 : stepsCtx.getStatus(stepNumber.value)) != null ? _b : "process";
    });
    const nextStepError = computed(() => {
      var _a;
      return (_a = stepsCtx == null ? void 0 : stepsCtx.errorSteps.includes(stepNumber.value + 1)) != null ? _a : false;
    });
    if (instance) {
      stepsCtx == null ? void 0 : stepsCtx.addItem(instance.uid, reactive({
        step: stepNumber,
        status: computedStatus
      }));
    }
    onBeforeUnmount(() => {
      if (instance) {
        stepsCtx == null ? void 0 : stepsCtx.removeItem(instance.uid);
      }
    });
    const showTail = computed(() => !(stepsCtx == null ? void 0 : stepsCtx.lineLess) && ((stepsCtx == null ? void 0 : stepsCtx.labelPlacement) === "vertical" || (stepsCtx == null ? void 0 : stepsCtx.direction) === "vertical"));
    const handleClick = (ev) => {
      if (!props.disabled) {
        stepsCtx == null ? void 0 : stepsCtx.onClick(stepNumber.value, ev);
      }
    };
    const cls = computed(() => [
      prefixCls,
      `${prefixCls}-${computedStatus.value}`,
      {
        [`${prefixCls}-active`]: stepNumber.value === (stepsCtx == null ? void 0 : stepsCtx.current),
        [`${prefixCls}-next-error`]: nextStepError.value,
        [`${prefixCls}-disabled`]: props.disabled
      }
    ]);
    return {
      prefixCls,
      iconCls,
      cls,
      itemRef,
      showTail,
      stepNumber,
      computedStatus,
      type,
      handleClick
    };
  }
});
function _sfc_render161(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_check = resolveComponent("icon-check");
  const _component_icon_close = resolveComponent("icon-close");
  return openBlock(), createElementBlock("div", {
    ref: "itemRef",
    class: normalizeClass(_ctx.cls),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    _ctx.showTail ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(`${_ctx.prefixCls}-tail`)
    }, null, 2)) : createCommentVNode("v-if", true),
    _ctx.type !== "arrow" ? (openBlock(), createElementBlock("div", {
      key: 1,
      class: normalizeClass(`${_ctx.prefixCls}-node`)
    }, [
      renderSlot(_ctx.$slots, "node", {
        step: _ctx.stepNumber,
        status: _ctx.computedStatus
      }, () => [
        _ctx.type !== "dot" ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(_ctx.iconCls)
        }, [
          renderSlot(_ctx.$slots, "icon", {
            step: _ctx.stepNumber,
            status: _ctx.computedStatus
          }, () => [
            _ctx.computedStatus === "finish" ? (openBlock(), createBlock(_component_icon_check, { key: 0 })) : _ctx.computedStatus === "error" ? (openBlock(), createBlock(_component_icon_close, { key: 1 })) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
              createTextVNode(toDisplayString(_ctx.stepNumber), 1)
            ], 2112))
          ])
        ], 2)) : createCommentVNode("v-if", true)
      ])
    ], 2)) : createCommentVNode("v-if", true),
    createBaseVNode("div", {
      class: normalizeClass(`${_ctx.prefixCls}-content`)
    }, [
      createBaseVNode("div", {
        class: normalizeClass(`${_ctx.prefixCls}-title`)
      }, [
        renderSlot(_ctx.$slots, "default", {}, () => [
          createTextVNode(toDisplayString(_ctx.title), 1)
        ])
      ], 2),
      _ctx.description || _ctx.$slots.description ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(`${_ctx.prefixCls}-description`)
      }, [
        renderSlot(_ctx.$slots, "description", {}, () => [
          createTextVNode(toDisplayString(_ctx.description), 1)
        ])
      ], 2)) : createCommentVNode("v-if", true)
    ], 2)
  ], 2);
}
var Step = _export_sfc(_sfc_main161, [["render", _sfc_render161]]);

// node_modules/@arco-design/web-vue/es/steps/index.js
var Steps = Object.assign(_Steps, {
  Step,
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Steps.name, _Steps);
    app.component(componentPrefix + Step.name, Step);
  }
});

// node_modules/@arco-design/web-vue/es/switch/switch.js
var _sfc_main162 = defineComponent({
  name: "Switch",
  components: {
    IconLoading
  },
  props: {
    modelValue: {
      type: [String, Number, Boolean],
      default: void 0
    },
    defaultChecked: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    loading: {
      type: Boolean,
      default: false
    },
    type: {
      type: String,
      default: "circle"
    },
    size: {
      type: String
    },
    checkedValue: {
      type: [String, Number, Boolean],
      default: true
    },
    uncheckedValue: {
      type: [String, Number, Boolean],
      default: false
    },
    checkedColor: {
      type: String
    },
    uncheckedColor: {
      type: String
    },
    beforeChange: {
      type: Function
    }
  },
  emits: {
    "update:modelValue": (value) => true,
    "change": (value, ev) => true,
    "focus": (ev) => true,
    "blur": (ev) => true
  },
  setup(props, { emit }) {
    const { disabled, size } = toRefs(props);
    const prefixCls = getPrefixCls("switch");
    const { mergedSize: configSize } = useSize(size);
    const { mergedDisabled, mergedSize, eventHandlers } = useFormItem({
      disabled,
      size: configSize
    });
    const _checked = ref(props.defaultChecked ? props.checkedValue : props.uncheckedValue);
    const computedCheck = computed(() => {
      var _a;
      return ((_a = props.modelValue) != null ? _a : _checked.value) === props.checkedValue;
    });
    const _loading = ref(props.loading);
    const computedLoading = computed(() => _loading.value || props.loading);
    const handleChange = (checked, ev) => {
      var _a, _b;
      _checked.value = checked ? props.checkedValue : props.uncheckedValue;
      emit("update:modelValue", _checked.value);
      emit("change", _checked.value, ev);
      (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onChange) == null ? void 0 : _b.call(_a, ev);
    };
    const handleClick = async (ev) => {
      if (computedLoading.value || mergedDisabled.value) {
        return;
      }
      const checked = !computedCheck.value;
      const checkedValue = checked ? props.checkedValue : props.uncheckedValue;
      const shouldChange = props.beforeChange;
      if (isFunction(shouldChange)) {
        _loading.value = true;
        try {
          const result = await shouldChange(checkedValue);
          if (result != null ? result : true) {
            handleChange(checked, ev);
          }
        } catch (error) {
        } finally {
          _loading.value = false;
        }
      } else {
        handleChange(checked, ev);
      }
    };
    const handleFocus = (ev) => {
      var _a, _b;
      emit("focus", ev);
      (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onFocus) == null ? void 0 : _b.call(_a, ev);
    };
    const handleBlur = (ev) => {
      var _a, _b;
      emit("blur", ev);
      (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onBlur) == null ? void 0 : _b.call(_a, ev);
    };
    const cls = computed(() => [
      prefixCls,
      `${prefixCls}-type-${props.type}`,
      {
        [`${prefixCls}-small`]: mergedSize.value === "small" || mergedSize.value === "mini",
        [`${prefixCls}-checked`]: computedCheck.value,
        [`${prefixCls}-disabled`]: mergedDisabled.value,
        [`${prefixCls}-loading`]: computedLoading.value,
        [`${prefixCls}-custom-color`]: props.type === "line" && (props.checkedColor || props.uncheckedColor)
      }
    ]);
    const buttonStyle = computed(() => {
      if (computedCheck.value && props.checkedColor) {
        return props.type === "line" ? { "--custom-color": props.checkedColor } : { backgroundColor: props.checkedColor };
      }
      if (!computedCheck.value && props.uncheckedColor) {
        return props.type === "line" ? { "--custom-color": props.uncheckedColor } : { backgroundColor: props.uncheckedColor };
      }
      return void 0;
    });
    return {
      prefixCls,
      cls,
      mergedDisabled,
      buttonStyle,
      computedCheck,
      computedLoading,
      handleClick,
      handleFocus,
      handleBlur
    };
  }
});
var _hoisted_170 = ["aria-checked", "disabled"];
function _sfc_render162(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_loading = resolveComponent("icon-loading");
  return openBlock(), createElementBlock("button", {
    type: "button",
    role: "switch",
    "aria-checked": _ctx.computedCheck,
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.buttonStyle),
    disabled: _ctx.mergedDisabled,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args)),
    onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
    onBlur: _cache[2] || (_cache[2] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args))
  }, [
    createBaseVNode("span", {
      class: normalizeClass(`${_ctx.prefixCls}-handle`)
    }, [
      createBaseVNode("span", {
        class: normalizeClass(`${_ctx.prefixCls}-handle-icon`)
      }, [
        _ctx.computedLoading ? (openBlock(), createBlock(_component_icon_loading, { key: 0 })) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          _ctx.computedCheck ? renderSlot(_ctx.$slots, "checked-icon", { key: 0 }) : renderSlot(_ctx.$slots, "unchecked-icon", { key: 1 })
        ], 2112))
      ], 2)
    ], 2),
    createCommentVNode("  prettier-ignore  "),
    _ctx.type !== "line" && _ctx.size !== "small" && (_ctx.$slots.checked || _ctx.$slots.unchecked) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
      createBaseVNode("span", {
        class: normalizeClass(`${_ctx.prefixCls}-text-holder`)
      }, [
        _ctx.computedCheck ? renderSlot(_ctx.$slots, "checked", { key: 0 }) : renderSlot(_ctx.$slots, "unchecked", { key: 1 })
      ], 2),
      createBaseVNode("span", {
        class: normalizeClass(`${_ctx.prefixCls}-text`)
      }, [
        _ctx.computedCheck ? renderSlot(_ctx.$slots, "checked", { key: 0 }) : renderSlot(_ctx.$slots, "unchecked", { key: 1 })
      ], 2)
    ], 64)) : createCommentVNode("v-if", true)
  ], 46, _hoisted_170);
}
var _Switch = _export_sfc(_sfc_main162, [["render", _sfc_render162]]);

// node_modules/@arco-design/web-vue/es/switch/index.js
var Switch = Object.assign(_Switch, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Switch.name, _Switch);
  }
});

// node_modules/@arco-design/web-vue/es/table/utils.js
var __defProp50 = Object.defineProperty;
var __defProps23 = Object.defineProperties;
var __getOwnPropDescs23 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols50 = Object.getOwnPropertySymbols;
var __hasOwnProp50 = Object.prototype.hasOwnProperty;
var __propIsEnum50 = Object.prototype.propertyIsEnumerable;
var __defNormalProp50 = (obj, key, value) => key in obj ? __defProp50(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues50 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp50.call(b, prop))
      __defNormalProp50(a, prop, b[prop]);
  if (__getOwnPropSymbols50)
    for (var prop of __getOwnPropSymbols50(b)) {
      if (__propIsEnum50.call(b, prop))
        __defNormalProp50(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps23 = (a, b) => __defProps23(a, __getOwnPropDescs23(b));
var getDataColumnsNumber = (columns) => {
  let count = 0;
  const travelColumns = (columns2) => {
    if (isArray(columns2) && columns2.length > 0) {
      for (const item of columns2) {
        if (!item.children) {
          count += 1;
        } else {
          travelColumns(item.children);
        }
      }
    }
  };
  travelColumns(columns);
  return count;
};
var getTotalHeaderRows = (columns) => {
  let count = 0;
  if (isArray(columns) && columns.length > 0) {
    count = 1;
    for (const item of columns) {
      if (item.children) {
        const depth = getTotalHeaderRows(item.children);
        if (depth > 0) {
          count = Math.max(count, depth + 1);
        }
      }
    }
  }
  return count;
};
var setParentFixed = (column, fixed) => {
  let { parent } = column;
  while (parent) {
    if (parent.fixed === fixed) {
      if (fixed === "left") {
        parent.isLastLeftFixed = true;
      } else {
        parent.isFirstRightFixed = true;
      }
    }
    parent = parent.parent;
  }
};
var getGroupColumns = (columns, columnMap) => {
  const totalHeaderRows = getTotalHeaderRows(columns);
  columnMap.clear();
  const dataColumns = [];
  const groupColumns = [...Array(totalHeaderRows)].map(() => []);
  let lastLeftFixedIndex;
  let firstRightFixedIndex;
  const travelColumns = (columns2, {
    level = 0,
    parent,
    fixed
  } = {}) => {
    var _a;
    for (const item of columns2) {
      const cell = __spreadProps23(__spreadValues50({}, item), { parent });
      if (isArray(cell.children)) {
        const colSpan = getDataColumnsNumber(cell.children);
        if (colSpan > 1) {
          cell.colSpan = colSpan;
        }
        groupColumns[level].push(cell);
        travelColumns(cell.children, {
          level: level + 1,
          parent: cell,
          fixed: cell.fixed
        });
      } else {
        const rowSpan = totalHeaderRows - level;
        if (rowSpan > 1) {
          cell.rowSpan = rowSpan;
        }
        if (fixed || cell.fixed) {
          cell.fixed = (_a = cell.fixed) != null ? _a : fixed;
          if (cell.fixed === "left") {
            lastLeftFixedIndex = dataColumns.length;
          } else if (isUndefined(firstRightFixedIndex)) {
            firstRightFixedIndex = dataColumns.length;
          }
        }
        if (isUndefined(cell.dataIndex) || isNull(cell.dataIndex)) {
          cell.dataIndex = `__arco_data_index_${dataColumns.length}`;
        }
        columnMap.set(cell.dataIndex, cell);
        dataColumns.push(cell);
        groupColumns[level].push(cell);
      }
    }
  };
  travelColumns(columns);
  if (!isUndefined(lastLeftFixedIndex)) {
    dataColumns[lastLeftFixedIndex].isLastLeftFixed = true;
    setParentFixed(dataColumns[lastLeftFixedIndex], "left");
  }
  if (!isUndefined(firstRightFixedIndex)) {
    dataColumns[firstRightFixedIndex].isFirstRightFixed = true;
    setParentFixed(dataColumns[firstRightFixedIndex], "right");
  }
  return { dataColumns, groupColumns };
};
var getOperationColumnIndex = (operations, name) => {
  for (let i2 = 0; i2 < operations.length; i2++) {
    if (operations[i2].name === name) {
      return i2;
    }
  }
  return -1;
};
var getOperationFixedNumber = (column, operations) => {
  var _a;
  const index3 = getOperationColumnIndex(operations, column.name);
  if (index3 <= 0) {
    return 0;
  }
  let count = 0;
  const _operations = operations.slice(0, index3);
  for (const item of _operations) {
    count += (_a = item.width) != null ? _a : 0;
  }
  return count;
};
var getFirstDataColumn = (column) => {
  if (column.children && column.children.length > 0)
    return getFirstDataColumn(column.children[0]);
  return column;
};
var getLastDataColumn = (column) => {
  if (column.children && column.children.length > 0)
    return getFirstDataColumn(column.children[column.children.length - 1]);
  return column;
};
var getFixedNumber = (column, {
  dataColumns,
  operations
}) => {
  var _a, _b;
  let count = 0;
  if (column.fixed === "left") {
    for (const item of operations) {
      count += (_a = item.width) != null ? _a : 40;
    }
    const first = getFirstDataColumn(column);
    for (const item of dataColumns) {
      if (first.dataIndex === item.dataIndex) {
        break;
      }
      count += (_b = item.width) != null ? _b : 0;
    }
    return count;
  }
  const last = getLastDataColumn(column);
  for (let i2 = dataColumns.length - 1; i2 > 0; i2--) {
    const item = dataColumns[i2];
    if (last.dataIndex === item.dataIndex) {
      break;
    }
    if (item.fixed === "right") {
      count += item.width;
    }
  }
  return count;
};
var getOperationFixedCls = (prefixCls, column) => {
  if (column.fixed) {
    return [
      `${prefixCls}-col-fixed-left`,
      {
        [`${prefixCls}-col-fixed-left-last`]: column.isLastLeftFixed
      }
    ];
  }
  return [];
};
var getFixedCls = (prefixCls, column) => {
  if (column.fixed === "left") {
    return [
      `${prefixCls}-col-fixed-left`,
      {
        [`${prefixCls}-col-fixed-left-last`]: column.isLastLeftFixed
      }
    ];
  }
  if (column.fixed === "right") {
    return [
      `${prefixCls}-col-fixed-right`,
      {
        [`${prefixCls}-col-fixed-right-first`]: column.isFirstRightFixed
      }
    ];
  }
  return [];
};
var getStyle2 = (column, {
  dataColumns,
  operations
}) => {
  if (column.fixed) {
    const offset = `${getFixedNumber(column, { dataColumns, operations })}px`;
    if (column.fixed === "left") {
      return {
        left: offset
      };
    }
    return {
      right: offset
    };
  }
  return {};
};
var getOperationStyle = (column, operations) => {
  if (column.fixed) {
    return {
      left: `${getOperationFixedNumber(column, operations)}px`
    };
  }
  return {};
};
var spliceFromPath = (data, path, item) => {
  var _a;
  let parent = data;
  for (let i2 = 0; i2 < path.length; i2++) {
    const index3 = path[i2];
    const isLast = i2 >= path.length - 1;
    if (isLast) {
      if (item) {
        parent.splice(index3, 0, item);
      } else {
        return parent.splice(index3, 1)[0];
      }
    }
    parent = (_a = parent[index3].children) != null ? _a : [];
  }
  return void 0;
};
var getLeafKeys = (record) => {
  const keys = [];
  if (record.children) {
    for (const item of record.children) {
      if (item.isLeaf) {
        keys.push(item.key);
      } else {
        keys.push(...getLeafKeys(item));
      }
    }
  }
  return keys;
};
var getSelectionStatus = (selectedRowKeys, leafKeys) => {
  let checked = false;
  let indeterminate = false;
  const selectedLeafKeys = leafKeys.filter((key) => selectedRowKeys.includes(key));
  if (selectedLeafKeys.length > 0) {
    if (selectedLeafKeys.length >= leafKeys.length) {
      checked = true;
    } else {
      indeterminate = true;
    }
  }
  return {
    checked,
    indeterminate
  };
};

// node_modules/@arco-design/web-vue/es/_utils/array.js
var union = (target3, source, difference = false) => {
  return difference ? target3.filter((item) => !source.includes(item)) : Array.from(new Set(target3.concat(source)));
};
var getReverse = (array) => {
  const result = [];
  for (let i2 = 0; i2 < array.length; i2++) {
    result[i2] = array[array.length - 1 - i2];
  }
  return result;
};

// node_modules/@arco-design/web-vue/es/table/hooks/use-row-selection.js
var useRowSelection = ({
  selectedKeys,
  defaultSelectedKeys,
  rowSelection,
  currentAllRowKeys,
  currentAllEnabledRowKeys,
  emit
}) => {
  var _a, _b, _c;
  const isRadio = computed(() => {
    var _a2;
    return ((_a2 = rowSelection.value) == null ? void 0 : _a2.type) === "radio";
  });
  const _selectedRowKeys = ref((_c = (_b = defaultSelectedKeys.value) != null ? _b : (_a = rowSelection.value) == null ? void 0 : _a.defaultSelectedRowKeys) != null ? _c : []);
  const selectedRowKeys = computed(() => {
    var _a2, _b2, _c2;
    return (_c2 = (_b2 = selectedKeys.value) != null ? _b2 : (_a2 = rowSelection.value) == null ? void 0 : _a2.selectedRowKeys) != null ? _c2 : _selectedRowKeys.value;
  });
  const currentSelectedRowKeys = computed(() => selectedRowKeys.value.filter((key) => currentAllRowKeys.value.includes(key)));
  const handleSelectAll = (checked) => {
    const newKeys = union(selectedRowKeys.value, currentAllEnabledRowKeys.value, !checked);
    _selectedRowKeys.value = newKeys;
    emit("selectAll", checked);
    emit("selectionChange", newKeys);
    emit("update:selectedKeys", newKeys);
  };
  const handleSelect = (checked, record) => {
    const selectedAllRowKeys = isRadio.value ? [record.key] : union(selectedRowKeys.value, [record.key], !checked);
    _selectedRowKeys.value = selectedAllRowKeys;
    emit("select", selectedAllRowKeys, record.key, record.raw);
    emit("selectionChange", selectedAllRowKeys);
    emit("update:selectedKeys", selectedAllRowKeys);
  };
  const handleSelectAllLeafs = (record, checked) => {
    const newKeys = union(selectedRowKeys.value, getLeafKeys(record), !checked);
    _selectedRowKeys.value = newKeys;
    emit("select", newKeys, record.key, record.raw);
    emit("selectionChange", newKeys);
    emit("update:selectedKeys", newKeys);
  };
  const select = (rowKey, checked = true) => {
    const _rowKeys = [].concat(rowKey);
    const newSelectedRowKeys = isRadio.value ? _rowKeys : union(selectedRowKeys.value, _rowKeys, !checked);
    _selectedRowKeys.value = newSelectedRowKeys;
    emit("selectionChange", newSelectedRowKeys);
    emit("update:selectedKeys", newSelectedRowKeys);
  };
  const selectAll = (checked = true) => {
    const newKeys = union(selectedRowKeys.value, currentAllEnabledRowKeys.value, !checked);
    _selectedRowKeys.value = newKeys;
    emit("selectionChange", newKeys);
    emit("update:selectedKeys", newKeys);
  };
  const clearSelected = () => {
    _selectedRowKeys.value = [];
    emit("selectionChange", []);
    emit("update:selectedKeys", []);
  };
  return {
    isRadio,
    selectedRowKeys,
    currentSelectedRowKeys,
    handleSelectAll,
    handleSelect,
    handleSelectAllLeafs,
    select,
    selectAll,
    clearSelected
  };
};

// node_modules/@arco-design/web-vue/es/table/hooks/use-expand.js
var useExpand = ({
  expandedKeys,
  defaultExpandedKeys,
  defaultExpandAllRows,
  expandable,
  allRowKeys,
  emit
}) => {
  const getDefaultExpandedRowKeys = () => {
    var _a, _b;
    if (defaultExpandedKeys.value) {
      return defaultExpandedKeys.value;
    }
    if ((_a = expandable.value) == null ? void 0 : _a.defaultExpandedRowKeys) {
      return expandable.value.defaultExpandedRowKeys;
    }
    if (defaultExpandAllRows.value || ((_b = expandable.value) == null ? void 0 : _b.defaultExpandAllRows)) {
      return [...allRowKeys.value];
    }
    return [];
  };
  const _expandedRowKeys = ref(getDefaultExpandedRowKeys());
  const expandedRowKeys = computed(() => {
    var _a, _b, _c;
    return (_c = (_b = expandedKeys.value) != null ? _b : (_a = expandable.value) == null ? void 0 : _a.expandedRowKeys) != null ? _c : _expandedRowKeys.value;
  });
  const handleExpand = (rowKey, record) => {
    const isExpanded = expandedRowKeys.value.includes(rowKey);
    const newExpandedRowKeys = isExpanded ? expandedRowKeys.value.filter((key) => rowKey !== key) : expandedRowKeys.value.concat(rowKey);
    _expandedRowKeys.value = newExpandedRowKeys;
    emit("expand", rowKey, record);
    emit("expandedChange", newExpandedRowKeys);
    emit("update:expandedKeys", newExpandedRowKeys);
  };
  const expand = (rowKey, expanded = true) => {
    const _rowKeys = [].concat(rowKey);
    const newExpandedRowKeys = expanded ? expandedRowKeys.value.concat(_rowKeys) : expandedRowKeys.value.filter((key) => !_rowKeys.includes(key));
    _expandedRowKeys.value = newExpandedRowKeys;
    emit("expandedChange", newExpandedRowKeys);
    emit("update:expandedKeys", newExpandedRowKeys);
  };
  const expandAll = (expanded = true) => {
    const newExpandedRowKeys = expanded ? [...allRowKeys.value] : [];
    _expandedRowKeys.value = newExpandedRowKeys;
    emit("expandedChange", newExpandedRowKeys);
    emit("update:expandedKeys", newExpandedRowKeys);
  };
  return {
    expandedRowKeys,
    handleExpand,
    expand,
    expandAll
  };
};

// node_modules/@arco-design/web-vue/es/table/hooks/use-pagination.js
var usePagination2 = (props, emit) => {
  var _a, _b;
  const _page = ref(isObject(props.pagination) ? (_a = props.pagination.defaultCurrent) != null ? _a : 1 : 1);
  const _pageSize = ref(isObject(props.pagination) ? (_b = props.pagination.defaultPageSize) != null ? _b : 10 : 10);
  const pageSize = computed(() => {
    var _a2;
    return isObject(props.pagination) ? (_a2 = props.pagination.pageSize) != null ? _a2 : _pageSize.value : _pageSize.value;
  });
  const page = computed(() => {
    var _a2;
    return isObject(props.pagination) ? (_a2 = props.pagination.current) != null ? _a2 : _page.value : _page.value;
  });
  const handlePageChange = (page2) => {
    _page.value = page2;
    emit("pageChange", page2);
  };
  const handlePageSizeChange = (pageSize2) => {
    _pageSize.value = pageSize2;
    emit("pageSizeChange", pageSize2);
  };
  return {
    page,
    pageSize,
    handlePageChange,
    handlePageSizeChange
  };
};

// node_modules/@arco-design/web-vue/es/table/table-col-group.js
var _sfc_main163 = defineComponent({
  name: "ColGroup",
  props: {
    dataColumns: {
      type: Array,
      required: true
    },
    operations: {
      type: Array,
      required: true
    },
    columnWidth: {
      type: Object
    }
  },
  setup() {
    const fixedWidth = (width) => {
      if (width) {
        return {
          width: `${width}px`,
          minWidth: `${width}px`,
          maxWidth: `${width}px`
        };
      }
      return void 0;
    };
    return {
      fixedWidth
    };
  }
});
function _sfc_render163(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("colgroup", null, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.operations, (item) => {
      return openBlock(), createElementBlock("col", {
        key: `arco-col-${item.name}`,
        class: normalizeClass(`arco-table-${item.name}-col`),
        style: normalizeStyle(_ctx.fixedWidth(item.width))
      }, null, 6);
    }), 128)),
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.dataColumns, (item) => {
      return openBlock(), createElementBlock("col", {
        key: `arco-col-${item.dataIndex}`,
        style: normalizeStyle(_ctx.fixedWidth(_ctx.columnWidth && item.dataIndex && _ctx.columnWidth[item.dataIndex] || item.width))
      }, null, 4);
    }), 128))
  ]);
}
var ColGroup = _export_sfc(_sfc_main163, [["render", _sfc_render163]]);

// node_modules/@arco-design/web-vue/es/table/table-thead.js
var Thead = defineComponent({
  name: "Thead",
  setup(_, {
    slots
  }) {
    return () => {
      var _a, _b;
      return createVNode((_b = (_a = slots.thead) == null ? void 0 : _a.call(slots)[0]) != null ? _b : "thead", null, {
        default: slots.default
      });
    };
  }
});

// node_modules/@arco-design/web-vue/es/table/table-tbody.js
var Tbody = defineComponent({
  name: "Tbody",
  setup(_, {
    slots
  }) {
    return () => {
      var _a, _b;
      return createVNode((_b = (_a = slots.tbody) == null ? void 0 : _a.call(slots)[0]) != null ? _b : "tbody", null, {
        default: slots.default
      });
    };
  }
});

// node_modules/@arco-design/web-vue/es/table/table-tr.js
var Tr = defineComponent({
  name: "Tr",
  props: {
    expand: {
      type: Boolean
    },
    empty: {
      type: Boolean
    },
    checked: {
      type: Boolean
    },
    rowIndex: Number,
    record: {
      type: Object,
      default: () => ({})
    }
  },
  setup(props, {
    slots
  }) {
    const prefixCls = getPrefixCls("table");
    const cls = computed(() => [`${prefixCls}-tr`, {
      [`${prefixCls}-tr-expand`]: props.expand,
      [`${prefixCls}-tr-empty`]: props.empty,
      [`${prefixCls}-tr-checked`]: props.checked
    }]);
    return () => {
      var _a, _b, _c;
      return createVNode((_c = (_b = slots.tr) == null ? void 0 : _b.call(slots, {
        rowIndex: props.rowIndex,
        record: (_a = props.record) == null ? void 0 : _a.raw
      })[0]) != null ? _c : "tr", {
        class: cls.value
      }, {
        default: slots.default
      });
    };
  }
});

// node_modules/@arco-design/web-vue/es/icon/icon-caret-down/icon-caret-down.js
var _sfc_main164 = defineComponent({
  name: "IconCaretDown",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-caret-down`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_171 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_253 = createBaseVNode("path", {
  d: "M24.938 34.829a1.2 1.2 0 0 1-1.875 0L9.56 17.949c-.628-.785-.069-1.949.937-1.949h27.007c1.006 0 1.565 1.164.937 1.95L24.937 34.829Z",
  fill: "currentColor",
  stroke: "none"
}, null, -1);
var _hoisted_349 = [
  _hoisted_253
];
function _sfc_render164(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_349, 14, _hoisted_171);
}
var _IconCaretDown = _export_sfc(_sfc_main164, [["render", _sfc_render164]]);

// node_modules/@arco-design/web-vue/es/icon/icon-caret-down/index.js
var IconCaretDown = Object.assign(_IconCaretDown, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconCaretDown.name, _IconCaretDown);
  }
});

// node_modules/@arco-design/web-vue/es/icon/icon-caret-up/icon-caret-up.js
var _sfc_main165 = defineComponent({
  name: "IconCaretUp",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-caret-up`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_172 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_254 = createBaseVNode("path", {
  d: "M23.063 13.171a1.2 1.2 0 0 1 1.875 0l13.503 16.88c.628.785.069 1.949-.937 1.949H10.497c-1.006 0-1.565-1.164-.937-1.95l13.503-16.879Z",
  fill: "currentColor",
  stroke: "none"
}, null, -1);
var _hoisted_350 = [
  _hoisted_254
];
function _sfc_render165(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_350, 14, _hoisted_172);
}
var _IconCaretUp = _export_sfc(_sfc_main165, [["render", _sfc_render165]]);

// node_modules/@arco-design/web-vue/es/icon/icon-caret-up/index.js
var IconCaretUp = Object.assign(_IconCaretUp, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconCaretUp.name, _IconCaretUp);
  }
});

// node_modules/@arco-design/web-vue/es/icon/icon-filter/icon-filter.js
var _sfc_main166 = defineComponent({
  name: "IconFilter",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-filter`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_173 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_255 = createBaseVNode("path", { d: "M30 42V22.549a1 1 0 0 1 .463-.844l10.074-6.41A1 1 0 0 0 41 14.45V8a1 1 0 0 0-1-1H8a1 1 0 0 0-1 1v6.451a1 1 0 0 0 .463.844l10.074 6.41a1 1 0 0 1 .463.844V37" }, null, -1);
var _hoisted_351 = [
  _hoisted_255
];
function _sfc_render166(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_351, 14, _hoisted_173);
}
var _IconFilter = _export_sfc(_sfc_main166, [["render", _sfc_render166]]);

// node_modules/@arco-design/web-vue/es/icon/icon-filter/index.js
var IconFilter = Object.assign(_IconFilter, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconFilter.name, _IconFilter);
  }
});

// node_modules/@arco-design/web-vue/es/table/hooks/use-column-sorter.js
var useColumnSorter = ({
  column,
  tableCtx
}) => {
  const sortOrder = computed(() => {
    var _a;
    if (column.value.dataIndex && column.value.dataIndex === ((_a = tableCtx.sorter) == null ? void 0 : _a.field)) {
      return tableCtx.sorter.direction;
    }
    return void 0;
  });
  const sortDirections = computed(() => {
    var _a, _b, _c;
    return (_c = (_b = (_a = column.value) == null ? void 0 : _a.sortable) == null ? void 0 : _b.sortDirections) != null ? _c : [];
  });
  const hasSorter = computed(() => sortDirections.value.length > 0);
  const hasAscendBtn = computed(() => sortDirections.value.includes("ascend"));
  const hasDescendBtn = computed(() => sortDirections.value.includes("descend"));
  const nextSortOrder = computed(() => {
    var _a, _b;
    if (!sortOrder.value) {
      return (_a = sortDirections.value[0]) != null ? _a : "";
    }
    if (sortOrder.value === sortDirections.value[0]) {
      return (_b = sortDirections.value[1]) != null ? _b : "";
    }
    return "";
  });
  const handleClickSorter = (ev) => {
    var _a;
    if (column.value.dataIndex) {
      (_a = tableCtx.onSorterChange) == null ? void 0 : _a.call(tableCtx, column.value.dataIndex, nextSortOrder.value, ev);
    }
  };
  return {
    sortOrder,
    hasSorter,
    hasAscendBtn,
    hasDescendBtn,
    nextSortOrder,
    handleClickSorter
  };
};

// node_modules/@arco-design/web-vue/es/table/hooks/use-column-filter.js
var useColumnFilter = ({
  column,
  tableCtx
}) => {
  const filterValue = computed(() => {
    var _a;
    if (column.value.dataIndex && ((_a = tableCtx.filters) == null ? void 0 : _a[column.value.dataIndex])) {
      return tableCtx.filters[column.value.dataIndex];
    }
    return [];
  });
  const filterPopupVisible = ref(false);
  const isFilterActive = computed(() => filterValue.value.length > 0);
  const isMultipleFilter = computed(() => {
    var _a;
    return Boolean((_a = column.value.filterable) == null ? void 0 : _a.multiple);
  });
  const columnFilterValue = ref(filterValue.value);
  watch(filterValue, (value) => {
    if (isArray(value) && String(value) !== String(columnFilterValue.value)) {
      columnFilterValue.value = value;
    }
  });
  const handleFilterPopupVisibleChange = (value) => {
    filterPopupVisible.value = value;
  };
  const setFilterValue = (filterValue2) => {
    columnFilterValue.value = filterValue2;
  };
  const handleCheckboxFilterChange = (values) => {
    setFilterValue(values);
  };
  const handleRadioFilterChange = (value) => {
    setFilterValue([value]);
  };
  const handleFilterConfirm = (ev) => {
    var _a;
    if (column.value.dataIndex) {
      (_a = tableCtx.onFilterChange) == null ? void 0 : _a.call(tableCtx, column.value.dataIndex, columnFilterValue.value, ev);
    }
    handleFilterPopupVisibleChange(false);
  };
  const handleFilterReset = (ev) => {
    var _a;
    setFilterValue([]);
    if (column.value.dataIndex) {
      (_a = tableCtx.onFilterChange) == null ? void 0 : _a.call(tableCtx, column.value.dataIndex, columnFilterValue.value, ev);
    }
    handleFilterPopupVisibleChange(false);
  };
  return {
    filterPopupVisible,
    isFilterActive,
    isMultipleFilter,
    columnFilterValue,
    handleFilterPopupVisibleChange,
    setFilterValue,
    handleCheckboxFilterChange,
    handleRadioFilterChange,
    handleFilterConfirm,
    handleFilterReset
  };
};

// node_modules/@arco-design/web-vue/es/table/context.js
var tableInjectionKey = Symbol("ArcoTable");
var tableColumnInjectionKey = Symbol("ArcoTableColumn");

// node_modules/@arco-design/web-vue/es/_components/auto-tooltip/auto-tooltip.js
function _isSlot10(s) {
  return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
var AutoTooltip = defineComponent({
  name: "AutoTooltip",
  inheritAttrs: false,
  props: {
    tooltipProps: {
      type: Object
    }
  },
  setup(props, {
    attrs,
    slots
  }) {
    const prefix = getPrefixCls("auto-tooltip");
    const containerRef = ref();
    const contentRef = ref();
    const text = ref("");
    const showTooltip = ref(false);
    const calTooltip = () => {
      if (containerRef.value && contentRef.value) {
        const _show = contentRef.value.offsetWidth > containerRef.value.offsetWidth;
        if (_show !== showTooltip.value) {
          showTooltip.value = _show;
        }
      }
    };
    const getText = () => {
      var _a;
      if (((_a = contentRef.value) == null ? void 0 : _a.textContent) && contentRef.value.textContent !== text.value) {
        text.value = contentRef.value.textContent;
      }
    };
    const onResize = () => {
      getText();
      calTooltip();
    };
    onMounted(() => {
      getText();
      calTooltip();
    });
    onUpdated(() => {
      getText();
      calTooltip();
    });
    const renderContent = () => {
      return createVNode("span", mergeProps({
        "ref": containerRef,
        "class": prefix
      }, attrs), [createVNode(ResizeObserver3, {
        "onResize": onResize
      }, {
        default: () => {
          var _a;
          return [createVNode("span", {
            "ref": contentRef,
            "class": `${prefix}-content`
          }, [(_a = slots.default) == null ? void 0 : _a.call(slots)])];
        }
      })]);
    };
    return () => {
      let _slot2;
      if (showTooltip.value) {
        let _slot;
        return createVNode(Tooltip, mergeProps({
          "content": text.value,
          "onResize": onResize
        }, props.tooltipProps), _isSlot10(_slot = renderContent()) ? _slot : {
          default: () => [_slot]
        });
      }
      return createVNode(ResizeObserver3, {
        "onResize": onResize
      }, _isSlot10(_slot2 = renderContent()) ? _slot2 : {
        default: () => [_slot2]
      });
    };
  }
});

// node_modules/@arco-design/web-vue/es/table/table-th.js
var __defProp51 = Object.defineProperty;
var __getOwnPropSymbols51 = Object.getOwnPropertySymbols;
var __hasOwnProp51 = Object.prototype.hasOwnProperty;
var __propIsEnum51 = Object.prototype.propertyIsEnumerable;
var __defNormalProp51 = (obj, key, value) => key in obj ? __defProp51(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues51 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp51.call(b, prop))
      __defNormalProp51(a, prop, b[prop]);
  if (__getOwnPropSymbols51)
    for (var prop of __getOwnPropSymbols51(b)) {
      if (__propIsEnum51.call(b, prop))
        __defNormalProp51(a, prop, b[prop]);
    }
  return a;
};
function _isSlot11(s) {
  return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
var Th = defineComponent({
  name: "Th",
  props: {
    column: {
      type: Object,
      default: () => ({})
    },
    operations: {
      type: Array,
      default: () => []
    },
    dataColumns: {
      type: Array,
      default: () => []
    },
    resizable: Boolean
  },
  setup(props, {
    slots
  }) {
    const {
      column
    } = toRefs(props);
    const prefixCls = getPrefixCls("table");
    const {
      t: t2
    } = useI18n();
    const tableCtx = inject(tableInjectionKey, {});
    const resizing = computed(() => {
      var _a;
      return ((_a = props.column) == null ? void 0 : _a.dataIndex) && tableCtx.resizingColumn === props.column.dataIndex;
    });
    const tooltipProps = computed(() => {
      var _a;
      if (isObject((_a = props.column) == null ? void 0 : _a.tooltip)) {
        return props.column.tooltip;
      }
      return void 0;
    });
    const filterIconAlignLeft = computed(() => {
      var _a;
      if (((_a = props.column) == null ? void 0 : _a.filterable) && isBoolean(props.column.filterable.alignLeft)) {
        return props.column.filterable.alignLeft;
      }
      return tableCtx.filterIconAlignLeft;
    });
    const {
      sortOrder,
      hasSorter,
      hasAscendBtn,
      hasDescendBtn,
      nextSortOrder,
      handleClickSorter
    } = useColumnSorter({
      column,
      tableCtx
    });
    const {
      filterPopupVisible,
      isFilterActive,
      isMultipleFilter,
      columnFilterValue,
      handleFilterPopupVisibleChange,
      setFilterValue,
      handleCheckboxFilterChange,
      handleRadioFilterChange,
      handleFilterConfirm,
      handleFilterReset
    } = useColumnFilter({
      column,
      tableCtx
    });
    const renderFilterContent = () => {
      var _a, _b, _c, _d, _e;
      let _slot, _slot2;
      const {
        filterable
      } = props.column;
      if ((_a = props.column.slots) == null ? void 0 : _a["filter-content"]) {
        return (_b = props.column.slots) == null ? void 0 : _b["filter-content"]({
          filterValue: columnFilterValue.value,
          setFilterValue,
          handleFilterConfirm,
          handleFilterReset
        });
      }
      if (filterable == null ? void 0 : filterable.slotName) {
        return (_d = (_c = tableCtx == null ? void 0 : tableCtx.slots) == null ? void 0 : _c[filterable == null ? void 0 : filterable.slotName]) == null ? void 0 : _d.call(_c, {
          filterValue: columnFilterValue.value,
          setFilterValue,
          handleFilterConfirm,
          handleFilterReset
        });
      }
      if (filterable == null ? void 0 : filterable.renderContent) {
        return filterable.renderContent({
          filterValue: columnFilterValue.value,
          setFilterValue,
          handleFilterConfirm,
          handleFilterReset
        });
      }
      return createVNode("div", {
        "class": `${prefixCls}-filters-content`
      }, [createVNode("ul", {
        "class": `${prefixCls}-filters-list`
      }, [(_e = filterable == null ? void 0 : filterable.filters) == null ? void 0 : _e.map((item, index3) => {
        var _a2;
        return createVNode("li", {
          "class": `${prefixCls}-filters-item`,
          "key": index3
        }, [isMultipleFilter.value ? createVNode(Checkbox, {
          "value": item.value,
          "modelValue": columnFilterValue.value,
          "uninjectGroupContext": true,
          "onChange": handleCheckboxFilterChange
        }, {
          default: () => [item.text]
        }) : createVNode(Radio, {
          "value": item.value,
          "modelValue": (_a2 = columnFilterValue.value[0]) != null ? _a2 : "",
          "uninjectGroupContext": true,
          "onChange": handleRadioFilterChange
        }, {
          default: () => [item.text]
        })]);
      })]), createVNode("div", {
        "class": `${prefixCls}-filters-bottom`
      }, [createVNode(Button, {
        "size": "mini",
        "onClick": handleFilterReset
      }, _isSlot11(_slot = t2("table.resetText")) ? _slot : {
        default: () => [_slot]
      }), createVNode(Button, {
        "type": "primary",
        "size": "mini",
        "onClick": handleFilterConfirm
      }, _isSlot11(_slot2 = t2("table.okText")) ? _slot2 : {
        default: () => [_slot2]
      })])]);
    };
    const renderFilter = () => {
      const {
        filterable
      } = props.column;
      if (!filterable) {
        return null;
      }
      return createVNode(Trigger, mergeProps({
        "popupVisible": filterPopupVisible.value,
        "trigger": "click",
        "autoFitPosition": true,
        "popupOffset": filterIconAlignLeft.value ? 4 : 0,
        "onPopupVisibleChange": handleFilterPopupVisibleChange
      }, filterable.triggerProps), {
        default: () => [createVNode(IconHover, {
          "class": [`${prefixCls}-filters`, {
            [`${prefixCls}-filters-active`]: isFilterActive.value,
            [`${prefixCls}-filters-open`]: filterPopupVisible.value,
            [`${prefixCls}-filters-align-left`]: filterIconAlignLeft.value
          }],
          "disabled": !filterIconAlignLeft.value,
          "onClick": (ev) => ev.stopPropagation()
        }, {
          default: () => {
            var _a, _b, _c, _d, _e;
            return [(_e = (_d = (_b = (_a = props.column.slots) == null ? void 0 : _a["filter-icon"]) == null ? void 0 : _b.call(_a)) != null ? _d : (_c = filterable.icon) == null ? void 0 : _c.call(filterable)) != null ? _e : createVNode(IconFilter, null, null)];
          }
        })],
        content: renderFilterContent
      });
    };
    const cellCls = computed(() => {
      var _a, _b;
      const cls2 = [`${prefixCls}-cell`, `${prefixCls}-cell-align-${(_b = (_a = props.column) == null ? void 0 : _a.align) != null ? _b : props.column.children ? "center" : "left"}`];
      if (hasSorter.value) {
        cls2.push(`${prefixCls}-cell-with-sorter`, {
          [`${prefixCls}-cell-next-ascend`]: nextSortOrder.value === "ascend",
          [`${prefixCls}-cell-next-descend`]: nextSortOrder.value === "descend"
        });
      }
      if (filterIconAlignLeft.value) {
        cls2.push(`${prefixCls}-cell-with-filter`);
      }
      return cls2;
    });
    const renderTitle = () => {
      var _a, _b, _c, _d, _e, _f;
      if (slots.default) {
        return slots.default();
      }
      if (((_a = props.column) == null ? void 0 : _a.titleSlotName) && ((_b = tableCtx.slots) == null ? void 0 : _b[props.column.titleSlotName])) {
        return (_d = (_c = tableCtx.slots)[props.column.titleSlotName]) == null ? void 0 : _d.call(_c, {
          column: props.column
        });
      }
      if ((_f = (_e = props.column) == null ? void 0 : _e.slots) == null ? void 0 : _f.title) {
        return props.column.slots.title();
      }
      if (isFunction(props.column.title)) {
        return props.column.title();
      }
      return props.column.title;
    };
    const renderCell = () => {
      var _a, _b, _c;
      let _slot3;
      return createVNode("span", {
        "class": cellCls.value,
        "onClick": hasSorter.value ? handleClickSorter : void 0
      }, [((_a = props.column) == null ? void 0 : _a.ellipsis) && ((_b = props.column) == null ? void 0 : _b.tooltip) ? createVNode(AutoTooltip, {
        "class": `${prefixCls}-th-title`,
        "tooltipProps": tooltipProps.value
      }, _isSlot11(_slot3 = renderTitle()) ? _slot3 : {
        default: () => [_slot3]
      }) : createVNode("span", {
        "class": [`${prefixCls}-th-title`, {
          [`${prefixCls}-text-ellipsis`]: (_c = props.column) == null ? void 0 : _c.ellipsis
        }]
      }, [renderTitle()]), hasSorter.value && createVNode("span", {
        "class": `${prefixCls}-sorter`
      }, [hasAscendBtn.value && createVNode("div", {
        "class": [`${prefixCls}-sorter-icon`, {
          [`${prefixCls}-sorter-icon-active`]: sortOrder.value === "ascend"
        }]
      }, [createVNode(IconCaretUp, null, null)]), hasDescendBtn.value && createVNode("div", {
        "class": [`${prefixCls}-sorter-icon`, {
          [`${prefixCls}-sorter-icon-active`]: sortOrder.value === "descend"
        }]
      }, [createVNode(IconCaretDown, null, null)])]), filterIconAlignLeft.value && renderFilter()]);
    };
    const style = computed(() => {
      var _a, _b;
      return __spreadValues51(__spreadValues51(__spreadValues51({}, getStyle2(props.column, {
        dataColumns: props.dataColumns,
        operations: props.operations
      })), (_a = props.column) == null ? void 0 : _a.cellStyle), (_b = props.column) == null ? void 0 : _b.headerCellStyle);
    });
    const cls = computed(() => {
      var _a, _b;
      return [`${prefixCls}-th`, {
        [`${prefixCls}-col-sorted`]: Boolean(sortOrder.value),
        [`${prefixCls}-th-resizing`]: resizing.value
      }, ...getFixedCls(prefixCls, props.column), (_a = props.column) == null ? void 0 : _a.cellClass, (_b = props.column) == null ? void 0 : _b.headerCellClass];
    });
    const handleMouseDown = (ev) => {
      var _a, _b, _c;
      if ((_a = props.column) == null ? void 0 : _a.dataIndex) {
        (_c = tableCtx.onThMouseDown) == null ? void 0 : _c.call(tableCtx, (_b = props.column) == null ? void 0 : _b.dataIndex, ev);
      }
    };
    return () => {
      var _a, _b, _c, _d;
      const colSpan = (_a = props.column.colSpan) != null ? _a : 1;
      const rowSpan = (_b = props.column.rowSpan) != null ? _b : 1;
      return createVNode((_d = (_c = slots.th) == null ? void 0 : _c.call(slots, {
        column: props.column
      })[0]) != null ? _d : "th", {
        class: cls.value,
        style: style.value,
        colspan: colSpan > 1 ? colSpan : void 0,
        rowspan: rowSpan > 1 ? rowSpan : void 0
      }, {
        default: () => [renderCell(), !filterIconAlignLeft.value && renderFilter(), props.resizable && createVNode("span", {
          "class": `${prefixCls}-column-handle`,
          "onMousedown": handleMouseDown
        }, null)]
      });
    };
  }
});

// node_modules/@arco-design/web-vue/es/table/table-td.js
var __defProp52 = Object.defineProperty;
var __getOwnPropSymbols52 = Object.getOwnPropertySymbols;
var __hasOwnProp52 = Object.prototype.hasOwnProperty;
var __propIsEnum52 = Object.prototype.propertyIsEnumerable;
var __defNormalProp52 = (obj, key, value) => key in obj ? __defProp52(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues52 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp52.call(b, prop))
      __defNormalProp52(a, prop, b[prop]);
  if (__getOwnPropSymbols52)
    for (var prop of __getOwnPropSymbols52(b)) {
      if (__propIsEnum52.call(b, prop))
        __defNormalProp52(a, prop, b[prop]);
    }
  return a;
};
function _isSlot12(s) {
  return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
var Td = defineComponent({
  name: "Td",
  props: {
    rowIndex: Number,
    record: {
      type: Object,
      default: () => ({})
    },
    column: {
      type: Object,
      default: () => ({})
    },
    type: {
      type: String,
      default: "normal"
    },
    operations: {
      type: Array,
      default: () => []
    },
    dataColumns: {
      type: Array,
      default: () => []
    },
    colSpan: {
      type: Number,
      default: 1
    },
    rowSpan: {
      type: Number,
      default: 1
    },
    isFixedExpand: {
      type: Boolean,
      default: false
    },
    containerWidth: {
      type: Number
    },
    showExpandBtn: {
      type: Boolean,
      default: false
    },
    indentSize: {
      type: Number,
      default: 0
    },
    renderExpandBtn: {
      type: Function
    },
    summary: {
      type: Boolean,
      default: false
    }
  },
  setup(props, {
    slots
  }) {
    const prefixCls = getPrefixCls("table");
    const tooltipProps = computed(() => {
      var _a;
      if (isObject((_a = props.column) == null ? void 0 : _a.tooltip)) {
        return props.column.tooltip;
      }
      return void 0;
    });
    const isSorted = computed(() => {
      var _a, _b;
      return ((_a = props.column) == null ? void 0 : _a.dataIndex) && ((_b = tableCtx.sorter) == null ? void 0 : _b.field) === props.column.dataIndex;
    });
    const resizing = computed(() => {
      var _a;
      return ((_a = props.column) == null ? void 0 : _a.dataIndex) && tableCtx.resizingColumn === props.column.dataIndex;
    });
    const getCustomClass = () => {
      var _a, _b, _c, _d, _e, _f;
      if (props.summary) {
        return isFunction((_a = props.column) == null ? void 0 : _a.summaryCellClass) ? props.column.summaryCellClass((_b = props.record) == null ? void 0 : _b.raw) : (_c = props.column) == null ? void 0 : _c.summaryCellClass;
      }
      return isFunction((_d = props.column) == null ? void 0 : _d.bodyCellClass) ? props.column.bodyCellClass((_e = props.record) == null ? void 0 : _e.raw) : (_f = props.column) == null ? void 0 : _f.bodyCellClass;
    };
    const cls = computed(() => {
      var _a;
      return [`${prefixCls}-td`, {
        [`${prefixCls}-col-sorted`]: isSorted.value,
        [`${prefixCls}-td-resizing`]: resizing.value
      }, ...getFixedCls(prefixCls, props.column), (_a = props.column) == null ? void 0 : _a.cellClass, getCustomClass()];
    });
    const getCustomStyle = () => {
      var _a, _b, _c, _d, _e, _f;
      if (props.summary) {
        return isFunction((_a = props.column) == null ? void 0 : _a.summaryCellStyle) ? props.column.summaryCellStyle((_b = props.record) == null ? void 0 : _b.raw) : (_c = props.column) == null ? void 0 : _c.summaryCellStyle;
      }
      return isFunction((_d = props.column) == null ? void 0 : _d.bodyCellStyle) ? props.column.bodyCellStyle((_e = props.record) == null ? void 0 : _e.raw) : (_f = props.column) == null ? void 0 : _f.bodyCellStyle;
    };
    const style = computed(() => {
      var _a;
      const style2 = getStyle2(props.column, {
        dataColumns: props.dataColumns,
        operations: props.operations
      });
      const customStyle = getCustomStyle();
      return __spreadValues52(__spreadValues52(__spreadValues52({}, style2), (_a = props.column) == null ? void 0 : _a.cellStyle), customStyle);
    });
    const cellStyle = computed(() => {
      if (props.isFixedExpand && props.containerWidth) {
        return {
          width: `${props.containerWidth}px`
        };
      }
      return void 0;
    });
    const tableCtx = inject(tableInjectionKey, {});
    const renderContent = () => {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      if (slots.default) {
        return slots.default();
      }
      const data = {
        record: (_a = props.record) == null ? void 0 : _a.raw,
        column: props.column,
        rowIndex: (_b = props.rowIndex) != null ? _b : -1
      };
      if (slots.cell) {
        return slots.cell(data);
      }
      if ((_c = props.column.slots) == null ? void 0 : _c.cell) {
        return props.column.slots.cell(data);
      }
      if (props.column.render) {
        return props.column.render(data);
      }
      if (props.column.slotName && ((_d = tableCtx.slots) == null ? void 0 : _d[props.column.slotName])) {
        return (_f = (_e = tableCtx.slots)[props.column.slotName]) == null ? void 0 : _f.call(_e, data);
      }
      return String((_h = getValueByPath((_g = props.record) == null ? void 0 : _g.raw, props.column.dataIndex)) != null ? _h : "");
    };
    const isLoading = ref(false);
    const handleClick = (ev) => {
      var _a, _b;
      if (isFunction(tableCtx.loadMore) && !((_a = props.record) == null ? void 0 : _a.isLeaf) && !((_b = props.record) == null ? void 0 : _b.children)) {
        isLoading.value = true;
        new Promise((resolve) => {
          var _a2;
          (_a2 = tableCtx.loadMore) == null ? void 0 : _a2.call(tableCtx, props.record.raw, resolve);
        }).then((children) => {
          var _a2;
          (_a2 = tableCtx.addLazyLoadData) == null ? void 0 : _a2.call(tableCtx, children, props.record);
          isLoading.value = false;
        });
      }
      ev.stopPropagation();
    };
    const renderCell = () => {
      var _a, _b, _c, _d, _e, _f;
      let _slot;
      return createVNode("span", {
        "class": [`${prefixCls}-cell`, `${prefixCls}-cell-align-${(_b = (_a = props.column) == null ? void 0 : _a.align) != null ? _b : "left"}`, {
          [`${prefixCls}-cell-fixed-expand`]: props.isFixedExpand,
          [`${prefixCls}-cell-expand-icon`]: props.showExpandBtn
        }],
        "style": cellStyle.value
      }, [props.indentSize > 0 && createVNode("span", {
        "style": {
          paddingLeft: `${props.indentSize}px`
        }
      }, null), props.showExpandBtn && createVNode("span", {
        "class": `${prefixCls}-cell-inline-icon`,
        "onClick": handleClick
      }, [isLoading.value ? createVNode(IconLoading, null, null) : (_c = props.renderExpandBtn) == null ? void 0 : _c.call(props, props.record, false)]), ((_d = props.column) == null ? void 0 : _d.ellipsis) && ((_e = props.column) == null ? void 0 : _e.tooltip) ? createVNode(AutoTooltip, {
        "class": `${prefixCls}-td-content`,
        "tooltipProps": tooltipProps.value
      }, _isSlot12(_slot = renderContent()) ? _slot : {
        default: () => [_slot]
      }) : createVNode("span", {
        "class": [`${prefixCls}-td-content`, {
          [`${prefixCls}-text-ellipsis`]: (_f = props.column) == null ? void 0 : _f.ellipsis
        }]
      }, [renderContent()])]);
    };
    return () => {
      var _a, _b, _c, _d;
      return createVNode((_d = (_c = slots.td) == null ? void 0 : _c.call(slots, {
        record: (_a = props.record) == null ? void 0 : _a.raw,
        column: props.column,
        rowIndex: (_b = props.rowIndex) != null ? _b : -1
      })[0]) != null ? _d : "td", {
        class: cls.value,
        style: style.value,
        rowspan: props.rowSpan > 1 ? props.rowSpan : void 0,
        colspan: props.colSpan > 1 ? props.colSpan : void 0
      }, {
        default: () => [renderCell()]
      });
    };
  }
});

// node_modules/@arco-design/web-vue/es/table/table-operation-th.js
var OperationTh = defineComponent({
  name: "OperationTh",
  props: {
    operationColumn: {
      type: Object,
      required: true
    },
    operations: {
      type: Array,
      required: true
    },
    rowSpan: {
      type: Number,
      default: 1
    },
    selectAll: {
      type: Boolean,
      default: false
    }
  },
  setup(props) {
    const prefixCls = getPrefixCls("table");
    const tableCtx = inject(tableInjectionKey, {});
    const checkboxStatus = computed(() => {
      var _a, _b, _c, _d;
      let checked = false;
      let indeterminate = false;
      const currentSelectedEnabledRowKeys = (_b = (_a = tableCtx.currentSelectedRowKeys) == null ? void 0 : _a.filter((key) => {
        var _a2, _b2;
        return (_b2 = (_a2 = tableCtx.currentAllEnabledRowKeys) == null ? void 0 : _a2.includes(key)) != null ? _b2 : true;
      })) != null ? _b : [];
      const selectedNumber = currentSelectedEnabledRowKeys.length;
      const totalEnabledNumber = (_d = (_c = tableCtx.currentAllEnabledRowKeys) == null ? void 0 : _c.length) != null ? _d : 0;
      if (selectedNumber > 0) {
        if (selectedNumber >= totalEnabledNumber) {
          checked = true;
        } else {
          indeterminate = true;
        }
      }
      return {
        checked,
        indeterminate
      };
    });
    const renderContent = () => {
      if (props.selectAll) {
        return createVNode(Checkbox, {
          "modelValue": checkboxStatus.value.checked,
          "indeterminate": checkboxStatus.value.indeterminate,
          "uninjectGroupContext": true,
          "onChange": (checked) => {
            var _a;
            (_a = tableCtx.onSelectAll) == null ? void 0 : _a.call(tableCtx, checked);
          }
        }, {
          default: isFunction(props.operationColumn.title) ? props.operationColumn.title() : props.operationColumn.title
        });
      }
      if (props.operationColumn.title) {
        return isFunction(props.operationColumn.title) ? props.operationColumn.title() : props.operationColumn.title;
      }
      return null;
    };
    const style = computed(() => getOperationStyle(props.operationColumn, props.operations));
    const cls = computed(() => [`${prefixCls}-th`, `${prefixCls}-operation`, {
      [`${prefixCls}-checkbox`]: props.selectAll
    }, ...getOperationFixedCls(prefixCls, props.operationColumn)]);
    return () => createVNode("th", {
      "class": cls.value,
      "style": style.value,
      "rowspan": props.rowSpan > 1 ? props.rowSpan : void 0
    }, [createVNode("span", {
      "class": `${prefixCls}-cell`
    }, [renderContent()])]);
  }
});

// node_modules/@arco-design/web-vue/es/table/table-operation-td.js
var OperationTd = defineComponent({
  name: "OperationTd",
  components: {
    Checkbox,
    Radio,
    IconPlus,
    IconMinus
  },
  props: {
    operationColumn: {
      type: Object,
      required: true
    },
    operations: {
      type: Array,
      required: true
    },
    record: {
      type: Object,
      required: true
    },
    hasExpand: {
      type: Boolean,
      default: false
    },
    selectedRowKeys: {
      type: Array
    },
    renderExpandBtn: {
      type: Function
    },
    colSpan: {
      type: Number,
      default: 1
    },
    rowSpan: {
      type: Number,
      default: 1
    },
    summary: {
      type: Boolean,
      default: false
    }
  },
  emits: ["select"],
  setup(props, {
    emit,
    slots
  }) {
    const prefixCls = getPrefixCls("table");
    const tableCtx = inject(tableInjectionKey, {});
    const style = computed(() => getOperationStyle(props.operationColumn, props.operations));
    const cls = computed(() => [`${prefixCls}-td`, `${prefixCls}-operation`, {
      [`${prefixCls}-checkbox`]: props.operationColumn.name === "selection-checkbox",
      [`${prefixCls}-radio`]: props.operationColumn.name === "selection-radio",
      [`${prefixCls}-expand`]: props.operationColumn.name === "expand",
      [`${prefixCls}-drag-handle`]: props.operationColumn.name === "drag-handle"
    }, ...getOperationFixedCls(prefixCls, props.operationColumn)]);
    const leafKeys = computed(() => getLeafKeys(props.record));
    const selectionStatus = computed(() => {
      var _a;
      return getSelectionStatus((_a = tableCtx.currentSelectedRowKeys) != null ? _a : [], leafKeys.value);
    });
    const renderContent = () => {
      var _a, _b, _c, _d, _e, _f;
      if (props.summary) {
        return null;
      }
      if (props.operationColumn.render) {
        return props.operationColumn.render(props.record.raw);
      }
      if (props.operationColumn.name === "selection-checkbox") {
        const value = props.record.key;
        if (!tableCtx.checkStrictly && !props.record.isLeaf) {
          return createVNode(Checkbox, {
            "modelValue": selectionStatus.value.checked,
            "indeterminate": selectionStatus.value.indeterminate,
            "disabled": Boolean(props.record.disabled),
            "uninjectGroupContext": true,
            "onChange": (checked) => {
              var _a2;
              return (_a2 = tableCtx.onSelectAllLeafs) == null ? void 0 : _a2.call(tableCtx, props.record, checked);
            },
            "onClick": (ev) => ev.stopPropagation()
          }, null);
        }
        return createVNode(Checkbox, {
          "modelValue": (_b = (_a = props.selectedRowKeys) == null ? void 0 : _a.includes(value)) != null ? _b : false,
          "disabled": Boolean(props.record.disabled),
          "uninjectGroupContext": true,
          "onChange": (checked) => {
            var _a2;
            return (_a2 = tableCtx.onSelect) == null ? void 0 : _a2.call(tableCtx, checked, props.record);
          },
          "onClick": (ev) => ev.stopPropagation()
        }, null);
      }
      if (props.operationColumn.name === "selection-radio") {
        const value = props.record.key;
        return createVNode(Radio, {
          "modelValue": (_d = (_c = props.selectedRowKeys) == null ? void 0 : _c.includes(value)) != null ? _d : false,
          "disabled": Boolean(props.record.disabled),
          "uninjectGroupContext": true,
          "onChange": (checked) => {
            var _a2;
            return (_a2 = tableCtx.onSelect) == null ? void 0 : _a2.call(tableCtx, checked, props.record);
          },
          "onClick": (ev) => ev.stopPropagation()
        }, null);
      }
      if (props.operationColumn.name === "expand") {
        if (props.hasExpand && props.renderExpandBtn) {
          return props.renderExpandBtn(props.record);
        }
        return null;
      }
      if (props.operationColumn.name === "drag-handle") {
        return (_f = (_e = slots["drag-handle-icon"]) == null ? void 0 : _e.call(slots)) != null ? _f : createVNode(IconDragDotVertical, null, null);
      }
      return null;
    };
    return () => createVNode("td", {
      "class": cls.value,
      "style": style.value,
      "rowspan": props.rowSpan > 1 ? props.rowSpan : void 0,
      "colspan": props.colSpan > 1 ? props.colSpan : void 0
    }, [createVNode("span", {
      "class": `${prefixCls}-cell`
    }, [renderContent()])]);
  }
});

// node_modules/@arco-design/web-vue/es/table/hooks/use-drag.js
var useDrag = (draggable) => {
  const dragType = computed(() => {
    if (draggable.value) {
      if (draggable.value.type === "handle") {
        return "handle";
      }
      return "row";
    }
    return void 0;
  });
  const dragState = reactive({
    dragging: false,
    sourceKey: "",
    sourcePath: [],
    targetPath: [],
    data: {}
  });
  const clearDragState = () => {
    dragState.dragging = false;
    dragState.sourceKey = "";
    dragState.sourcePath = [];
    dragState.targetPath = [];
    dragState.data = {};
  };
  const handleDragStart = (ev, targetKey, targetPath, data) => {
    if (ev.dataTransfer) {
      ev.dataTransfer.effectAllowed = "move";
      if (ev.target && ev.target.tagName === "TD") {
        const { parentElement } = ev.target;
        if (parentElement && parentElement.tagName === "TR") {
          ev.dataTransfer.setDragImage(parentElement, 0, 0);
        }
      }
    }
    dragState.dragging = true;
    dragState.sourceKey = targetKey;
    dragState.sourcePath = targetPath;
    dragState.data = data;
  };
  const handleDragEnter = (ev, sourcePath) => {
    if (ev.dataTransfer) {
      ev.dataTransfer.dropEffect = "move";
    }
    dragState.targetPath = sourcePath;
    ev.preventDefault();
  };
  const handleDragLeave = (ev) => {
  };
  const handleDragover = (ev) => {
    if (ev.dataTransfer) {
      ev.dataTransfer.dropEffect = "move";
    }
    ev.preventDefault();
  };
  const handleDragEnd = (ev) => {
    var _a;
    if (((_a = ev.dataTransfer) == null ? void 0 : _a.dropEffect) === "none") {
      clearDragState();
    }
  };
  const handleDrop = (ev) => {
    clearDragState();
    ev.preventDefault();
  };
  return {
    dragType,
    dragState,
    handleDragStart,
    handleDragEnter,
    handleDragLeave,
    handleDragover,
    handleDragEnd,
    handleDrop
  };
};

// node_modules/@arco-design/web-vue/es/table/hooks/use-column-resize.js
var useColumnResize = (thRefs, emit) => {
  const resizingColumn = ref("");
  const columnWidth = reactive({});
  const handleThMouseDown = (dataIndex, ev) => {
    ev.preventDefault();
    resizingColumn.value = dataIndex;
    on(window, "mousemove", handleThMouseMoving);
    on(window, "mouseup", handleThMouseUp);
    on(window, "contextmenu", handleThMouseUp);
  };
  const handleThMouseUp = () => {
    resizingColumn.value = "";
    off(window, "mousemove", handleThMouseMoving);
    off(window, "mouseup", handleThMouseUp);
    off(window, "contextmenu", handleThMouseUp);
  };
  const handleThMouseMoving = (ev) => {
    const element = thRefs.value[resizingColumn.value];
    if (element) {
      const { clientX } = ev;
      const { x } = element.getBoundingClientRect();
      let width = Math.ceil(clientX - x);
      if (width < 40) {
        width = 40;
      }
      columnWidth[resizingColumn.value] = width;
      emit("columnResize", resizingColumn.value, width);
    }
  };
  return {
    resizingColumn,
    columnWidth,
    handleThMouseDown,
    handleThMouseUp
  };
};

// node_modules/@arco-design/web-vue/es/table/hooks/use-filter.js
var useFilter = ({
  columns,
  onFilterChange
}) => {
  const _filters = ref(getDefaultFilters(columns.value));
  watch(columns, (columns2) => {
    const newFilters = getDefaultFilters(columns2);
    if (!isEqual(newFilters, _filters.value)) {
      _filters.value = newFilters;
    }
  });
  const computedFilters = computed(() => {
    var _a, _b;
    const filters = {};
    for (const item of columns.value) {
      if (item.dataIndex) {
        const value = (_b = (_a = item.filterable) == null ? void 0 : _a.filteredValue) != null ? _b : _filters.value[item.dataIndex];
        if (value) {
          filters[item.dataIndex] = value;
        }
      }
    }
    return filters;
  });
  const resetFilters = (dataIndex) => {
    var _a;
    const _dataIndex = dataIndex ? [].concat(dataIndex) : [];
    const filters = {};
    for (const item of columns.value) {
      if (item.dataIndex && item.filterable) {
        if (_dataIndex.length === 0 || _dataIndex.includes(item.dataIndex)) {
          const filteredValue = (_a = item.filterable.defaultFilteredValue) != null ? _a : [];
          filters[item.dataIndex] = filteredValue;
          onFilterChange(item.dataIndex, filteredValue);
        }
      }
    }
    _filters.value = filters;
  };
  const clearFilters = (dataIndex) => {
    const _dataIndex = dataIndex ? [].concat(dataIndex) : [];
    const filters = {};
    for (const item of columns.value) {
      if (item.dataIndex && item.filterable) {
        if (_dataIndex.length === 0 || _dataIndex.includes(item.dataIndex)) {
          const filteredValue = [];
          filters[item.dataIndex] = filteredValue;
          onFilterChange(item.dataIndex, filteredValue);
        }
      }
    }
    _filters.value = filters;
  };
  return {
    _filters,
    computedFilters,
    resetFilters,
    clearFilters
  };
};
var getDefaultFilters = (columns) => {
  var _a;
  const filters = {};
  for (const item of columns) {
    if (item.dataIndex && ((_a = item.filterable) == null ? void 0 : _a.defaultFilteredValue)) {
      filters[item.dataIndex] = item.filterable.defaultFilteredValue;
    }
  }
  return filters;
};

// node_modules/@arco-design/web-vue/es/table/hooks/use-sorter.js
var useSorter = ({
  columns,
  onSorterChange
}) => {
  const _sorter = ref(getDefaultSorter(columns.value));
  watch(columns, (columns2) => {
    const newSorter = getDefaultSorter(columns2);
    if (!isEqual(newSorter, _sorter.value)) {
      _sorter.value = newSorter;
    }
  });
  const computedSorter = computed(() => {
    var _a;
    for (const item of columns.value) {
      if (item.dataIndex && item.sortable) {
        const direction = isString(item.sortable.sortOrder) ? item.sortable.sortOrder : ((_a = _sorter.value) == null ? void 0 : _a.field) === item.dataIndex ? _sorter.value.direction : "";
        if (direction) {
          return {
            field: item.dataIndex,
            direction
          };
        }
      }
    }
    return void 0;
  });
  const resetSorters = () => {
    var _a;
    let sorter;
    for (const item of columns.value) {
      if (item.dataIndex && item.sortable) {
        if (!sorter && item.sortable.defaultSortOrder) {
          sorter = {
            field: item.dataIndex,
            direction: item.sortable.defaultSortOrder
          };
        }
        onSorterChange(item.dataIndex, (_a = item.sortable.defaultSortOrder) != null ? _a : "");
      }
    }
    _sorter.value = sorter;
  };
  const clearSorters = () => {
    for (const item of columns.value) {
      if (item.dataIndex && item.sortable) {
        onSorterChange(item.dataIndex, "");
      }
    }
  };
  return {
    _sorter,
    computedSorter,
    resetSorters,
    clearSorters
  };
};
var getDefaultSorter = (columns) => {
  var _a;
  for (const item of columns) {
    if (item.dataIndex && ((_a = item.sortable) == null ? void 0 : _a.defaultSortOrder)) {
      return {
        field: item.dataIndex,
        direction: item.sortable.defaultSortOrder
      };
    }
  }
  return void 0;
};

// node_modules/@arco-design/web-vue/es/table/hooks/use-span.js
var useSpan = ({
  spanMethod,
  data,
  columns
}) => {
  const tableSpan = computed(() => {
    const span = {};
    if (spanMethod.value) {
      data.value.forEach((record, rowIndex) => {
        columns.value.forEach((column, columnIndex) => {
          var _a, _b;
          const { rowspan = 1, colspan = 1 } = (_b = (_a = spanMethod.value) == null ? void 0 : _a.call(spanMethod, {
            record: record.raw,
            column,
            rowIndex,
            columnIndex
          })) != null ? _b : {};
          if (rowspan > 1 || colspan > 1) {
            span[`${rowIndex}-${columnIndex}`] = [rowspan, colspan];
          }
        });
      });
    }
    return span;
  });
  const removedCells = computed(() => {
    const data2 = [];
    for (const indexKey of Object.keys(tableSpan.value)) {
      const indexArray = indexKey.split("-").map((item) => Number(item));
      const span = tableSpan.value[indexKey];
      for (let i2 = 1; i2 < span[0]; i2++) {
        data2.push(`${indexArray[0] + i2}-${indexArray[1]}`);
        for (let j = 1; j < span[1]; j++) {
          data2.push(`${indexArray[0] + i2}-${indexArray[1] + j}`);
        }
      }
      for (let i2 = 1; i2 < span[1]; i2++) {
        data2.push(`${indexArray[0]}-${indexArray[1] + i2}`);
      }
    }
    return data2;
  });
  return {
    tableSpan,
    removedCells
  };
};

// node_modules/@arco-design/web-vue/es/table/table.js
var __defProp53 = Object.defineProperty;
var __defProps24 = Object.defineProperties;
var __getOwnPropDescs24 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols53 = Object.getOwnPropertySymbols;
var __hasOwnProp53 = Object.prototype.hasOwnProperty;
var __propIsEnum53 = Object.prototype.propertyIsEnumerable;
var __defNormalProp53 = (obj, key, value) => key in obj ? __defProp53(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues53 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp53.call(b, prop))
      __defNormalProp53(a, prop, b[prop]);
  if (__getOwnPropSymbols53)
    for (var prop of __getOwnPropSymbols53(b)) {
      if (__propIsEnum53.call(b, prop))
        __defNormalProp53(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps24 = (a, b) => __defProps24(a, __getOwnPropDescs24(b));
function _isSlot13(s) {
  return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
var DEFAULT_BORDERED = {
  wrapper: true,
  cell: false,
  headerCell: false,
  bodyCell: false
};
var _Table = defineComponent({
  name: "Table",
  props: {
    columns: {
      type: Array,
      default: () => []
    },
    data: {
      type: Array,
      default: () => []
    },
    bordered: {
      type: [Boolean, Object],
      default: true
    },
    hoverable: {
      type: Boolean,
      default: true
    },
    stripe: {
      type: Boolean,
      default: false
    },
    size: {
      type: String,
      default: () => {
        var _a, _b;
        return (_b = (_a = inject(configProviderInjectionKey, void 0)) == null ? void 0 : _a.size) != null ? _b : "large";
      }
    },
    tableLayoutFixed: {
      type: Boolean,
      default: false
    },
    loading: {
      type: [Boolean, Object],
      default: false
    },
    rowSelection: {
      type: Object
    },
    expandable: {
      type: Object
    },
    scroll: {
      type: Object
    },
    pagination: {
      type: [Boolean, Object],
      default: true
    },
    pagePosition: {
      type: String,
      default: "br"
    },
    indentSize: {
      type: Number,
      default: 16
    },
    rowKey: {
      type: String,
      default: "key"
    },
    showHeader: {
      type: Boolean,
      default: true
    },
    virtualListProps: {
      type: Object
    },
    spanMethod: {
      type: Function
    },
    spanAll: {
      type: Boolean,
      default: false
    },
    components: {
      type: Object
    },
    loadMore: {
      type: Function
    },
    filterIconAlignLeft: {
      type: Boolean,
      default: false
    },
    hideExpandButtonOnEmpty: {
      type: Boolean,
      default: false
    },
    rowClass: {
      type: [String, Array, Object, Function]
    },
    draggable: {
      type: Object
    },
    rowNumber: {
      type: [Boolean, Object]
    },
    columnResizable: {
      type: Boolean
    },
    summary: {
      type: [Boolean, Function]
    },
    summaryText: {
      type: String,
      default: "Summary"
    },
    summarySpanMethod: {
      type: Function
    },
    selectedKeys: {
      type: Array
    },
    defaultSelectedKeys: {
      type: Array
    },
    expandedKeys: {
      type: Array
    },
    defaultExpandedKeys: {
      type: Array
    },
    defaultExpandAllRows: {
      type: Boolean,
      default: false
    },
    stickyHeader: {
      type: [Boolean, Number],
      default: false
    },
    scrollbar: {
      type: [Object, Boolean],
      default: true
    }
  },
  emits: {
    "update:selectedKeys": (rowKeys) => true,
    "update:expandedKeys": (rowKeys) => true,
    "expand": (rowKey, record) => true,
    "expandedChange": (rowKeys) => true,
    "select": (rowKeys, rowKey, record) => true,
    "selectAll": (checked) => true,
    "selectionChange": (rowKeys) => true,
    "sorterChange": (dataIndex, direction) => true,
    "filterChange": (dataIndex, filteredValues) => true,
    "pageChange": (page) => true,
    "pageSizeChange": (pageSize) => true,
    "change": (data, extra, currentData) => true,
    "cellClick": (record, column, ev) => true,
    "rowClick": (record, ev) => true,
    "headerClick": (column, ev) => true,
    "columnResize": (dataIndex, width) => true
  },
  setup(props, {
    emit,
    slots
  }) {
    const {
      columns,
      rowKey,
      rowSelection,
      expandable,
      loadMore,
      filterIconAlignLeft,
      selectedKeys,
      defaultSelectedKeys,
      expandedKeys,
      defaultExpandedKeys,
      defaultExpandAllRows,
      spanMethod,
      draggable,
      summarySpanMethod,
      scrollbar
    } = toRefs(props);
    const prefixCls = getPrefixCls("table");
    const bordered = computed(() => {
      if (isObject(props.bordered)) {
        return __spreadValues53(__spreadValues53({}, DEFAULT_BORDERED), props.bordered);
      }
      return __spreadProps24(__spreadValues53({}, DEFAULT_BORDERED), {
        wrapper: props.bordered
      });
    });
    const {
      children,
      components: components2
    } = useChildrenComponents("TableColumn");
    const checkStrictly = computed(() => {
      var _a, _b;
      return (_b = (_a = rowSelection.value) == null ? void 0 : _a.checkStrictly) != null ? _b : true;
    });
    const {
      displayScrollbar,
      scrollbarProps
    } = useScrollbar(scrollbar);
    const isScroll2 = computed(() => {
      var _a, _b, _c, _d;
      const x = Boolean(((_a = props.scroll) == null ? void 0 : _a.x) || ((_b = props.scroll) == null ? void 0 : _b.minWidth));
      const y = Boolean(((_c = props.scroll) == null ? void 0 : _c.y) || ((_d = props.scroll) == null ? void 0 : _d.maxHeight));
      return {
        x,
        y
      };
    });
    const summaryRef = ref();
    const thRefs = ref({});
    const {
      componentRef: contentComRef,
      elementRef: contentRef
    } = useComponentRef("containerRef");
    const {
      componentRef: tbodyComRef,
      elementRef: tbodyRef
    } = useComponentRef("containerRef");
    const {
      componentRef: virtualComRef,
      elementRef: virtualRef
    } = useComponentRef("viewportRef");
    const {
      componentRef: theadComRef,
      elementRef: theadRef
    } = useComponentRef("containerRef");
    const containerElement = computed(() => {
      if (splitTable.value) {
        if (isVirtualList.value) {
          return virtualRef.value;
        }
        return tbodyRef.value;
      }
      return contentRef.value;
    });
    const splitTable = computed(() => isScroll2.value.y || props.stickyHeader || isVirtualList.value || isScroll2.value.x && flattenData.value.length === 0);
    const slotColumnMap = reactive(/* @__PURE__ */ new Map());
    const slotColumns = ref();
    watch([components2, slotColumnMap], ([components22, slotColumnMap2]) => {
      if (components22.length > 0) {
        const columns2 = [];
        components22.forEach((id) => {
          const column = slotColumnMap2.get(id);
          if (column)
            columns2.push(column);
        });
        slotColumns.value = columns2;
      } else {
        slotColumns.value = void 0;
      }
    });
    const dataColumnMap = /* @__PURE__ */ new Map();
    const dataColumns = ref([]);
    const groupColumns = ref([]);
    watch([columns, slotColumns], ([columns2, slotColumns2]) => {
      var _a;
      const result = getGroupColumns((_a = slotColumns2 != null ? slotColumns2 : columns2) != null ? _a : [], dataColumnMap);
      dataColumns.value = result.dataColumns;
      groupColumns.value = result.groupColumns;
    }, {
      immediate: true,
      deep: true
    });
    const isPaginationTop = computed(() => ["tl", "top", "tr"].includes(props.pagePosition));
    const hasLeftFixedColumn = ref(false);
    const hasRightFixedColumn = ref(false);
    const hasLeftFixedDataColumns = ref(false);
    watchEffect(() => {
      var _a, _b, _c;
      let _hasLeftFixedColumn = false;
      let _hasRightFixedColumn = false;
      let _hasLeftFixedDataColumns = false;
      if (((_a = props.rowSelection) == null ? void 0 : _a.fixed) || ((_b = props.expandable) == null ? void 0 : _b.fixed) || ((_c = props.draggable) == null ? void 0 : _c.fixed)) {
        _hasLeftFixedColumn = true;
      }
      for (const column of dataColumns.value) {
        if (column.fixed === "left") {
          _hasLeftFixedColumn = true;
          _hasLeftFixedDataColumns = true;
        } else if (column.fixed === "right") {
          _hasRightFixedColumn = true;
        }
      }
      if (_hasLeftFixedColumn !== hasLeftFixedColumn.value) {
        hasLeftFixedColumn.value = _hasLeftFixedColumn;
      }
      if (_hasRightFixedColumn !== hasRightFixedColumn.value) {
        hasRightFixedColumn.value = _hasRightFixedColumn;
      }
      if (_hasLeftFixedDataColumns !== hasLeftFixedDataColumns.value) {
        hasLeftFixedDataColumns.value = _hasLeftFixedDataColumns;
      }
    });
    const hasEllipsis = computed(() => {
      for (const col of dataColumns.value) {
        if (col.ellipsis) {
          return true;
        }
      }
      return false;
    });
    const handleChange = (type) => {
      const extra = {
        type,
        page: page.value,
        pageSize: pageSize.value,
        sorter: computedSorter.value,
        filters: computedFilters.value,
        dragTarget: type === "drag" ? dragState.data : void 0
      };
      emit("change", flattenRawData.value, extra, sortedData.value);
    };
    const handleFilterChange = (dataIndex, filteredValues) => {
      _filters.value = __spreadProps24(__spreadValues53({}, computedFilters.value), {
        [dataIndex]: filteredValues
      });
      emit("filterChange", dataIndex, filteredValues);
      handleChange("filter");
    };
    const handleSorterChange = (dataIndex, direction) => {
      _sorter.value = direction ? {
        field: dataIndex,
        direction
      } : void 0;
      emit("sorterChange", dataIndex, direction);
      handleChange("sorter");
    };
    const {
      _filters,
      computedFilters,
      resetFilters,
      clearFilters
    } = useFilter({
      columns: dataColumns,
      onFilterChange: handleFilterChange
    });
    const {
      _sorter,
      computedSorter,
      resetSorters,
      clearSorters
    } = useSorter({
      columns: dataColumns,
      onSorterChange: handleSorterChange
    });
    const disabledKeys = /* @__PURE__ */ new Set();
    const allRowKeys = computed(() => {
      const allRowKeys2 = [];
      disabledKeys.clear();
      const travelData = (data) => {
        if (isArray(data) && data.length > 0) {
          for (const record of data) {
            allRowKeys2.push(record[rowKey.value]);
            if (record.disabled) {
              disabledKeys.add(record[rowKey.value]);
            }
            if (record.children) {
              travelData(record.children);
            }
          }
        }
      };
      travelData(props.data);
      return allRowKeys2;
    });
    const currentAllRowKeys = computed(() => {
      const keys = [];
      const travel = (data) => {
        for (const record of data) {
          keys.push(record.key);
          if (record.children) {
            travel(record.children);
          }
        }
      };
      travel(flattenData.value);
      return keys;
    });
    const currentAllEnabledRowKeys = computed(() => {
      const keys = [];
      const travel = (data) => {
        for (const record of data) {
          if (!record.disabled) {
            keys.push(record.key);
          }
          if (record.children) {
            travel(record.children);
          }
        }
      };
      travel(flattenData.value);
      return keys;
    });
    const {
      isRadio,
      selectedRowKeys,
      currentSelectedRowKeys,
      handleSelect,
      handleSelectAllLeafs,
      handleSelectAll,
      select,
      selectAll,
      clearSelected
    } = useRowSelection({
      selectedKeys,
      defaultSelectedKeys,
      rowSelection,
      currentAllRowKeys,
      currentAllEnabledRowKeys,
      emit
    });
    const {
      expandedRowKeys,
      handleExpand,
      expand,
      expandAll
    } = useExpand({
      expandedKeys,
      defaultExpandedKeys,
      defaultExpandAllRows,
      expandable,
      allRowKeys,
      emit
    });
    const lazyLoadData = reactive({});
    const addLazyLoadData = (children2, record) => {
      if (children2) {
        lazyLoadData[record.key] = children2;
      }
    };
    const isValidRecord = (record) => {
      var _a, _b;
      for (const field of Object.keys(computedFilters.value)) {
        const filteredValues = computedFilters.value[field];
        const column = dataColumnMap.get(field);
        if (column && ((_a = column.filterable) == null ? void 0 : _a.filter) && filteredValues.length > 0) {
          const result = (_b = column.filterable) == null ? void 0 : _b.filter(filteredValues, record.raw);
          if (!result) {
            return result;
          }
        }
      }
      return true;
    };
    const {
      dragType,
      dragState,
      handleDragStart,
      handleDragEnter,
      handleDragLeave,
      handleDragover,
      handleDragEnd,
      handleDrop
    } = useDrag(draggable);
    const {
      resizingColumn,
      columnWidth,
      handleThMouseDown
    } = useColumnResize(thRefs, emit);
    const processedData = computed(() => {
      var _a;
      const travel = (data) => {
        const result = [];
        for (const _record of data) {
          const record = {
            raw: _record,
            key: _record[props.rowKey],
            disabled: _record.disabled,
            expand: _record.expand,
            isLeaf: _record.isLeaf
          };
          if (_record.children) {
            record.isLeaf = false;
            record.children = travel(_record.children);
          } else if (props.loadMore && !_record.isLeaf) {
            record.isLeaf = false;
            if (lazyLoadData[record.key]) {
              record.children = travel(lazyLoadData[record.key]);
            }
          } else {
            record.isLeaf = true;
          }
          record.hasSubtree = Boolean(record.children ? props.hideExpandButtonOnEmpty ? record.children.length > 0 : true : props.loadMore && !record.isLeaf);
          result.push(record);
        }
        return result;
      };
      return travel((_a = props.data) != null ? _a : []);
    });
    const validData = computed(() => {
      const travel = (data) => data.filter((record) => {
        if (isValidRecord(record)) {
          if (record.children) {
            record.children = travel(record.children);
          }
          return true;
        }
        return false;
      });
      return Object.keys(computedFilters.value).length > 0 ? travel(processedData.value) : processedData.value;
    });
    const sortedData = computed(() => {
      var _a, _b;
      const data = [...validData.value];
      if (data.length > 0) {
        if ((_a = computedSorter.value) == null ? void 0 : _a.field) {
          const column = dataColumnMap.get(computedSorter.value.field);
          if (column && ((_b = column.sortable) == null ? void 0 : _b.sorter) !== true) {
            const {
              field,
              direction
            } = computedSorter.value;
            data.sort((a, b) => {
              var _a2;
              const valueA = a.raw[field];
              const valueB = b.raw[field];
              if (((_a2 = column.sortable) == null ? void 0 : _a2.sorter) && isFunction(column.sortable.sorter)) {
                return column.sortable.sorter(a.raw, b.raw, {
                  dataIndex: field,
                  direction
                });
              }
              const result = valueA > valueB ? 1 : -1;
              return direction === "descend" ? -result : result;
            });
          }
        }
        if (dragState.dragging && dragState.targetPath.length > 0) {
          const target3 = spliceFromPath(data, dragState.sourcePath);
          spliceFromPath(data, dragState.targetPath, target3);
        }
      }
      return data;
    });
    const {
      page,
      pageSize,
      handlePageChange,
      handlePageSizeChange
    } = usePagination2(props, emit);
    const onlyCurrent = computed(() => {
      var _a, _b;
      return (_b = (_a = rowSelection.value) == null ? void 0 : _a.onlyCurrent) != null ? _b : false;
    });
    watch(page, (cur, pre) => {
      if (cur !== pre && onlyCurrent.value) {
        clearSelected();
      }
    });
    const flattenData = computed(() => {
      if (props.pagination && sortedData.value.length > pageSize.value) {
        return sortedData.value.slice((page.value - 1) * pageSize.value, page.value * pageSize.value);
      }
      return sortedData.value;
    });
    const flattenRawData = computed(() => flattenData.value.map((item) => item.raw));
    const getSummaryData = () => {
      return dataColumns.value.reduce((per, column, index3) => {
        if (column.dataIndex) {
          if (index3 === 0) {
            per[column.dataIndex] = props.summaryText;
          } else {
            let count = 0;
            let isNotNumber = false;
            flattenData.value.forEach((data) => {
              if (column.dataIndex) {
                if (isNumber(data.raw[column.dataIndex])) {
                  count += data.raw[column.dataIndex];
                } else if (!isUndefined(data.raw[column.dataIndex]) && !isNull(data.raw[column.dataIndex])) {
                  isNotNumber = true;
                }
              }
            });
            per[column.dataIndex] = isNotNumber ? "" : count;
          }
        }
        return per;
      }, {});
    };
    const getTableDataWithRaw = (data) => {
      if (data && data.length > 0) {
        return data.map((raw) => {
          return {
            raw,
            key: raw[props.rowKey]
          };
        });
      }
      return void 0;
    };
    const summaryData = computed(() => {
      if (props.summary) {
        if (isFunction(props.summary)) {
          return getTableDataWithRaw(props.summary({
            columns: dataColumns.value,
            data: flattenRawData.value
          }));
        }
        return getTableDataWithRaw([getSummaryData()]);
      }
      return void 0;
    });
    const containerScrollLeft = ref(0);
    const alignLeft = ref(true);
    const alignRight = ref(true);
    const setAlignPosition = () => {
      let _alignLeft = true;
      let _alignRight = true;
      const scrollContainer = containerElement.value;
      if (scrollContainer) {
        _alignLeft = containerScrollLeft.value === 0;
        _alignRight = Math.ceil(containerScrollLeft.value + scrollContainer.offsetWidth) >= scrollContainer.scrollWidth;
      }
      if (_alignLeft !== alignLeft.value) {
        alignLeft.value = _alignLeft;
      }
      if (_alignRight !== alignRight.value) {
        alignRight.value = _alignRight;
      }
    };
    const getTableScrollCls = () => {
      if (alignLeft.value && alignRight.value) {
        return `${prefixCls}-scroll-position-both`;
      }
      if (alignLeft.value) {
        return `${prefixCls}-scroll-position-left`;
      }
      if (alignRight.value) {
        return `${prefixCls}-scroll-position-right`;
      }
      return `${prefixCls}-scroll-position-middle`;
    };
    const getTableFixedCls = () => {
      const cls2 = [];
      if (hasLeftFixedColumn.value) {
        cls2.push(`${prefixCls}-has-fixed-col-left`);
      }
      if (hasRightFixedColumn.value) {
        cls2.push(`${prefixCls}-has-fixed-col-right`);
      }
      return cls2;
    };
    const handleScroll = (e2) => {
      if (e2.target.scrollLeft !== containerScrollLeft.value) {
        containerScrollLeft.value = e2.target.scrollLeft;
      }
      setAlignPosition();
    };
    const onTbodyScroll = (e2) => {
      handleScroll(e2);
      const {
        scrollLeft
      } = e2.target;
      if (theadRef.value) {
        theadRef.value.scrollLeft = scrollLeft;
      }
      if (summaryRef.value) {
        summaryRef.value.scrollLeft = scrollLeft;
      }
    };
    const handleRowClick = (record, ev) => {
      emit("rowClick", record.raw, ev);
    };
    const handleCellClick = (record, column, ev) => {
      emit("cellClick", record.raw, column, ev);
    };
    const handleHeaderClick = (column, ev) => {
      emit("headerClick", column, ev);
    };
    const operations = computed(() => {
      var _a, _b;
      const operations2 = [];
      const hasFixedColumn = hasLeftFixedColumn.value || hasRightFixedColumn.value;
      let dragHandle;
      let expand2;
      let selection;
      if (((_a = props.draggable) == null ? void 0 : _a.type) === "handle") {
        dragHandle = {
          name: "drag-handle",
          title: props.draggable.title,
          width: props.draggable.width,
          fixed: props.draggable.fixed || hasFixedColumn
        };
        operations2.push(dragHandle);
      }
      if (props.expandable) {
        expand2 = {
          name: "expand",
          title: props.expandable.title,
          width: props.expandable.width,
          fixed: props.expandable.fixed || hasFixedColumn
        };
        operations2.push(expand2);
      }
      if (props.rowSelection) {
        selection = {
          name: props.rowSelection.type === "radio" ? "selection-radio" : "selection-checkbox",
          title: props.rowSelection.title,
          width: props.rowSelection.width,
          fixed: props.rowSelection.fixed || hasFixedColumn
        };
        operations2.push(selection);
      }
      if (!hasLeftFixedDataColumns.value && operations2.length > 0 && operations2[operations2.length - 1].fixed) {
        operations2[operations2.length - 1].isLastLeftFixed = true;
      }
      const operationsFn = (_b = props.components) == null ? void 0 : _b.operations;
      return isFunction(operationsFn) ? operationsFn({
        dragHandle,
        expand: expand2,
        selection
      }) : operations2;
    });
    const headerStyle = computed(() => {
      var _a, _b, _c, _d;
      if (isScroll2.value.x) {
        const style2 = {
          width: isNumber((_a = props.scroll) == null ? void 0 : _a.x) ? `${(_b = props.scroll) == null ? void 0 : _b.x}px` : (_c = props.scroll) == null ? void 0 : _c.x
        };
        if ((_d = props.scroll) == null ? void 0 : _d.minWidth) {
          style2.minWidth = isNumber(props.scroll.minWidth) ? `${props.scroll.minWidth}px` : props.scroll.minWidth;
        }
        return style2;
      }
      return void 0;
    });
    const contentStyle = computed(() => {
      var _a, _b, _c, _d;
      if (isScroll2.value.x && flattenData.value.length > 0) {
        const style2 = {
          width: isNumber((_a = props.scroll) == null ? void 0 : _a.x) ? `${(_b = props.scroll) == null ? void 0 : _b.x}px` : (_c = props.scroll) == null ? void 0 : _c.x
        };
        if ((_d = props.scroll) == null ? void 0 : _d.minWidth) {
          style2.minWidth = isNumber(props.scroll.minWidth) ? `${props.scroll.minWidth}px` : props.scroll.minWidth;
        }
        return style2;
      }
      return void 0;
    });
    const addColumn = (id, column) => {
      slotColumnMap.set(id, column);
    };
    const removeColumn = (id) => {
      slotColumnMap.delete(id);
    };
    provide(tableInjectionKey, reactive({
      loadMore,
      addLazyLoadData,
      slots,
      sorter: computedSorter,
      filters: computedFilters,
      filterIconAlignLeft,
      resizingColumn,
      checkStrictly,
      currentAllEnabledRowKeys,
      currentSelectedRowKeys,
      addColumn,
      removeColumn,
      onSelectAll: handleSelectAll,
      onSelect: handleSelect,
      onSelectAllLeafs: handleSelectAllLeafs,
      onSorterChange: handleSorterChange,
      onFilterChange: handleFilterChange,
      onThMouseDown: handleThMouseDown
    }));
    const cls = computed(() => [prefixCls, `${prefixCls}-size-${props.size}`, {
      [`${prefixCls}-border`]: bordered.value.wrapper,
      [`${prefixCls}-border-cell`]: bordered.value.cell,
      [`${prefixCls}-border-header-cell`]: !bordered.value.cell && bordered.value.headerCell,
      [`${prefixCls}-border-body-cell`]: !bordered.value.cell && bordered.value.bodyCell,
      [`${prefixCls}-stripe`]: props.stripe,
      [`${prefixCls}-hover`]: props.hoverable,
      [`${prefixCls}-dragging`]: dragState.dragging,
      [`${prefixCls}-type-selection`]: Boolean(props.rowSelection),
      [`${prefixCls}-empty`]: props.data && flattenData.value.length === 0,
      [`${prefixCls}-layout-fixed`]: props.tableLayoutFixed || isScroll2.value.x || splitTable.value || hasEllipsis.value
    }]);
    const paginationCls = computed(() => [`${prefixCls}-pagination`, {
      [`${prefixCls}-pagination-left`]: props.pagePosition === "tl" || props.pagePosition === "bl",
      [`${prefixCls}-pagination-center`]: props.pagePosition === "top" || props.pagePosition === "bottom",
      [`${prefixCls}-pagination-right`]: props.pagePosition === "tr" || props.pagePosition === "br",
      [`${prefixCls}-pagination-top`]: isPaginationTop.value
    }]);
    const tableCls = computed(() => {
      const cls2 = getTableFixedCls();
      if (isScroll2.value.x) {
        cls2.push(getTableScrollCls());
      }
      if (splitTable.value) {
        cls2.push(`${prefixCls}-scroll-y`);
      }
      return cls2;
    });
    const isVirtualList = computed(() => Boolean(props.virtualListProps));
    const thWidth = ref({});
    const getThWidth = () => {
      const width = {};
      for (const key of Object.keys(thRefs.value)) {
        width[key] = thRefs.value[key].offsetWidth;
      }
      thWidth.value = width;
    };
    const hasScrollBar = ref(false);
    const isTbodyHasScrollBar = () => {
      if (tbodyRef.value) {
        return tbodyRef.value.offsetWidth > tbodyRef.value.clientWidth;
      }
      return false;
    };
    const handleTbodyResize = () => {
      const _hasScrollBar = isTbodyHasScrollBar();
      if (hasScrollBar.value !== _hasScrollBar) {
        hasScrollBar.value = _hasScrollBar;
      }
      setAlignPosition();
      getThWidth();
    };
    onMounted(() => {
      hasScrollBar.value = isTbodyHasScrollBar();
      getThWidth();
    });
    const spinProps = computed(() => isObject(props.loading) ? props.loading : {
      loading: props.loading
    });
    const renderEmpty = () => {
      return createVNode(Tr, {
        "empty": true
      }, {
        default: () => [createVNode(Td, {
          "colSpan": dataColumns.value.length + operations.value.length
        }, {
          default: () => {
            var _a, _b;
            return [(_b = (_a = slots.empty) == null ? void 0 : _a.call(slots)) != null ? _b : createVNode(Empty2, null, null)];
          }
        })]
      });
    };
    const renderExpandContent = (record) => {
      var _a;
      if (record.expand) {
        return isFunction(record.expand) ? record.expand() : record.expand;
      }
      if (slots["expand-row"]) {
        return slots["expand-row"]({
          record: record.raw
        });
      }
      if ((_a = props.expandable) == null ? void 0 : _a.expandedRowRender) {
        return props.expandable.expandedRowRender(record.raw);
      }
      return void 0;
    };
    const allColumns = computed(() => [].concat(operations.value, dataColumns.value));
    const spanColumns = computed(() => props.spanAll ? allColumns.value : dataColumns.value);
    const {
      tableSpan,
      removedCells
    } = useSpan({
      spanMethod,
      data: flattenData,
      columns: spanColumns
    });
    const {
      tableSpan: tableSummarySpan,
      removedCells: removedSummaryCells
    } = useSpan({
      spanMethod: summarySpanMethod,
      data: flattenData,
      columns: allColumns
    });
    const getVirtualColumnStyle = (name) => {
      if (!isVirtualList.value || !name || !thWidth.value[name]) {
        return void 0;
      }
      return {
        width: `${thWidth.value[name]}px`
      };
    };
    const renderSummaryRow = (record, rowIndex) => {
      return createVNode(Tr, {
        "key": `table-summary-${rowIndex}`,
        "class": [`${prefixCls}-tr-summary`, isFunction(props.rowClass) ? props.rowClass(record.raw, rowIndex) : props.rowClass],
        "onClick": (ev) => handleRowClick(record, ev)
      }, {
        default: () => [operations.value.map((operation, index3) => {
          var _a;
          const cellId = `${rowIndex}-${index3}`;
          const [rowspan, colspan] = (_a = tableSummarySpan.value[cellId]) != null ? _a : [1, 1];
          if (removedSummaryCells.value.includes(cellId)) {
            return null;
          }
          const style2 = getVirtualColumnStyle(operation.name);
          return createVNode(OperationTd, {
            "style": style2,
            "operationColumn": operation,
            "operations": operations.value,
            "record": record,
            "rowSpan": rowspan,
            "colSpan": colspan,
            "summary": true
          }, null);
        }), dataColumns.value.map((column, index3) => {
          var _a;
          const cellId = `${rowIndex}-${operations.value.length + index3}`;
          const [rowspan, colspan] = (_a = tableSummarySpan.value[cellId]) != null ? _a : [1, 1];
          if (removedSummaryCells.value.includes(cellId)) {
            return null;
          }
          const style2 = getVirtualColumnStyle(column.dataIndex);
          return createVNode(Td, {
            "key": `td-${cellId}`,
            "style": style2,
            "rowIndex": rowIndex,
            "record": record,
            "column": column,
            "operations": operations.value,
            "dataColumns": dataColumns.value,
            "rowSpan": rowspan,
            "colSpan": colspan,
            "summary": true,
            "onClick": (ev) => handleCellClick(record, column, ev)
          }, {
            td: slots.td,
            cell: slots["summary-cell"]
          });
        })],
        tr: slots.tr
      });
    };
    const renderSummary = () => {
      if (summaryData.value) {
        return createVNode("tfoot", null, [summaryData.value.map((data, index3) => renderSummaryRow(data, index3))]);
      }
      return null;
    };
    const renderExpandBtn = (record, stopPropagation = true) => {
      var _a, _b, _c, _d, _e;
      const currentKey = record.key;
      const expanded = expandedRowKeys.value.includes(currentKey);
      return createVNode("button", {
        "type": "button",
        "class": `${prefixCls}-expand-btn`,
        "onClick": (ev) => {
          handleExpand(currentKey, record.raw);
          if (stopPropagation) {
            ev.stopPropagation();
          }
        }
      }, [(_e = (_d = (_a = slots["expand-icon"]) == null ? void 0 : _a.call(slots, {
        expanded,
        record: record.raw
      })) != null ? _d : (_c = (_b = props.expandable) == null ? void 0 : _b.icon) == null ? void 0 : _c.call(_b, expanded, record.raw)) != null ? _e : expanded ? createVNode(IconMinus, null, null) : createVNode(IconPlus, null, null)]);
    };
    const renderExpand = (record, {
      indentSize,
      indexPath,
      allowDrag,
      expandContent
    }) => {
      var _a;
      if (record.hasSubtree) {
        return (_a = record.children) == null ? void 0 : _a.map((item, index3) => renderRecord(item, index3, {
          indentSize,
          indexPath,
          allowDrag
        }));
      }
      if (expandContent) {
        const scrollContainer = containerElement.value;
        return createVNode(Tr, {
          "key": `${record.key}-expand`,
          "expand": true
        }, {
          default: () => [createVNode(Td, {
            "isFixedExpand": hasLeftFixedColumn.value || hasRightFixedColumn.value,
            "containerWidth": scrollContainer == null ? void 0 : scrollContainer.clientWidth,
            "colSpan": dataColumns.value.length + operations.value.length
          }, _isSlot13(expandContent) ? expandContent : {
            default: () => [expandContent]
          })]
        });
      }
      return null;
    };
    const renderRecord = (record, rowIndex, {
      indentSize = 0,
      indexPath,
      allowDrag = true
    } = {}) => {
      var _a;
      const currentKey = record.key;
      const currentPath = (indexPath != null ? indexPath : []).concat(rowIndex);
      const expandContent = renderExpandContent(record);
      const showExpand = expandedRowKeys.value.includes(currentKey);
      const isDragTarget = dragState.sourceKey === record.key;
      const dragSourceEvent = dragType.value ? {
        draggable: allowDrag,
        onDragstart: (ev) => {
          if (!allowDrag)
            return;
          handleDragStart(ev, record.key, currentPath, record.raw);
        },
        onDragend: (ev) => {
          if (!allowDrag)
            return;
          handleDragEnd(ev);
        }
      } : {};
      const dragTargetEvent = dragType.value ? {
        onDragenter: (ev) => {
          if (!allowDrag)
            return;
          handleDragEnter(ev, currentPath);
        },
        onDragover: (ev) => {
          if (!allowDrag)
            return;
          handleDragover(ev);
        },
        onDrop: (ev) => {
          if (!allowDrag)
            return;
          handleChange("drag");
          handleDrop(ev);
        }
      } : {};
      return createVNode(Fragment, null, [createVNode(Tr, mergeProps({
        "key": currentKey,
        "class": [{
          [`${prefixCls}-tr-draggable`]: dragType.value === "row",
          [`${prefixCls}-tr-drag`]: isDragTarget
        }, isFunction(props.rowClass) ? props.rowClass(record, rowIndex) : props.rowClass],
        "rowIndex": rowIndex,
        "record": record,
        "checked": (_a = selectedRowKeys.value) == null ? void 0 : _a.includes(currentKey),
        "onClick": (ev) => handleRowClick(record, ev)
      }, dragType.value === "row" ? dragSourceEvent : {}, dragTargetEvent), {
        default: () => [operations.value.map((operation, index3) => {
          var _a2;
          const cellId = `${rowIndex}-${index3}`;
          const [rowspan, colspan] = props.spanAll ? (_a2 = tableSpan.value[cellId]) != null ? _a2 : [1, 1] : [1, 1];
          if (props.spanAll && removedCells.value.includes(cellId)) {
            return null;
          }
          const style2 = getVirtualColumnStyle(operation.name);
          return createVNode(OperationTd, mergeProps({
            "key": `operation-td-${index3}`,
            "style": style2,
            "operationColumn": operation,
            "operations": operations.value,
            "record": record,
            "hasExpand": Boolean(expandContent),
            "selectedRowKeys": currentSelectedRowKeys.value,
            "rowSpan": rowspan,
            "colSpan": colspan,
            "renderExpandBtn": renderExpandBtn
          }, dragType.value === "handle" ? dragSourceEvent : {}), {
            "drag-handle-icon": slots["drag-handle-icon"]
          });
        }), dataColumns.value.map((column, index3) => {
          var _a2;
          const cellId = `${rowIndex}-${props.spanAll ? operations.value.length + index3 : index3}`;
          const [rowspan, colspan] = (_a2 = tableSpan.value[cellId]) != null ? _a2 : [1, 1];
          if (removedCells.value.includes(cellId)) {
            return null;
          }
          const extraProps = index3 === 0 ? {
            showExpandBtn: record.hasSubtree,
            indentSize: record.hasSubtree ? indentSize - 20 : indentSize
          } : {};
          const style2 = getVirtualColumnStyle(column.dataIndex);
          return createVNode(Td, mergeProps({
            "key": `td-${index3}`,
            "style": style2,
            "rowIndex": rowIndex,
            "record": record,
            "column": column,
            "operations": operations.value,
            "dataColumns": dataColumns.value,
            "rowSpan": rowspan,
            "renderExpandBtn": renderExpandBtn,
            "colSpan": colspan
          }, extraProps, {
            "onClick": (ev) => handleCellClick(record, column, ev)
          }), {
            td: slots.td
          });
        })],
        tr: slots.tr
      }), showExpand && renderExpand(record, {
        indentSize: indentSize + props.indentSize,
        indexPath: currentPath,
        allowDrag: allowDrag && !isDragTarget,
        expandContent
      })]);
    };
    const renderBody = () => {
      const hasSubData = flattenData.value.some((record) => Boolean(record.hasSubtree));
      return createVNode(Tbody, null, {
        default: () => [flattenData.value.length > 0 ? flattenData.value.map((record, index3) => renderRecord(record, index3, {
          indentSize: hasSubData ? 20 : 0
        })) : renderEmpty()],
        tbody: slots.tbody
      });
    };
    const renderHeader = () => createVNode(Thead, null, {
      default: () => [groupColumns.value.map((row, index3) => createVNode(Tr, {
        "key": `header-row-${index3}`
      }, {
        default: () => [index3 === 0 && operations.value.map((operation, index22) => {
          var _a;
          return createVNode(OperationTh, {
            "key": `operation-th-${index22}`,
            "ref": (ins) => {
              if ((ins == null ? void 0 : ins.$el) && operation.name) {
                thRefs.value[operation.name] = ins.$el;
              }
            },
            "operationColumn": operation,
            "operations": operations.value,
            "selectAll": Boolean(operation.name === "selection-checkbox" && ((_a = props.rowSelection) == null ? void 0 : _a.showCheckedAll)),
            "rowSpan": groupColumns.value.length
          }, null);
        }), row.map((column, index22) => {
          const resizable = props.columnResizable && Boolean(column.dataIndex) && index22 < row.length - 1;
          return createVNode(Th, {
            "key": `th-${index22}`,
            "ref": (ins) => {
              if ((ins == null ? void 0 : ins.$el) && column.dataIndex) {
                thRefs.value[column.dataIndex] = ins.$el;
              }
            },
            "column": column,
            "operations": operations.value,
            "dataColumns": dataColumns.value,
            "resizable": resizable,
            "onClick": (ev) => handleHeaderClick(column, ev)
          }, {
            th: slots.th
          });
        })]
      }))],
      thead: slots.thead
    });
    const renderContent = () => {
      if (splitTable.value) {
        const style2 = {};
        if (hasScrollBar.value) {
          style2.overflowY = "scroll";
        }
        if (isNumber(props.stickyHeader)) {
          style2.top = `${props.stickyHeader}px`;
        }
        const Component = displayScrollbar.value ? Scrollbar : "div";
        return createVNode(Fragment, null, [props.showHeader && createVNode(Component, mergeProps({
          "ref": theadComRef,
          "class": [`${prefixCls}-header`, {
            [`${prefixCls}-header-sticky`]: props.stickyHeader
          }],
          "style": style2
        }, scrollbar.value ? __spreadValues53({
          hide: flattenData.value.length !== 0,
          disableVertical: true
        }, scrollbarProps.value) : void 0), {
          default: () => [createVNode("table", {
            "class": `${prefixCls}-element`,
            "style": headerStyle.value,
            "cellpadding": 0,
            "cellspacing": 0
          }, [createVNode(ColGroup, {
            "dataColumns": dataColumns.value,
            "operations": operations.value,
            "columnWidth": columnWidth
          }, null), renderHeader()])]
        }), createVNode(ResizeObserver2, {
          "onResize": handleTbodyResize
        }, {
          default: () => {
            var _a, _b;
            return [isVirtualList.value ? createVNode(VirtualList, mergeProps({
              "ref": (ins) => {
                if (ins == null ? void 0 : ins.$el)
                  tbodyRef.value = ins.$el;
              },
              "class": `${prefixCls}-body`,
              "data": flattenData.value,
              "itemKey": "_key",
              "component": {
                list: "table",
                content: "tbody"
              },
              "listAttrs": {
                class: `${prefixCls}-element`,
                style: contentStyle.value
              },
              "paddingPosition": "list"
            }, props.virtualListProps, {
              "onScroll": onTbodyScroll
            }), {
              item: ({
                item,
                index: index3
              }) => renderRecord(item, index3)
            }) : createVNode(Component, mergeProps({
              "ref": tbodyComRef,
              "class": `${prefixCls}-body`,
              "style": {
                maxHeight: isNumber((_a = props.scroll) == null ? void 0 : _a.y) ? `${(_b = props.scroll) == null ? void 0 : _b.y}px` : "100%"
              }
            }, scrollbar.value ? __spreadValues53({
              outerStyle: {
                display: "flex",
                minHeight: "0"
              }
            }, scrollbarProps.value) : void 0, {
              "onScroll": onTbodyScroll
            }), {
              default: () => [createVNode("table", {
                "class": `${prefixCls}-element`,
                "style": contentStyle.value,
                "cellpadding": 0,
                "cellspacing": 0
              }, [flattenData.value.length !== 0 && createVNode(ColGroup, {
                "dataColumns": dataColumns.value,
                "operations": operations.value,
                "columnWidth": columnWidth
              }, null), renderBody()])]
            })];
          }
        }), summaryData.value && summaryData.value.length && createVNode("div", {
          "ref": summaryRef,
          "class": `${prefixCls}-tfoot`,
          "style": {
            overflowY: hasScrollBar.value ? "scroll" : "hidden"
          }
        }, [createVNode("table", {
          "class": `${prefixCls}-element`,
          "style": contentStyle.value,
          "cellpadding": 0,
          "cellspacing": 0
        }, [createVNode(ColGroup, {
          "dataColumns": dataColumns.value,
          "operations": operations.value,
          "columnWidth": columnWidth
        }, null), renderSummary()])])]);
      }
      return createVNode(ResizeObserver2, {
        "onResize": () => setAlignPosition()
      }, {
        default: () => [createVNode("table", {
          "class": `${prefixCls}-element`,
          "cellpadding": 0,
          "cellspacing": 0,
          "style": contentStyle.value
        }, [createVNode(ColGroup, {
          "dataColumns": dataColumns.value,
          "operations": operations.value,
          "columnWidth": columnWidth
        }, null), props.showHeader && renderHeader(), renderBody(), summaryData.value && summaryData.value.length && renderSummary()])]
      });
    };
    const renderTable = (content) => {
      var _a;
      const style2 = ((_a = props.scroll) == null ? void 0 : _a.maxHeight) ? {
        maxHeight: props.scroll.maxHeight
      } : void 0;
      const Component = displayScrollbar.value ? Scrollbar : "div";
      return createVNode(Fragment, null, [createVNode("div", {
        "class": [`${prefixCls}-container`, tableCls.value]
      }, [createVNode(Component, mergeProps({
        "ref": contentComRef,
        "class": [`${prefixCls}-content`, {
          [`${prefixCls}-content-scroll-x`]: !splitTable.value
        }],
        "style": style2
      }, scrollbar.value ? __spreadValues53({
        outerStyle: {
          height: "100%"
        }
      }, scrollbarProps.value) : void 0, {
        "onScroll": handleScroll
      }), {
        default: () => [content ? createVNode("table", {
          "class": `${prefixCls}-element`,
          "cellpadding": 0,
          "cellspacing": 0
        }, [content()]) : renderContent()]
      })]), slots.footer && createVNode("div", {
        "class": `${prefixCls}-footer`
      }, [slots.footer()])]);
    };
    const renderPagination = () => {
      var _a, _b;
      const paginationProps = isObject(props.pagination) ? omit(props.pagination, ["current", "pageSize", "defaultCurrent", "defaultPageSize"]) : {};
      return createVNode("div", {
        "class": paginationCls.value
      }, [(_a = slots["pagination-left"]) == null ? void 0 : _a.call(slots), createVNode(Pagination, mergeProps({
        "total": validData.value.length,
        "current": page.value,
        "pageSize": pageSize.value,
        "onChange": (page2) => {
          handlePageChange(page2);
          handleChange("pagination");
        },
        "onPageSizeChange": (pageSize2) => {
          handlePageSizeChange(pageSize2);
          handleChange("pagination");
        }
      }, paginationProps), null), (_b = slots["pagination-right"]) == null ? void 0 : _b.call(slots)]);
    };
    const style = computed(() => {
      var _a, _b;
      if (isString((_a = props.scroll) == null ? void 0 : _a.y)) {
        return {
          height: (_b = props.scroll) == null ? void 0 : _b.y
        };
      }
      return void 0;
    });
    const render2 = () => {
      var _a;
      if (slots.default) {
        return createVNode("div", {
          "class": cls.value
        }, [renderTable(slots.default)]);
      }
      children.value = (_a = slots.columns) == null ? void 0 : _a.call(slots);
      return createVNode("div", {
        "class": cls.value,
        "style": style.value
      }, [children.value, createVNode(Spin, spinProps.value, {
        default: () => [props.pagination !== false && (flattenData.value.length > 0 || sortedData.value.length > 0) && isPaginationTop.value && renderPagination(), renderTable(), props.pagination !== false && (flattenData.value.length > 0 || sortedData.value.length > 0) && !isPaginationTop.value && renderPagination()]
      })]);
    };
    return {
      render: render2,
      selfExpand: expand,
      selfExpandAll: expandAll,
      selfSelect: select,
      selfSelectAll: selectAll,
      selfResetFilters: resetFilters,
      selfClearFilters: clearFilters,
      selfResetSorters: resetSorters,
      selfClearSorters: clearSorters
    };
  },
  methods: {
    selectAll(checked) {
      return this.selfSelectAll(checked);
    },
    select(rowKey, checked) {
      return this.selfSelect(rowKey, checked);
    },
    expandAll(checked) {
      return this.selfExpandAll(checked);
    },
    expand(rowKey, checked) {
      return this.selfExpand(rowKey, checked);
    },
    resetFilters(dataIndex) {
      return this.selfResetFilters(dataIndex);
    },
    clearFilters(dataIndex) {
      return this.selfClearFilters(dataIndex);
    },
    resetSorters() {
      return this.selfResetSorters();
    },
    clearSorters() {
      return this.selfClearSorters();
    }
  },
  render() {
    return this.render();
  }
});

// node_modules/@arco-design/web-vue/es/_hooks/use-pure-prop.js
var usePureProp = (props, name) => {
  const _value = toRef(props, name);
  const value = ref(_value.value);
  watch(_value, (cur, pre) => {
    if (!isEqual(cur, pre)) {
      value.value = cur;
    }
  });
  return value;
};

// node_modules/@arco-design/web-vue/es/table/table-column.js
var TableColumn = defineComponent({
  name: "TableColumn",
  props: {
    dataIndex: String,
    title: String,
    width: Number,
    align: {
      type: String
    },
    fixed: {
      type: String
    },
    ellipsis: {
      type: Boolean,
      default: false
    },
    sortable: {
      type: Object,
      default: void 0
    },
    filterable: {
      type: Object,
      default: void 0
    },
    cellClass: {
      type: [String, Array, Object]
    },
    headerCellClass: {
      type: [String, Array, Object]
    },
    bodyCellClass: {
      type: [String, Array, Object, Function]
    },
    summaryCellClass: {
      type: [String, Array, Object, Function]
    },
    cellStyle: {
      type: Object
    },
    headerCellStyle: {
      type: Object
    },
    bodyCellStyle: {
      type: [Object, Function]
    },
    summaryCellStyle: {
      type: [Object, Function]
    },
    index: {
      type: Number
    },
    tooltip: {
      type: [Boolean, Object],
      default: false
    }
  },
  setup(props, {
    slots
  }) {
    var _a;
    const {
      dataIndex,
      title,
      width,
      align,
      fixed,
      ellipsis,
      index: index3
    } = toRefs(props);
    const sortable = usePureProp(props, "sortable");
    const filterable = usePureProp(props, "filterable");
    const cellClass = usePureProp(props, "cellClass");
    const headerCellClass = usePureProp(props, "headerCellClass");
    const bodyCellClass = usePureProp(props, "bodyCellClass");
    const summaryCellClass = usePureProp(props, "summaryCellClass");
    const cellStyle = usePureProp(props, "cellStyle");
    const headerCellStyle = usePureProp(props, "headerCellStyle");
    const bodyCellStyle = usePureProp(props, "bodyCellStyle");
    const summaryCellStyle = usePureProp(props, "summaryCellStyle");
    const tooltip = usePureProp(props, "tooltip");
    const instance = getCurrentInstance();
    const tableCtx = inject(tableInjectionKey, {});
    const tableColumnCtx = inject(tableColumnInjectionKey, void 0);
    const {
      children,
      components: components2
    } = useChildrenComponents("TableColumn");
    const childrenColumnMap = reactive(/* @__PURE__ */ new Map());
    const addChild = (id, data) => {
      childrenColumnMap.set(id, data);
    };
    const removeChild = (id) => {
      childrenColumnMap.delete(id);
    };
    provide(tableColumnInjectionKey, {
      addChild,
      removeChild
    });
    const childrenColumns = ref();
    watch([components2, childrenColumnMap], ([components22, childrenColumnMap2]) => {
      if (components22.length > 0) {
        const columns = [];
        components22.forEach((id) => {
          const column2 = childrenColumnMap2.get(id);
          if (column2)
            columns.push(column2);
        });
        childrenColumns.value = columns;
      } else {
        childrenColumns.value = void 0;
      }
    });
    const column = reactive({
      dataIndex,
      title,
      width,
      align,
      fixed,
      ellipsis,
      sortable,
      filterable,
      cellClass,
      headerCellClass,
      bodyCellClass,
      summaryCellClass,
      cellStyle,
      headerCellStyle,
      bodyCellStyle,
      summaryCellStyle,
      index: index3,
      tooltip,
      children: childrenColumns,
      slots
    });
    if (instance) {
      if (tableColumnCtx) {
        tableColumnCtx.addChild(instance.uid, column);
      } else {
        (_a = tableCtx.addColumn) == null ? void 0 : _a.call(tableCtx, instance.uid, column);
      }
    }
    onBeforeUnmount(() => {
      var _a2;
      if (instance) {
        if (tableColumnCtx) {
          tableColumnCtx.removeChild(instance.uid);
        } else {
          (_a2 = tableCtx.removeColumn) == null ? void 0 : _a2.call(tableCtx, instance.uid);
        }
      }
    });
    return () => {
      var _a2;
      children.value = (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
      return children.value;
    };
  }
});

// node_modules/@arco-design/web-vue/es/table/index.js
var Table = Object.assign(_Table, {
  Thead,
  Tbody,
  Tr,
  Th,
  Td,
  Column: TableColumn,
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Table.name, _Table);
    app.component(componentPrefix + Thead.name, Thead);
    app.component(componentPrefix + Tbody.name, Tbody);
    app.component(componentPrefix + Tr.name, Tr);
    app.component(componentPrefix + Th.name, Th);
    app.component(componentPrefix + Td.name, Td);
    app.component(componentPrefix + TableColumn.name, TableColumn);
  }
});

// node_modules/@arco-design/web-vue/es/tabs/utils.js
var getTabListStyle = ({
  direction,
  type,
  offset
}) => {
  if (direction === "vertical") {
    return { transform: `translateY(${-offset}px)` };
  }
  return { transform: `translateX(${-offset}px)` };
};

// node_modules/@arco-design/web-vue/es/tabs/context.js
var tabsInjectionKey = Symbol("ArcoTabs");

// node_modules/@arco-design/web-vue/es/tabs/tabs-tab.js
var _sfc_main167 = defineComponent({
  name: "TabsTab",
  components: {
    IconHover,
    IconClose
  },
  props: {
    tab: {
      type: Object,
      required: true
    },
    active: Boolean,
    editable: Boolean
  },
  emits: ["click", "delete"],
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("tabs-tab");
    const tabsCtx = inject(tabsInjectionKey, {});
    const handleClick = (e2) => {
      if (!props.tab.disabled) {
        emit("click", props.tab.key, e2);
      }
    };
    const onKeyDown = (ev) => {
      if (ev.key === "Enter") {
        handleClick(ev);
      }
    };
    const eventHandlers = computed(() => {
      return Object.assign(tabsCtx.trigger === "click" ? { onClick: handleClick } : { onMouseover: handleClick }, { onKeydown: onKeyDown });
    });
    const handleDelete = (e2) => {
      if (!props.tab.disabled) {
        emit("delete", props.tab.key, e2);
      }
    };
    const cls = computed(() => [
      prefixCls,
      {
        [`${prefixCls}-active`]: props.active,
        [`${prefixCls}-closable`]: props.editable && props.tab.closable,
        [`${prefixCls}-disabled`]: props.tab.disabled
      }
    ]);
    return {
      prefixCls,
      cls,
      eventHandlers,
      handleDelete
    };
  }
});
function _sfc_render167(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_close = resolveComponent("icon-close");
  const _component_icon_hover = resolveComponent("icon-hover");
  return openBlock(), createElementBlock("div", mergeProps({
    tabindex: "0",
    class: _ctx.cls
  }, _ctx.eventHandlers), [
    createBaseVNode("span", {
      class: normalizeClass(`${_ctx.prefixCls}-title`)
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 2),
    _ctx.editable && _ctx.tab.closable ? (openBlock(), createBlock(_component_icon_hover, {
      key: 0,
      class: normalizeClass(`${_ctx.prefixCls}-close-btn`),
      onClick: withModifiers(_ctx.handleDelete, ["stop"])
    }, {
      default: withCtx(() => [
        createVNode(_component_icon_close)
      ]),
      _: 1
    }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
  ], 16);
}
var TabsTab = _export_sfc(_sfc_main167, [["render", _sfc_render167]]);

// node_modules/@arco-design/web-vue/es/tabs/tabs-button.js
function _isSlot14(s) {
  return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
var TabsButton = defineComponent({
  name: "TabsButton",
  props: {
    type: {
      type: String,
      default: "next"
    },
    direction: {
      type: String,
      default: "horizontal"
    },
    disabled: {
      type: Boolean,
      default: false
    },
    onClick: {
      type: Function
    }
  },
  emits: ["click"],
  setup(props, {
    emit
  }) {
    const prefixCls = getPrefixCls("tabs-nav-button");
    const handleClick = (ev) => {
      if (!props.disabled) {
        emit("click", props.type, ev);
      }
    };
    const renderIcon = () => {
      if (props.direction === "horizontal") {
        if (props.type === "next") {
          return createVNode(IconRight, null, null);
        }
        return createVNode(IconLeft, null, null);
      }
      if (props.type === "next") {
        return createVNode(IconDown, null, null);
      }
      return createVNode(IconUp, null, null);
    };
    const cls = computed(() => [prefixCls, {
      [`${prefixCls}-disabled`]: props.disabled,
      [`${prefixCls}-left`]: props.direction === "horizontal" && props.type === "previous",
      [`${prefixCls}-right`]: props.direction === "horizontal" && props.type === "next",
      [`${prefixCls}-up`]: props.direction === "vertical" && props.type === "previous",
      [`${prefixCls}-down`]: props.direction === "vertical" && props.type === "next"
    }]);
    return () => {
      let _slot;
      return createVNode("div", {
        "class": cls.value,
        "onClick": handleClick
      }, [createVNode(IconHover, {
        "disabled": props.disabled
      }, _isSlot14(_slot = renderIcon()) ? _slot : {
        default: () => [_slot]
      })]);
    };
  }
});

// node_modules/@arco-design/web-vue/es/tabs/tabs-nav-ink.js
var _sfc_main168 = defineComponent({
  name: "TabsNavInk",
  props: {
    activeTabRef: {
      type: Object
    },
    direction: {
      type: String
    },
    disabled: Boolean,
    animation: Boolean
  },
  setup(props) {
    const { activeTabRef } = toRefs(props);
    const prefixCls = getPrefixCls("tabs-nav-ink");
    const position = ref(0);
    const size = ref(0);
    const style = computed(() => {
      if (props.direction === "vertical") {
        return {
          top: `${position.value}px`,
          height: `${size.value}px`
        };
      }
      return {
        left: `${position.value}px`,
        width: `${size.value}px`
      };
    });
    const getInkStyle = () => {
      if (activeTabRef.value) {
        const _position = props.direction === "vertical" ? activeTabRef.value.offsetTop : activeTabRef.value.offsetLeft;
        const _size = props.direction === "vertical" ? activeTabRef.value.offsetHeight : activeTabRef.value.offsetWidth;
        if (_position !== position.value || _size !== size.value) {
          position.value = _position;
          size.value = _size;
        }
      }
    };
    onMounted(() => {
      nextTick(() => getInkStyle());
    });
    onUpdated(() => {
      getInkStyle();
    });
    const cls = computed(() => [
      prefixCls,
      {
        [`${prefixCls}-animation`]: props.animation,
        [`${prefixCls}-disabled`]: props.disabled
      }
    ]);
    return {
      prefixCls,
      cls,
      style
    };
  }
});
function _sfc_render168(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.style)
  }, null, 6);
}
var TabsNavInk = _export_sfc(_sfc_main168, [["render", _sfc_render168]]);

// node_modules/@arco-design/web-vue/es/tabs/tabs-nav.js
var TabsNav = defineComponent({
  name: "TabsNav",
  props: {
    tabs: {
      type: Array,
      required: true
    },
    direction: {
      type: String,
      required: true
    },
    type: {
      type: String,
      required: true
    },
    activeKey: {
      type: [String, Number]
    },
    activeIndex: {
      type: Number,
      required: true
    },
    position: {
      type: String,
      required: true
    },
    size: {
      type: String,
      required: true
    },
    showAddButton: {
      type: Boolean,
      default: false
    },
    editable: {
      type: Boolean,
      default: false
    },
    animation: {
      type: Boolean,
      required: true
    },
    headerPadding: {
      type: Boolean,
      default: true
    }
  },
  emits: ["click", "add", "delete"],
  setup(props, {
    emit,
    slots
  }) {
    const {
      tabs,
      activeKey,
      activeIndex,
      direction
    } = toRefs(props);
    const prefixCls = getPrefixCls("tabs-nav");
    const wrapperRef = ref();
    const listRef = ref();
    const tabsRef = ref({});
    const activeTabRef = computed(() => {
      if (!isUndefined(activeKey.value)) {
        return tabsRef.value[activeKey.value];
      }
      return void 0;
    });
    const inkRef = ref();
    const mergedEditable = computed(() => props.editable && ["line", "card", "card-gutter"].includes(props.type));
    const isScroll2 = ref(false);
    const wrapperLength = ref(0);
    const maxOffset = ref(0);
    const tabEndOffsets = ref([]);
    const offset = ref(0);
    const getWrapperLength = () => {
      var _a, _b, _c;
      return (_c = direction.value === "vertical" ? (_a = wrapperRef.value) == null ? void 0 : _a.offsetHeight : (_b = wrapperRef.value) == null ? void 0 : _b.offsetWidth) != null ? _c : 0;
    };
    const getMaxOffset = () => {
      if (!listRef.value || !wrapperRef.value) {
        return 0;
      }
      if (direction.value === "vertical") {
        return listRef.value.offsetHeight - wrapperRef.value.offsetHeight;
      }
      return listRef.value.offsetWidth - wrapperRef.value.offsetWidth;
    };
    const getTabEndOffsets = () => {
      return tabs.value.map((item) => {
        const ele = tabsRef.value[item.key];
        if (direction.value === "vertical") {
          return ele.offsetTop + ele.offsetHeight;
        }
        return ele.offsetLeft + ele.offsetWidth;
      });
    };
    const getSize = () => {
      isScroll2.value = isOverflow();
      if (isScroll2.value) {
        wrapperLength.value = getWrapperLength();
        maxOffset.value = getMaxOffset();
        tabEndOffsets.value = getTabEndOffsets();
        if (offset.value > maxOffset.value) {
          offset.value = maxOffset.value;
        }
      } else {
        offset.value = 0;
      }
    };
    const isOverflow = () => {
      if (wrapperRef.value && listRef.value) {
        return props.direction === "vertical" ? listRef.value.offsetHeight > wrapperRef.value.offsetHeight : listRef.value.offsetWidth > wrapperRef.value.offsetWidth;
      }
      return false;
    };
    const isInView = (index3) => {
      var _a;
      return ((_a = tabEndOffsets.value[index3 - 1]) != null ? _a : 0) >= offset.value && tabEndOffsets.value[index3] <= offset.value + wrapperLength.value;
    };
    const getNextOffset = (type) => {
      if (!wrapperRef.value) {
        return 0;
      }
      return type === "previous" ? offset.value - wrapperLength.value : offset.value + wrapperLength.value;
    };
    const getValidOffset = (offset2) => {
      if (!wrapperRef.value || !listRef.value || offset2 < 0) {
        return 0;
      }
      if (offset2 > maxOffset.value) {
        return maxOffset.value;
      }
      return offset2;
    };
    const handleClick = (key, ev) => {
      emit("click", key, ev);
    };
    const handleDelete = (key, ev) => {
      emit("delete", key, ev);
    };
    const handleButtonClick = (type) => {
      offset.value = getValidOffset(getNextOffset(type));
    };
    const handleResize = () => {
      getSize();
      if (inkRef.value) {
        inkRef.value.$forceUpdate();
      }
    };
    watch(tabs, () => {
      nextTick(() => {
        getSize();
      });
    });
    watch(activeIndex, (current, pre) => {
      nextTick(() => {
        var _a;
        if (isScroll2.value) {
          if (current >= pre) {
            const offsetIndex = current < tabEndOffsets.value.length - 1 ? current + 1 : current;
            if (!isInView(offsetIndex)) {
              offset.value = tabEndOffsets.value[offsetIndex] - wrapperLength.value;
            }
          } else {
            const offsetIndex = current > 0 ? current - 1 : current;
            if (!isInView(offsetIndex)) {
              offset.value = (_a = tabEndOffsets.value[offsetIndex - 1]) != null ? _a : 0;
            }
          }
        }
      });
    });
    onMounted(() => {
      getSize();
    });
    const renderAddBtn = () => {
      if (!mergedEditable.value || !props.showAddButton) {
        return null;
      }
      return createVNode("div", {
        "class": `${prefixCls}-add-btn`,
        "onClick": (ev) => emit("add", ev)
      }, [createVNode(IconHover, null, {
        default: () => [createVNode(IconPlus, null, null)]
      })]);
    };
    const cls = computed(() => [prefixCls, `${prefixCls}-${props.direction}`, `${prefixCls}-${props.position}`, `${prefixCls}-size-${props.size}`, `${prefixCls}-type-${props.type}`]);
    const listCls = computed(() => [`${prefixCls}-tab-list`, {
      [`${prefixCls}-tab-list-no-padding`]: !props.headerPadding && ["line", "text"].includes(props.type) && props.direction === "horizontal"
    }]);
    const listStyle = computed(() => getTabListStyle({
      direction: props.direction,
      type: props.type,
      offset: offset.value
    }));
    const tabCls = computed(() => [`${prefixCls}-tab`, {
      [`${prefixCls}-tab-scroll`]: isScroll2.value
    }]);
    return () => {
      var _a;
      return createVNode("div", {
        "class": cls.value
      }, [isScroll2.value && createVNode(TabsButton, {
        "type": "previous",
        "direction": props.direction,
        "disabled": offset.value <= 0,
        "onClick": handleButtonClick
      }, null), createVNode(ResizeObserver2, {
        "onResize": () => getSize()
      }, {
        default: () => [createVNode("div", {
          "class": tabCls.value,
          "ref": wrapperRef
        }, [createVNode(ResizeObserver2, {
          "onResize": handleResize
        }, {
          default: () => [createVNode("div", {
            "ref": listRef,
            "class": listCls.value,
            "style": listStyle.value
          }, [props.tabs.map((tab, index3) => createVNode(TabsTab, {
            "key": tab.key,
            "ref": (component) => {
              if (component == null ? void 0 : component.$el) {
                tabsRef.value[tab.key] = component.$el;
              }
            },
            "active": tab.key === activeKey.value,
            "tab": tab,
            "editable": props.editable,
            "onClick": handleClick,
            "onDelete": handleDelete
          }, {
            default: () => {
              var _a2, _b, _c;
              return [(_c = (_b = (_a2 = tab.slots).title) == null ? void 0 : _b.call(_a2)) != null ? _c : tab.title];
            }
          })), props.type === "line" && activeTabRef.value && createVNode(TabsNavInk, {
            "ref": inkRef,
            "activeTabRef": activeTabRef.value,
            "direction": props.direction,
            "disabled": false,
            "animation": props.animation
          }, null)])]
        }), !isScroll2.value && renderAddBtn()])]
      }), isScroll2.value && createVNode(TabsButton, {
        "type": "next",
        "direction": props.direction,
        "disabled": offset.value >= maxOffset.value,
        "onClick": handleButtonClick
      }, null), createVNode("div", {
        "class": `${prefixCls}-extra`
      }, [isScroll2.value && renderAddBtn(), (_a = slots.extra) == null ? void 0 : _a.call(slots)])]);
    };
  }
});

// node_modules/@arco-design/web-vue/es/tabs/tabs.js
var _Tabs = defineComponent({
  name: "Tabs",
  props: {
    activeKey: {
      type: [String, Number],
      default: void 0
    },
    defaultActiveKey: {
      type: [String, Number],
      default: void 0
    },
    position: {
      type: String,
      default: "top"
    },
    size: {
      type: String
    },
    type: {
      type: String,
      default: "line"
    },
    direction: {
      type: String,
      default: "horizontal"
    },
    editable: {
      type: Boolean,
      default: false
    },
    showAddButton: {
      type: Boolean,
      default: false
    },
    destroyOnHide: {
      type: Boolean,
      default: false
    },
    lazyLoad: {
      type: Boolean,
      default: false
    },
    justify: {
      type: Boolean,
      default: false
    },
    animation: {
      type: Boolean,
      default: false
    },
    headerPadding: {
      type: Boolean,
      default: true
    },
    autoSwitch: {
      type: Boolean,
      default: false
    },
    hideContent: {
      type: Boolean,
      default: false
    },
    trigger: {
      type: String,
      default: "click"
    }
  },
  emits: {
    "update:activeKey": (key) => true,
    "change": (key) => true,
    "tabClick": (key, ev) => true,
    "add": (ev) => true,
    "delete": (key, ev) => true
  },
  setup(props, {
    emit,
    slots
  }) {
    const {
      size,
      lazyLoad,
      destroyOnHide,
      trigger
    } = toRefs(props);
    const prefixCls = getPrefixCls("tabs");
    const {
      mergedSize
    } = useSize(size);
    const mergedPosition = computed(() => props.direction === "vertical" ? "left" : props.position);
    const mergedDirection = computed(() => ["left", "right"].includes(mergedPosition.value) ? "vertical" : "horizontal");
    const {
      children,
      components: components2
    } = useChildrenComponents("TabPane");
    const tabMap = reactive(/* @__PURE__ */ new Map());
    const sortedTabs = computed(() => {
      const tabData = [];
      components2.value.forEach((id) => {
        const tab = tabMap.get(id);
        if (tab)
          tabData.push(tab);
      });
      return tabData;
    });
    const tabKeys = computed(() => sortedTabs.value.map((item) => item.key));
    const addItem = (id, data) => {
      tabMap.set(id, data);
    };
    const removeItem = (id) => {
      tabMap.delete(id);
    };
    const _activeKey = ref(props.defaultActiveKey);
    const computedActiveKey = computed(() => {
      var _a;
      const activeKey = (_a = props.activeKey) != null ? _a : _activeKey.value;
      if (isUndefined(activeKey)) {
        return tabKeys.value[0];
      }
      return activeKey;
    });
    const activeIndex = computed(() => {
      const index3 = tabKeys.value.indexOf(computedActiveKey.value);
      if (index3 === -1) {
        return 0;
      }
      return index3;
    });
    provide(tabsInjectionKey, reactive({
      lazyLoad,
      destroyOnHide,
      activeKey: computedActiveKey,
      addItem,
      removeItem,
      trigger
    }));
    const handleChange = (key) => {
      if (key !== computedActiveKey.value) {
        _activeKey.value = key;
        emit("update:activeKey", key);
        emit("change", key);
      }
    };
    const handleClick = (key, e2) => {
      handleChange(key);
      emit("tabClick", key, e2);
    };
    const handleAdd = (ev) => {
      emit("add", ev);
      if (props.autoSwitch) {
        nextTick(() => {
          const lastKey = tabKeys.value[tabKeys.value.length - 1];
          handleChange(lastKey);
        });
      }
    };
    const handleDelete = (key, ev) => {
      emit("delete", key, ev);
    };
    const renderContent = () => {
      return createVNode("div", {
        "class": [`${prefixCls}-content`, {
          [`${prefixCls}-content-hide`]: props.hideContent
        }]
      }, [createVNode("div", {
        "class": [`${prefixCls}-content-list`, {
          [`${prefixCls}-content-animation`]: props.animation
        }],
        "style": {
          marginLeft: `-${activeIndex.value * 100}%`
        }
      }, [children.value])]);
    };
    const cls = computed(() => [prefixCls, `${prefixCls}-${mergedDirection.value}`, `${prefixCls}-${mergedPosition.value}`, `${prefixCls}-type-${props.type}`, `${prefixCls}-size-${mergedSize.value}`, {
      [`${prefixCls}-justify`]: props.justify
    }]);
    return () => {
      var _a;
      children.value = (_a = slots.default) == null ? void 0 : _a.call(slots);
      return createVNode("div", {
        "class": cls.value
      }, [mergedPosition.value === "bottom" && renderContent(), createVNode(TabsNav, {
        "tabs": sortedTabs.value,
        "activeKey": computedActiveKey.value,
        "activeIndex": activeIndex.value,
        "direction": mergedDirection.value,
        "position": mergedPosition.value,
        "editable": props.editable,
        "animation": props.animation,
        "showAddButton": props.showAddButton,
        "headerPadding": props.headerPadding,
        "size": mergedSize.value,
        "type": props.type,
        "onClick": handleClick,
        "onAdd": handleAdd,
        "onDelete": handleDelete
      }, {
        extra: slots.extra
      }), mergedPosition.value !== "bottom" && renderContent()]);
    };
  }
});

// node_modules/@arco-design/web-vue/es/tabs/tab-pane.js
var _sfc_main169 = defineComponent({
  name: "TabPane",
  props: {
    title: String,
    disabled: {
      type: Boolean,
      default: false
    },
    closable: {
      type: Boolean,
      default: true
    },
    destroyOnHide: {
      type: Boolean,
      default: false
    }
  },
  setup(props, { slots }) {
    var _a;
    const { title, disabled, closable } = toRefs(props);
    const instance = getCurrentInstance();
    const prefixCls = getPrefixCls("tabs");
    const tabsCtx = inject(tabsInjectionKey, {});
    const itemRef = ref();
    const key = computed(() => instance == null ? void 0 : instance.vnode.key);
    const active = computed(() => key.value === tabsCtx.activeKey);
    const mounted = ref(tabsCtx.lazyLoad ? active.value : true);
    const data = reactive({
      key,
      title,
      disabled,
      closable,
      slots
    });
    if (instance == null ? void 0 : instance.uid) {
      (_a = tabsCtx.addItem) == null ? void 0 : _a.call(tabsCtx, instance.uid, data);
    }
    onBeforeUnmount(() => {
      var _a2;
      if (instance == null ? void 0 : instance.uid) {
        (_a2 = tabsCtx.removeItem) == null ? void 0 : _a2.call(tabsCtx, instance.uid);
      }
    });
    watch(active, (active2) => {
      if (active2) {
        if (!mounted.value) {
          mounted.value = true;
        }
      } else if (props.destroyOnHide || tabsCtx.destroyOnHide) {
        mounted.value = false;
      }
    });
    return {
      prefixCls,
      active,
      itemRef,
      mounted
    };
  }
});
function _sfc_render169(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    ref: "itemRef",
    class: normalizeClass([
      `${_ctx.prefixCls}-content-item`,
      { [`${_ctx.prefixCls}-content-item-active`]: _ctx.active }
    ])
  }, [
    _ctx.mounted ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(`${_ctx.prefixCls}-pane`)
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 2)) : createCommentVNode("v-if", true)
  ], 2);
}
var TabPane = _export_sfc(_sfc_main169, [["render", _sfc_render169]]);

// node_modules/@arco-design/web-vue/es/tabs/index.js
var Tabs = Object.assign(_Tabs, {
  TabPane,
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Tabs.name, _Tabs);
    app.component(componentPrefix + TabPane.name, TabPane);
  }
});

// node_modules/@arco-design/web-vue/es/time-picker/hooks/use-time-state.js
function useTimeState(props) {
  const { modelValue, defaultValue, format, isRange } = toRefs(props);
  function getLocalEmptyValue() {
    return isRange.value ? [] : void 0;
  }
  function normalizeValue(time) {
    if (isUndefined(time)) {
      return void 0;
    }
    if (isRange.value) {
      return isArray(time) ? time : [time, void 0];
    }
    return time;
  }
  const computedModelValue = computed(() => {
    const time = normalizeValue(modelValue.value);
    return getDayjsValue(time, format.value);
  });
  const computedDefaultValue = computed(() => {
    const time = normalizeValue(defaultValue.value);
    return getDayjsValue(time, format.value);
  });
  const [localValue, setLocalValue] = useState(!isUndefined(computedModelValue.value) ? computedModelValue.value : !isUndefined(computedDefaultValue.value) ? computedDefaultValue.value : getLocalEmptyValue());
  watch(computedModelValue, () => {
    if (isUndefined(computedModelValue.value)) {
      setLocalValue(getLocalEmptyValue());
    }
  });
  const computedValue = computed(() => computedModelValue.value || localValue.value);
  const [panelValue, setPanelValue] = useState(computedValue.value);
  watch([computedValue], () => {
    setPanelValue(computedValue.value);
  });
  const [inputValue, setInputValue] = useState();
  watch([panelValue], () => {
    setInputValue(void 0);
  });
  return {
    computedValue,
    panelValue,
    inputValue,
    setValue: setLocalValue,
    setPanelValue,
    setInputValue
  };
}

// node_modules/@arco-design/web-vue/es/time-picker/range-panel.js
var __defProp54 = Object.defineProperty;
var __defProps25 = Object.defineProperties;
var __getOwnPropDescs25 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols54 = Object.getOwnPropertySymbols;
var __hasOwnProp54 = Object.prototype.hasOwnProperty;
var __propIsEnum54 = Object.prototype.propertyIsEnumerable;
var __defNormalProp54 = (obj, key, value) => key in obj ? __defProp54(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues54 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp54.call(b, prop))
      __defNormalProp54(a, prop, b[prop]);
  if (__getOwnPropSymbols54)
    for (var prop of __getOwnPropSymbols54(b)) {
      if (__propIsEnum54.call(b, prop))
        __defNormalProp54(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps25 = (a, b) => __defProps25(a, __getOwnPropDescs25(b));
var RangePanel = defineComponent({
  name: "TimePickerRangePanel",
  components: {
    Panel
  },
  props: {
    value: {
      type: Array
    },
    displayIndex: {
      type: Number,
      default: 0
    }
  },
  emits: ["select", "confirm", "update:displayIndex", "display-index-change"],
  setup(props, {
    emit
  }) {
    const {
      value,
      displayIndex
    } = toRefs(props);
    const localDisplayIndex = ref(displayIndex.value);
    watch(displayIndex, () => {
      localDisplayIndex.value = displayIndex.value;
    });
    const displayValue = computed(() => (value == null ? void 0 : value.value) ? value.value[localDisplayIndex.value] : void 0);
    function onSelect(selectedValue) {
      const newValue = isUndefined(value) || isUndefined(value == null ? void 0 : value.value) ? [] : [...value.value];
      newValue[localDisplayIndex.value] = selectedValue;
      emit("select", newValue);
    }
    function onConfirm() {
      if (!isValidRangeValue(value == null ? void 0 : value.value)) {
        const newIndex = (localDisplayIndex.value + 1) % 2;
        localDisplayIndex.value = newIndex;
        emit("display-index-change", newIndex);
        emit("update:displayIndex", newIndex);
      } else {
        emit("confirm", value == null ? void 0 : value.value);
      }
    }
    return {
      displayValue,
      onSelect,
      onConfirm
    };
  },
  render() {
    const _props = __spreadProps25(__spreadValues54({}, this.$attrs), {
      isRange: true,
      value: this.displayValue,
      onSelect: this.onSelect,
      onConfirm: this.onConfirm
    });
    return createVNode(Panel, _props, this.$slots);
  }
});

// node_modules/@arco-design/web-vue/es/time-picker/time-picker.js
var __defProp55 = Object.defineProperty;
var __getOwnPropSymbols55 = Object.getOwnPropertySymbols;
var __hasOwnProp55 = Object.prototype.hasOwnProperty;
var __propIsEnum55 = Object.prototype.propertyIsEnumerable;
var __defNormalProp55 = (obj, key, value) => key in obj ? __defProp55(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues55 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp55.call(b, prop))
      __defNormalProp55(a, prop, b[prop]);
  if (__getOwnPropSymbols55)
    for (var prop of __getOwnPropSymbols55(b)) {
      if (__propIsEnum55.call(b, prop))
        __defNormalProp55(a, prop, b[prop]);
    }
  return a;
};
var _sfc_main170 = defineComponent({
  name: "TimePicker",
  components: {
    Trigger,
    DateInput,
    DateRangeInput,
    Panel,
    RangePanel,
    IconClockCircle
  },
  inheritAttrs: false,
  props: {
    type: {
      type: String,
      default: "time"
    },
    modelValue: {
      type: [String, Number, Date, Array]
    },
    defaultValue: {
      type: [String, Number, Date, Array]
    },
    disabled: {
      type: Boolean
    },
    allowClear: {
      type: Boolean,
      default: true
    },
    readonly: {
      type: Boolean
    },
    error: {
      type: Boolean
    },
    format: {
      type: String,
      default: "HH:mm:ss"
    },
    placeholder: {
      type: String
    },
    size: {
      type: String
    },
    popupContainer: {
      type: [String, Object]
    },
    use12Hours: {
      type: Boolean
    },
    step: {
      type: Object
    },
    disabledHours: {
      type: Function
    },
    disabledMinutes: {
      type: Function
    },
    disabledSeconds: {
      type: Function
    },
    hideDisabledOptions: {
      type: Boolean
    },
    disableConfirm: {
      type: Boolean
    },
    position: {
      type: String,
      default: "bl"
    },
    popupVisible: {
      type: Boolean,
      default: void 0
    },
    defaultPopupVisible: {
      type: Boolean,
      default: false
    },
    triggerProps: {
      type: Object
    },
    unmountOnClose: {
      type: Boolean
    }
  },
  emits: {
    "change": (timeString, time) => true,
    "update:modelValue": (timeString) => true,
    "select": (timeString, time) => true,
    "clear": () => true,
    "popup-visible-change": (visible) => true,
    "update:popupVisible": (visible) => true
  },
  setup(props, { emit }) {
    const {
      type,
      format,
      use12Hours,
      modelValue,
      defaultValue,
      popupVisible,
      defaultPopupVisible,
      disabled,
      placeholder,
      disableConfirm,
      disabledHours,
      disabledMinutes,
      disabledSeconds
    } = toRefs(props);
    const { mergedDisabled, eventHandlers } = useFormItem({ disabled });
    const isRange = computed(() => type.value === "time-range");
    const prefixCls = getPrefixCls("timepicker");
    const refInput = ref();
    const { format: computedFormat, use12Hours: computedUse12Hours } = useTimeFormat(reactive({
      format,
      use12Hours
    }));
    const {
      computedValue,
      panelValue,
      inputValue,
      setValue,
      setPanelValue,
      setInputValue
    } = useTimeState(reactive({
      modelValue,
      defaultValue,
      isRange,
      format: computedFormat
    }));
    const [panelVisible, setLocalVisible] = useMergeState(defaultPopupVisible.value, reactive({ value: popupVisible }));
    const setPanelVisible = (newVisible) => {
      if (newVisible !== panelVisible.value) {
        setLocalVisible(newVisible);
        emit("popup-visible-change", newVisible);
        emit("update:popupVisible", newVisible);
      }
    };
    const { t: t2 } = useI18n();
    const [focusedInputIndex, setFocusedInputIndex] = useState(0);
    const computedPlaceholder = computed(() => {
      const _placeholder = placeholder == null ? void 0 : placeholder.value;
      if (!isRange.value) {
        return !isUndefined(_placeholder) ? _placeholder : t2("datePicker.placeholder.time");
      }
      if (isUndefined(_placeholder)) {
        return t2("datePicker.rangePlaceholder.time");
      }
      if (!isArray(_placeholder)) {
        return [_placeholder, _placeholder];
      }
      return _placeholder;
    });
    const isDisabledTime2 = useIsDisabledTime(reactive({
      disabledHours,
      disabledMinutes,
      disabledSeconds
    }));
    function emitChange(value) {
      var _a, _b;
      if (isValueChange(value, computedValue.value)) {
        const formattedValue = getFormattedValue(value, computedFormat.value);
        const dateValue = getDateValue(value);
        emit("update:modelValue", formattedValue);
        emit("change", formattedValue, dateValue);
        (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onChange) == null ? void 0 : _b.call(_a);
      }
    }
    function confirm(value, showPanel) {
      if (isDisabledTime2(value))
        return;
      let newValue = value;
      if (isArray(value)) {
        const now = dayjs();
        newValue = value.map((item) => {
          if (item) {
            item = item.year(now.year());
            item = item.month(now.month());
            item = item.date(now.date());
          }
          return item;
        });
        if (isValidRangeValue(newValue)) {
          newValue = getSortedDayjsArray(newValue);
        }
        if ((newValue == null ? void 0 : newValue.length) === 0) {
          newValue = void 0;
        }
      }
      emitChange(newValue);
      setValue(newValue);
      if (showPanel !== panelVisible.value) {
        setPanelVisible(showPanel);
      }
    }
    function select(value, showPanel) {
      setPanelValue(value);
      if (showPanel !== panelVisible.value) {
        setPanelVisible(showPanel);
      }
    }
    function focusInput(index3) {
      refInput.value && refInput.value.focus && refInput.value.focus(index3);
    }
    function onPanelVisibleChange(newVisible) {
      if (mergedDisabled.value)
        return;
      setPanelVisible(newVisible);
      if (newVisible) {
        nextTick(() => {
          focusInput(focusedInputIndex.value);
        });
      }
    }
    function onPanelSelect(value) {
      const formattedValue = getFormattedValue(value, computedFormat.value);
      const dateValue = getDateValue(value);
      emit("select", formattedValue, dateValue);
      if (disableConfirm.value && (!isRange.value || isValidRangeValue(value))) {
        confirm(value, true);
      } else {
        select(value, true);
        setInputValue(void 0);
      }
    }
    function onPanelConfirm(value) {
      confirm(value, false);
    }
    function onInputPressEnter() {
      confirm(panelValue.value || computedValue.value, false);
    }
    function onRangeInputPressEnter() {
      if (isValidRangeValue(panelValue.value)) {
        confirm(panelValue.value, false);
      } else {
        const newFocusedInputIndex = (focusedInputIndex.value + 1) % 2;
        setFocusedInputIndex(newFocusedInputIndex);
        focusInput(newFocusedInputIndex);
      }
    }
    function onInputChange(e2) {
      setPanelVisible(true);
      const targetValue = e2.target.value;
      setInputValue(targetValue);
      if (!isValidInputValue(targetValue, computedFormat.value))
        return;
      const newValue = dayjs(targetValue, computedFormat.value);
      if (isDisabledTime2(newValue))
        return;
      if (disableConfirm.value) {
        confirm(newValue, true);
      } else {
        select(newValue, true);
      }
    }
    function onRangeInputChange(e2) {
      setPanelVisible(true);
      const targetValue = e2.target.value;
      const newInputValue = isArray(inputValue.value) ? [...inputValue.value] : isArray(panelValue.value) && getFormattedValue(panelValue.value, computedFormat.value) || [];
      newInputValue[focusedInputIndex.value] = targetValue;
      setInputValue(newInputValue);
      if (!isValidInputValue(targetValue, computedFormat.value))
        return;
      const targetValueDayjs = dayjs(targetValue, computedFormat.value);
      if (isDisabledTime2(targetValueDayjs))
        return;
      const newValue = isArray(panelValue.value) ? [...panelValue.value] : [];
      newValue[focusedInputIndex.value] = targetValueDayjs;
      if (disableConfirm.value && isValidRangeValue(newValue)) {
        confirm(newValue, true);
      } else {
        select(newValue, true);
      }
    }
    function onClear() {
      setPanelValue(void 0);
      confirm(void 0, true);
    }
    watch(panelVisible, (curVal, preVal) => {
      if (curVal !== preVal) {
        setPanelValue(computedValue.value);
      }
      if (!curVal) {
        setInputValue(void 0);
      }
    });
    const inputProps = computed(() => {
      if (isRange.value) {
        return {
          focusedIndex: focusedInputIndex.value,
          onFocusedIndexChange: (index3) => {
            setFocusedInputIndex(index3);
          },
          onChange: onRangeInputChange,
          onPressEnter: onRangeInputPressEnter
        };
      }
      return {
        onChange: onInputChange,
        onPressEnter: onInputPressEnter
      };
    });
    const panelProps = computed(() => {
      if (isRange.value) {
        return {
          displayIndex: focusedInputIndex.value,
          onDisplayIndexChange: (index3) => {
            setFocusedInputIndex(index3);
            focusInput(index3);
          }
        };
      }
      return {};
    });
    return {
      refInput,
      isRange,
      prefixCls,
      panelVisible,
      focusedInputIndex,
      computedPlaceholder,
      panelValue,
      inputValue,
      computedFormat,
      computedUse12Hours,
      inputProps,
      panelProps,
      mergedDisabled,
      onPanelVisibleChange,
      onInputClear: onClear,
      onPanelSelect,
      onPanelConfirm,
      onPanelClick: () => {
        focusInput(focusedInputIndex.value);
      }
    };
  }
});
function _sfc_render170(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_IconClockCircle = resolveComponent("IconClockCircle");
  const _component_Trigger = resolveComponent("Trigger");
  return openBlock(), createBlock(_component_Trigger, {
    trigger: "click",
    "animation-name": "slide-dynamic-origin",
    "auto-fit-transform-origin": "",
    "click-to-close": false,
    position: _ctx.position,
    disabled: _ctx.mergedDisabled || _ctx.readonly,
    "popup-offset": 4,
    "popup-visible": _ctx.panelVisible,
    "prevent-focus": true,
    "unmount-on-close": _ctx.unmountOnClose,
    "popup-container": _ctx.popupContainer,
    onPopupVisibleChange: _ctx.onPanelVisibleChange
  }, {
    content: withCtx(() => [
      createBaseVNode("div", {
        class: normalizeClass(`${_ctx.prefixCls}-container`),
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onPanelClick && _ctx.onPanelClick(...args))
      }, [
        (openBlock(), createBlock(resolveDynamicComponent(_ctx.isRange ? "RangePanel" : "Panel"), mergeProps(_ctx.panelProps, {
          value: _ctx.panelValue,
          visible: _ctx.panelVisible,
          format: _ctx.computedFormat,
          "use12-hours": _ctx.computedUse12Hours,
          step: _ctx.step,
          "disabled-hours": _ctx.disabledHours,
          "disabled-minutes": _ctx.disabledMinutes,
          "disabled-seconds": _ctx.disabledSeconds,
          "hide-disabled-options": _ctx.hideDisabledOptions,
          "hide-footer": _ctx.disableConfirm,
          onSelect: _ctx.onPanelSelect,
          onConfirm: _ctx.onPanelConfirm
        }), createSlots({ _: 2 }, [
          _ctx.$slots.extra ? {
            name: "extra-footer",
            fn: withCtx(() => [
              renderSlot(_ctx.$slots, "extra")
            ])
          } : void 0
        ]), 1040, ["value", "visible", "format", "use12-hours", "step", "disabled-hours", "disabled-minutes", "disabled-seconds", "hide-disabled-options", "hide-footer", "onSelect", "onConfirm"]))
      ], 2)
    ]),
    default: withCtx(() => [
      (openBlock(), createBlock(resolveDynamicComponent(_ctx.isRange ? "DateRangeInput" : "DateInput"), mergeProps(__spreadValues55(__spreadValues55({}, _ctx.$attrs), _ctx.inputProps), {
        ref: "refInput",
        "input-value": _ctx.inputValue,
        value: _ctx.panelValue,
        size: _ctx.size,
        focused: _ctx.panelVisible,
        format: _ctx.computedFormat,
        visible: _ctx.panelVisible,
        disabled: _ctx.mergedDisabled,
        error: _ctx.error,
        editable: !_ctx.readonly,
        "allow-clear": _ctx.allowClear && !_ctx.readonly,
        placeholder: _ctx.computedPlaceholder,
        onClear: _ctx.onInputClear
      }), createSlots({
        "suffix-icon": withCtx(() => [
          renderSlot(_ctx.$slots, "suffix-icon", {}, () => [
            createVNode(_component_IconClockCircle)
          ])
        ]),
        _: 2
      }, [
        _ctx.$slots.prefix ? {
          name: "prefix",
          fn: withCtx(() => [
            renderSlot(_ctx.$slots, "prefix")
          ])
        } : void 0
      ]), 1040, ["input-value", "value", "size", "focused", "format", "visible", "disabled", "error", "editable", "allow-clear", "placeholder", "onClear"]))
    ]),
    _: 3
  }, 8, ["position", "disabled", "popup-visible", "unmount-on-close", "popup-container", "onPopupVisibleChange"]);
}
var _TimePicker = _export_sfc(_sfc_main170, [["render", _sfc_render170]]);

// node_modules/@arco-design/web-vue/es/time-picker/index.js
var TimePicker = Object.assign(_TimePicker, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _TimePicker.name, _TimePicker);
  }
});

// node_modules/@arco-design/web-vue/es/timeline/context.js
var timelineInjectionKey = Symbol("ArcoTimeline");

// node_modules/@arco-design/web-vue/es/timeline/item.js
var __defProp56 = Object.defineProperty;
var __getOwnPropSymbols56 = Object.getOwnPropertySymbols;
var __hasOwnProp56 = Object.prototype.hasOwnProperty;
var __propIsEnum56 = Object.prototype.propertyIsEnumerable;
var __defNormalProp56 = (obj, key, value) => key in obj ? __defProp56(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues56 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp56.call(b, prop))
      __defNormalProp56(a, prop, b[prop]);
  if (__getOwnPropSymbols56)
    for (var prop of __getOwnPropSymbols56(b)) {
      if (__propIsEnum56.call(b, prop))
        __defNormalProp56(a, prop, b[prop]);
    }
  return a;
};
var getDefaultPosition = (index3, mode, direction, position) => {
  let map = ["left", "right"];
  if (direction === "horizontal") {
    map = ["top", "bottom"];
  }
  const res = mode === "alternate" ? position || map[index3 % 2] : mode;
  return map.indexOf(res) > -1 ? res : map[0];
};
var _sfc_main171 = defineComponent({
  name: "TimelineItem",
  props: {
    dotColor: {
      type: String
    },
    dotType: {
      type: String,
      default: "solid"
    },
    lineType: {
      type: String,
      default: "solid"
    },
    lineColor: {
      type: String
    },
    label: {
      type: String
    },
    position: {
      type: String
    }
  },
  setup(props) {
    const prefixCls = getPrefixCls("timeline-item");
    const instance = getCurrentInstance();
    const context = inject(timelineInjectionKey, {});
    const index3 = computed(() => {
      var _a, _b, _c;
      return (_c = (_b = context.items) == null ? void 0 : _b.indexOf((_a = instance == null ? void 0 : instance.uid) != null ? _a : -1)) != null ? _c : -1;
    });
    const contextDirection = computed(() => {
      var _a;
      return (_a = context == null ? void 0 : context.direction) != null ? _a : "vertical";
    });
    const contextLabelPosition = computed(() => {
      var _a;
      return (_a = context == null ? void 0 : context.labelPosition) != null ? _a : "same";
    });
    const cls = computed(() => {
      const { items = [], reverse, labelPosition, mode = "left" } = context;
      const direction = contextDirection.value;
      const computedPosition = getDefaultPosition(index3.value, mode, direction, props.position);
      return [
        prefixCls,
        {
          [`${prefixCls}-${direction}-${computedPosition}`]: direction,
          [`${prefixCls}-label-${labelPosition}`]: labelPosition,
          [`${prefixCls}-last`]: index3.value === (reverse === true ? 0 : items.length - 1)
        }
      ];
    });
    const dotLineCls = computed(() => {
      return [
        `${prefixCls}-dot-line`,
        `${prefixCls}-dot-line-is-${contextDirection.value}`
      ];
    });
    const computedDotLineStyle = computed(() => {
      const { direction } = context || {};
      return __spreadValues56({
        [direction === "horizontal" ? "borderTopStyle" : "borderLeftStyle"]: props.lineType
      }, props.lineColor ? { borderColor: props.lineColor } : {});
    });
    const dotTypeCls = computed(() => {
      return [`${prefixCls}-dot`, `${prefixCls}-dot-${props.dotType}`];
    });
    const computedDotStyle = computed(() => {
      return {
        [props.dotType === "solid" ? "backgroundColor" : "borderColor"]: props.dotColor
      };
    });
    return {
      cls,
      dotLineCls,
      dotTypeCls,
      prefixCls,
      computedDotLineStyle,
      computedDotStyle,
      labelPosition: contextLabelPosition
    };
  }
});
function _sfc_render171(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    role: "listitem",
    class: normalizeClass(_ctx.cls)
  }, [
    createBaseVNode("div", {
      class: normalizeClass(`${_ctx.prefixCls}-dot-wrapper`)
    }, [
      createBaseVNode("div", {
        class: normalizeClass(_ctx.dotLineCls),
        style: normalizeStyle(_ctx.computedDotLineStyle)
      }, null, 6),
      createBaseVNode("div", {
        class: normalizeClass(`${_ctx.prefixCls}-dot-content`)
      }, [
        _ctx.$slots.dot ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(`${_ctx.prefixCls}-dot-custom`)
        }, [
          renderSlot(_ctx.$slots, "dot")
        ], 2)) : (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass(_ctx.dotTypeCls),
          style: normalizeStyle(_ctx.computedDotStyle)
        }, null, 6))
      ], 2)
    ], 2),
    createBaseVNode("div", {
      class: normalizeClass(`${_ctx.prefixCls}-content-wrapper`)
    }, [
      _ctx.$slots.default ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(`${_ctx.prefixCls}-content`)
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 2)) : createCommentVNode("v-if", true),
      _ctx.labelPosition !== "relative" ? (openBlock(), createElementBlock("div", {
        key: 1,
        class: normalizeClass(`${_ctx.prefixCls}-label`)
      }, toDisplayString(_ctx.label), 3)) : createCommentVNode("v-if", true)
    ], 2),
    _ctx.labelPosition === "relative" ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(`${_ctx.prefixCls}-label`)
    }, toDisplayString(_ctx.label), 3)) : createCommentVNode("v-if", true)
  ], 2);
}
var TimelineItem = _export_sfc(_sfc_main171, [["render", _sfc_render171]]);

// node_modules/@arco-design/web-vue/es/timeline/timeline.js
var _Timeline = defineComponent({
  name: "Timeline",
  components: {
    Item: TimelineItem,
    Spin
  },
  props: {
    reverse: {
      type: Boolean
    },
    direction: {
      type: String,
      default: "vertical"
    },
    mode: {
      type: String,
      default: "left"
    },
    pending: {
      type: [Boolean, String]
    },
    labelPosition: {
      type: String,
      default: "same"
    }
  },
  setup(props, {
    slots
  }) {
    const prefixCls = getPrefixCls("timeline");
    const hasPending = computed(() => {
      return props.pending || slots.pending;
    });
    const {
      children,
      components: components2
    } = useChildrenComponents("TimelineItem");
    const {
      reverse: reverseRef,
      direction: directionRef,
      labelPosition: labelPositionRef,
      mode: modeRef
    } = toRefs(props);
    const timelineContext = reactive({
      items: components2,
      direction: directionRef,
      reverse: reverseRef,
      labelPosition: labelPositionRef,
      mode: modeRef
    });
    provide(timelineInjectionKey, timelineContext);
    const cls = computed(() => {
      return [prefixCls, `${prefixCls}-${props.mode}`, `${prefixCls}-direction-${props.direction}`, {
        [`${prefixCls}-is-reverse`]: props.reverse
      }];
    });
    return () => {
      var _a, _b;
      if (hasPending.value) {
        children.value = (_a = slots.default) == null ? void 0 : _a.call(slots).concat(createVNode(TimelineItem, {
          "lineType": "dashed"
        }, {
          default: () => [props.pending !== true && createVNode("div", null, [props.pending])],
          dot: () => {
            var _a2, _b2;
            return (_b2 = (_a2 = slots.dot) == null ? void 0 : _a2.call(slots)) != null ? _b2 : createVNode(Spin, {
              "size": 12
            }, null);
          }
        }));
      } else {
        children.value = (_b = slots.default) == null ? void 0 : _b.call(slots);
      }
      return createVNode("div", {
        "role": "list",
        "class": cls.value
      }, [children.value]);
    };
  }
});

// node_modules/@arco-design/web-vue/es/timeline/index.js
var Timeline = Object.assign(_Timeline, {
  Item: TimelineItem,
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Timeline.name, _Timeline);
    app.component(componentPrefix + TimelineItem.name, TimelineItem);
  }
});

// node_modules/@arco-design/web-vue/es/icon/icon-delete/icon-delete.js
var _sfc_main172 = defineComponent({
  name: "IconDelete",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-delete`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_174 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_256 = createBaseVNode("path", { d: "M5 11h5.5m0 0v29a1 1 0 0 0 1 1h25a1 1 0 0 0 1-1V11m-27 0H16m21.5 0H43m-5.5 0H32m-16 0V7h16v4m-16 0h16M20 18v15m8-15v15" }, null, -1);
var _hoisted_352 = [
  _hoisted_256
];
function _sfc_render172(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_352, 14, _hoisted_174);
}
var _IconDelete = _export_sfc(_sfc_main172, [["render", _sfc_render172]]);

// node_modules/@arco-design/web-vue/es/icon/icon-delete/index.js
var IconDelete = Object.assign(_IconDelete, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconDelete.name, _IconDelete);
  }
});

// node_modules/@arco-design/web-vue/es/transfer/context.js
var transferInjectionKey = Symbol("ArcoTransfer");

// node_modules/@arco-design/web-vue/es/transfer/transfer-list-item.js
var TransferListItem = defineComponent({
  name: "TransferListItem",
  props: {
    type: {
      type: String
    },
    data: {
      type: Object,
      required: true
    },
    allowClear: {
      type: Boolean
    },
    disabled: {
      type: Boolean
    },
    draggable: {
      type: Boolean
    },
    simple: Boolean
  },
  setup(props) {
    const prefixCls = getPrefixCls("transfer-list-item");
    const transferCtx = inject(transferInjectionKey, void 0);
    const handleClick = () => {
      if (!props.simple) {
        return;
      }
      transferCtx == null ? void 0 : transferCtx.moveTo([props.data.value], props.type === "target" ? "source" : "target");
    };
    const cls = computed(() => [prefixCls, {
      [`${prefixCls}-disabled`]: props.disabled,
      [`${prefixCls}-draggable`]: props.draggable
    }]);
    const handleRemove = () => {
      transferCtx == null ? void 0 : transferCtx.moveTo([props.data.value], "source");
    };
    return () => {
      var _a, _b, _c;
      return createVNode("div", {
        "class": cls.value,
        "onClick": handleClick
      }, [props.allowClear || props.simple ? createVNode("span", {
        "class": `${prefixCls}-content`
      }, [(_c = (_b = transferCtx == null ? void 0 : (_a = transferCtx.slots).item) == null ? void 0 : _b.call(_a, {
        label: props.data.label,
        value: props.data.value
      })) != null ? _c : props.data.label]) : createVNode(Checkbox, {
        "class": [`${prefixCls}-content`, `${prefixCls}-checkbox`],
        "modelValue": transferCtx == null ? void 0 : transferCtx.selected,
        "value": props.data.value,
        "onChange": (value) => transferCtx == null ? void 0 : transferCtx.onSelect(value),
        "uninjectGroupContext": true
      }, {
        default: () => {
          var _a2, _b2, _c2;
          return [(_c2 = (_b2 = transferCtx == null ? void 0 : (_a2 = transferCtx.slots).item) == null ? void 0 : _b2.call(_a2, {
            label: props.data.label,
            value: props.data.value
          })) != null ? _c2 : props.data.label];
        }
      }), props.allowClear && !props.disabled && createVNode(IconHover, {
        "class": `${prefixCls}-remove-btn`,
        "onClick": handleRemove
      }, {
        default: () => [createVNode(IconClose, null, null)]
      })]);
    };
  }
});

// node_modules/@arco-design/web-vue/es/transfer/transfer-view.js
var _sfc_main173 = defineComponent({
  name: "TransferView",
  components: {
    Empty,
    Checkbox,
    IconHover,
    IconDelete,
    InputSearch: Input.Search,
    List,
    TransferListItem,
    Scrollbar
  },
  props: {
    type: {
      type: String
    },
    dataInfo: {
      type: Object,
      required: true
    },
    title: String,
    data: {
      type: Array,
      required: true
    },
    allowClear: Boolean,
    selected: {
      type: Array,
      required: true
    },
    showSearch: Boolean,
    showSelectAll: Boolean,
    simple: Boolean
  },
  emits: ["search"],
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("transfer-view");
    const filter = ref("");
    const transferCtx = inject(transferInjectionKey, void 0);
    const checked = computed(() => props.dataInfo.data.length > 0 && props.dataInfo.selected.length === props.dataInfo.data.length);
    const indeterminate = computed(() => props.dataInfo.selected.length > 0 && props.dataInfo.selected.length < props.dataInfo.data.length);
    const handleSelectAllChange = (checked2) => {
      if (checked2) {
        transferCtx == null ? void 0 : transferCtx.onSelect([
          ...props.selected,
          ...props.dataInfo.allValidValues
        ]);
      } else {
        transferCtx == null ? void 0 : transferCtx.onSelect(props.selected.filter((value) => !props.dataInfo.allValidValues.includes(value)));
      }
    };
    const filteredData = computed(() => props.dataInfo.data.filter((item) => {
      if (filter.value) {
        return item.label.includes(filter.value);
      }
      return true;
    }));
    const handleSearch = (value) => {
      emit("search", value, props.type);
    };
    const handleClear = () => {
      transferCtx == null ? void 0 : transferCtx.moveTo(props.dataInfo.allValidValues, "source");
    };
    return {
      prefixCls,
      filteredData,
      filter,
      checked,
      indeterminate,
      handleSelectAllChange,
      handleSearch,
      handleClear,
      transferCtx
    };
  }
});
function _sfc_render173(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_checkbox = resolveComponent("checkbox");
  const _component_icon_delete = resolveComponent("icon-delete");
  const _component_icon_hover = resolveComponent("icon-hover");
  const _component_input_search = resolveComponent("input-search");
  const _component_transfer_list_item = resolveComponent("transfer-list-item");
  const _component_list = resolveComponent("list");
  const _component_Scrollbar = resolveComponent("Scrollbar");
  const _component_Empty = resolveComponent("Empty");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.prefixCls)
  }, [
    createBaseVNode("div", {
      class: normalizeClass(`${_ctx.prefixCls}-header`)
    }, [
      createBaseVNode("span", {
        class: normalizeClass(`${_ctx.prefixCls}-header-title`)
      }, [
        _ctx.allowClear || _ctx.simple || !_ctx.showSelectAll ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createTextVNode(toDisplayString(_ctx.title), 1)
        ], 2112)) : (openBlock(), createBlock(_component_checkbox, {
          key: 1,
          "model-value": _ctx.checked,
          indeterminate: _ctx.indeterminate,
          "uninject-group-context": "",
          onChange: _ctx.handleSelectAllChange
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(_ctx.title), 1)
          ]),
          _: 1
        }, 8, ["model-value", "indeterminate", "onChange"]))
      ], 2),
      _ctx.allowClear ? (openBlock(), createBlock(_component_icon_hover, {
        key: 0,
        class: normalizeClass(`${_ctx.prefixCls}-header-clear-btn`),
        onClick: _ctx.handleClear
      }, {
        default: withCtx(() => [
          createVNode(_component_icon_delete)
        ]),
        _: 1
      }, 8, ["class", "onClick"])) : !_ctx.simple ? (openBlock(), createElementBlock("span", {
        key: 1,
        class: normalizeClass(`${_ctx.prefixCls}-header-count`)
      }, toDisplayString(_ctx.dataInfo.selected.length) + " / " + toDisplayString(_ctx.dataInfo.data.length), 3)) : createCommentVNode("v-if", true)
    ], 2),
    _ctx.showSearch ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(`${_ctx.prefixCls}-search`)
    }, [
      createVNode(_component_input_search, {
        modelValue: _ctx.filter,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.filter = $event),
        onChange: _ctx.handleSearch
      }, null, 8, ["modelValue", "onChange"])
    ], 2)) : createCommentVNode("v-if", true),
    createBaseVNode("div", {
      class: normalizeClass(`${_ctx.prefixCls}-body`)
    }, [
      _ctx.filteredData.length > 0 ? (openBlock(), createBlock(_component_Scrollbar, { key: 0 }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default", {
            data: _ctx.filteredData,
            selectedKeys: _ctx.transferCtx.selected,
            onSelect: _ctx.transferCtx.onSelect
          }, () => [
            createVNode(_component_list, {
              class: normalizeClass(`${_ctx.prefixCls}-list`),
              bordered: false,
              scrollbar: false
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.filteredData, (item) => {
                  return openBlock(), createBlock(_component_transfer_list_item, {
                    key: item.value,
                    type: _ctx.type,
                    data: item,
                    simple: _ctx.simple,
                    "allow-clear": _ctx.allowClear
                  }, null, 8, ["type", "data", "simple", "allow-clear"]);
                }), 128))
              ]),
              _: 1
            }, 8, ["class"])
          ])
        ]),
        _: 3
      })) : (openBlock(), createBlock(_component_Empty, {
        key: 1,
        class: normalizeClass(`${_ctx.prefixCls}-empty`)
      }, null, 8, ["class"]))
    ], 2)
  ], 2);
}
var TransferView = _export_sfc(_sfc_main173, [["render", _sfc_render173]]);

// node_modules/@arco-design/web-vue/es/transfer/transfer.js
var _sfc_main174 = defineComponent({
  name: "Transfer",
  components: {
    ArcoButton: Button,
    TransferView,
    IconLeft,
    IconRight
  },
  props: {
    data: {
      type: Array,
      default: () => []
    },
    modelValue: {
      type: Array,
      default: void 0
    },
    defaultValue: {
      type: Array,
      default: () => []
    },
    selected: {
      type: Array,
      default: void 0
    },
    defaultSelected: {
      type: Array,
      default: () => []
    },
    disabled: {
      type: Boolean,
      default: false
    },
    simple: {
      type: Boolean,
      default: false
    },
    oneWay: {
      type: Boolean,
      default: false
    },
    showSearch: {
      type: Boolean,
      default: false
    },
    showSelectAll: {
      type: Boolean,
      default: true
    },
    title: {
      type: Array,
      default: () => ["Source", "Target"]
    }
  },
  emits: {
    "update:modelValue": (value) => true,
    "update:selected": (selected) => true,
    "change": (value) => true,
    "select": (selected) => true,
    "search": (value, type) => true
  },
  setup(props, { emit, slots }) {
    const { mergedDisabled, eventHandlers } = useFormItem({
      disabled: toRef(props, "disabled")
    });
    const prefixCls = getPrefixCls("transfer");
    const _target = ref(props.defaultValue);
    const computedTarget = computed(() => {
      var _a;
      return (_a = props.modelValue) != null ? _a : _target.value;
    });
    const _selected = ref(props.defaultSelected);
    const computedSelected = computed(() => {
      var _a;
      return (_a = props.selected) != null ? _a : _selected.value;
    });
    const sourceTitle = computed(() => {
      var _a;
      return (_a = props.title) == null ? void 0 : _a[0];
    });
    const targetTitle = computed(() => {
      var _a;
      return (_a = props.title) == null ? void 0 : _a[1];
    });
    const dataInfo = computed(() => {
      const sourceInfo = {
        data: [],
        allValidValues: [],
        selected: [],
        validSelected: []
      };
      const targetInfo = {
        data: [],
        allValidValues: [],
        selected: [],
        validSelected: []
      };
      for (const item of props.data) {
        if (computedTarget.value.includes(item.value)) {
          targetInfo.data.push(item);
          if (!item.disabled) {
            targetInfo.allValidValues.push(item.value);
          }
          if (computedSelected.value.includes(item.value)) {
            targetInfo.selected.push(item.value);
            if (!item.disabled) {
              targetInfo.validSelected.push(item.value);
            }
          }
        } else {
          sourceInfo.data.push(item);
          if (!item.disabled) {
            sourceInfo.allValidValues.push(item.value);
          }
          if (computedSelected.value.includes(item.value)) {
            sourceInfo.selected.push(item.value);
            if (!item.disabled) {
              sourceInfo.validSelected.push(item.value);
            }
          }
        }
      }
      return {
        sourceInfo,
        targetInfo
      };
    });
    const handleSearch = (value, type) => {
      emit("search", value, type);
    };
    const moveTo = (values, target3) => {
      var _a, _b;
      const newTarget = target3 === "target" ? [...computedTarget.value, ...values] : computedTarget.value.filter((value) => !values.includes(value));
      handleSelect(dataInfo.value[target3 === "target" ? "targetInfo" : "sourceInfo"].selected);
      _target.value = newTarget;
      emit("update:modelValue", newTarget);
      emit("change", newTarget);
      (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onChange) == null ? void 0 : _b.call(_a);
    };
    const handleClick = (target3) => {
      const values = target3 === "target" ? dataInfo.value.sourceInfo.validSelected : dataInfo.value.targetInfo.validSelected;
      moveTo(values, target3);
    };
    const handleSelect = (values) => {
      _selected.value = values;
      emit("update:selected", values);
      emit("select", values);
    };
    provide(transferInjectionKey, reactive({
      selected: computedSelected,
      slots,
      moveTo,
      onSelect: handleSelect
    }));
    const cls = computed(() => [
      prefixCls,
      {
        [`${prefixCls}-simple`]: props.simple,
        [`${prefixCls}-disabled`]: mergedDisabled.value
      }
    ]);
    return {
      prefixCls,
      cls,
      dataInfo,
      computedSelected,
      sourceTitle,
      targetTitle,
      handleClick,
      handleSearch
    };
  }
});
function _sfc_render174(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_transfer_view = resolveComponent("transfer-view");
  const _component_icon_right = resolveComponent("icon-right");
  const _component_arco_button = resolveComponent("arco-button");
  const _component_icon_left = resolveComponent("icon-left");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.cls)
  }, [
    createVNode(_component_transfer_view, {
      type: "source",
      class: normalizeClass(`${_ctx.prefixCls}-view-source`),
      title: _ctx.sourceTitle,
      "data-info": _ctx.dataInfo.sourceInfo,
      data: _ctx.dataInfo.sourceInfo.data,
      selected: _ctx.computedSelected,
      "show-search": _ctx.showSearch,
      "show-select-all": _ctx.showSelectAll,
      simple: _ctx.simple,
      onSearch: _ctx.handleSearch
    }, createSlots({ _: 2 }, [
      _ctx.$slots.source ? {
        name: "default",
        fn: withCtx((slotData) => [
          renderSlot(_ctx.$slots, "source", normalizeProps(guardReactiveProps(slotData)))
        ])
      } : void 0
    ]), 1032, ["class", "title", "data-info", "data", "selected", "show-search", "show-select-all", "simple", "onSearch"]),
    !_ctx.simple ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass([`${_ctx.prefixCls}-operations`])
    }, [
      createVNode(_component_arco_button, {
        tabindex: "-1",
        "aria-label": "Move selected right",
        size: "small",
        shape: "round",
        disabled: _ctx.dataInfo.sourceInfo.validSelected.length === 0,
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.handleClick("target"))
      }, {
        icon: withCtx(() => [
          createVNode(_component_icon_right)
        ]),
        _: 1
      }, 8, ["disabled"]),
      !_ctx.oneWay ? (openBlock(), createBlock(_component_arco_button, {
        key: 0,
        tabindex: "-1",
        "aria-label": "Move selected left",
        size: "small",
        shape: "round",
        disabled: _ctx.dataInfo.targetInfo.validSelected.length === 0,
        onClick: _cache[1] || (_cache[1] = ($event) => _ctx.handleClick("source"))
      }, {
        icon: withCtx(() => [
          createVNode(_component_icon_left)
        ]),
        _: 1
      }, 8, ["disabled"])) : createCommentVNode("v-if", true)
    ], 2)) : createCommentVNode("v-if", true),
    createVNode(_component_transfer_view, {
      type: "target",
      class: normalizeClass(`${_ctx.prefixCls}-view-target`),
      title: _ctx.targetTitle,
      "data-info": _ctx.dataInfo.targetInfo,
      data: _ctx.dataInfo.targetInfo.data,
      selected: _ctx.computedSelected,
      "allow-clear": _ctx.oneWay,
      "show-search": _ctx.showSearch,
      "show-select-all": _ctx.showSelectAll,
      simple: _ctx.simple,
      onSearch: _ctx.handleSearch
    }, createSlots({ _: 2 }, [
      _ctx.$slots.target ? {
        name: "default",
        fn: withCtx((slotData) => [
          renderSlot(_ctx.$slots, "target", normalizeProps(guardReactiveProps(slotData)))
        ])
      } : void 0
    ]), 1032, ["class", "title", "data-info", "data", "selected", "allow-clear", "show-search", "show-select-all", "simple", "onSearch"])
  ], 2);
}
var _Transfer = _export_sfc(_sfc_main174, [["render", _sfc_render174]]);

// node_modules/@arco-design/web-vue/es/transfer/index.js
var Transfer = Object.assign(_Transfer, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Transfer.name, _Transfer);
  }
});

// node_modules/@arco-design/web-vue/es/tree/context.js
var TreeInjectionKey = Symbol("TreeInjectionKey");

// node_modules/@arco-design/web-vue/es/tree/utils/index.js
function getFlattenTreeData(tree) {
  const flattenTreeData = [];
  function preOrder(tree2) {
    if (!tree2)
      return;
    tree2.forEach((node) => {
      flattenTreeData.push(node);
      preOrder(node.children);
    });
  }
  preOrder(tree);
  return flattenTreeData;
}
function getKey2TreeNode(flattenTreeData) {
  const key2TreeNode = /* @__PURE__ */ new Map();
  flattenTreeData.forEach((node) => {
    key2TreeNode.set(node.key, node);
  });
  return key2TreeNode;
}
function isNodeSelectable(node) {
  return node.selectable && !node.disabled;
}
function isNodeExpandable(node) {
  return !node.isLeaf && node.children;
}
function isLeafNode(node) {
  if (isBoolean(node.isLeaf))
    return node.isLeaf;
  return !node.children;
}

// node_modules/@arco-design/web-vue/es/tree/utils/check-utils.js
function SetAdd(set) {
  return Set.prototype.add.bind(set);
}
function SetDelete(set) {
  return Set.prototype.delete.bind(set);
}
function isNodeCheckable(node) {
  if (node.disabled || node.disableCheckbox)
    return false;
  return !!node.checkable;
}
function getChildrenKeys(node) {
  var _a;
  const keys = [];
  (_a = node.children) == null ? void 0 : _a.forEach((child) => {
    if (isNodeCheckable(child)) {
      keys.push(child.key, ...getChildrenKeys(child));
    }
  });
  return keys;
}
function updateParent(options) {
  var _a;
  const { node, checkedKeySet, indeterminateKeySet } = options;
  let parentNode = node.parent;
  while (parentNode) {
    if (isNodeCheckable(parentNode)) {
      const parentKey = parentNode.key;
      const children = ((_a = parentNode.children) == null ? void 0 : _a.filter(isNodeCheckable)) || [];
      let checkedCount = 0;
      const total = children.length;
      children.some(({ key: childKey }) => {
        if (checkedKeySet.has(childKey)) {
          checkedCount += 1;
        } else if (indeterminateKeySet.has(childKey)) {
          checkedCount += 0.5;
          return true;
        }
        return false;
      });
      if (checkedCount && checkedCount !== total) {
        indeterminateKeySet.add(parentKey);
      } else {
        indeterminateKeySet.delete(parentKey);
      }
      if (checkedCount && checkedCount === total) {
        checkedKeySet.add(parentKey);
      } else {
        checkedKeySet.delete(parentKey);
      }
    }
    parentNode = parentNode.parent;
  }
}
function getCheckedStateByCheck(options) {
  const {
    node,
    checked,
    checkedKeys,
    indeterminateKeys,
    checkStrictly = false
  } = options;
  const { key } = node;
  const checkedKeySet = new Set(checkedKeys);
  const indeterminateKeySet = new Set(indeterminateKeys);
  checked ? checkedKeySet.add(key) : checkedKeySet.delete(key);
  indeterminateKeySet.delete(key);
  if (!checkStrictly) {
    const childKeys = getChildrenKeys(node);
    if (checked) {
      childKeys.forEach(SetAdd(checkedKeySet));
    } else {
      childKeys.forEach(SetDelete(checkedKeySet));
    }
    childKeys.forEach(SetDelete(indeterminateKeySet));
    updateParent({ node, checkedKeySet, indeterminateKeySet });
  }
  return [[...checkedKeySet], [...indeterminateKeySet]];
}
function getCheckedStateByInitKeys(options) {
  const { initCheckedKeys, key2TreeNode, checkStrictly, onlyCheckLeaf } = options;
  const checkedKeySet = /* @__PURE__ */ new Set();
  const childCheckedKeySet = /* @__PURE__ */ new Set();
  const indeterminateKeySet = /* @__PURE__ */ new Set();
  if (!checkStrictly) {
    initCheckedKeys.forEach((key) => {
      var _a;
      const node = key2TreeNode.get(key);
      if (!node || childCheckedKeySet.has(key) || onlyCheckLeaf && ((_a = node.children) == null ? void 0 : _a.length)) {
        return;
      }
      const childKeys = getChildrenKeys(node);
      childKeys.forEach(SetAdd(childCheckedKeySet));
      childKeys.forEach(SetDelete(indeterminateKeySet));
      checkedKeySet.add(key);
      indeterminateKeySet.delete(key);
      updateParent({ node, checkedKeySet, indeterminateKeySet });
    });
  } else {
    initCheckedKeys.forEach(SetAdd(checkedKeySet));
  }
  return [[...checkedKeySet, ...childCheckedKeySet], [...indeterminateKeySet]];
}

// node_modules/@arco-design/web-vue/es/tree/hooks/use-tree-context.js
function useTreeContext() {
  const treeContext = inject(TreeInjectionKey);
  return treeContext || {};
}

// node_modules/@arco-design/web-vue/es/icon/icon-file/icon-file.js
var _sfc_main175 = defineComponent({
  name: "IconFile",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-file`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_175 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_257 = createBaseVNode("path", { d: "M16 21h16m-16 8h10m11 13H11a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h21l7 7v27a2 2 0 0 1-2 2Z" }, null, -1);
var _hoisted_353 = [
  _hoisted_257
];
function _sfc_render175(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_353, 14, _hoisted_175);
}
var _IconFile = _export_sfc(_sfc_main175, [["render", _sfc_render175]]);

// node_modules/@arco-design/web-vue/es/icon/icon-file/index.js
var IconFile = Object.assign(_IconFile, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconFile.name, _IconFile);
  }
});

// node_modules/@arco-design/web-vue/es/tree/node-switcher.vue_vue&type=script&lang.js
var _sfc_main176 = defineComponent({
  name: "TreeNodeSwitcher",
  components: {
    IconLoading,
    RenderFunction
  },
  props: {
    prefixCls: String,
    loading: Boolean,
    showLine: Boolean,
    treeNodeData: {
      type: Object
    },
    icons: {
      type: Object
    },
    nodeStatus: {
      type: Object
    }
  },
  emits: ["click"],
  setup(props, {
    slots,
    emit
  }) {
    const {
      icons,
      nodeStatus,
      treeNodeData
    } = toRefs(props);
    const treeContext = useTreeContext();
    const nodeSwitcherIcon = usePickSlots(slots, "switcher-icon");
    const nodeLoadingIcon = usePickSlots(slots, "loading-icon");
    return {
      getSwitcherIcon: () => {
        var _a, _b, _c;
        const icon = (_b = (_a = icons == null ? void 0 : icons.value) == null ? void 0 : _a.switcherIcon) != null ? _b : nodeSwitcherIcon.value;
        return icon ? icon(nodeStatus.value) : (_c = treeContext.switcherIcon) == null ? void 0 : _c.call(treeContext, treeNodeData.value, nodeStatus.value);
      },
      getLoadingIcon: () => {
        var _a, _b, _c;
        const icon = (_b = (_a = icons == null ? void 0 : icons.value) == null ? void 0 : _a.loadingIcon) != null ? _b : nodeLoadingIcon.value;
        return icon ? icon(nodeStatus.value) : (_c = treeContext.loadingIcon) == null ? void 0 : _c.call(treeContext, treeNodeData.value, nodeStatus.value);
      },
      onClick(e2) {
        emit("click", e2);
      }
    };
  },
  render() {
    var _a, _b, _c;
    const {
      prefixCls,
      getSwitcherIcon,
      getLoadingIcon,
      onClick,
      nodeStatus = {},
      loading,
      showLine
    } = this;
    const {
      expanded,
      isLeaf
    } = nodeStatus;
    if (loading) {
      return (_a = getLoadingIcon()) != null ? _a : h(IconLoading);
    }
    let icon = null;
    let needIconHover = false;
    if (!isLeaf) {
      const defaultIcon = showLine ? h("span", {
        class: `${prefixCls}-${expanded ? "minus" : "plus"}-icon`
      }) : h(IconCaretDown);
      icon = (_b = getSwitcherIcon()) != null ? _b : defaultIcon;
      needIconHover = !showLine;
    } else if (showLine) {
      icon = (_c = getSwitcherIcon()) != null ? _c : h(IconFile);
    }
    if (!icon)
      return null;
    const content = h("span", {
      class: `${prefixCls}-switcher-icon`,
      onClick
    }, icon);
    return needIconHover ? h(IconHover, {
      class: `${prefixCls}-icon-hover`
    }, () => content) : content;
  }
});

// node_modules/@arco-design/web-vue/es/tree/utils/tree-data.js
var __defProp57 = Object.defineProperty;
var __defProps26 = Object.defineProperties;
var __getOwnPropDescs26 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols57 = Object.getOwnPropertySymbols;
var __hasOwnProp57 = Object.prototype.hasOwnProperty;
var __propIsEnum57 = Object.prototype.propertyIsEnumerable;
var __defNormalProp57 = (obj, key, value) => key in obj ? __defProp57(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues57 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp57.call(b, prop))
      __defNormalProp57(a, prop, b[prop]);
  if (__getOwnPropSymbols57)
    for (var prop of __getOwnPropSymbols57(b)) {
      if (__propIsEnum57.call(b, prop))
        __defNormalProp57(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps26 = (a, b) => __defProps26(a, __getOwnPropDescs26(b));
var generateKey = (() => {
  let i2 = 0;
  return () => {
    i2 += 1;
    return `__arco_tree${i2}`;
  };
})();
function getBoolean(val1, val2) {
  return !!(isUndefined(val1) ? val2 : val1);
}
function mapObject(obj, nameMap) {
  const _obj = __spreadValues57({}, obj);
  if (nameMap) {
    const names = Object.keys(nameMap);
    names.forEach((name) => {
      const sourceName = nameMap[name];
      if (sourceName !== name) {
        _obj[name] = obj[sourceName];
        delete _obj[sourceName];
      }
    });
  }
  return _obj;
}
function getEnableResult({
  subEnable,
  superEnable,
  isLeaf,
  treeNodeData,
  level
}) {
  if (!isUndefined(subEnable))
    return subEnable;
  if (isFunction(superEnable)) {
    return superEnable(treeNodeData, { isLeaf, level });
  }
  return superEnable != null ? superEnable : false;
}
function generateNode(options) {
  var _a, _b;
  const { treeNodeData, parentNode, isTail = true, treeProps } = options;
  const { fieldNames } = treeProps || {};
  const mapTreeNodeData = mapObject(treeNodeData, fieldNames);
  const isLeaf = treeProps.loadMore ? !!mapTreeNodeData.isLeaf : !((_a = mapTreeNodeData.children) == null ? void 0 : _a.length);
  const level = parentNode ? parentNode.level + 1 : 0;
  const treeNodeProps = __spreadProps26(__spreadValues57({}, omit(mapTreeNodeData, ["children"])), {
    key: (_b = mapTreeNodeData.key) != null ? _b : generateKey(),
    selectable: getEnableResult({
      subEnable: mapTreeNodeData.selectable,
      superEnable: treeProps == null ? void 0 : treeProps.selectable,
      isLeaf,
      level,
      treeNodeData
    }),
    disabled: !!mapTreeNodeData.disabled,
    disableCheckbox: !!mapTreeNodeData.disableCheckbox,
    checkable: getEnableResult({
      subEnable: mapTreeNodeData.checkable,
      superEnable: treeProps == null ? void 0 : treeProps.checkable,
      isLeaf,
      level,
      treeNodeData
    }),
    isLeaf,
    isTail,
    blockNode: !!(treeProps == null ? void 0 : treeProps.blockNode),
    showLine: !!(treeProps == null ? void 0 : treeProps.showLine),
    level,
    lineless: parentNode ? [...parentNode.lineless, parentNode.isTail] : [],
    draggable: getBoolean(mapTreeNodeData.draggable, treeProps == null ? void 0 : treeProps.draggable)
  });
  const node = __spreadProps26(__spreadValues57({}, treeNodeProps), {
    treeNodeProps,
    treeNodeData,
    parent: parentNode,
    parentKey: parentNode == null ? void 0 : parentNode.key,
    pathParentKeys: parentNode ? [...parentNode.pathParentKeys, parentNode.key] : []
  });
  return node;
}
function generateTreeData(treeData, treeProps) {
  function preOrder(tree, parentNode) {
    if (!tree)
      return void 0;
    const { fieldNames } = treeProps;
    const nodes = [];
    tree.forEach((treeNodeData, index3) => {
      const node = generateNode({
        treeNodeData,
        treeProps,
        parentNode,
        isTail: index3 === tree.length - 1
      });
      node.children = preOrder(treeNodeData[(fieldNames == null ? void 0 : fieldNames.children) || "children"], node);
      nodes.push(node);
    });
    return nodes;
  }
  return preOrder(treeData);
}

// node_modules/@arco-design/web-vue/es/tree/hooks/use-node-key.js
function useNodeKey() {
  const instance = getCurrentInstance();
  const getKey2 = () => {
    var _a;
    return (_a = instance == null ? void 0 : instance.vnode.key) != null ? _a : generateKey();
  };
  const key = ref(getKey2());
  onUpdated(() => {
    key.value = getKey2();
  });
  return key;
}

// node_modules/@arco-design/web-vue/es/tree/hooks/use-draggable.js
function useDraggable2(props) {
  const { key, refTitle } = toRefs(props);
  const treeContext = useTreeContext();
  const isDragOver = ref(false);
  const isDragging = ref(false);
  const isAllowDrop = ref(false);
  const dropPosition = ref(0);
  const updateDropPosition = throttleByRaf((e2) => {
    if (!refTitle.value)
      return;
    const rect = refTitle.value.getBoundingClientRect();
    const offsetY = window.pageYOffset + rect.top;
    const { pageY } = e2;
    const gapHeight = rect.height / 4;
    const diff = pageY - offsetY;
    dropPosition.value = diff < gapHeight ? -1 : diff < rect.height - gapHeight ? 0 : 1;
    isAllowDrop.value = treeContext.allowDrop ? treeContext.allowDrop(key.value, dropPosition.value) : true;
  });
  return {
    isDragOver,
    isDragging,
    isAllowDrop,
    dropPosition,
    setDragStatus(status, e2) {
      switch (status) {
        case "dragStart":
          isDragging.value = true;
          dropPosition.value = 0;
          treeContext.onDragStart && treeContext.onDragStart(key.value, e2);
          break;
        case "dragEnd":
          isDragging.value = false;
          isDragOver.value = false;
          dropPosition.value = 0;
          updateDropPosition.cancel();
          treeContext.onDragEnd && treeContext.onDragEnd(key.value, e2);
          break;
        case "dragOver":
          isDragOver.value = true;
          updateDropPosition(e2);
          treeContext.onDragOver && treeContext.onDragOver(key.value, e2);
          break;
        case "dragLeave":
          isDragOver.value = false;
          dropPosition.value = 0;
          updateDropPosition.cancel();
          treeContext.onDragLeave && treeContext.onDragLeave(key.value, e2);
          break;
        case "drop":
          treeContext.onDrop && treeContext.onDrop(key.value, dropPosition.value, e2);
          isDragOver.value = false;
          dropPosition.value = 0;
          updateDropPosition.cancel();
          break;
      }
    }
  };
}

// node_modules/@arco-design/web-vue/es/_utils/to-array.js
function toArray(val) {
  return isArray(val) ? val : [val];
}

// node_modules/@arco-design/web-vue/es/tree/base-node.js
var _sfc_main177 = defineComponent({
  name: "BaseTreeNode",
  components: {
    NodeSwitcher: _sfc_main176,
    Checkbox,
    RenderFunction,
    IconDragDotVertical
  },
  props: {
    key: {
      type: [String, Number]
    },
    title: {
      type: String
    },
    selectable: {
      type: Boolean
    },
    disabled: {
      type: Boolean
    },
    disableCheckbox: {
      type: Boolean
    },
    checkable: {
      type: Boolean
    },
    draggable: {
      type: Boolean
    },
    isLeaf: {
      type: Boolean
    },
    icon: {
      type: Function
    },
    switcherIcon: {
      type: Function
    },
    loadingIcon: {
      type: Function
    },
    dragIcon: {
      type: Function
    },
    isTail: {
      type: Boolean
    },
    blockNode: {
      type: Boolean
    },
    showLine: {
      type: Boolean
    },
    level: {
      type: Number,
      default: 0
    },
    lineless: {
      type: Array,
      default: () => []
    }
  },
  setup(props) {
    const key = useNodeKey();
    const prefixCls = getPrefixCls("tree-node");
    const treeContext = useTreeContext();
    const node = computed(() => {
      var _a;
      return (_a = treeContext.key2TreeNode) == null ? void 0 : _a.get(key.value);
    });
    const treeNodeData = computed(() => node.value.treeNodeData);
    const children = computed(() => node.value.children);
    const actionOnNodeClick = computed(() => {
      var _a;
      const action = (_a = treeContext.treeProps) == null ? void 0 : _a.actionOnNodeClick;
      return action ? toArray(action) : [];
    });
    const { isLeaf, isTail, selectable, disabled, disableCheckbox, draggable } = toRefs(props);
    const classNames = computed(() => {
      var _a;
      return [
        `${prefixCls}`,
        {
          [`${prefixCls}-selected`]: selected.value,
          [`${prefixCls}-is-leaf`]: isLeaf.value,
          [`${prefixCls}-is-tail`]: isTail.value,
          [`${prefixCls}-expanded`]: expanded.value,
          [`${prefixCls}-disabled-selectable`]: !selectable.value && !((_a = treeContext.treeProps) == null ? void 0 : _a.disableSelectActionOnly),
          [`${prefixCls}-disabled`]: disabled.value
        }
      ];
    });
    const refTitle = ref();
    const { isDragOver, isDragging, isAllowDrop, dropPosition, setDragStatus } = useDraggable2(reactive({
      key,
      refTitle
    }));
    const titleClassNames = computed(() => [
      `${prefixCls}-title`,
      {
        [`${prefixCls}-title-draggable`]: draggable.value,
        [`${prefixCls}-title-gap-top`]: isDragOver.value && isAllowDrop.value && dropPosition.value < 0,
        [`${prefixCls}-title-gap-bottom`]: isDragOver.value && isAllowDrop.value && dropPosition.value > 0,
        [`${prefixCls}-title-highlight`]: !isDragging.value && isDragOver.value && isAllowDrop.value && dropPosition.value === 0,
        [`${prefixCls}-title-dragging`]: isDragging.value,
        [`${prefixCls}-title-block`]: node.value.blockNode
      }
    ]);
    const checked = computed(() => {
      var _a, _b;
      return (_b = (_a = treeContext.checkedKeys) == null ? void 0 : _a.includes) == null ? void 0 : _b.call(_a, key.value);
    });
    const indeterminate = computed(() => {
      var _a, _b;
      return (_b = (_a = treeContext.indeterminateKeys) == null ? void 0 : _a.includes) == null ? void 0 : _b.call(_a, key.value);
    });
    const selected = computed(() => {
      var _a, _b;
      return (_b = (_a = treeContext.selectedKeys) == null ? void 0 : _a.includes) == null ? void 0 : _b.call(_a, key.value);
    });
    const expanded = computed(() => {
      var _a, _b;
      return (_b = (_a = treeContext.expandedKeys) == null ? void 0 : _a.includes) == null ? void 0 : _b.call(_a, key.value);
    });
    const loading = computed(() => {
      var _a, _b;
      return (_b = (_a = treeContext.loadingKeys) == null ? void 0 : _a.includes) == null ? void 0 : _b.call(_a, key.value);
    });
    const treeDragIcon = computed(() => treeContext.dragIcon);
    const treeNodeIcon = computed(() => treeContext.nodeIcon);
    function onSwitcherClick(e2) {
      var _a, _b;
      if (isLeaf.value)
        return;
      if (!((_a = children.value) == null ? void 0 : _a.length) && isFunction(treeContext.onLoadMore)) {
        treeContext.onLoadMore(key.value);
      } else {
        (_b = treeContext == null ? void 0 : treeContext.onExpand) == null ? void 0 : _b.call(treeContext, !expanded.value, key.value, e2);
      }
    }
    const nodeStatus = reactive({
      loading,
      checked,
      selected,
      indeterminate,
      expanded,
      isLeaf
    });
    const treeTitle = computed(() => treeContext.nodeTitle ? () => {
      var _a;
      return (_a = treeContext.nodeTitle) == null ? void 0 : _a.call(treeContext, treeNodeData.value, nodeStatus);
    } : void 0);
    const extra = computed(() => treeContext.nodeExtra ? () => {
      var _a;
      return (_a = treeContext.nodeExtra) == null ? void 0 : _a.call(treeContext, treeNodeData.value, nodeStatus);
    } : void 0);
    return {
      refTitle,
      prefixCls,
      classNames,
      titleClassNames,
      indeterminate,
      checked,
      expanded,
      selected,
      treeTitle,
      treeNodeData,
      loading,
      treeDragIcon,
      treeNodeIcon,
      extra,
      nodeStatus,
      onCheckboxChange(checked2, e2) {
        var _a;
        if (disableCheckbox.value || disabled.value) {
          return;
        }
        (_a = treeContext.onCheck) == null ? void 0 : _a.call(treeContext, checked2, key.value, e2);
      },
      onTitleClick(e2) {
        var _a;
        if (actionOnNodeClick.value.includes("expand")) {
          onSwitcherClick(e2);
        }
        if (!selectable.value || disabled.value)
          return;
        (_a = treeContext.onSelect) == null ? void 0 : _a.call(treeContext, key.value, e2);
      },
      onSwitcherClick,
      onDragStart(e2) {
        var _a;
        if (!draggable.value)
          return;
        e2.stopPropagation();
        setDragStatus("dragStart", e2);
        try {
          (_a = e2.dataTransfer) == null ? void 0 : _a.setData("text/plain", "");
        } catch (error) {
        }
      },
      onDragEnd(e2) {
        if (!draggable.value)
          return;
        e2.stopPropagation();
        setDragStatus("dragEnd", e2);
      },
      onDragOver(e2) {
        if (!draggable)
          return;
        e2.stopPropagation();
        e2.preventDefault();
        setDragStatus("dragOver", e2);
      },
      onDragLeave(e2) {
        if (!draggable.value)
          return;
        e2.stopPropagation();
        setDragStatus("dragLeave", e2);
      },
      onDrop(e2) {
        if (!draggable.value || !isAllowDrop.value)
          return;
        e2.stopPropagation();
        e2.preventDefault();
        setDragStatus("drop", e2);
      }
    };
  }
});
var _hoisted_176 = ["draggable"];
function _sfc_render176(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_NodeSwitcher = resolveComponent("NodeSwitcher");
  const _component_Checkbox = resolveComponent("Checkbox");
  const _component_RenderFunction = resolveComponent("RenderFunction");
  const _component_IconDragDotVertical = resolveComponent("IconDragDotVertical");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.classNames)
  }, [
    createCommentVNode(" 缩进 "),
    createBaseVNode("span", {
      class: normalizeClass(`${_ctx.prefixCls}-indent`)
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.level, (i2) => {
        return openBlock(), createElementBlock("span", {
          key: i2,
          class: normalizeClass([
            `${_ctx.prefixCls}-indent-block`,
            {
              [`${_ctx.prefixCls}-indent-block-lineless`]: _ctx.lineless[i2 - 1]
            }
          ])
        }, null, 2);
      }), 128))
    ], 2),
    createCommentVNode(" switcher "),
    createBaseVNode("span", {
      class: normalizeClass([
        `${_ctx.prefixCls}-switcher`,
        {
          [`${_ctx.prefixCls}-switcher-expanded`]: _ctx.expanded
        }
      ])
    }, [
      createVNode(_component_NodeSwitcher, {
        "prefix-cls": _ctx.prefixCls,
        loading: _ctx.loading,
        "show-line": _ctx.showLine,
        "tree-node-data": _ctx.treeNodeData,
        icons: {
          switcherIcon: _ctx.switcherIcon,
          loadingIcon: _ctx.loadingIcon
        },
        "node-status": _ctx.nodeStatus,
        onClick: _ctx.onSwitcherClick
      }, createSlots({ _: 2 }, [
        _ctx.$slots["switcher-icon"] ? {
          name: "switcher-icon",
          fn: withCtx(() => [
            createCommentVNode(" @slot 定制 switcher 图标，会覆盖 Tree 的配置 "),
            renderSlot(_ctx.$slots, "switcher-icon")
          ])
        } : void 0,
        _ctx.$slots["loading-icon"] ? {
          name: "loading-icon",
          fn: withCtx(() => [
            createCommentVNode(" @slot 定制 loading 图标，会覆盖 Tree 的配置 "),
            renderSlot(_ctx.$slots, "loading-icon")
          ])
        } : void 0
      ]), 1032, ["prefix-cls", "loading", "show-line", "tree-node-data", "icons", "node-status", "onClick"])
    ], 2),
    createCommentVNode(" checkbox "),
    _ctx.checkable ? (openBlock(), createBlock(_component_Checkbox, {
      key: 0,
      disabled: _ctx.disableCheckbox || _ctx.disabled,
      "model-value": _ctx.checked,
      indeterminate: _ctx.indeterminate,
      "uninject-group-context": "",
      onChange: _ctx.onCheckboxChange
    }, null, 8, ["disabled", "model-value", "indeterminate", "onChange"])) : createCommentVNode("v-if", true),
    createCommentVNode(" 内容 "),
    createBaseVNode("span", {
      ref: "refTitle",
      class: normalizeClass(_ctx.titleClassNames),
      draggable: _ctx.draggable,
      onDragstart: _cache[0] || (_cache[0] = (...args) => _ctx.onDragStart && _ctx.onDragStart(...args)),
      onDragend: _cache[1] || (_cache[1] = (...args) => _ctx.onDragEnd && _ctx.onDragEnd(...args)),
      onDragover: _cache[2] || (_cache[2] = (...args) => _ctx.onDragOver && _ctx.onDragOver(...args)),
      onDragleave: _cache[3] || (_cache[3] = (...args) => _ctx.onDragLeave && _ctx.onDragLeave(...args)),
      onDrop: _cache[4] || (_cache[4] = (...args) => _ctx.onDrop && _ctx.onDrop(...args)),
      onClick: _cache[5] || (_cache[5] = (...args) => _ctx.onTitleClick && _ctx.onTitleClick(...args))
    }, [
      _ctx.$slots.icon || _ctx.icon || _ctx.treeNodeIcon ? (openBlock(), createElementBlock("span", {
        key: 0,
        class: normalizeClass([`${_ctx.prefixCls}-icon`, `${_ctx.prefixCls}-custom-icon`])
      }, [
        createCommentVNode(" 节点图标 "),
        _ctx.$slots.icon ? renderSlot(_ctx.$slots, "icon", normalizeProps(mergeProps({ key: 0 }, _ctx.nodeStatus))) : _ctx.icon ? (openBlock(), createBlock(_component_RenderFunction, mergeProps({
          key: 1,
          "render-func": _ctx.icon
        }, _ctx.nodeStatus), null, 16, ["render-func"])) : _ctx.treeNodeIcon ? (openBlock(), createBlock(_component_RenderFunction, mergeProps({
          key: 2,
          "render-func": _ctx.treeNodeIcon,
          node: _ctx.treeNodeData
        }, _ctx.nodeStatus), null, 16, ["render-func", "node"])) : createCommentVNode("v-if", true)
      ], 2)) : createCommentVNode("v-if", true),
      createBaseVNode("span", {
        class: normalizeClass(`${_ctx.prefixCls}-title-text`)
      }, [
        _ctx.treeTitle ? (openBlock(), createBlock(_component_RenderFunction, {
          key: 0,
          "render-func": _ctx.treeTitle
        }, null, 8, ["render-func"])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          createCommentVNode(" 标题，treeTitle 优先级高于节点的 title "),
          renderSlot(_ctx.$slots, "title", {}, () => [
            createTextVNode(toDisplayString(_ctx.title), 1)
          ])
        ], 2112)),
        _ctx.draggable ? (openBlock(), createElementBlock("span", {
          key: 2,
          class: normalizeClass([`${_ctx.prefixCls}-icon`, `${_ctx.prefixCls}-drag-icon`])
        }, [
          createCommentVNode(" 拖拽图标 "),
          _ctx.$slots["drag-icon"] ? renderSlot(_ctx.$slots, "drag-icon", normalizeProps(mergeProps({ key: 0 }, _ctx.nodeStatus))) : _ctx.dragIcon ? (openBlock(), createBlock(_component_RenderFunction, mergeProps({
            key: 1,
            "render-func": _ctx.dragIcon
          }, _ctx.nodeStatus), null, 16, ["render-func"])) : _ctx.treeDragIcon ? (openBlock(), createBlock(_component_RenderFunction, mergeProps({
            key: 2,
            "render-func": _ctx.treeDragIcon,
            node: _ctx.treeNodeData
          }, _ctx.nodeStatus), null, 16, ["render-func", "node"])) : (openBlock(), createBlock(_component_IconDragDotVertical, { key: 3 }))
        ], 2)) : createCommentVNode("v-if", true)
      ], 2)
    ], 42, _hoisted_176),
    createCommentVNode(" 额外 "),
    _ctx.extra ? (openBlock(), createBlock(_component_RenderFunction, {
      key: 1,
      "render-func": _ctx.extra
    }, null, 8, ["render-func"])) : createCommentVNode("v-if", true)
  ], 2);
}
var BaseTreeNode = _export_sfc(_sfc_main177, [["render", _sfc_render176]]);

// node_modules/@arco-design/web-vue/es/tree/expand-transition.js
var _sfc_main178 = defineComponent({
  name: "ExpandTransition",
  props: {
    expanded: Boolean
  },
  emits: ["end"],
  setup(props, { emit }) {
    return {
      onBeforeEnter(el) {
        el.style.height = props.expanded ? "0" : `${el.scrollHeight}px`;
      },
      onEnter(el) {
        el.style.height = props.expanded ? `${el.scrollHeight}px` : "0";
      },
      onAfterEnter(el) {
        el.style.height = props.expanded ? "" : "0";
        emit("end");
      },
      onBeforeLeave(el) {
        el.style.display = "none";
      }
    };
  }
});
function _sfc_render177(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, {
    onBeforeEnter: _ctx.onBeforeEnter,
    onEnter: _ctx.onEnter,
    onAfterEnter: _ctx.onAfterEnter,
    onBeforeLeave: _ctx.onBeforeLeave
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 8, ["onBeforeEnter", "onEnter", "onAfterEnter", "onBeforeLeave"]);
}
var ExpandTransition2 = _export_sfc(_sfc_main178, [["render", _sfc_render177]]);

// node_modules/@arco-design/web-vue/es/tree/transition-node-list.js
var _sfc_main179 = defineComponent({
  name: "TransitionNodeList",
  components: {
    ExpandTransition: ExpandTransition2,
    BaseTreeNode
  },
  props: {
    nodeKey: {
      type: [String, Number],
      required: true
    }
  },
  setup(props) {
    const prefixCls = getPrefixCls("tree");
    const classNames = [`${prefixCls}-node-list`];
    const treeContext = useTreeContext();
    const { nodeKey } = toRefs(props);
    const expanded = computed(() => {
      var _a, _b;
      return (_b = (_a = treeContext.expandedKeys) == null ? void 0 : _a.includes) == null ? void 0 : _b.call(_a, nodeKey.value);
    });
    const visibleNodeList = computed(() => {
      var _a;
      const expandedKeysSet = new Set(treeContext.expandedKeys || []);
      const childNodeList = (_a = treeContext.flattenTreeData) == null ? void 0 : _a.filter((node) => {
        var _a2, _b;
        if ((_a2 = node.pathParentKeys) == null ? void 0 : _a2.includes(nodeKey.value)) {
          return !treeContext.filterTreeNode || ((_b = treeContext.filterTreeNode) == null ? void 0 : _b.call(treeContext, node.treeNodeData));
        }
        return false;
      });
      return childNodeList == null ? void 0 : childNodeList.filter((node) => {
        var _a2;
        if (expanded.value) {
          return (_a2 = node.pathParentKeys) == null ? void 0 : _a2.every((_key) => expandedKeysSet.has(_key));
        }
        const index3 = node.pathParentKeys.indexOf(nodeKey.value);
        return node.pathParentKeys.slice(index3 + 1).every((_key) => expandedKeysSet.has(_key));
      });
    });
    const show = computed(() => {
      var _a, _b;
      return ((_a = treeContext.currentExpandKeys) == null ? void 0 : _a.includes(nodeKey.value)) && ((_b = visibleNodeList.value) == null ? void 0 : _b.length);
    });
    return {
      classNames,
      visibleNodeList,
      show,
      expanded,
      onTransitionEnd() {
        var _a;
        (_a = treeContext.onExpandEnd) == null ? void 0 : _a.call(treeContext, nodeKey.value);
      }
    };
  }
});
function _sfc_render178(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_BaseTreeNode = resolveComponent("BaseTreeNode");
  const _component_ExpandTransition = resolveComponent("ExpandTransition");
  return openBlock(), createBlock(_component_ExpandTransition, {
    expanded: _ctx.expanded,
    onEnd: _ctx.onTransitionEnd
  }, {
    default: withCtx(() => [
      _ctx.show ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(_ctx.classNames)
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.visibleNodeList, (node) => {
          return openBlock(), createBlock(_component_BaseTreeNode, mergeProps({
            key: node.key
          }, node.treeNodeProps), null, 16);
        }), 128))
      ], 2)) : createCommentVNode("v-if", true)
    ]),
    _: 1
  }, 8, ["expanded", "onEnd"]);
}
var TransitionNodeList = _export_sfc(_sfc_main179, [["render", _sfc_render178]]);

// node_modules/@arco-design/web-vue/es/tree/node.js
var __defProp58 = Object.defineProperty;
var __getOwnPropSymbols58 = Object.getOwnPropertySymbols;
var __hasOwnProp58 = Object.prototype.hasOwnProperty;
var __propIsEnum58 = Object.prototype.propertyIsEnumerable;
var __defNormalProp58 = (obj, key, value) => key in obj ? __defProp58(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues58 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp58.call(b, prop))
      __defNormalProp58(a, prop, b[prop]);
  if (__getOwnPropSymbols58)
    for (var prop of __getOwnPropSymbols58(b)) {
      if (__propIsEnum58.call(b, prop))
        __defNormalProp58(a, prop, b[prop]);
    }
  return a;
};
var TreeNode = defineComponent({
  name: "TreeNode",
  inheritAttrs: false,
  props: __spreadValues58({}, BaseTreeNode.props),
  setup(props, {
    slots,
    attrs
  }) {
    const key = useNodeKey();
    return () => {
      return createVNode(Fragment, null, [createVNode(BaseTreeNode, mergeProps(props, attrs, {
        "key": key.value
      }), slots), createVNode(TransitionNodeList, {
        "key": key.value,
        "nodeKey": key.value
      }, null)]);
    };
  }
});

// node_modules/@arco-design/web-vue/es/tree/hooks/use-checked-state.js
function useCheckedState(props) {
  const {
    defaultCheckedKeys,
    checkedKeys: propCheckedKeys,
    key2TreeNode,
    checkStrictly,
    halfCheckedKeys,
    onlyCheckLeaf
  } = toRefs(props);
  const isInitialized = ref(false);
  const localCheckedKeys = ref([]);
  const localIndeterminateKeys = ref([]);
  const computedCheckedKeys = ref();
  const computedIndeterminateKeys = ref();
  const getStateByKeys = (keys) => {
    return getCheckedStateByInitKeys({
      initCheckedKeys: keys,
      key2TreeNode: key2TreeNode.value,
      checkStrictly: checkStrictly.value,
      onlyCheckLeaf: onlyCheckLeaf.value
    });
  };
  const init = (keys) => {
    const initState = getStateByKeys(keys);
    [localCheckedKeys.value, localIndeterminateKeys.value] = initState;
  };
  init(propCheckedKeys.value || (defaultCheckedKeys == null ? void 0 : defaultCheckedKeys.value) || []);
  watchEffect(() => {
    if (propCheckedKeys.value) {
      [computedCheckedKeys.value, computedIndeterminateKeys.value] = getStateByKeys(propCheckedKeys.value);
    } else if (isInitialized.value) {
      computedCheckedKeys.value = void 0;
      computedIndeterminateKeys.value = void 0;
      localCheckedKeys.value = [];
      localIndeterminateKeys.value = [];
    }
    if (!isInitialized.value) {
      isInitialized.value = true;
    }
  });
  return {
    checkedKeys: computed(() => computedCheckedKeys.value || localCheckedKeys.value),
    indeterminateKeys: computed(() => {
      if (checkStrictly.value && halfCheckedKeys.value) {
        return halfCheckedKeys.value;
      }
      return computedIndeterminateKeys.value || localIndeterminateKeys.value;
    }),
    setCheckedState(newCheckedKeys, newIndeterminateKeys, reinitialize = false) {
      if (reinitialize) {
        init(newCheckedKeys);
      } else {
        localCheckedKeys.value = newCheckedKeys;
        localIndeterminateKeys.value = newIndeterminateKeys;
      }
      return [localCheckedKeys.value, localIndeterminateKeys.value];
    }
  };
}

// node_modules/@arco-design/web-vue/es/tree/hooks/use-tree-data.js
function useTreeData(props) {
  const {
    treeData: propTreeData,
    fieldNames,
    selectable,
    showLine,
    blockNode,
    checkable,
    loadMore,
    draggable
  } = toRefs(props);
  const treeData = ref([]);
  watchEffect(() => {
    var _a, _b;
    treeData.value = generateTreeData(propTreeData.value || [], {
      selectable: (_a = selectable == null ? void 0 : selectable.value) != null ? _a : false,
      showLine: !!(showLine == null ? void 0 : showLine.value),
      blockNode: !!(blockNode == null ? void 0 : blockNode.value),
      checkable: (_b = checkable == null ? void 0 : checkable.value) != null ? _b : false,
      fieldNames: fieldNames == null ? void 0 : fieldNames.value,
      loadMore: !!(loadMore == null ? void 0 : loadMore.value),
      draggable: !!(draggable == null ? void 0 : draggable.value)
    });
  });
  const flattenTreeData = computed(() => getFlattenTreeData(treeData.value));
  const key2TreeNode = computed(() => getKey2TreeNode(flattenTreeData.value));
  return { treeData, flattenTreeData, key2TreeNode };
}

// node_modules/@arco-design/web-vue/es/tree/tree.js
var _sfc_main180 = defineComponent({
  name: "Tree",
  components: {
    VirtualList,
    TreeNode
  },
  props: {
    size: {
      type: String,
      default: "medium"
    },
    blockNode: {
      type: Boolean
    },
    defaultExpandAll: {
      type: Boolean,
      default: true
    },
    multiple: {
      type: Boolean
    },
    checkable: {
      type: [Boolean, String, Function],
      default: false
    },
    selectable: {
      type: [Boolean, Function],
      default: true
    },
    checkStrictly: {
      type: Boolean
    },
    checkedStrategy: {
      type: String,
      default: "all"
    },
    defaultSelectedKeys: {
      type: Array
    },
    selectedKeys: {
      type: Array
    },
    defaultCheckedKeys: {
      type: Array
    },
    checkedKeys: {
      type: Array
    },
    defaultExpandedKeys: {
      type: Array
    },
    expandedKeys: {
      type: Array
    },
    data: {
      type: Array,
      default: () => []
    },
    fieldNames: {
      type: Object
    },
    showLine: {
      type: Boolean
    },
    loadMore: {
      type: Function
    },
    draggable: {
      type: Boolean
    },
    allowDrop: {
      type: Function
    },
    filterTreeNode: {
      type: Function
    },
    virtualListProps: {
      type: Object
    },
    defaultExpandSelected: {
      type: Boolean
    },
    defaultExpandChecked: {
      type: Boolean
    },
    autoExpandParent: {
      type: Boolean,
      default: true
    },
    halfCheckedKeys: {
      type: Array
    },
    onlyCheckLeaf: {
      type: Boolean,
      default: false
    },
    animation: {
      type: Boolean,
      default: true
    },
    actionOnNodeClick: {
      type: String
    },
    disableSelectActionOnly: {
      type: Boolean,
      default: false
    }
  },
  emits: {
    "select": (selectedKeys, data) => true,
    "update:selectedKeys": (selectedKeys) => true,
    "check": (checkedKeys, data) => true,
    "update:checkedKeys": (checkedKeys) => true,
    "update:halfCheckedKeys": (halfCheckedKeys) => true,
    "expand": (expandKeys, data) => true,
    "update:expandedKeys": (expandKeys) => true,
    "dragStart": (ev, node) => true,
    "dragEnd": (ev, node) => true,
    "dragOver": (ev, node) => true,
    "dragLeave": (ev, node) => true,
    "drop": (data) => true
  },
  setup(props, { emit, slots }) {
    const {
      data: propTreeData,
      showLine,
      multiple,
      loadMore,
      checkStrictly,
      checkedKeys: propCheckedKeys,
      defaultCheckedKeys,
      selectedKeys: propSelectedKeys,
      defaultSelectedKeys,
      expandedKeys: propExpandedKeys,
      defaultExpandedKeys,
      checkedStrategy,
      selectable,
      checkable,
      blockNode,
      fieldNames,
      size,
      defaultExpandAll,
      filterTreeNode,
      draggable,
      allowDrop,
      defaultExpandSelected,
      defaultExpandChecked,
      autoExpandParent,
      halfCheckedKeys,
      onlyCheckLeaf,
      animation
    } = toRefs(props);
    const prefixCls = getPrefixCls("tree");
    const classNames = computed(() => [
      `${prefixCls}`,
      {
        [`${prefixCls}-checkable`]: checkable.value,
        [`${prefixCls}-show-line`]: showLine.value
      },
      `${prefixCls}-size-${size.value}`
    ]);
    const switcherIcon = usePickSlots(slots, "switcher-icon");
    const loadingIcon = usePickSlots(slots, "loading-icon");
    const dragIcon = usePickSlots(slots, "drag-icon");
    const nodeIcon = usePickSlots(slots, "icon");
    const nodeTitle = usePickSlots(slots, "title");
    const nodeExtra = usePickSlots(slots, "extra");
    const { treeData, flattenTreeData, key2TreeNode } = useTreeData(reactive({
      treeData: propTreeData,
      selectable,
      showLine,
      blockNode,
      checkable,
      fieldNames,
      loadMore,
      draggable
    }));
    const { checkedKeys, indeterminateKeys, setCheckedState } = useCheckedState(reactive({
      defaultCheckedKeys,
      checkedKeys: propCheckedKeys,
      checkStrictly,
      key2TreeNode,
      halfCheckedKeys,
      onlyCheckLeaf
    }));
    const [selectedKeys, setSelectedState] = useMergeState((defaultSelectedKeys == null ? void 0 : defaultSelectedKeys.value) || [], reactive({
      value: propSelectedKeys
    }));
    const loadingKeys = ref([]);
    const dragNode = ref();
    function getDefaultExpandedKeys() {
      if (defaultExpandedKeys == null ? void 0 : defaultExpandedKeys.value) {
        const expandedKeysSet = /* @__PURE__ */ new Set([]);
        defaultExpandedKeys.value.forEach((_key) => {
          if (expandedKeysSet.has(_key))
            return;
          const node = key2TreeNode.value.get(_key);
          if (!node)
            return;
          [
            ...autoExpandParent.value ? node.pathParentKeys : [],
            _key
          ].forEach((_key2) => expandedKeysSet.add(_key2));
        });
        return [...expandedKeysSet];
      }
      if (defaultExpandAll.value) {
        return flattenTreeData.value.filter((node) => node.children && node.children.length).map((node) => node.key);
      }
      if (defaultExpandSelected.value || defaultExpandChecked.value) {
        const expandedKeysSet = /* @__PURE__ */ new Set([]);
        const addToExpandKeysSet = (keys) => {
          keys.forEach((key) => {
            const node = key2TreeNode.value.get(key);
            if (!node)
              return;
            (node.pathParentKeys || []).forEach((k) => expandedKeysSet.add(k));
          });
        };
        if (defaultExpandSelected.value) {
          addToExpandKeysSet(selectedKeys.value);
        }
        if (defaultExpandChecked.value) {
          addToExpandKeysSet(checkedKeys.value);
        }
        return [...expandedKeysSet];
      }
      return [];
    }
    const [expandedKeys, setExpandState] = useMergeState(getDefaultExpandedKeys(), reactive({
      value: propExpandedKeys
    }));
    const currentExpandKeys = ref([]);
    const visibleTreeNodeList = computed(() => {
      const expandedKeysSet = new Set(expandedKeys.value);
      const currentExpandKeysSet = new Set(currentExpandKeys.value);
      return flattenTreeData.value.filter((node) => {
        var _a;
        const passFilter = !filterTreeNode || !filterTreeNode.value || (filterTreeNode == null ? void 0 : filterTreeNode.value(node.treeNodeData));
        if (!passFilter)
          return false;
        const isRoot = isUndefined(node.parentKey);
        const isVisibleNode = (_a = node.pathParentKeys) == null ? void 0 : _a.every((_key) => expandedKeysSet.has(_key) && !currentExpandKeysSet.has(_key));
        return isRoot || isVisibleNode;
      });
    });
    function getPublicCheckedKeys(rawCheckedKeys, rawCheckedStrategy = checkedStrategy.value) {
      let publicCheckedKeys = [...rawCheckedKeys];
      if (rawCheckedStrategy === "parent") {
        publicCheckedKeys = rawCheckedKeys.filter((_key) => {
          const item = key2TreeNode.value.get(_key);
          return item && !(!isUndefined(item.parentKey) && rawCheckedKeys.includes(item.parentKey));
        });
      } else if (rawCheckedStrategy === "child") {
        publicCheckedKeys = rawCheckedKeys.filter((_key) => {
          var _a, _b;
          return !((_b = (_a = key2TreeNode.value.get(_key)) == null ? void 0 : _a.children) == null ? void 0 : _b.length);
        });
      }
      return publicCheckedKeys;
    }
    function getNodes(keys) {
      return keys.map((key) => {
        var _a;
        return ((_a = key2TreeNode.value.get(key)) == null ? void 0 : _a.treeNodeData) || void 0;
      }).filter(Boolean);
    }
    function emitCheckEvent(options) {
      const {
        targetKey,
        targetChecked,
        newCheckedKeys,
        newIndeterminateKeys,
        event
      } = options;
      const targetNode = targetKey ? key2TreeNode.value.get(targetKey) : void 0;
      const publicCheckedKeys = getPublicCheckedKeys(newCheckedKeys);
      emit("check", publicCheckedKeys, {
        checked: targetChecked,
        node: targetNode == null ? void 0 : targetNode.treeNodeData,
        checkedNodes: getNodes(publicCheckedKeys),
        halfCheckedKeys: newIndeterminateKeys,
        halfCheckedNodes: getNodes(newIndeterminateKeys),
        e: event
      });
      emit("update:checkedKeys", publicCheckedKeys);
      emit("update:halfCheckedKeys", newIndeterminateKeys);
    }
    function emitSelectEvent(options) {
      const { targetKey, targetSelected, newSelectedKeys, event } = options;
      const targetNode = targetKey ? key2TreeNode.value.get(targetKey) : void 0;
      emit("select", newSelectedKeys, {
        selected: targetSelected,
        node: targetNode == null ? void 0 : targetNode.treeNodeData,
        selectedNodes: getNodes(newSelectedKeys),
        e: event
      });
      emit("update:selectedKeys", newSelectedKeys);
    }
    function emitExpandEvent(options) {
      const { targetKey, targetExpanded, newExpandedKeys, event } = options;
      const targetNode = targetKey ? key2TreeNode.value.get(targetKey) : void 0;
      emit("expand", newExpandedKeys, {
        expanded: targetExpanded,
        node: targetNode == null ? void 0 : targetNode.treeNodeData,
        expandedNodes: getNodes(newExpandedKeys),
        e: event
      });
      emit("update:expandedKeys", newExpandedKeys);
    }
    function setCheckedKeys(keys) {
      const [newCheckedKeys, newIndeterminateKeys] = setCheckedState(keys, [], true);
      emitCheckEvent({ newCheckedKeys, newIndeterminateKeys });
    }
    function setSelectedKeys(keys) {
      let newSelectedKeys = keys;
      if (!multiple.value && keys.length > 1) {
        newSelectedKeys = [keys[0]];
      }
      setSelectedState(newSelectedKeys);
      emitSelectEvent({
        newSelectedKeys
      });
    }
    function setExpandedKeys(keys) {
      currentExpandKeys.value = [];
      setExpandState(keys);
      emitExpandEvent({ newExpandedKeys: keys });
    }
    function checkNodes(keys, checked, targetKey) {
      if (!keys.length)
        return;
      let newCheckedKeys = [...checkedKeys.value];
      let newIndeterminateKeys = [...indeterminateKeys.value];
      keys.forEach((key) => {
        const node = key2TreeNode.value.get(key);
        if (node) {
          [newCheckedKeys, newIndeterminateKeys] = getCheckedStateByCheck({
            node,
            checked,
            checkedKeys: [...newCheckedKeys],
            indeterminateKeys: [...newIndeterminateKeys],
            checkStrictly: checkStrictly.value
          });
        }
      });
      setCheckedState(newCheckedKeys, newIndeterminateKeys);
      emitCheckEvent({
        targetKey,
        targetChecked: isUndefined(targetKey) ? void 0 : checked,
        newCheckedKeys,
        newIndeterminateKeys
      });
    }
    function selectNodes(keys, selected, targetKey) {
      if (!keys.length)
        return;
      let newSelectedKeys;
      if (multiple.value) {
        const selectedKeysSet = new Set(selectedKeys.value);
        keys.forEach((key) => {
          selected ? selectedKeysSet.add(key) : selectedKeysSet.delete(key);
        });
        newSelectedKeys = [...selectedKeysSet];
      } else {
        newSelectedKeys = selected ? [keys[0]] : [];
      }
      setSelectedState(newSelectedKeys);
      emitSelectEvent({
        targetKey,
        targetSelected: isUndefined(targetKey) ? void 0 : selected,
        newSelectedKeys
      });
    }
    function expandNodes(keys, expanded, targetKey) {
      const expandedKeysSet = new Set(expandedKeys.value);
      keys.forEach((key) => {
        expanded ? expandedKeysSet.add(key) : expandedKeysSet.delete(key);
        onExpandEnd(key);
      });
      const newExpandedKeys = [...expandedKeysSet];
      setExpandState(newExpandedKeys);
      emitExpandEvent({
        targetKey,
        targetExpanded: isUndefined(targetKey) ? void 0 : expanded,
        newExpandedKeys
      });
    }
    function onCheck(checked, key, e2) {
      const node = key2TreeNode.value.get(key);
      if (!node)
        return;
      const [newCheckedKeys, newIndeterminateKeys] = getCheckedStateByCheck({
        node,
        checked,
        checkedKeys: checkedKeys.value,
        indeterminateKeys: indeterminateKeys.value,
        checkStrictly: checkStrictly.value
      });
      setCheckedState(newCheckedKeys, newIndeterminateKeys);
      emitCheckEvent({
        targetKey: key,
        targetChecked: checked,
        newCheckedKeys,
        newIndeterminateKeys,
        event: e2
      });
    }
    function onSelect(key, e2) {
      const node = key2TreeNode.value.get(key);
      if (!node)
        return;
      let newSelectedKeys;
      let selected;
      if (multiple.value) {
        const selectedKeysSet = new Set(selectedKeys.value);
        selected = !selectedKeysSet.has(key);
        selected ? selectedKeysSet.add(key) : selectedKeysSet.delete(key);
        newSelectedKeys = [...selectedKeysSet];
      } else {
        selected = true;
        newSelectedKeys = [key];
      }
      setSelectedState(newSelectedKeys);
      emitSelectEvent({
        targetKey: key,
        targetSelected: selected,
        newSelectedKeys,
        event: e2
      });
    }
    function onExpand(expanded, key, e2) {
      if (currentExpandKeys.value.includes(key))
        return;
      const node = key2TreeNode.value.get(key);
      if (!node)
        return;
      const expandedKeysSet = new Set(expandedKeys.value);
      expanded ? expandedKeysSet.add(key) : expandedKeysSet.delete(key);
      const newExpandedKeys = [...expandedKeysSet];
      setExpandState(newExpandedKeys);
      if (animation.value) {
        currentExpandKeys.value.push(key);
      }
      emitExpandEvent({
        targetKey: key,
        targetExpanded: expanded,
        newExpandedKeys,
        event: e2
      });
    }
    function onExpandEnd(key) {
      const index3 = currentExpandKeys.value.indexOf(key);
      currentExpandKeys.value.splice(index3, 1);
    }
    const onLoadMore = computed(() => (loadMore == null ? void 0 : loadMore.value) ? async (key) => {
      if (!isFunction(loadMore.value))
        return;
      const node = key2TreeNode.value.get(key);
      if (!node)
        return;
      const { treeNodeData } = node;
      loadingKeys.value = [.../* @__PURE__ */ new Set([...loadingKeys.value, key])];
      try {
        await loadMore.value(treeNodeData);
        loadingKeys.value = loadingKeys.value.filter((v) => v !== key);
        onExpand(true, key);
        if (checkedKeys.value.includes(key)) {
          onCheck(true, key);
        }
      } catch (err) {
        loadingKeys.value = loadingKeys.value.filter((v) => v !== key);
        console.error("[tree]load data error: ", err);
      }
    } : void 0);
    const treeContext = reactive({
      treeProps: props,
      switcherIcon,
      loadingIcon,
      dragIcon,
      nodeIcon,
      nodeTitle,
      nodeExtra,
      treeData,
      flattenTreeData,
      key2TreeNode,
      checkedKeys,
      indeterminateKeys,
      selectedKeys,
      expandedKeys,
      loadingKeys,
      currentExpandKeys,
      onLoadMore,
      filterTreeNode,
      onCheck,
      onSelect,
      onExpand,
      onExpandEnd,
      allowDrop(key, dropPosition) {
        const node = key2TreeNode.value.get(key);
        if (node && isFunction(allowDrop.value)) {
          return !!allowDrop.value({
            dropNode: node.treeNodeData,
            dropPosition
          });
        }
        return true;
      },
      onDragStart(key, e2) {
        const node = key2TreeNode.value.get(key);
        dragNode.value = node;
        if (node) {
          emit("dragStart", e2, node.treeNodeData);
        }
      },
      onDragEnd(key, e2) {
        const node = key2TreeNode.value.get(key);
        dragNode.value = void 0;
        if (node) {
          emit("dragEnd", e2, node.treeNodeData);
        }
      },
      onDragOver(key, e2) {
        const node = key2TreeNode.value.get(key);
        if (node) {
          emit("dragOver", e2, node.treeNodeData);
        }
      },
      onDragLeave(key, e2) {
        const node = key2TreeNode.value.get(key);
        if (node) {
          emit("dragLeave", e2, node.treeNodeData);
        }
      },
      onDrop(key, dropPosition, e2) {
        const node = key2TreeNode.value.get(key);
        if (dragNode.value && node && !(node.key === dragNode.value.key || node.pathParentKeys.includes(dragNode.value.key || ""))) {
          emit("drop", {
            e: e2,
            dragNode: dragNode.value.treeNodeData,
            dropNode: node.treeNodeData,
            dropPosition
          });
        }
      }
    });
    provide(TreeInjectionKey, treeContext);
    return {
      classNames,
      visibleTreeNodeList,
      treeContext,
      virtualListRef: ref(),
      computedSelectedKeys: selectedKeys,
      computedExpandedKeys: expandedKeys,
      computedCheckedKeys: checkedKeys,
      computedIndeterminateKeys: indeterminateKeys,
      getPublicCheckedKeys,
      getNodes,
      internalCheckNodes: checkNodes,
      internalSetCheckedKeys: setCheckedKeys,
      internalSelectNodes: selectNodes,
      internalSetSelectedKeys: setSelectedKeys,
      internalExpandNodes: expandNodes,
      internalSetExpandedKeys: setExpandedKeys
    };
  },
  methods: {
    toggleCheck(key, e2) {
      const { key2TreeNode, onCheck, checkedKeys } = this.treeContext;
      const checked = !checkedKeys.includes(key);
      const node = key2TreeNode.get(key);
      if (node && isNodeCheckable(node)) {
        onCheck(checked, key, e2);
      }
    },
    scrollIntoView(options) {
      this.virtualListRef && this.virtualListRef.scrollTo(options);
    },
    getSelectedNodes() {
      return this.getNodes(this.computedSelectedKeys);
    },
    getCheckedNodes(options = {}) {
      const { checkedStrategy, includeHalfChecked } = options;
      const checkedKeys = this.getPublicCheckedKeys(this.computedCheckedKeys, checkedStrategy);
      const checkedNodes = this.getNodes(checkedKeys);
      return [
        ...checkedNodes,
        ...includeHalfChecked ? this.getHalfCheckedNodes() : []
      ];
    },
    getHalfCheckedNodes() {
      return this.getNodes(this.computedIndeterminateKeys);
    },
    getExpandedNodes() {
      return this.getNodes(this.computedExpandedKeys);
    },
    checkAll(checked = true) {
      const { key2TreeNode } = this.treeContext;
      const newKeys = checked ? [...key2TreeNode.keys()].filter((key) => {
        const node = key2TreeNode.get(key);
        return node && isNodeCheckable(node);
      }) : [];
      this.internalSetCheckedKeys(newKeys);
    },
    checkNode(key, checked = true, onlyCheckLeaf = false) {
      const { checkStrictly, treeContext } = this;
      const { key2TreeNode } = treeContext;
      const isBatch = isArray(key);
      const keys = (isBatch ? key : [key]).filter((key2) => {
        const node = key2TreeNode.get(key2);
        return node && isNodeCheckable(node) && (checkStrictly || !onlyCheckLeaf || isLeafNode(node));
      });
      this.internalCheckNodes(keys, checked, isBatch ? void 0 : key);
    },
    selectAll(selected = true) {
      const { key2TreeNode } = this.treeContext;
      const newKeys = selected ? [...key2TreeNode.keys()].filter((key) => {
        const node = key2TreeNode.get(key);
        return node && isNodeSelectable(node);
      }) : [];
      this.internalSetSelectedKeys(newKeys);
    },
    selectNode(key, selected = true) {
      const { key2TreeNode } = this.treeContext;
      const isBatch = isArray(key);
      const keys = (isBatch ? key : [key]).filter((key2) => {
        const node = key2TreeNode.get(key2);
        return node && isNodeSelectable(node);
      });
      this.internalSelectNodes(keys, selected, isBatch ? void 0 : key);
    },
    expandAll(expanded = true) {
      const { key2TreeNode } = this.treeContext;
      const newKeys = expanded ? [...key2TreeNode.keys()].filter((key) => {
        const node = key2TreeNode.get(key);
        return node && isNodeExpandable(node);
      }) : [];
      this.internalSetExpandedKeys(newKeys);
    },
    expandNode(key, expanded = true) {
      const { key2TreeNode } = this.treeContext;
      const isBatch = isArray(key);
      const keys = (isBatch ? key : [key]).filter((key2) => {
        const node = key2TreeNode.get(key2);
        return node && isNodeExpandable(node);
      });
      this.internalExpandNodes(keys, expanded, isBatch ? void 0 : key);
    }
  }
});
function _sfc_render179(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_TreeNode = resolveComponent("TreeNode");
  const _component_VirtualList = resolveComponent("VirtualList");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.classNames)
  }, [
    _ctx.virtualListProps ? (openBlock(), createBlock(_component_VirtualList, mergeProps({
      key: 0,
      ref: "virtualListRef"
    }, _ctx.virtualListProps, { data: _ctx.visibleTreeNodeList }), {
      item: withCtx(({ item: node }) => [
        createVNode(_component_TreeNode, mergeProps({
          key: node.key
        }, node.treeNodeProps), null, 16)
      ]),
      _: 1
    }, 16, ["data"])) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(_ctx.visibleTreeNodeList, (node) => {
      return openBlock(), createBlock(_component_TreeNode, mergeProps({
        key: node.key
      }, node.treeNodeProps), null, 16);
    }), 128))
  ], 2);
}
var _Tree = _export_sfc(_sfc_main180, [["render", _sfc_render179]]);

// node_modules/@arco-design/web-vue/es/tree/index.js
var Tree = Object.assign(_Tree, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Tree.name, _Tree);
  }
});

// node_modules/@arco-design/web-vue/es/typography/typography.js
var _sfc_main181 = defineComponent({
  name: "Typography",
  setup() {
    const prefixCls = getPrefixCls("typography");
    return {
      classNames: [prefixCls]
    };
  }
});
function _sfc_render180(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("article", {
    class: normalizeClass(_ctx.classNames)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
var _Typography = _export_sfc(_sfc_main181, [["render", _sfc_render180]]);

// node_modules/@arco-design/web-vue/es/typography/edit-content.js
var _sfc_main182 = defineComponent({
  name: "TypographyEditContent",
  components: {
    Input
  },
  props: {
    text: {
      type: String,
      required: true
    }
  },
  emits: ["change", "end", "update:text"],
  setup(_, { emit }) {
    const prefixCls = getPrefixCls("typography");
    const classNames = [`${prefixCls}-edit-content`];
    const inputRef = ref();
    function onChange(value) {
      emit("update:text", value);
      emit("change", value);
    }
    function onEnd() {
      emit("end");
    }
    onMounted(() => {
      if (!inputRef.value || !inputRef.value.$el)
        return;
      const inputEl = inputRef.value.$el.querySelector("input");
      if (!inputEl)
        return;
      inputEl.focus && inputEl.focus();
      const { length } = inputEl.value;
      inputEl.setSelectionRange(length, length);
    });
    return {
      classNames,
      inputRef,
      onBlur: onEnd,
      onChange,
      onEnd
    };
  }
});
function _sfc_render181(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Input = resolveComponent("Input");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.classNames)
  }, [
    createVNode(_component_Input, {
      ref: "inputRef",
      "auto-size": "",
      "model-value": _ctx.text,
      onBlur: _ctx.onBlur,
      onInput: _ctx.onChange,
      onKeydown: withKeys(_ctx.onEnd, ["enter"])
    }, null, 8, ["model-value", "onBlur", "onInput", "onKeydown"])
  ], 2);
}
var EditContent = _export_sfc(_sfc_main182, [["render", _sfc_render181]]);

// node_modules/@arco-design/web-vue/es/icon/icon-copy/icon-copy.js
var _sfc_main183 = defineComponent({
  name: "IconCopy",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-copy`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_177 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_258 = createBaseVNode("path", { d: "M20 6h18a2 2 0 0 1 2 2v22M8 16v24c0 1.105.891 2 1.996 2h20.007A1.99 1.99 0 0 0 32 40.008V15.997A1.997 1.997 0 0 0 30 14H10a2 2 0 0 0-2 2Z" }, null, -1);
var _hoisted_354 = [
  _hoisted_258
];
function _sfc_render182(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_354, 14, _hoisted_177);
}
var _IconCopy = _export_sfc(_sfc_main183, [["render", _sfc_render182]]);

// node_modules/@arco-design/web-vue/es/icon/icon-copy/index.js
var IconCopy = Object.assign(_IconCopy, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconCopy.name, _IconCopy);
  }
});

// node_modules/@arco-design/web-vue/es/icon/icon-edit/icon-edit.js
var _sfc_main184 = defineComponent({
  name: "IconEdit",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-edit`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_178 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_259 = createBaseVNode("path", { d: "m30.48 19.038 5.733-5.734a1 1 0 0 0 0-1.414l-5.586-5.586a1 1 0 0 0-1.414 0l-5.734 5.734m7 7L15.763 33.754a1 1 0 0 1-.59.286l-6.048.708a1 1 0 0 1-1.113-1.069l.477-6.31a1 1 0 0 1 .29-.631l14.7-14.7m7 7-7-7M6 42h36" }, null, -1);
var _hoisted_355 = [
  _hoisted_259
];
function _sfc_render183(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_355, 14, _hoisted_178);
}
var _IconEdit = _export_sfc(_sfc_main184, [["render", _sfc_render183]]);

// node_modules/@arco-design/web-vue/es/icon/icon-edit/index.js
var IconEdit = Object.assign(_IconEdit, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconEdit.name, _IconEdit);
  }
});

// node_modules/@arco-design/web-vue/es/typography/operations.js
var _sfc_main185 = defineComponent({
  name: "TypographyOperations",
  components: {
    Tooltip,
    IconCheckCircleFill,
    IconCopy,
    IconEdit
  },
  props: {
    editable: Boolean,
    copyable: Boolean,
    expandable: Boolean,
    isCopied: Boolean,
    isEllipsis: Boolean,
    expanded: Boolean,
    forceRenderExpand: Boolean,
    editTooltipProps: Object,
    copyTooltipProps: Object
  },
  emits: {
    edit: () => true,
    copy: () => true,
    expand: () => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("typography");
    const showExpand = computed(() => props.forceRenderExpand || props.expandable && props.isEllipsis);
    const { t: t2 } = useI18n();
    return {
      prefixCls,
      showExpand,
      t: t2,
      onEditClick() {
        emit("edit");
      },
      onCopyClick() {
        emit("copy");
      },
      onExpandClick() {
        emit("expand");
      }
    };
  }
});
function _sfc_render184(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_IconEdit = resolveComponent("IconEdit");
  const _component_Tooltip = resolveComponent("Tooltip");
  const _component_IconCheckCircleFill = resolveComponent("IconCheckCircleFill");
  const _component_IconCopy = resolveComponent("IconCopy");
  return openBlock(), createElementBlock(Fragment, null, [
    _ctx.editable ? (openBlock(), createBlock(_component_Tooltip, mergeProps({
      key: 0,
      content: _ctx.t("typography.edit")
    }, _ctx.editTooltipProps), {
      default: withCtx(() => [
        createBaseVNode("span", {
          class: normalizeClass(`${_ctx.prefixCls}-operation-edit`),
          onClick: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.onEditClick && _ctx.onEditClick(...args), ["stop"]))
        }, [
          createVNode(_component_IconEdit)
        ], 2)
      ]),
      _: 1
    }, 16, ["content"])) : createCommentVNode("v-if", true),
    _ctx.copyable ? (openBlock(), createBlock(_component_Tooltip, normalizeProps(mergeProps({ key: 1 }, _ctx.copyTooltipProps)), {
      content: withCtx(() => [
        renderSlot(_ctx.$slots, "copy-tooltip", { copied: _ctx.isCopied }, () => [
          createTextVNode(toDisplayString(_ctx.isCopied ? _ctx.t("typography.copied") : _ctx.t("typography.copy")), 1)
        ])
      ]),
      default: withCtx(() => [
        createBaseVNode("span", {
          class: normalizeClass({
            [`${_ctx.prefixCls}-operation-copied`]: _ctx.isCopied,
            [`${_ctx.prefixCls}-operation-copy`]: !_ctx.isCopied
          }),
          onClick: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.onCopyClick && _ctx.onCopyClick(...args), ["stop"]))
        }, [
          renderSlot(_ctx.$slots, "copy-icon", { copied: _ctx.isCopied }, () => [
            _ctx.isCopied ? (openBlock(), createBlock(_component_IconCheckCircleFill, { key: 0 })) : (openBlock(), createBlock(_component_IconCopy, { key: 1 }))
          ])
        ], 2)
      ]),
      _: 3
    }, 16)) : createCommentVNode("v-if", true),
    _ctx.showExpand ? (openBlock(), createElementBlock("a", {
      key: 2,
      class: normalizeClass(`${_ctx.prefixCls}-operation-expand`),
      onClick: _cache[2] || (_cache[2] = withModifiers((...args) => _ctx.onExpandClick && _ctx.onExpandClick(...args), ["stop"]))
    }, [
      renderSlot(_ctx.$slots, "expand-node", { expanded: _ctx.expanded }, () => [
        createTextVNode(toDisplayString(_ctx.expanded ? _ctx.t("typography.collapse") : _ctx.t("typography.expand")), 1)
      ])
    ], 2)) : createCommentVNode("v-if", true)
  ], 64);
}
var Operations = _export_sfc(_sfc_main185, [["render", _sfc_render184]]);

// node_modules/@arco-design/web-vue/es/typography/utils/measure.js
var ellipsisContainer;
function styleToString(style) {
  const styleNames = Array.prototype.slice.apply(style);
  return styleNames.map((name) => `${name}: ${style.getPropertyValue(name)};`).join("");
}
function pxToNumber(value) {
  if (!value)
    return 0;
  const match = value.match(/^\d*(\.\d*)?/);
  return match ? Number(match[0]) : 0;
}
var measure = (originElement, ellipsisConfig, operations, fullText) => {
  if (!ellipsisContainer) {
    ellipsisContainer = document.createElement("div");
    document.body.appendChild(ellipsisContainer);
  }
  const {
    rows,
    suffix,
    ellipsisStr
  } = ellipsisConfig;
  const originStyle = window.getComputedStyle(originElement);
  const styleString = styleToString(originStyle);
  const lineHeight = pxToNumber(originStyle.lineHeight);
  const maxHeight = Math.round(lineHeight * rows + pxToNumber(originStyle.paddingTop) + pxToNumber(originStyle.paddingBottom));
  ellipsisContainer.setAttribute("style", styleString);
  ellipsisContainer.setAttribute("aria-hidden", "true");
  ellipsisContainer.style.height = "auto";
  ellipsisContainer.style.minHeight = "auto";
  ellipsisContainer.style.maxHeight = "auto";
  ellipsisContainer.style.position = "fixed";
  ellipsisContainer.style.left = "0";
  ellipsisContainer.style.top = "-99999999px";
  ellipsisContainer.style.zIndex = "-200";
  ellipsisContainer.style.whiteSpace = "normal";
  const vm = createApp({
    render() {
      return createVNode("span", null, [operations]);
    }
  });
  vm.mount(ellipsisContainer);
  const operationsChildNodes = Array.prototype.slice.apply(ellipsisContainer.childNodes[0].cloneNode(true).childNodes);
  vm.unmount();
  ellipsisContainer.innerHTML = "";
  const ellipsisTextNode = document.createTextNode(`${ellipsisStr}${suffix}`);
  ellipsisContainer.appendChild(ellipsisTextNode);
  operationsChildNodes.forEach((operationNode) => {
    ellipsisContainer.appendChild(operationNode);
  });
  const textNode = document.createTextNode(fullText);
  ellipsisContainer.insertBefore(textNode, ellipsisTextNode);
  function inRange() {
    return ellipsisContainer.offsetHeight <= maxHeight;
  }
  if (inRange()) {
    return {
      ellipsis: false,
      text: fullText
    };
  }
  function measureText(textNode2, startLoc = 0, endLoc = fullText.length, lastSuccessLoc = 0) {
    const midLoc = Math.floor((startLoc + endLoc) / 2);
    const currentText = fullText.slice(0, midLoc);
    textNode2.textContent = currentText;
    if (startLoc >= endLoc - 1) {
      for (let step = endLoc; step >= startLoc; step -= 1) {
        const currentStepText = fullText.slice(0, step);
        textNode2.textContent = currentStepText;
        if (inRange() || !currentStepText) {
          return;
        }
      }
    }
    if (inRange()) {
      measureText(textNode2, midLoc, endLoc, midLoc);
    } else {
      measureText(textNode2, startLoc, midLoc, lastSuccessLoc);
    }
  }
  measureText(textNode);
  return {
    text: textNode.textContent,
    ellipsis: true
  };
};

// node_modules/@arco-design/web-vue/es/_utils/clipboard.js
var clipboard = async (text) => {
  var _a;
  if ((_a = navigator.clipboard) == null ? void 0 : _a.writeText) {
    try {
      await navigator.clipboard.writeText(text);
      return;
    } catch (err) {
      console.error(err != null ? err : new DOMException("The request is not allowed", "NotAllowedError"));
    }
  }
  const span = document.createElement("span");
  span.textContent = text;
  span.style.whiteSpace = "pre";
  document.body.appendChild(span);
  const selection = window.getSelection();
  const range = window.document.createRange();
  selection == null ? void 0 : selection.removeAllRanges();
  range.selectNode(span);
  selection == null ? void 0 : selection.addRange(range);
  try {
    window.document.execCommand("copy");
  } catch (err) {
    console.error(`execCommand Error: ${err}`);
  }
  selection == null ? void 0 : selection.removeAllRanges();
  window.document.body.removeChild(span);
};

// node_modules/@arco-design/web-vue/es/typography/utils/getInnerText.js
var container;
function getInnerText(node) {
  if (!node)
    return "";
  if (!container) {
    container = document.createElement("div");
    container.setAttribute("aria-hidden", "true");
    document.body.appendChild(container);
  }
  const vm = createApp({
    render() {
      return createVNode("div", null, [node]);
    }
  });
  vm.mount(container);
  const text = container.innerText;
  vm.unmount();
  return text;
}

// node_modules/@arco-design/web-vue/es/typography/base.js
var __defProp59 = Object.defineProperty;
var __defProps27 = Object.defineProperties;
var __getOwnPropDescs27 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols59 = Object.getOwnPropertySymbols;
var __hasOwnProp59 = Object.prototype.hasOwnProperty;
var __propIsEnum59 = Object.prototype.propertyIsEnumerable;
var __defNormalProp59 = (obj, key, value) => key in obj ? __defProp59(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues59 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp59.call(b, prop))
      __defNormalProp59(a, prop, b[prop]);
  if (__getOwnPropSymbols59)
    for (var prop of __getOwnPropSymbols59(b)) {
      if (__propIsEnum59.call(b, prop))
        __defNormalProp59(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps27 = (a, b) => __defProps27(a, __getOwnPropDescs27(b));
function _isSlot15(s) {
  return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
function getComponentTags(props) {
  const {
    bold,
    mark,
    underline,
    delete: propDelete,
    code
  } = props;
  const componentTags = [];
  if (bold) {
    componentTags.push("b");
  }
  if (underline) {
    componentTags.push("u");
  }
  if (propDelete) {
    componentTags.push("del");
  }
  if (code) {
    componentTags.push("code");
  }
  if (mark) {
    componentTags.push("mark");
  }
  return componentTags;
}
function Wrap(props, children) {
  const {
    mark
  } = props;
  const componentTags = getComponentTags(props);
  const markStyle = isObject(mark) && mark.color ? {
    backgroundColor: mark.color
  } : {};
  return componentTags.reduce((content, Tag2) => {
    const attrs = Tag2 === "mark" ? {
      style: markStyle
    } : {};
    return createVNode(Tag2, attrs, _isSlot15(content) ? content : {
      default: () => [content]
    });
  }, children);
}
function normalizeEllipsisConfig(config) {
  const showTooltip = !!config.showTooltip;
  const TooltipComponent = isObject(config.showTooltip) && config.showTooltip.type === "popover" ? Popover : Tooltip;
  const tooltipProps = isObject(config.showTooltip) && config.showTooltip.props || {};
  return __spreadProps27(__spreadValues59({
    rows: 1,
    suffix: "",
    ellipsisStr: "...",
    expandable: false,
    css: false
  }, omit(config, ["showTooltip"])), {
    showTooltip,
    TooltipComponent,
    tooltipProps
  });
}
var Base3 = defineComponent({
  name: "TypographyBase",
  inheritAttrs: false,
  props: {
    component: {
      type: String,
      required: true
    },
    type: {
      type: String
    },
    bold: {
      type: Boolean
    },
    mark: {
      type: [Boolean, Object],
      default: false
    },
    underline: {
      type: Boolean
    },
    delete: {
      type: Boolean
    },
    code: {
      type: Boolean
    },
    disabled: {
      type: Boolean
    },
    editable: {
      type: Boolean
    },
    editing: {
      type: Boolean,
      default: void 0
    },
    defaultEditing: {
      type: Boolean
    },
    editText: {
      type: String
    },
    copyable: {
      type: Boolean
    },
    copyText: {
      type: String
    },
    copyDelay: {
      type: Number,
      default: 3e3
    },
    ellipsis: {
      type: [Boolean, Object],
      default: false
    },
    editTooltipProps: {
      type: Object
    },
    copyTooltipProps: {
      type: Object
    }
  },
  emits: {
    "editStart": () => true,
    "change": (text) => true,
    "update:editText": (text) => true,
    "editEnd": () => true,
    "update:editing": (editing) => true,
    "copy": (text) => true,
    "ellipsis": (isEllipsis) => true,
    "expand": (expanded) => true
  },
  setup(props, {
    slots,
    emit,
    attrs
  }) {
    const {
      editing: propEditing,
      defaultEditing,
      ellipsis,
      copyable,
      editable,
      copyText,
      editText,
      copyDelay,
      component
    } = toRefs(props);
    const prefixCls = getPrefixCls("typography");
    const classNames = computed(() => [prefixCls, {
      [`${prefixCls}-${props.type}`]: props.type,
      [`${prefixCls}-disabled`]: props.disabled
    }]);
    const wrapperRef = ref();
    const fullText = ref("");
    const [editing, setEditing] = useMergeState(defaultEditing.value, reactive({
      value: propEditing
    }));
    const mergeEditing = computed(() => editable.value && editing.value);
    function onEditStart() {
      emit("update:editing", true);
      emit("editStart");
      setEditing(true);
    }
    function onEditChange(text) {
      emit("update:editText", text);
      emit("change", text);
    }
    function onEditEnd() {
      if (!editing.value)
        return;
      emit("update:editing", false);
      emit("editEnd");
      setEditing(false);
    }
    const isCopied = ref(false);
    let copyTimer = null;
    function onCopyClick() {
      var _a;
      const text = (_a = copyText.value) != null ? _a : fullText.value;
      clipboard(text || "");
      isCopied.value = true;
      emit("copy", text);
      copyTimer = setTimeout(() => {
        isCopied.value = false;
      }, copyDelay.value);
    }
    onUnmounted(() => {
      copyTimer && clearTimeout(copyTimer);
      copyTimer = null;
    });
    const isEllipsis = ref(false);
    const expanded = ref(false);
    const ellipsisText = ref("");
    const ellipsisConfig = computed(() => normalizeEllipsisConfig(isObject(ellipsis.value) && ellipsis.value || {}));
    let rafId = null;
    function onExpandClick() {
      const newVal = !expanded.value;
      expanded.value = newVal;
      emit("expand", newVal);
    }
    function renderOperations(forceRenderExpand = false) {
      if (ellipsisConfig.value.css) {
        return createVNode(Operations, {
          "editable": editable.value,
          "copyable": copyable.value,
          "expandable": ellipsisConfig.value.expandable,
          "isCopied": isCopied.value,
          "isEllipsis": showCSSTooltip.value,
          "expanded": expanded.value,
          "forceRenderExpand": forceRenderExpand || expanded.value,
          "editTooltipProps": props.editTooltipProps,
          "copyTooltipProps": props.copyTooltipProps,
          "onEdit": onEditStart,
          "onCopy": onCopyClick,
          "onExpand": onExpandClick
        }, {
          "copy-tooltip": slots["copy-tooltip"],
          "copy-icon": slots["copy-icon"],
          "expand-node": slots["expand-node"]
        });
      }
      return createVNode(Operations, {
        "editable": editable.value,
        "copyable": copyable.value,
        "expandable": ellipsisConfig.value.expandable,
        "isCopied": isCopied.value,
        "isEllipsis": isEllipsis.value,
        "expanded": expanded.value,
        "forceRenderExpand": forceRenderExpand,
        "editTooltipProps": props.editTooltipProps,
        "copyTooltipProps": props.copyTooltipProps,
        "onEdit": onEditStart,
        "onCopy": onCopyClick,
        "onExpand": onExpandClick
      }, {
        "copy-tooltip": slots["copy-tooltip"],
        "copy-icon": slots["copy-icon"],
        "expand-node": slots["expand-node"]
      });
    }
    function calEllipsis() {
      if (!wrapperRef.value)
        return;
      const {
        ellipsis: ellipsis2,
        text
      } = measure(wrapperRef.value, ellipsisConfig.value, renderOperations(!!ellipsisConfig.value.expandable), fullText.value);
      if (isEllipsis.value !== ellipsis2) {
        isEllipsis.value = ellipsis2;
        if (!ellipsisConfig.value.css) {
          emit("ellipsis", ellipsis2);
        }
      }
      if (ellipsisText.value !== text) {
        ellipsisText.value = text || "";
      }
    }
    function resizeOnNextFrame() {
      const needCalEllipsis = ellipsis.value && !expanded.value;
      if (!needCalEllipsis)
        return;
      caf(rafId);
      rafId = raf(() => {
        calEllipsis();
      });
    }
    onUnmounted(() => {
      caf(rafId);
    });
    watch(() => ellipsisConfig.value.rows, () => {
      resizeOnNextFrame();
    });
    watch(ellipsis, (newVal) => {
      if (newVal) {
        resizeOnNextFrame();
      } else {
        isEllipsis.value = false;
      }
    });
    let children = [];
    const updateFullText = () => {
      if (ellipsis.value || copyable.value || editable.value) {
        const _fullText = getInnerText(children);
        if (_fullText !== fullText.value) {
          fullText.value = _fullText;
          resizeOnNextFrame();
        }
      }
    };
    onMounted(updateFullText);
    onUpdated(updateFullText);
    const contentRef = ref();
    const showCSSTooltip = ref(false);
    const calTooltip = () => {
      if (wrapperRef.value && contentRef.value) {
        const _show = contentRef.value.offsetHeight > wrapperRef.value.offsetHeight;
        if (_show !== showCSSTooltip.value) {
          showCSSTooltip.value = _show;
          emit("ellipsis", _show);
        }
      }
    };
    const ellipsisStyle = computed(() => {
      if (expanded.value) {
        return {};
      }
      return {
        "overflow": "hidden",
        "text-overflow": "ellipsis",
        "display": "-webkit-box",
        "-webkit-line-clamp": ellipsisConfig.value.rows,
        "-webkit-box-orient": "vertical"
      };
    });
    return () => {
      var _a, _b;
      children = ((_a = slots.default) == null ? void 0 : _a.call(slots)) || [];
      if (mergeEditing.value) {
        const _editText = (_b = editText.value) != null ? _b : fullText.value;
        return createVNode(EditContent, {
          "text": _editText,
          "onChange": (text) => {
            if (text !== _editText) {
              onEditChange(text);
            }
          },
          "onEnd": onEditEnd
        }, null);
      }
      const {
        suffix,
        ellipsisStr,
        showTooltip,
        tooltipProps,
        TooltipComponent
      } = ellipsisConfig.value;
      const showEllipsis = isEllipsis.value && !expanded.value;
      const titleAttrs = showEllipsis && !showTooltip ? {
        title: fullText.value
      } : {};
      const Component = component.value;
      if (ellipsisConfig.value.css) {
        const Content2 = Wrap(props, children);
        const Outer = createVNode(Component, mergeProps({
          "class": classNames.value,
          "ref": wrapperRef,
          "style": ellipsisStyle.value
        }, titleAttrs, attrs), {
          default: () => [createVNode("span", {
            "ref": contentRef
          }, [Content2])]
        });
        if (showCSSTooltip.value) {
          return createVNode(TooltipComponent, mergeProps(tooltipProps, {
            "onResize": () => calTooltip()
          }), {
            default: () => [Outer],
            content: () => fullText.value
          });
        }
        return createVNode(ResizeObserver2, {
          "onResize": () => {
            calTooltip();
          }
        }, _isSlot15(Outer) ? Outer : {
          default: () => [Outer]
        });
      }
      const Content = Wrap(props, showEllipsis ? ellipsisText.value : children);
      return createVNode(ResizeObserver2, {
        "onResize": () => resizeOnNextFrame()
      }, {
        default: () => [createVNode(Component, mergeProps({
          "class": classNames.value,
          "ref": wrapperRef
        }, titleAttrs, attrs), {
          default: () => [showEllipsis && showTooltip ? createVNode(TooltipComponent, tooltipProps, {
            default: () => [createVNode("span", null, [Content])],
            content: () => fullText.value
          }) : Content, showEllipsis ? ellipsisStr : null, suffix, renderOperations()]
        })]
      });
    };
  }
});

// node_modules/@arco-design/web-vue/es/typography/paragraph.js
var TypographyParagraph = defineComponent({
  name: "TypographyParagraph",
  inheritAttrs: false,
  props: {
    blockquote: {
      type: Boolean
    },
    spacing: {
      type: String,
      default: "default"
    }
  },
  setup(props) {
    const {
      blockquote,
      spacing
    } = toRefs(props);
    const prefixCls = getPrefixCls("typography");
    const component = computed(() => (blockquote == null ? void 0 : blockquote.value) ? "blockquote" : "div");
    const classNames = computed(() => [{
      [`${prefixCls}-spacing-close`]: (spacing == null ? void 0 : spacing.value) === "close"
    }]);
    return {
      component,
      classNames
    };
  },
  render() {
    const {
      component,
      classNames
    } = this;
    return createVNode(Base3, mergeProps({
      "class": classNames
    }, this.$attrs, {
      "component": component
    }), this.$slots);
  }
});

// node_modules/@arco-design/web-vue/es/typography/title.js
var TypographyTitle = defineComponent({
  name: "TypographyTitle",
  inheritAttrs: false,
  props: {
    heading: {
      type: Number,
      default: 1
    }
  },
  setup(props) {
    const {
      heading
    } = toRefs(props);
    const component = computed(() => `h${heading == null ? void 0 : heading.value}`);
    return {
      component
    };
  },
  render() {
    const {
      component
    } = this;
    return createVNode(Base3, mergeProps(this.$attrs, {
      "component": component
    }), this.$slots);
  }
});

// node_modules/@arco-design/web-vue/es/typography/text.js
var TypographyText = defineComponent({
  name: "TypographyText",
  inheritAttrs: false,
  props: {
    ellipsis: {
      type: [Boolean, Object],
      default: false
    }
  },
  setup(props) {
    const {
      ellipsis
    } = toRefs(props);
    const component = computed(() => (ellipsis == null ? void 0 : ellipsis.value) ? "div" : "span");
    return {
      component
    };
  },
  render() {
    const {
      ellipsis,
      component
    } = this;
    return createVNode(Base3, mergeProps(this.$attrs, {
      "ellipsis": ellipsis,
      "component": component
    }), this.$slots);
  }
});

// node_modules/@arco-design/web-vue/es/typography/index.js
var Typography = Object.assign(_Typography, {
  Paragraph: TypographyParagraph,
  Title: TypographyTitle,
  Text: TypographyText,
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Typography.name, _Typography);
    app.component(componentPrefix + TypographyParagraph.name, TypographyParagraph);
    app.component(componentPrefix + TypographyTitle.name, TypographyTitle);
    app.component(componentPrefix + TypographyText.name, TypographyText);
  }
});

// node_modules/@arco-design/web-vue/es/upload/utils.js
var getResponse = (xhr) => {
  const res = xhr.responseText || xhr.response;
  if (!res) {
    return void 0;
  }
  const contentType = xhr.getResponseHeader("Content-Type");
  if (contentType && contentType.includes("json")) {
    try {
      return JSON.parse(res);
    } catch {
      return res;
    }
  }
  return res;
};
var getProgressStatus = (status) => {
  switch (status) {
    case "done":
      return "success";
    case "error":
      return "danger";
    default:
      return "normal";
  }
};
var getValue = (obj, fileItem) => {
  if (isFunction(obj)) {
    return obj(fileItem);
  }
  return obj;
};
var uploadRequest = ({
  fileItem,
  action,
  name: originName,
  data: originData,
  headers = {},
  withCredentials = false,
  onProgress = NOOP,
  onSuccess = NOOP,
  onError = NOOP
}) => {
  const name = getValue(originName, fileItem) || "file";
  const data = getValue(originData, fileItem);
  const xhr = new XMLHttpRequest();
  if (withCredentials) {
    xhr.withCredentials = true;
  }
  xhr.upload.onprogress = (e2) => {
    const percent = e2.total > 0 ? index_es_default.round(e2.loaded / e2.total, 2) : 0;
    onProgress(percent, e2);
  };
  xhr.onerror = function error(e2) {
    onError(e2);
  };
  xhr.onload = () => {
    if (xhr.status < 200 || xhr.status >= 300) {
      onError(getResponse(xhr));
      return;
    }
    onSuccess(getResponse(xhr));
  };
  const formData = new FormData();
  if (data) {
    for (const key of Object.keys(data)) {
      formData.append(key, data[key]);
    }
  }
  if (fileItem.file) {
    formData.append(name, fileItem.file);
  }
  xhr.open("post", action != null ? action : "", true);
  for (const key of Object.keys(headers)) {
    xhr.setRequestHeader(key, headers[key]);
  }
  xhr.send(formData);
  return {
    abort() {
      xhr.abort();
    }
  };
};
var isAcceptFile = (file, accept) => {
  if (accept && file) {
    const accepts = isArray(accept) ? accept : accept.split(",").map((x) => x.trim()).filter((x) => x);
    const fileExtension = (file.name.indexOf(".") > -1 ? `.${file.name.split(".").pop()}` : "").toLowerCase();
    return accepts.some((type) => {
      const typeText = type && type.toLowerCase();
      const fileType = (file.type || "").toLowerCase();
      const baseFileType = fileType.split("/")[0];
      if (typeText === fileType || `${baseFileType}${fileExtension.replace(".", "/")}` === typeText) {
        return true;
      }
      if (/^\*(\/\*)?$/.test(typeText)) {
        return true;
      }
      if (/\/\*/.test(typeText)) {
        return fileType.replace(/\/.*$/, "") === typeText.replace(/\/.*$/, "");
      }
      if (/\..*/.test(typeText)) {
        let suffixList = [typeText];
        if (typeText === ".jpg" || typeText === ".jpeg") {
          suffixList = [".jpg", ".jpeg"];
        }
        return suffixList.indexOf(fileExtension) > -1;
      }
      return false;
    });
  }
  return !!file;
};
var loopDirectory = (itemList, accept, callback) => {
  const files = [];
  let restFileCount = 0;
  const onFinish = () => {
    !restFileCount && callback(files);
  };
  const _loopDirectory = (item) => {
    restFileCount += 1;
    if (item == null ? void 0 : item.isFile) {
      item.file((file) => {
        restFileCount -= 1;
        if (isAcceptFile(file, accept)) {
          Object.defineProperty(file, "webkitRelativePath", {
            value: item.fullPath.replace(/^\//, "")
          });
          files.push(file);
        }
        onFinish();
      });
      return;
    }
    if (item == null ? void 0 : item.isDirectory) {
      const reader = item.createReader();
      let flag = false;
      const readEntries = () => {
        reader.readEntries((entries) => {
          if (!flag) {
            restFileCount -= 1;
            flag = true;
          }
          if (entries.length === 0) {
            onFinish();
          } else {
            readEntries();
            entries.forEach(_loopDirectory);
          }
        });
      };
      readEntries();
      return;
    }
    restFileCount -= 1;
    onFinish();
  };
  [].slice.call(itemList).forEach((item) => item.webkitGetAsEntry && _loopDirectory(item.webkitGetAsEntry()));
};
var isImage = (file) => {
  var _a;
  return (_a = file.type) == null ? void 0 : _a.includes("image");
};
var getFiles = (fileList, accept) => {
  if (!fileList) {
    return [];
  }
  const files = Array.from(fileList);
  if (accept) {
    return files.filter((file) => {
      return isAcceptFile(file, accept);
    });
  }
  return files;
};

// node_modules/@arco-design/web-vue/es/icon/icon-upload/icon-upload.js
var _sfc_main186 = defineComponent({
  name: "IconUpload",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-upload`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_179 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_260 = createBaseVNode("path", { d: "M14.93 17.071 24.001 8l9.071 9.071m-9.07 16.071v-25M40 35v6H8v-6" }, null, -1);
var _hoisted_356 = [
  _hoisted_260
];
function _sfc_render185(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_356, 14, _hoisted_179);
}
var _IconUpload = _export_sfc(_sfc_main186, [["render", _sfc_render185]]);

// node_modules/@arco-design/web-vue/es/icon/icon-upload/index.js
var IconUpload = Object.assign(_IconUpload, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconUpload.name, _IconUpload);
  }
});

// node_modules/@arco-design/web-vue/es/upload/upload-button.js
var UploadButton = defineComponent({
  name: "UploadButton",
  props: {
    disabled: {
      type: Boolean,
      default: false
    },
    directory: {
      type: Boolean,
      default: false
    },
    accept: String,
    listType: {
      type: String
    },
    tip: String,
    draggable: {
      type: Boolean,
      default: false
    },
    multiple: {
      type: Boolean,
      default: false
    },
    uploadFiles: {
      type: Function,
      required: true
    },
    hide: Boolean,
    onButtonClick: {
      type: Function
    }
  },
  setup(props, {
    slots
  }) {
    const prefixCls = getPrefixCls("upload");
    const {
      t: t2
    } = useI18n();
    const isDragging = ref(false);
    const inputRef = ref(null);
    const dropRef = ref(null);
    const dragEnterCount = ref(0);
    const setDragEnterCount = (type) => {
      if (type === "subtract") {
        dragEnterCount.value -= 1;
      } else if (type === "add") {
        dragEnterCount.value += 1;
      } else if (type === "reset") {
        dragEnterCount.value = 0;
      }
    };
    const handleClick = (e2) => {
      if (props.disabled)
        return;
      if (isFunction(props.onButtonClick)) {
        const result = props.onButtonClick(e2);
        if (isPromise(result)) {
          result.then((files) => {
            props.uploadFiles(getFiles(files));
          });
          return;
        }
      }
      if (inputRef.value) {
        inputRef.value.click();
      }
    };
    const handleInputChange = (e2) => {
      const target3 = e2.target;
      if (target3.files) {
        props.uploadFiles(getFiles(target3.files));
      }
      target3.value = "";
    };
    const handleDrop = (e2) => {
      var _a, _b;
      e2.preventDefault();
      isDragging.value = false;
      setDragEnterCount("reset");
      if (props.disabled) {
        return;
      }
      if (props.directory && ((_a = e2.dataTransfer) == null ? void 0 : _a.items)) {
        loopDirectory(e2.dataTransfer.items, props.accept, (files) => {
          props.uploadFiles(files);
        });
      } else {
        const files = getFiles((_b = e2.dataTransfer) == null ? void 0 : _b.files, props.accept);
        props.uploadFiles(props.multiple ? files : files.slice(0, 1));
      }
    };
    const handleDragLeave = (e2) => {
      e2.preventDefault();
      setDragEnterCount("subtract");
      if (dragEnterCount.value === 0) {
        isDragging.value = false;
        setDragEnterCount("reset");
      }
    };
    const handleDragOver = (e2) => {
      e2.preventDefault();
      if (!props.disabled && !isDragging.value) {
        isDragging.value = true;
      }
    };
    const renderButton = () => {
      if (slots.default) {
        return createVNode("span", null, [slots.default()]);
      }
      if (props.listType === "picture-card") {
        return createVNode("div", {
          "class": `${prefixCls}-picture-card`
        }, [createVNode("div", {
          "class": `${prefixCls}-picture-card-text`
        }, [createVNode(IconPlus, null, null)]), props.tip && createVNode("div", {
          "class": `${prefixCls}-tip`
        }, [props.tip])]);
      }
      if (props.draggable) {
        return createVNode("div", {
          "class": [`${prefixCls}-drag`, {
            [`${prefixCls}-drag-active`]: isDragging.value
          }]
        }, [createVNode("div", null, [createVNode(IconPlus, null, null)]), createVNode("div", {
          "class": `${prefixCls}-drag-text`
        }, [isDragging.value ? t2("upload.dragHover") : t2("upload.drag")]), props.tip && createVNode("div", {
          "class": `${prefixCls}-tip`
        }, [props.tip])]);
      }
      return createVNode(Button, {
        "type": "primary",
        "disabled": props.disabled
      }, {
        default: () => [t2("upload.buttonText")],
        icon: () => createVNode(IconUpload, null, null)
      });
    };
    const cls = computed(() => [prefixCls, {
      [`${prefixCls}-type-picture-card`]: props.listType === "picture-card",
      [`${prefixCls}-draggable`]: props.draggable,
      [`${prefixCls}-disabled`]: props.disabled,
      [`${prefixCls}-hide`]: props.hide
    }]);
    return () => createVNode("span", {
      "ref": dropRef,
      "class": cls.value,
      "onClick": handleClick,
      "onDragenter": () => {
        setDragEnterCount("add");
      },
      "onDrop": handleDrop,
      "onDragover": handleDragOver,
      "onDragleave": handleDragLeave
    }, [createVNode("input", mergeProps({
      "ref": inputRef,
      "type": "file",
      "style": {
        display: "none"
      },
      "disabled": props.disabled,
      "accept": props.accept,
      "multiple": props.multiple
    }, props.directory ? {
      webkitdirectory: "webkitdirectory"
    } : {}, {
      "onChange": handleInputChange
    }), null), renderButton()]);
  }
});

// node_modules/@arco-design/web-vue/es/icon/icon-pause/icon-pause.js
var _sfc_main187 = defineComponent({
  name: "IconPause",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-pause`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_180 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_261 = createBaseVNode("path", { d: "M14 12h4v24h-4zM30 12h4v24h-4z" }, null, -1);
var _hoisted_357 = createBaseVNode("path", {
  fill: "currentColor",
  stroke: "none",
  d: "M14 12h4v24h-4zM30 12h4v24h-4z"
}, null, -1);
var _hoisted_414 = [
  _hoisted_261,
  _hoisted_357
];
function _sfc_render186(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_414, 14, _hoisted_180);
}
var _IconPause = _export_sfc(_sfc_main187, [["render", _sfc_render186]]);

// node_modules/@arco-design/web-vue/es/icon/icon-pause/index.js
var IconPause = Object.assign(_IconPause, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconPause.name, _IconPause);
  }
});

// node_modules/@arco-design/web-vue/es/icon/icon-play-arrow-fill/icon-play-arrow-fill.js
var _sfc_main188 = defineComponent({
  name: "IconPlayArrowFill",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-play-arrow-fill`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_181 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_262 = createBaseVNode("path", {
  d: "M17.533 10.974a1 1 0 0 0-1.537.844v24.356a1 1 0 0 0 1.537.844L36.67 24.84a1 1 0 0 0 0-1.688L17.533 10.974Z",
  fill: "currentColor",
  stroke: "none"
}, null, -1);
var _hoisted_358 = [
  _hoisted_262
];
function _sfc_render187(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_358, 14, _hoisted_181);
}
var _IconPlayArrowFill = _export_sfc(_sfc_main188, [["render", _sfc_render187]]);

// node_modules/@arco-design/web-vue/es/icon/icon-play-arrow-fill/index.js
var IconPlayArrowFill = Object.assign(_IconPlayArrowFill, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconPlayArrowFill.name, _IconPlayArrowFill);
  }
});

// node_modules/@arco-design/web-vue/es/upload/context.js
var uploadInjectionKey = Symbol("ArcoUpload");

// node_modules/@arco-design/web-vue/es/upload/upload-progress.js
var UploadProgress = defineComponent({
  name: "UploadProgress",
  props: {
    file: {
      type: Object,
      required: true
    },
    listType: {
      type: String,
      required: true
    }
  },
  setup(props) {
    const prefixCls = getPrefixCls("upload-progress");
    const {
      t: t2
    } = useI18n();
    const uploadCtx = inject(uploadInjectionKey, void 0);
    const renderIcon = () => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
      if (props.file.status === "error") {
        return createVNode("span", {
          "class": [uploadCtx == null ? void 0 : uploadCtx.iconCls, `${uploadCtx == null ? void 0 : uploadCtx.iconCls}-upload`],
          "onClick": () => uploadCtx == null ? void 0 : uploadCtx.onUpload(props.file)
        }, [(uploadCtx == null ? void 0 : uploadCtx.showRetryButton) && ((_e = (_b = uploadCtx == null ? void 0 : (_a = uploadCtx.slots)["retry-icon"]) == null ? void 0 : _b.call(_a)) != null ? _e : (_d = (_c = uploadCtx == null ? void 0 : uploadCtx.customIcon) == null ? void 0 : _c.retryIcon) == null ? void 0 : _d.call(_c)) || props.listType === "picture-card" ? createVNode(IconUpload, null, null) : t2("upload.retry")]);
      }
      if (props.file.status === "done") {
        return createVNode("span", {
          "class": [uploadCtx == null ? void 0 : uploadCtx.iconCls, `${uploadCtx == null ? void 0 : uploadCtx.iconCls}-success`]
        }, [(_k = (_j = (_g = uploadCtx == null ? void 0 : (_f = uploadCtx.slots)["success-icon"]) == null ? void 0 : _g.call(_f)) != null ? _j : (_i = (_h = uploadCtx == null ? void 0 : uploadCtx.customIcon) == null ? void 0 : _h.successIcon) == null ? void 0 : _i.call(_h)) != null ? _k : createVNode(IconCheck2, null, null)]);
      }
      if (props.file.status === "init") {
        return createVNode(Tooltip, {
          "content": t2("upload.start")
        }, {
          default: () => {
            var _a2, _b2, _c2, _d2, _e2, _f2;
            return [createVNode("span", {
              "class": [uploadCtx == null ? void 0 : uploadCtx.iconCls, `${uploadCtx == null ? void 0 : uploadCtx.iconCls}-start`],
              "onClick": () => uploadCtx == null ? void 0 : uploadCtx.onUpload(props.file)
            }, [(_f2 = (_e2 = (_b2 = uploadCtx == null ? void 0 : (_a2 = uploadCtx.slots)["start-icon"]) == null ? void 0 : _b2.call(_a2)) != null ? _e2 : (_d2 = (_c2 = uploadCtx == null ? void 0 : uploadCtx.customIcon) == null ? void 0 : _c2.startIcon) == null ? void 0 : _d2.call(_c2)) != null ? _f2 : createVNode(IconPlayArrowFill, null, null)])];
          }
        });
      }
      return (uploadCtx == null ? void 0 : uploadCtx.showCancelButton) && createVNode(Tooltip, {
        "content": t2("upload.cancel")
      }, {
        default: () => {
          var _a2, _b2, _c2, _d2, _e2, _f2;
          return [createVNode("span", {
            "class": [uploadCtx == null ? void 0 : uploadCtx.iconCls, `${uploadCtx == null ? void 0 : uploadCtx.iconCls}-cancel`],
            "onClick": () => uploadCtx == null ? void 0 : uploadCtx.onAbort(props.file)
          }, [(_f2 = (_e2 = (_b2 = uploadCtx == null ? void 0 : (_a2 = uploadCtx.slots)["cancel-icon"]) == null ? void 0 : _b2.call(_a2)) != null ? _e2 : (_d2 = (_c2 = uploadCtx == null ? void 0 : uploadCtx.customIcon) == null ? void 0 : _c2.cancelIcon) == null ? void 0 : _d2.call(_c2)) != null ? _f2 : createVNode(IconPause, null, null)])];
        }
      });
    };
    const renderProgress = () => {
      var _a;
      if (["init", "uploading"].includes((_a = props.file.status) != null ? _a : "")) {
        const status = getProgressStatus(props.file.status);
        return createVNode(Progress, {
          "type": "circle",
          "size": "mini",
          "showText": false,
          "status": status,
          "percent": props.file.percent
        }, null);
      }
      return null;
    };
    return () => createVNode("span", {
      "class": prefixCls
    }, [renderProgress(), renderIcon()]);
  }
});

// node_modules/@arco-design/web-vue/es/icon/icon-file-pdf/icon-file-pdf.js
var _sfc_main189 = defineComponent({
  name: "IconFilePdf",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-file-pdf`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_182 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_263 = createBaseVNode("path", { d: "M11 42h26a2 2 0 0 0 2-2V13.828a2 2 0 0 0-.586-1.414l-5.828-5.828A2 2 0 0 0 31.172 6H11a2 2 0 0 0-2 2v32a2 2 0 0 0 2 2Z" }, null, -1);
var _hoisted_359 = createBaseVNode("path", { d: "M22.305 21.028c.874 1.939 3.506 6.265 4.903 8.055 1.747 2.237 3.494 2.685 4.368 2.237.873-.447 1.21-4.548-7.425-2.685-7.523 1.623-7.424 3.58-6.988 4.476.728 1.193 2.522 2.627 5.678-6.266C25.699 18.79 24.489 17 23.277 17c-1.409 0-2.538.805-.972 4.028Z" }, null, -1);
var _hoisted_415 = [
  _hoisted_263,
  _hoisted_359
];
function _sfc_render188(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_415, 14, _hoisted_182);
}
var _IconFilePdf = _export_sfc(_sfc_main189, [["render", _sfc_render188]]);

// node_modules/@arco-design/web-vue/es/icon/icon-file-pdf/index.js
var IconFilePdf = Object.assign(_IconFilePdf, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconFilePdf.name, _IconFilePdf);
  }
});

// node_modules/@arco-design/web-vue/es/icon/icon-file-image/icon-file-image.js
var _sfc_main190 = defineComponent({
  name: "IconFileImage",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-file-image`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_183 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_264 = createBaseVNode("path", { d: "m26 33 5-6v6h-5Zm0 0-3-4-4 4h7Zm11 9H11a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h21l7 7v27a2 2 0 0 1-2 2ZM17 19h1v1h-1v-1Z" }, null, -1);
var _hoisted_360 = [
  _hoisted_264
];
function _sfc_render189(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_360, 14, _hoisted_183);
}
var _IconFileImage = _export_sfc(_sfc_main190, [["render", _sfc_render189]]);

// node_modules/@arco-design/web-vue/es/icon/icon-file-image/index.js
var IconFileImage = Object.assign(_IconFileImage, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconFileImage.name, _IconFileImage);
  }
});

// node_modules/@arco-design/web-vue/es/icon/icon-file-video/icon-file-video.js
var _sfc_main191 = defineComponent({
  name: "IconFileVideo",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-file-video`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_184 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_265 = createBaseVNode("path", { d: "M37 42H11a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h21l7 7v27a2 2 0 0 1-2 2Z" }, null, -1);
var _hoisted_361 = createBaseVNode("path", { d: "M22 27.796v-6l5 3-5 3Z" }, null, -1);
var _hoisted_416 = [
  _hoisted_265,
  _hoisted_361
];
function _sfc_render190(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_416, 14, _hoisted_184);
}
var _IconFileVideo = _export_sfc(_sfc_main191, [["render", _sfc_render190]]);

// node_modules/@arco-design/web-vue/es/icon/icon-file-video/index.js
var IconFileVideo = Object.assign(_IconFileVideo, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconFileVideo.name, _IconFileVideo);
  }
});

// node_modules/@arco-design/web-vue/es/icon/icon-file-audio/icon-file-audio.js
var _sfc_main192 = defineComponent({
  name: "IconFileAudio",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value) => {
        return ["butt", "round", "square"].includes(value);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-file-audio`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
var _hoisted_185 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
var _hoisted_266 = createBaseVNode("path", { d: "M37 42H11a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h21l7 7v27a2 2 0 0 1-2 2Z" }, null, -1);
var _hoisted_362 = createBaseVNode("path", {
  d: "M25 30a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z",
  fill: "currentColor",
  stroke: "none"
}, null, -1);
var _hoisted_417 = createBaseVNode("path", { d: "M25 30a3 3 0 1 1-6 0 3 3 0 0 1 6 0Zm0 0-.951-12.363a.5.5 0 0 1 .58-.532L30 18" }, null, -1);
var _hoisted_55 = [
  _hoisted_266,
  _hoisted_362,
  _hoisted_417
];
function _sfc_render191(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_55, 14, _hoisted_185);
}
var _IconFileAudio = _export_sfc(_sfc_main192, [["render", _sfc_render191]]);

// node_modules/@arco-design/web-vue/es/icon/icon-file-audio/index.js
var IconFileAudio = Object.assign(_IconFileAudio, {
  install: (app, options) => {
    var _a;
    const iconPrefix = (_a = options == null ? void 0 : options.iconPrefix) != null ? _a : "";
    app.component(iconPrefix + _IconFileAudio.name, _IconFileAudio);
  }
});

// node_modules/@arco-design/web-vue/es/upload/upload-list-item.js
var UploadListItem = defineComponent({
  name: "UploadListItem",
  props: {
    file: {
      type: Object,
      required: true
    },
    listType: {
      type: String,
      required: true
    }
  },
  setup(props) {
    const prefixCls = getPrefixCls("upload-list");
    const itemCls = `${prefixCls}-item`;
    const {
      t: t2
    } = useI18n();
    const uploadCtx = inject(uploadInjectionKey, void 0);
    const renderFileIcon = () => {
      var _a, _b;
      let type = "";
      if (props.file.file && props.file.file.type) {
        type = props.file.file.type;
      } else {
        const extension = (_b = (_a = props.file.name) == null ? void 0 : _a.split(".")[1]) != null ? _b : "";
        if (["png", "jpg", "jpeg", "bmp", "gif", "webp"].includes(extension)) {
          type = "image";
        } else if (["mp4", "m2v", "mkv", "m4v", "mov"].includes(extension)) {
          type = "video";
        } else if (["mp3", "wav", "wmv", "m4a", "acc", "flac"].includes(extension)) {
          type = "audio";
        }
      }
      if (type.includes("image")) {
        return createVNode(IconFileImage, null, null);
      }
      if (type.includes("pdf")) {
        return createVNode(IconFilePdf, null, null);
      }
      if (type.includes("audio")) {
        return createVNode(IconFileAudio, null, null);
      }
      if (type.includes("video")) {
        return createVNode(IconFileVideo, null, null);
      }
      return createVNode(IconFile, null, null);
    };
    return () => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w;
      return createVNode("div", {
        "class": [itemCls, `${itemCls}-${props.file.status}`]
      }, [createVNode("div", {
        "class": `${itemCls}-content`
      }, [(uploadCtx == null ? void 0 : uploadCtx.listType) === "picture" && createVNode("span", {
        "class": `${itemCls}-thumbnail`
      }, [(_c = (_b = uploadCtx == null ? void 0 : (_a = uploadCtx.slots).image) == null ? void 0 : _b.call(_a, {
        fileItem: props.file
      })) != null ? _c : createVNode("img", mergeProps({
        "src": props.file.url,
        "alt": props.file.name
      }, (uploadCtx == null ? void 0 : uploadCtx.imageLoading) ? {
        loading: uploadCtx.imageLoading
      } : void 0), null)]), createVNode("div", {
        "class": `${itemCls}-name`
      }, [(uploadCtx == null ? void 0 : uploadCtx.listType) === "text" && createVNode("span", {
        "class": `${itemCls}-file-icon`
      }, [(_i = (_h = (_e = uploadCtx == null ? void 0 : (_d = uploadCtx.slots)["file-icon"]) == null ? void 0 : _e.call(_d, {
        fileItem: props.file
      })) != null ? _h : (_g = (_f = uploadCtx == null ? void 0 : uploadCtx.customIcon) == null ? void 0 : _f.fileIcon) == null ? void 0 : _g.call(_f, props.file)) != null ? _i : renderFileIcon()]), (uploadCtx == null ? void 0 : uploadCtx.showLink) && props.file.url ? createVNode("a", mergeProps({
        "class": `${itemCls}-name-link`,
        "target": "_blank",
        "href": props.file.url
      }, (uploadCtx == null ? void 0 : uploadCtx.download) ? {
        download: props.file.name
      } : void 0), [(_o = (_n = (_k = uploadCtx == null ? void 0 : (_j = uploadCtx.slots)["file-name"]) == null ? void 0 : _k.call(_j, {
        fileItem: props.file
      })) != null ? _n : (_m = (_l = uploadCtx == null ? void 0 : uploadCtx.customIcon) == null ? void 0 : _l.fileName) == null ? void 0 : _m.call(_l, props.file)) != null ? _o : props.file.name]) : createVNode("span", {
        "class": `${itemCls}-name-text`,
        "onClick": () => uploadCtx == null ? void 0 : uploadCtx.onPreview(props.file)
      }, [(_u = (_t = (_q = uploadCtx == null ? void 0 : (_p = uploadCtx.slots)["file-name"]) == null ? void 0 : _q.call(_p, {
        fileItem: props.file
      })) != null ? _t : (_s = (_r = uploadCtx == null ? void 0 : uploadCtx.customIcon) == null ? void 0 : _r.fileName) == null ? void 0 : _s.call(_r, props.file)) != null ? _u : props.file.name]), props.file.status === "error" && createVNode(Tooltip, {
        "content": t2("upload.error")
      }, {
        default: () => {
          var _a2, _b2, _c2, _d2, _e2, _f2;
          return [createVNode("span", {
            "class": [uploadCtx == null ? void 0 : uploadCtx.iconCls, `${uploadCtx == null ? void 0 : uploadCtx.iconCls}-error`]
          }, [(_f2 = (_e2 = (_b2 = uploadCtx == null ? void 0 : (_a2 = uploadCtx.slots)["error-icon"]) == null ? void 0 : _b2.call(_a2)) != null ? _e2 : (_d2 = (_c2 = uploadCtx == null ? void 0 : uploadCtx.customIcon) == null ? void 0 : _c2.errorIcon) == null ? void 0 : _d2.call(_c2)) != null ? _f2 : createVNode(IconExclamationCircleFill, null, null)])];
        }
      })]), createVNode(UploadProgress, {
        "file": props.file,
        "listType": props.listType
      }, null)]), (uploadCtx == null ? void 0 : uploadCtx.showRemoveButton) && createVNode("span", {
        "class": `${itemCls}-operation`
      }, [createVNode(IconHover, {
        "onClick": () => {
          var _a2;
          return (_a2 = uploadCtx == null ? void 0 : uploadCtx.onRemove) == null ? void 0 : _a2.call(uploadCtx, props.file);
        }
      }, {
        default: () => {
          var _a2, _b2, _c2, _d2, _e2, _f2;
          return [createVNode("span", {
            "class": [uploadCtx == null ? void 0 : uploadCtx.iconCls, `${uploadCtx == null ? void 0 : uploadCtx.iconCls}-remove`]
          }, [(_f2 = (_e2 = (_b2 = uploadCtx == null ? void 0 : (_a2 = uploadCtx.slots)["remove-icon"]) == null ? void 0 : _b2.call(_a2)) != null ? _e2 : (_d2 = (_c2 = uploadCtx == null ? void 0 : uploadCtx.customIcon) == null ? void 0 : _c2.removeIcon) == null ? void 0 : _d2.call(_c2)) != null ? _f2 : createVNode(IconDelete, null, null)])];
        }
      })]), (_w = uploadCtx == null ? void 0 : (_v = uploadCtx.slots)["extra-button"]) == null ? void 0 : _w.call(_v, props.file)]);
    };
  }
});

// node_modules/@arco-design/web-vue/es/upload/upload-picture-item.js
var UploadPictureItem = defineComponent({
  name: "UploadPictureItem",
  props: {
    file: {
      type: Object,
      required: true
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  setup(props) {
    const prefixCls = getPrefixCls("upload-list");
    const itemCls = `${prefixCls}-picture`;
    const cls = computed(() => [itemCls, {
      [`${itemCls}-status-error`]: props.file.status === "error"
    }]);
    const uploadCtx = inject(uploadInjectionKey, void 0);
    const renderCard = () => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C;
      if (props.file.status === "uploading") {
        return createVNode(UploadProgress, {
          "file": props.file,
          "listType": "picture-card"
        }, null);
      }
      return createVNode(Fragment, null, [(_c = (_b = uploadCtx == null ? void 0 : (_a = uploadCtx.slots).image) == null ? void 0 : _b.call(_a, {
        fileItem: props.file
      })) != null ? _c : createVNode("img", mergeProps({
        "src": props.file.url,
        "alt": props.file.name
      }, (uploadCtx == null ? void 0 : uploadCtx.imageLoading) ? {
        loading: uploadCtx.imageLoading
      } : void 0), null), createVNode("div", {
        "class": `${itemCls}-mask`
      }, [props.file.status === "error" && (uploadCtx == null ? void 0 : uploadCtx.showCancelButton) && createVNode("div", {
        "class": `${itemCls}-error-tip`
      }, [createVNode("span", {
        "class": [uploadCtx == null ? void 0 : uploadCtx.iconCls, `${uploadCtx == null ? void 0 : uploadCtx.iconCls}-error`]
      }, [(_i = (_h = (_e = uploadCtx == null ? void 0 : (_d = uploadCtx.slots)["error-icon"]) == null ? void 0 : _e.call(_d)) != null ? _h : (_g = (_f = uploadCtx == null ? void 0 : uploadCtx.customIcon) == null ? void 0 : _f.errorIcon) == null ? void 0 : _g.call(_f)) != null ? _i : createVNode(IconImageClose, null, null)])]), createVNode("div", {
        "class": `${itemCls}-operation`
      }, [props.file.status !== "error" && (uploadCtx == null ? void 0 : uploadCtx.showPreviewButton) && createVNode("span", {
        "class": [uploadCtx == null ? void 0 : uploadCtx.iconCls, `${uploadCtx == null ? void 0 : uploadCtx.iconCls}-preview`],
        "onClick": () => uploadCtx == null ? void 0 : uploadCtx.onPreview(props.file)
      }, [(_o = (_n = (_k = uploadCtx == null ? void 0 : (_j = uploadCtx.slots)["preview-icon"]) == null ? void 0 : _k.call(_j)) != null ? _n : (_m = (_l = uploadCtx == null ? void 0 : uploadCtx.customIcon) == null ? void 0 : _l.previewIcon) == null ? void 0 : _m.call(_l)) != null ? _o : createVNode(IconEye, null, null)]), ["init", "error"].includes(props.file.status) && (uploadCtx == null ? void 0 : uploadCtx.showRetryButton) && createVNode("span", {
        "class": [uploadCtx == null ? void 0 : uploadCtx.iconCls, `${uploadCtx == null ? void 0 : uploadCtx.iconCls}-upload`],
        "onClick": () => uploadCtx == null ? void 0 : uploadCtx.onUpload(props.file)
      }, [(_u = (_t = (_q = uploadCtx == null ? void 0 : (_p = uploadCtx.slots)["retry-icon"]) == null ? void 0 : _q.call(_p)) != null ? _t : (_s = (_r = uploadCtx == null ? void 0 : uploadCtx.customIcon) == null ? void 0 : _r.retryIcon) == null ? void 0 : _s.call(_r)) != null ? _u : createVNode(IconUpload, null, null)]), !(uploadCtx == null ? void 0 : uploadCtx.disabled) && (uploadCtx == null ? void 0 : uploadCtx.showRemoveButton) && createVNode("span", {
        "class": [uploadCtx == null ? void 0 : uploadCtx.iconCls, `${uploadCtx == null ? void 0 : uploadCtx.iconCls}-remove`],
        "onClick": () => uploadCtx == null ? void 0 : uploadCtx.onRemove(props.file)
      }, [(_A = (_z = (_w = uploadCtx == null ? void 0 : (_v = uploadCtx.slots)["remove-icon"]) == null ? void 0 : _w.call(_v)) != null ? _z : (_y = (_x = uploadCtx == null ? void 0 : uploadCtx.customIcon) == null ? void 0 : _x.removeIcon) == null ? void 0 : _y.call(_x)) != null ? _A : createVNode(IconDelete, null, null)]), (_C = uploadCtx == null ? void 0 : (_B = uploadCtx.slots)["extra-button"]) == null ? void 0 : _C.call(_B, props.file)])])]);
    };
    return () => createVNode("span", {
      "class": cls.value
    }, [renderCard()]);
  }
});

// node_modules/@arco-design/web-vue/es/upload/upload-list.js
var UploadList = defineComponent({
  name: "UploadList",
  components: {
    UploadListItem,
    UploadPictureItem
  },
  props: {
    fileList: {
      type: Array,
      required: true
    },
    listType: {
      type: String,
      required: true
    }
  },
  setup(props, {
    slots
  }) {
    const prefixCls = getPrefixCls("upload");
    const cls = computed(() => [`${prefixCls}-list`, `${prefixCls}-list-type-${props.listType}`]);
    const renderItem = (fileItem, index3) => {
      if (isFunction(slots["upload-item"])) {
        return slots["upload-item"]({
          fileItem,
          index: index3
        });
      }
      if (props.listType === "picture-card") {
        return createVNode(UploadPictureItem, {
          "file": fileItem,
          "key": `item-${index3}`
        }, null);
      }
      return createVNode(UploadListItem, {
        "file": fileItem,
        "listType": props.listType,
        "key": `item-${index3}`
      }, null);
    };
    return () => createVNode(TransitionGroup, {
      "tag": "div",
      "class": cls.value
    }, {
      default: () => {
        var _a;
        return [...props.fileList.map((item, index3) => renderItem(item, index3)), props.listType === "picture-card" && ((_a = slots["upload-button"]) == null ? void 0 : _a.call(slots))];
      }
    });
  }
});

// node_modules/@arco-design/web-vue/es/upload/upload.js
var __defProp60 = Object.defineProperty;
var __defProps28 = Object.defineProperties;
var __getOwnPropDescs28 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols60 = Object.getOwnPropertySymbols;
var __hasOwnProp60 = Object.prototype.hasOwnProperty;
var __propIsEnum60 = Object.prototype.propertyIsEnumerable;
var __defNormalProp60 = (obj, key, value) => key in obj ? __defProp60(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues60 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp60.call(b, prop))
      __defNormalProp60(a, prop, b[prop]);
  if (__getOwnPropSymbols60)
    for (var prop of __getOwnPropSymbols60(b)) {
      if (__propIsEnum60.call(b, prop))
        __defNormalProp60(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps28 = (a, b) => __defProps28(a, __getOwnPropDescs28(b));
var _Upload = defineComponent({
  name: "Upload",
  props: {
    fileList: {
      type: Array,
      default: void 0
    },
    defaultFileList: {
      type: Array,
      default: () => []
    },
    accept: String,
    action: String,
    disabled: {
      type: Boolean,
      default: false
    },
    multiple: {
      type: Boolean,
      default: false
    },
    directory: {
      type: Boolean,
      default: false
    },
    draggable: {
      type: Boolean,
      default: false
    },
    tip: String,
    headers: {
      type: Object
    },
    data: {
      type: [Object, Function]
    },
    name: {
      type: [String, Function]
    },
    withCredentials: {
      type: Boolean,
      default: false
    },
    customRequest: {
      type: Function
    },
    limit: {
      type: Number,
      default: 0
    },
    autoUpload: {
      type: Boolean,
      default: true
    },
    showFileList: {
      type: Boolean,
      default: true
    },
    showRemoveButton: {
      type: Boolean,
      default: true
    },
    showRetryButton: {
      type: Boolean,
      default: true
    },
    showCancelButton: {
      type: Boolean,
      default: true
    },
    showUploadButton: {
      type: [Boolean, Object],
      default: true
    },
    showPreviewButton: {
      type: Boolean,
      default: true
    },
    download: {
      type: Boolean,
      default: false
    },
    showLink: {
      type: Boolean,
      default: true
    },
    imageLoading: {
      type: String
    },
    listType: {
      type: String,
      default: "text"
    },
    responseUrlKey: {
      type: [String, Function]
    },
    customIcon: {
      type: Object
    },
    imagePreview: {
      type: Boolean,
      default: false
    },
    onBeforeUpload: {
      type: Function
    },
    onBeforeRemove: {
      type: Function
    },
    onButtonClick: {
      type: Function
    }
  },
  emits: {
    "update:fileList": (fileList) => true,
    "exceedLimit": (fileList, files) => true,
    "change": (fileList, fileItem) => true,
    "progress": (fileItem, ev) => true,
    "preview": (fileItem) => true,
    "success": (fileItem) => true,
    "error": (fileItem) => true
  },
  setup(props, {
    emit,
    slots
  }) {
    const {
      fileList,
      disabled,
      listType,
      customIcon,
      showRetryButton,
      showCancelButton,
      showRemoveButton,
      showPreviewButton,
      imageLoading,
      download,
      showLink
    } = toRefs(props);
    const prefixCls = getPrefixCls("upload");
    const {
      mergedDisabled,
      eventHandlers
    } = useFormItem({
      disabled
    });
    const _fileList = ref([]);
    const fileMap = /* @__PURE__ */ new Map();
    const requestMap = /* @__PURE__ */ new Map();
    const isMax = computed(() => {
      return props.limit > 0 && _fileList.value.length >= props.limit;
    });
    const checkFileList = (fileList2) => {
      fileMap.clear();
      const newFileList = fileList2 == null ? void 0 : fileList2.map((data, index3) => {
        var _a, _b, _c;
        const status = (_a = data.status) != null ? _a : "done";
        const fileItem = reactive(__spreadProps28(__spreadValues60({}, data), {
          uid: (_b = data.uid) != null ? _b : `${Date.now()}${index3}`,
          status,
          percent: (_c = data.percent) != null ? _c : ["error", "init"].indexOf(status) > -1 ? 0 : 1
        }));
        fileMap.set(fileItem.uid, fileItem);
        return fileItem;
      });
      _fileList.value = newFileList != null ? newFileList : [];
    };
    checkFileList(props.defaultFileList);
    watch(fileList, (fileList2) => {
      if (fileList2) {
        checkFileList(fileList2);
      }
    }, {
      immediate: true,
      deep: true
    });
    const updateFileList = (file) => {
      var _a, _b;
      emit("update:fileList", _fileList.value);
      emit("change", _fileList.value, file);
      (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onChange) == null ? void 0 : _b.call(_a);
    };
    const updateFile = (id, file) => {
      for (const item of _fileList.value) {
        if (item.uid === id) {
          item.file = file;
          updateFileList(item);
          break;
        }
      }
    };
    const uploadFile = (fileItem) => {
      const handleProgress = (percent, event) => {
        const file = fileMap.get(fileItem.uid);
        if (file) {
          file.status = "uploading";
          file.percent = percent;
          emit("progress", file, event);
          updateFileList(file);
        }
      };
      const handleSuccess = (response) => {
        const file = fileMap.get(fileItem.uid);
        if (file) {
          file.status = "done";
          file.percent = 1;
          file.response = response;
          if (props.responseUrlKey) {
            if (isFunction(props.responseUrlKey)) {
              file.url = props.responseUrlKey(file);
            } else if (response[props.responseUrlKey]) {
              file.url = response[props.responseUrlKey];
            }
          }
          requestMap.delete(file.uid);
          emit("success", file);
          updateFileList(file);
        }
      };
      const handleError = (response) => {
        const file = fileMap.get(fileItem.uid);
        if (file) {
          file.status = "error";
          file.percent = 0;
          file.response = response;
          requestMap.delete(file.uid);
          emit("error", file);
          updateFileList(file);
        }
      };
      const option = {
        fileItem,
        action: props.action,
        name: props.name,
        data: props.data,
        headers: props.headers,
        withCredentials: props.withCredentials,
        onProgress: handleProgress,
        onSuccess: handleSuccess,
        onError: handleError
      };
      fileItem.status = "uploading";
      fileItem.percent = 0;
      const request = isFunction(props.customRequest) ? props.customRequest(option) : uploadRequest(option);
      requestMap.set(fileItem.uid, request);
      updateFileList(fileItem);
    };
    const abort = (fileItem) => {
      var _a;
      const req = requestMap.get(fileItem.uid);
      if (req) {
        (_a = req.abort) == null ? void 0 : _a.call(req);
        requestMap.delete(fileItem.uid);
        const file = fileMap.get(fileItem.uid);
        if (file) {
          file.status = "error";
          file.percent = 0;
          updateFileList(file);
        }
      }
    };
    const submit = (fileItem) => {
      if (fileItem) {
        const file = fileMap.get(fileItem.uid);
        if (file) {
          uploadFile(file);
        }
      } else {
        for (const item of _fileList.value) {
          if (item.status === "init") {
            uploadFile(item);
          }
        }
      }
    };
    const initUpload = async (file, index3) => {
      const uid = `${Date.now()}-${index3}`;
      const dataURL = isImage(file) ? URL.createObjectURL(file) : void 0;
      const fileItem = reactive({
        uid,
        file,
        url: dataURL,
        name: file.name,
        status: "init",
        percent: 0
      });
      fileMap.set(uid, fileItem);
      _fileList.value = [..._fileList.value, fileItem];
      updateFileList(fileItem);
      if (props.autoUpload) {
        uploadFile(fileItem);
      }
    };
    const uploadFiles = (files) => {
      if (props.limit > 0 && _fileList.value.length + files.length > props.limit) {
        emit("exceedLimit", _fileList.value, files);
        return;
      }
      for (let i2 = 0; i2 < files.length; i2++) {
        const file = files[i2];
        if (isFunction(props.onBeforeUpload)) {
          Promise.resolve(props.onBeforeUpload(file)).then((result) => {
            if (result) {
              initUpload(isBoolean(result) ? file : result, i2);
            }
          }).catch((err) => {
            console.error(err);
          });
        } else {
          initUpload(file, i2);
        }
      }
    };
    const removeFile = (fileItem) => {
      _fileList.value = _fileList.value.filter((item) => {
        return item.uid !== fileItem.uid;
      });
      updateFileList(fileItem);
    };
    const handleRemove = (fileItem) => {
      if (isFunction(props.onBeforeRemove)) {
        Promise.resolve(props.onBeforeRemove(fileItem)).then((result) => {
          if (result) {
            removeFile(fileItem);
          }
        }).catch((err) => {
          console.error(err);
        });
      } else {
        removeFile(fileItem);
      }
    };
    const handlePreview = (fileItem) => {
      if (props.imagePreview && fileItem.url) {
        const current = imageList.value.indexOf(fileItem.url);
        if (current > -1) {
          imagePreviewCurrent.value = current;
          imagePreviewVisible.value = true;
        }
      }
      emit("preview", fileItem);
    };
    provide(uploadInjectionKey, reactive({
      disabled: mergedDisabled,
      listType,
      iconCls: `${prefixCls}-icon`,
      showRemoveButton,
      showRetryButton,
      showCancelButton,
      showPreviewButton,
      showLink,
      imageLoading,
      download,
      customIcon,
      slots,
      onUpload: uploadFile,
      onAbort: abort,
      onRemove: handleRemove,
      onPreview: handlePreview
    }));
    const mergedAccept = computed(() => {
      if (props.accept) {
        return props.accept;
      }
      if (props.listType === "picture" || props.listType === "picture-card") {
        return "image/*";
      }
      return void 0;
    });
    const renderButton = () => {
      const button = createVNode(UploadButton, {
        "key": "arco-upload-button",
        "disabled": mergedDisabled.value,
        "draggable": props.draggable,
        "listType": props.listType,
        "uploadFiles": uploadFiles,
        "multiple": props.multiple,
        "directory": props.directory,
        "tip": props.tip,
        "hide": !props.showUploadButton || isMax.value && !(isObject(props.showUploadButton) && props.showUploadButton.showOnExceedLimit),
        "accept": mergedAccept.value,
        "onButtonClick": props.onButtonClick
      }, {
        default: slots["upload-button"]
      });
      if (props.tip && props.listType !== "picture-card" && !props.draggable) {
        return createVNode("span", null, [button, createVNode("div", {
          "class": `${prefixCls}-tip`
        }, [props.tip])]);
      }
      return button;
    };
    const imagePreviewVisible = ref(false);
    const imagePreviewCurrent = ref(0);
    const handleImagePreviewChange = (current) => {
      imagePreviewCurrent.value = current;
    };
    const handleImagePreviewVisibleChange = (visible) => {
      imagePreviewVisible.value = visible;
    };
    const imageList = computed(() => _fileList.value.filter((item) => Boolean(item.url)).map((item) => item.url));
    const render2 = () => {
      if (!props.showFileList) {
        return props.showUploadButton && renderButton();
      }
      return createVNode("div", {
        "class": [`${prefixCls}-wrapper`, `${prefixCls}-wrapper-type-${props.listType}`]
      }, [props.imagePreview && imageList.value.length > 0 && createVNode(ImagePreviewGroup, {
        "srcList": imageList.value,
        "visible": imagePreviewVisible.value,
        "current": imagePreviewCurrent.value,
        "onChange": handleImagePreviewChange,
        "onVisibleChange": handleImagePreviewVisibleChange
      }, null), props.listType !== "picture-card" && props.showUploadButton && renderButton(), createVNode(UploadList, {
        "fileList": _fileList.value,
        "listType": props.listType
      }, {
        "upload-button": renderButton,
        "upload-item": slots["upload-item"]
      })]);
    };
    return {
      prefixCls,
      render: render2,
      innerSubmit: submit,
      innerAbort: abort,
      innerUpdateFile: updateFile,
      innerUpload: uploadFiles
    };
  },
  methods: {
    submit(fileItem) {
      return this.innerSubmit(fileItem);
    },
    abort(fileItem) {
      return this.innerAbort(fileItem);
    },
    updateFile(id, file) {
      return this.innerUpdateFile(id, file);
    },
    upload(files) {
      return this.innerUpload(files);
    }
  },
  render() {
    return this.render();
  }
});

// node_modules/@arco-design/web-vue/es/upload/index.js
var Upload = Object.assign(_Upload, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Upload.name, _Upload);
  }
});

// node_modules/@arco-design/web-vue/es/overflow-list/overflow-list.js
var _OverflowList = defineComponent({
  name: "OverflowList",
  props: {
    min: {
      type: Number,
      default: 0
    },
    margin: {
      type: Number,
      default: 8
    },
    from: {
      type: String,
      default: "end"
    }
  },
  emits: {
    change: (value) => true
  },
  setup(props, {
    emit,
    slots
  }) {
    const prefixCls = getPrefixCls("overflow-list");
    const listRef = ref();
    const overflowRef = ref();
    const spacerRef = ref();
    const children = {};
    const itemWidths = [];
    const total = ref(0);
    const overflowNumber = ref(0);
    const showOverflow = computed(() => overflowNumber.value > 0);
    const nextWidth = ref(0);
    const isStart = computed(() => props.from === "start");
    watch(total, (cur, pre) => {
      if (overflowNumber.value > 0) {
        overflowNumber.value += cur - pre;
        if (overflowNumber.value < 0) {
          overflowNumber.value = 0;
        }
      }
    });
    watch(overflowNumber, (val) => {
      emit("change", val);
    });
    const onResize = () => {
      var _a, _b, _c;
      if (listRef.value && children.value && spacerRef.value) {
        const spacerWidth = spacerRef.value.offsetWidth;
        if (spacerWidth > 1 && (overflowNumber.value === 0 || spacerWidth < nextWidth.value)) {
          return;
        }
        for (let i2 = 0; i2 < children.value.length; i2++) {
          const element = children.value[i2].el;
          if (element && element.offsetWidth) {
            itemWidths[i2] = element.offsetWidth + props.margin;
          }
        }
        let remainingWidth = listRef.value.clientWidth - ((_b = (_a = overflowRef.value) == null ? void 0 : _a.offsetWidth) != null ? _b : 0) - (isStart.value ? props.margin : 0);
        const _itemWidths = isStart.value ? getReverse(itemWidths) : itemWidths;
        let count = 0;
        for (let i2 = 0; i2 < _itemWidths.length; i2++) {
          const itemWidth = (_c = _itemWidths[i2]) != null ? _c : 0;
          if (itemWidth < remainingWidth - 1) {
            remainingWidth -= itemWidth;
            count += 1;
          } else {
            nextWidth.value = itemWidth;
            break;
          }
        }
        if (count < props.min && props.min < total.value) {
          count = props.min;
        }
        if (overflowNumber.value !== total.value - count) {
          overflowNumber.value = total.value - count;
        }
      }
    };
    watch(showOverflow, () => onResize(), {
      flush: "post"
    });
    onMounted(() => {
      if (spacerRef.value && spacerRef.value.offsetWidth < 1) {
        onResize();
      }
    });
    const renderOverflow = () => {
      var _a, _b;
      const style = isStart.value ? {
        marginRight: `${props.margin}px`
      } : void 0;
      return createVNode("div", {
        "ref": overflowRef,
        "class": `${prefixCls}-overflow`,
        "style": style
      }, [(_b = (_a = slots.overflow) == null ? void 0 : _a.call(slots, {
        number: overflowNumber.value
      })) != null ? _b : createVNode(Tag, null, {
        default: () => [createTextVNode("+"), overflowNumber.value]
      })]);
    };
    return () => {
      var _a, _b;
      children.value = getAllElements((_a = slots.default) == null ? void 0 : _a.call(slots));
      if (total.value !== children.value.length) {
        total.value = children.value.length;
        itemWidths.length = total.value;
      }
      let visibleChildren = children.value;
      if (overflowNumber.value > 0) {
        visibleChildren = isStart.value ? children.value.slice(overflowNumber.value) : children.value.slice(0, -overflowNumber.value);
      }
      const withMarginNumber = overflowNumber.value === 0 || isStart.value ? visibleChildren.length - 1 : visibleChildren.length;
      for (let i2 = 0; i2 < withMarginNumber; i2++) {
        visibleChildren[i2].props = mergeProps((_b = visibleChildren[i2].props) != null ? _b : {}, {
          style: {
            marginRight: `${props.margin}px`
          }
        });
      }
      return createVNode("div", {
        "ref": listRef,
        "class": prefixCls
      }, [isStart.value && overflowNumber.value > 0 && renderOverflow(), visibleChildren, !isStart.value && overflowNumber.value > 0 && renderOverflow(), createVNode(ResizeObserver3, {
        "onResize": onResize
      }, {
        default: () => [createVNode("div", {
          "ref": spacerRef,
          "class": `${prefixCls}-spacer`
        }, null)]
      })]);
    };
  }
});

// node_modules/@arco-design/web-vue/es/overflow-list/index.js
var OverflowList = Object.assign(_OverflowList, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _OverflowList.name, _OverflowList);
  }
});

// node_modules/@arco-design/web-vue/es/tree-select/panel.js
var __defProp61 = Object.defineProperty;
var __defProps29 = Object.defineProperties;
var __getOwnPropDescs29 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols61 = Object.getOwnPropertySymbols;
var __hasOwnProp61 = Object.prototype.hasOwnProperty;
var __propIsEnum61 = Object.prototype.propertyIsEnumerable;
var __defNormalProp61 = (obj, key, value) => key in obj ? __defProp61(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues61 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp61.call(b, prop))
      __defNormalProp61(a, prop, b[prop]);
  if (__getOwnPropSymbols61)
    for (var prop of __getOwnPropSymbols61(b)) {
      if (__propIsEnum61.call(b, prop))
        __defNormalProp61(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps29 = (a, b) => __defProps29(a, __getOwnPropDescs29(b));
function _isSlot16(s) {
  return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
var Panel2 = defineComponent({
  name: "TreeSelectPanel",
  components: {
    Tree
  },
  props: {
    treeProps: {
      type: Object,
      default: () => ({})
    },
    selectedKeys: {
      type: Array
    },
    showCheckable: {
      type: Boolean
    },
    treeSlots: {
      type: Object,
      default: () => ({})
    },
    scrollbar: {
      type: [Boolean, Object],
      default: true
    }
  },
  emits: ["change"],
  setup(props, {
    emit
  }) {
    const {
      showCheckable,
      selectedKeys,
      treeProps,
      scrollbar
    } = toRefs(props);
    const {
      displayScrollbar,
      scrollbarProps
    } = useScrollbar(scrollbar);
    const prefixCls = getPrefixCls("tree-select");
    const refTree = ref();
    const computedTreeProps = computed(() => {
      return __spreadProps29(__spreadValues61({}, treeProps.value), {
        disableSelectActionOnly: true,
        checkedKeys: showCheckable.value ? selectedKeys.value : [],
        selectedKeys: showCheckable.value ? [] : selectedKeys.value
      });
    });
    const onSelect = (newVal, e2) => {
      var _a, _b;
      if (showCheckable.value) {
        (_b = (_a = refTree.value) == null ? void 0 : _a.toggleCheck) == null ? void 0 : _b.call(_a, newVal[0], e2);
      } else {
        emit("change", newVal);
      }
    };
    const onCheck = (newVal) => {
      emit("change", newVal);
    };
    const renderTree = () => {
      return createVNode(Tree, mergeProps({
        "ref": refTree
      }, computedTreeProps.value, {
        "onSelect": onSelect,
        "onCheck": onCheck
      }), props.treeSlots);
    };
    return () => {
      if (displayScrollbar.value) {
        let _slot;
        return createVNode(Scrollbar, mergeProps({
          "class": `${prefixCls}-tree-wrapper`
        }, scrollbarProps.value), _isSlot16(_slot = renderTree()) ? _slot : {
          default: () => [_slot]
        });
      }
      return createVNode("div", {
        "class": `${prefixCls}-tree-wrapper`
      }, [renderTree()]);
    };
  }
});

// node_modules/@arco-design/web-vue/es/tree-select/hooks/use-selected-state.js
var __defProp62 = Object.defineProperty;
var __defProps30 = Object.defineProperties;
var __getOwnPropDescs30 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols62 = Object.getOwnPropertySymbols;
var __hasOwnProp62 = Object.prototype.hasOwnProperty;
var __propIsEnum62 = Object.prototype.propertyIsEnumerable;
var __defNormalProp62 = (obj, key, value) => key in obj ? __defProp62(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues62 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp62.call(b, prop))
      __defNormalProp62(a, prop, b[prop]);
  if (__getOwnPropSymbols62)
    for (var prop of __getOwnPropSymbols62(b)) {
      if (__propIsEnum62.call(b, prop))
        __defNormalProp62(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps30 = (a, b) => __defProps30(a, __getOwnPropDescs30(b));
function isLabelValue(value) {
  return isObject(value);
}
function isValidKey(key) {
  return key !== void 0 && key !== null && key !== "";
}
function getKey(value) {
  return isLabelValue(value) ? value.value : value;
}
function getLabel(value) {
  return isLabelValue(value) ? value.label : void 0;
}
function isValidValue(value) {
  const key = getKey(value);
  return isValidKey(key);
}
function getKeys2(value) {
  return value.map(getKey).filter(isValidKey);
}
function useSelectedState(props) {
  var _a;
  const {
    defaultValue,
    modelValue,
    key2TreeNode,
    multiple,
    treeCheckable,
    fallbackOption,
    fieldNames
  } = toRefs(props);
  function normalizeValue(value) {
    const validValue = (isArray(value) ? value : [value]).filter(isValidValue);
    return (multiple == null ? void 0 : multiple.value) || (treeCheckable == null ? void 0 : treeCheckable.value) ? validValue : validValue.slice(0, 1);
  }
  function getLabelValues(value, originValue) {
    const res = [];
    const validValue = value ? value.filter(isValidValue) : [];
    if (validValue.length) {
      const originValueMap = /* @__PURE__ */ new Map();
      originValue == null ? void 0 : originValue.forEach((item) => {
        originValueMap.set(item.value, item);
      });
      validValue.forEach((item) => {
        var _a2, _b, _c, _d, _e;
        const key = getKey(item);
        const originValueItem = originValueMap.get(key);
        const node = key2TreeNode.value.get(key);
        let fallbackNodeData = null;
        const nodeDataTitle = ((_a2 = fieldNames == null ? void 0 : fieldNames.value) == null ? void 0 : _a2.title) || "title";
        if (!node) {
          const fallbackResult = isFunction(fallbackOption == null ? void 0 : fallbackOption.value) ? fallbackOption == null ? void 0 : fallbackOption.value(key) : fallbackOption == null ? void 0 : fallbackOption.value;
          if (fallbackResult === false) {
            return;
          }
          if (isObject(fallbackResult)) {
            fallbackNodeData = fallbackResult;
          }
        }
        res.push(__spreadProps30(__spreadValues62(__spreadValues62({}, isLabelValue(item) ? item : {}), originValueItem || {}), {
          value: key,
          label: (_e = (_d = (_c = (_b = getLabel(item)) != null ? _b : node == null ? void 0 : node.title) != null ? _c : originValueItem == null ? void 0 : originValueItem.label) != null ? _d : fallbackNodeData == null ? void 0 : fallbackNodeData[nodeDataTitle]) != null ? _e : key
        }));
      });
    }
    return res;
  }
  const computedModelValueKeys = ref();
  const computedModelValue = ref();
  watchEffect(() => {
    var _a2;
    const isControlled = (modelValue == null ? void 0 : modelValue.value) !== void 0;
    const normalizeModelValue = normalizeValue((_a2 = modelValue == null ? void 0 : modelValue.value) != null ? _a2 : []);
    const modelValueKeys = getKeys2(normalizeModelValue);
    computedModelValue.value = isControlled ? getLabelValues(modelValueKeys, getLabelValues(normalizeModelValue)) : void 0;
    computedModelValueKeys.value = isControlled ? modelValueKeys : void 0;
  });
  const normalizeDefaultValue = normalizeValue((_a = defaultValue == null ? void 0 : defaultValue.value) != null ? _a : []);
  const defaultKeys = getKeys2(normalizeDefaultValue);
  const defaultLabelValues = getLabelValues(defaultKeys, getLabelValues(normalizeDefaultValue));
  const localValueKeys = ref(defaultKeys || []);
  const localValue = ref(defaultLabelValues);
  watch(localValueKeys, () => {
    localValue.value = getLabelValues(localValueKeys.value, defaultLabelValues);
  });
  watch([computedModelValueKeys, computedModelValue], ([valueKeys, value]) => {
    localValueKeys.value = valueKeys || [];
    localValue.value = value || [];
  });
  const selectedKeys = computed(() => {
    var _a2;
    return (_a2 = computedModelValueKeys.value) != null ? _a2 : localValueKeys.value;
  });
  const selectedValue = computed(() => {
    var _a2;
    return (_a2 = computedModelValue.value) != null ? _a2 : localValue.value;
  });
  return {
    selectedKeys,
    selectedValue,
    setLocalSelectedKeys(keys) {
      localValueKeys.value = keys;
    },
    localSelectedKeys: localValueKeys,
    localSelectedValue: localValue
  };
}

// node_modules/@arco-design/web-vue/es/tree-select/hooks/use-filter-tree-node.js
function useFilterTreeNode(props) {
  const {
    searchValue,
    flattenTreeData,
    filterMethod: propFilterMethod,
    disableFilter,
    fieldNames
  } = toRefs(props);
  const keyField = computed(() => {
    var _a;
    return ((_a = fieldNames.value) == null ? void 0 : _a.key) || "key";
  });
  const defaultFilterMethod = (keyword, node) => {
    const key = node[keyField.value];
    return !isUndefined(key) && String(key).indexOf(keyword) > -1;
  };
  const filterMethod = computed(() => (propFilterMethod == null ? void 0 : propFilterMethod.value) || defaultFilterMethod);
  const filteredKeysSet = ref();
  const isFiltering = computed(() => !!searchValue.value);
  const isEmptyFilterResult = computed(() => !(disableFilter == null ? void 0 : disableFilter.value) && isFiltering.value && filteredKeysSet.value && filteredKeysSet.value.size === 0);
  const filterTreeNode = computed(() => (disableFilter == null ? void 0 : disableFilter.value) ? void 0 : (node) => {
    var _a;
    if (!isFiltering.value)
      return true;
    const key = node[keyField.value];
    return (_a = filteredKeysSet.value) == null ? void 0 : _a.has(key || "");
  });
  const updateFilteredKeysSet = debounce((treeData, keyword) => {
    const hitNodes = treeData.filter((node) => filterMethod.value(keyword, node.treeNodeData));
    const _keysSet = /* @__PURE__ */ new Set();
    hitNodes.forEach((node) => {
      _keysSet.add(node.key);
      node.pathParentKeys.forEach((_key) => {
        _keysSet.add(_key);
      });
    });
    filteredKeysSet.value = _keysSet;
  }, 100);
  watchEffect(() => {
    if (disableFilter == null ? void 0 : disableFilter.value) {
      filteredKeysSet.value = void 0;
    } else {
      updateFilteredKeysSet(flattenTreeData.value, searchValue.value);
    }
  });
  return {
    isEmptyFilterResult,
    filterTreeNode
  };
}

// node_modules/@arco-design/web-vue/es/_utils/pick-sub-comp-slots.js
function pickSubCompSlots(slots, subCompName) {
  const prefix = `${subCompName}-slot-`;
  const subSlots = Object.keys(slots).reduce((cur, s) => {
    if (s.startsWith(prefix)) {
      const subSlotName = s.slice(prefix.length);
      if (subSlotName) {
        cur[subSlotName] = slots[s];
      }
    }
    return cur;
  }, {});
  return subSlots;
}

// node_modules/@arco-design/web-vue/es/tree-select/tree-select.js
var __defProp63 = Object.defineProperty;
var __defProps31 = Object.defineProperties;
var __getOwnPropDescs31 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols63 = Object.getOwnPropertySymbols;
var __hasOwnProp63 = Object.prototype.hasOwnProperty;
var __propIsEnum63 = Object.prototype.propertyIsEnumerable;
var __defNormalProp63 = (obj, key, value) => key in obj ? __defProp63(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues63 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp63.call(b, prop))
      __defNormalProp63(a, prop, b[prop]);
  if (__getOwnPropSymbols63)
    for (var prop of __getOwnPropSymbols63(b)) {
      if (__propIsEnum63.call(b, prop))
        __defNormalProp63(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps31 = (a, b) => __defProps31(a, __getOwnPropDescs31(b));
var _sfc_main193 = defineComponent({
  name: "TreeSelect",
  components: {
    Trigger,
    SelectView,
    Panel: Panel2,
    Empty: Empty2,
    Spin
  },
  inheritAttrs: false,
  props: {
    disabled: {
      type: Boolean
    },
    loading: {
      type: Boolean
    },
    error: {
      type: Boolean
    },
    size: {
      type: String
    },
    border: {
      type: Boolean
    },
    allowSearch: {
      type: [Boolean, Object],
      default: (props) => Boolean(props.multiple)
    },
    allowClear: {
      type: Boolean
    },
    placeholder: {
      type: String
    },
    maxTagCount: {
      type: Number
    },
    multiple: {
      type: Boolean
    },
    defaultValue: {
      type: [String, Number, Array, Object]
    },
    modelValue: {
      type: [String, Number, Array, Object]
    },
    fieldNames: {
      type: Object
    },
    data: {
      type: Array,
      default: () => []
    },
    labelInValue: {
      type: Boolean
    },
    treeCheckable: {
      type: Boolean
    },
    treeCheckStrictly: {
      type: Boolean
    },
    treeCheckedStrategy: {
      type: String,
      default: "all"
    },
    treeProps: {
      type: Object
    },
    triggerProps: {
      type: Object
    },
    popupVisible: {
      type: Boolean,
      default: void 0
    },
    defaultPopupVisible: {
      type: Boolean
    },
    dropdownStyle: {
      type: Object
    },
    dropdownClassName: {
      type: [String, Array]
    },
    filterTreeNode: {
      type: Function
    },
    loadMore: {
      type: Function
    },
    disableFilter: {
      type: Boolean
    },
    popupContainer: {
      type: [String, Object]
    },
    fallbackOption: {
      type: [Boolean, Function],
      default: true
    },
    selectable: {
      type: [Boolean, String, Function],
      default: true
    },
    scrollbar: {
      type: [Boolean, Object],
      default: true
    }
  },
  emits: {
    "change": (value) => true,
    "update:modelValue": (value) => true,
    "popup-visible-change": (visible) => true,
    "update:popupVisible": (visible) => true,
    "search": (searchKey) => true,
    "clear": () => true
  },
  setup(props, { emit }) {
    const {
      defaultValue,
      modelValue,
      multiple,
      popupVisible,
      defaultPopupVisible,
      treeCheckable,
      treeCheckStrictly,
      data,
      fieldNames,
      disabled,
      labelInValue,
      filterTreeNode,
      disableFilter,
      dropdownStyle,
      treeProps,
      fallbackOption,
      selectable
    } = toRefs(props);
    const { mergedDisabled, eventHandlers } = useFormItem({
      disabled
    });
    const prefixCls = getPrefixCls("tree-select");
    const isMultiple = computed(() => multiple.value || treeCheckable.value);
    const isSelectable = (node, info) => {
      var _a;
      if (selectable.value === "leaf")
        return info.isLeaf;
      if (isFunction(selectable.value))
        return selectable.value(node, info);
      return (_a = selectable.value) != null ? _a : false;
    };
    const isCheckable = computed(() => treeCheckable.value ? isSelectable : false);
    const retainInputValue = computed(() => isObject(props.allowSearch) && Boolean(props.allowSearch.retainInputValue));
    const { flattenTreeData, key2TreeNode } = useTreeData(reactive({
      treeData: data,
      fieldNames,
      selectable: isSelectable,
      checkable: isCheckable
    }));
    const {
      selectedKeys,
      selectedValue,
      setLocalSelectedKeys,
      localSelectedKeys,
      localSelectedValue
    } = useSelectedState(reactive({
      defaultValue,
      modelValue,
      key2TreeNode,
      multiple,
      treeCheckable,
      treeCheckStrictly,
      fallbackOption,
      fieldNames
    }));
    function isNodeClosable(node) {
      return treeCheckable.value ? isNodeCheckable(node) : isNodeSelectable(node);
    }
    const selectViewValue = computed(() => {
      if (isUndefined(selectedValue.value)) {
        return [];
      }
      if (isMultiple.value && !mergedDisabled.value) {
        return selectedValue.value.map((i2) => {
          const node = key2TreeNode.value.get(i2.value);
          return __spreadProps31(__spreadValues63({}, i2), {
            closable: !node || isNodeClosable(node)
          });
        });
      }
      return selectedValue.value;
    });
    const setSelectedKeys = (newVal) => {
      setLocalSelectedKeys(newVal);
      nextTick(() => {
        var _a, _b;
        const forEmitValue = (labelInValue.value ? localSelectedValue.value : localSelectedKeys.value) || [];
        const emitValue = isMultiple.value ? forEmitValue : forEmitValue[0];
        emit("update:modelValue", emitValue);
        emit("change", emitValue);
        (_b = (_a = eventHandlers.value) == null ? void 0 : _a.onChange) == null ? void 0 : _b.call(_a);
      });
    };
    const searchValue = ref("");
    const [panelVisible, setLocalPanelVisible] = useMergeState(defaultPopupVisible.value, reactive({
      value: popupVisible
    }));
    const setPanelVisible = (visible) => {
      if (visible !== panelVisible.value) {
        setLocalPanelVisible(visible);
        emit("popup-visible-change", visible);
        emit("update:popupVisible", visible);
      }
      if (!visible) {
        refSelectView.value && refSelectView.value.blur && refSelectView.value.blur();
      }
    };
    const { isEmptyFilterResult, filterTreeNode: computedFilterTreeNode } = useFilterTreeNode(reactive({
      searchValue,
      flattenTreeData,
      filterMethod: filterTreeNode,
      disableFilter,
      fieldNames
    }));
    const isEmptyTreeData = computed(() => !flattenTreeData.value.length);
    const refSelectView = ref();
    const computedDropdownStyle = computed(() => {
      var _a;
      return [
        (dropdownStyle == null ? void 0 : dropdownStyle.value) || {},
        ((_a = treeProps == null ? void 0 : treeProps.value) == null ? void 0 : _a.virtualListProps) ? { "max-height": "unset" } : {}
      ];
    });
    const onBlur = () => {
      if (!retainInputValue.value && searchValue.value) {
        searchValue.value = "";
      }
    };
    return {
      refSelectView,
      prefixCls,
      selectedValue,
      selectedKeys,
      mergedDisabled,
      searchValue,
      panelVisible,
      isEmptyTreeData,
      isEmptyFilterResult,
      computedFilterTreeNode,
      isMultiple,
      selectViewValue,
      computedDropdownStyle,
      onSearchValueChange(newVal) {
        if (newVal !== searchValue.value) {
          setPanelVisible(true);
          searchValue.value = newVal;
          emit("search", newVal);
        }
      },
      onSelectChange(newVal) {
        setSelectedKeys(newVal);
        searchValue.value = "";
        if (!isMultiple.value) {
          setPanelVisible(false);
        }
      },
      onVisibleChange: setPanelVisible,
      onInnerClear() {
        setSelectedKeys([]);
        emit("clear");
      },
      pickSubCompSlots,
      isSelectable,
      isCheckable,
      onBlur,
      onItemRemove(id) {
        if (mergedDisabled.value)
          return;
        const node = key2TreeNode.value.get(id);
        if (treeCheckable.value && node) {
          if (isNodeClosable(node)) {
            const [newVal] = getCheckedStateByCheck({
              node,
              checked: false,
              checkedKeys: selectedKeys.value,
              indeterminateKeys: [],
              checkStrictly: treeCheckStrictly.value
            });
            setSelectedKeys(newVal);
          }
        } else {
          const newVal = selectedKeys.value.filter((i2) => i2 !== id);
          setSelectedKeys(newVal);
        }
      }
    };
  }
});
function _sfc_render192(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_SelectView = resolveComponent("SelectView");
  const _component_Spin = resolveComponent("Spin");
  const _component_Empty = resolveComponent("Empty");
  const _component_Panel = resolveComponent("Panel");
  const _component_Trigger = resolveComponent("Trigger");
  return openBlock(), createBlock(_component_Trigger, mergeProps({
    class: `${_ctx.prefixCls}-trigger`,
    "auto-fit-popup-min-width": "",
    trigger: "click",
    position: "bl",
    "popup-offset": 4,
    "animation-name": "slide-dynamic-origin",
    "prevent-focus": true
  }, _ctx.triggerProps, {
    disabled: _ctx.mergedDisabled,
    "popup-visible": _ctx.panelVisible,
    "popup-container": _ctx.popupContainer,
    "click-to-close": !_ctx.allowSearch,
    "auto-fit-transform-origin": "",
    onPopupVisibleChange: _ctx.onVisibleChange
  }), {
    content: withCtx(() => [
      createBaseVNode("div", {
        class: normalizeClass([`${_ctx.prefixCls}-popup`, _ctx.dropdownClassName]),
        style: normalizeStyle(_ctx.computedDropdownStyle)
      }, [
        _ctx.loading ? renderSlot(_ctx.$slots, "loader", { key: 0 }, () => [
          createVNode(_component_Spin)
        ]) : _ctx.isEmptyTreeData || _ctx.isEmptyFilterResult ? renderSlot(_ctx.$slots, "empty", { key: 1 }, () => [
          createVNode(_component_Empty)
        ]) : (openBlock(), createBlock(_component_Panel, {
          key: 2,
          "selected-keys": _ctx.selectedKeys,
          "show-checkable": _ctx.treeCheckable,
          scrollbar: _ctx.scrollbar,
          "tree-props": __spreadProps31(__spreadValues63({
            actionOnNodeClick: _ctx.selectable === "leaf" ? "expand" : void 0,
            blockNode: true
          }, _ctx.treeProps), {
            data: _ctx.data,
            checkStrictly: _ctx.treeCheckStrictly,
            checkedStrategy: _ctx.treeCheckedStrategy,
            fieldNames: _ctx.fieldNames,
            multiple: _ctx.multiple,
            loadMore: _ctx.loadMore,
            filterTreeNode: _ctx.computedFilterTreeNode,
            size: _ctx.size,
            checkable: _ctx.isCheckable,
            selectable: _ctx.isSelectable
          }),
          "tree-slots": _ctx.pickSubCompSlots(_ctx.$slots, "tree"),
          onChange: _ctx.onSelectChange
        }, null, 8, ["selected-keys", "show-checkable", "scrollbar", "tree-props", "tree-slots", "onChange"]))
      ], 6)
    ]),
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "trigger", {}, () => [
        createVNode(_component_SelectView, mergeProps({
          ref: "refSelectView",
          "model-value": _ctx.selectViewValue,
          "input-value": _ctx.searchValue,
          "allow-search": Boolean(_ctx.allowSearch),
          "allow-clear": _ctx.allowClear,
          loading: _ctx.loading,
          size: _ctx.size,
          "max-tag-count": _ctx.maxTagCount,
          disabled: _ctx.mergedDisabled,
          opened: _ctx.panelVisible,
          error: _ctx.error,
          border: _ctx.border,
          placeholder: _ctx.placeholder,
          multiple: _ctx.isMultiple
        }, _ctx.$attrs, {
          onInputValueChange: _ctx.onSearchValueChange,
          onClear: _ctx.onInnerClear,
          onRemove: _ctx.onItemRemove,
          onBlur: _ctx.onBlur
        }), createSlots({ _: 2 }, [
          _ctx.$slots.prefix ? {
            name: "prefix",
            fn: withCtx(() => [
              renderSlot(_ctx.$slots, "prefix")
            ])
          } : void 0,
          _ctx.$slots.label ? {
            name: "label",
            fn: withCtx((selectedData) => [
              renderSlot(_ctx.$slots, "label", normalizeProps(guardReactiveProps(selectedData)))
            ])
          } : void 0
        ]), 1040, ["model-value", "input-value", "allow-search", "allow-clear", "loading", "size", "max-tag-count", "disabled", "opened", "error", "border", "placeholder", "multiple", "onInputValueChange", "onClear", "onRemove", "onBlur"])
      ])
    ]),
    _: 3
  }, 16, ["class", "disabled", "popup-visible", "popup-container", "click-to-close", "onPopupVisibleChange"]);
}
var _TreeSelect = _export_sfc(_sfc_main193, [["render", _sfc_render192]]);

// node_modules/@arco-design/web-vue/es/tree-select/index.js
var TreeSelect = Object.assign(_TreeSelect, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _TreeSelect.name, _TreeSelect);
  }
});

// node_modules/@arco-design/web-vue/es/arco-vue.js
var __defProp64 = Object.defineProperty;
var __defProps32 = Object.defineProperties;
var __getOwnPropDescs32 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols64 = Object.getOwnPropertySymbols;
var __hasOwnProp64 = Object.prototype.hasOwnProperty;
var __propIsEnum64 = Object.prototype.propertyIsEnumerable;
var __defNormalProp64 = (obj, key, value) => key in obj ? __defProp64(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues64 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp64.call(b, prop))
      __defNormalProp64(a, prop, b[prop]);
  if (__getOwnPropSymbols64)
    for (var prop of __getOwnPropSymbols64(b)) {
      if (__propIsEnum64.call(b, prop))
        __defNormalProp64(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps32 = (a, b) => __defProps32(a, __getOwnPropDescs32(b));
var components = {
  Button,
  Link,
  Typography,
  Divider,
  Grid,
  Layout,
  Space,
  Avatar,
  Badge,
  Card,
  Carousel,
  Collapse,
  Comment: Comment2,
  Descriptions,
  Empty: Empty2,
  Image,
  Scrollbar,
  List,
  Popover,
  Statistic,
  Table,
  Tabs,
  Tag,
  Timeline,
  Tooltip,
  AutoComplete,
  Cascader,
  Checkbox,
  DatePicker,
  Form,
  Input,
  InputNumber,
  InputTag,
  Mention,
  Radio,
  Rate,
  Select,
  Slider,
  Switch,
  Textarea,
  TimePicker,
  Transfer,
  Tree,
  Upload,
  TreeSelect,
  Alter: Alert,
  Drawer,
  Message: Message2,
  Modal,
  Notification: Notification2,
  Popconfirm,
  Progress,
  Result,
  Spin,
  Skeleton,
  Breadcrumb,
  Dropdown,
  Menu,
  PageHeader,
  Pagination,
  Steps,
  Affix,
  Anchor,
  BackTop,
  ConfigProvider,
  ResizeBox,
  Trigger,
  Split,
  Icon,
  OverflowList
};
var install = (app, options) => {
  for (const key of Object.keys(components)) {
    app.use(components[key], options);
  }
};
var ArcoVue = __spreadProps32(__spreadValues64({}, components), {
  AnchorLink,
  AvatarGroup,
  BreadcrumbItem,
  ButtonGroup,
  CardMeta,
  CardGrid,
  CarouselItem,
  CascaderPanel,
  CheckboxGroup,
  CollapseItem,
  DescriptionsItem,
  WeekPicker,
  MonthPicker,
  YearPicker,
  QuarterPicker,
  RangePicker,
  Doption,
  Dgroup,
  Dsubmenu,
  DropdownButton,
  FormItem,
  Row,
  Col,
  GridItem,
  ImagePreview,
  ImagePreviewGroup,
  InputGroup,
  InputSearch,
  InputPassword,
  LayoutHeader,
  LayoutContent,
  LayoutFooter,
  LayoutSider,
  ListItem,
  ListItemMeta,
  MenuItem,
  MenuItemGroup,
  SubMenu,
  RadioGroup,
  Option,
  Optgroup,
  SkeletonLine,
  SkeletonShape,
  Countdown,
  Step,
  Thead,
  Td,
  Th,
  Tr,
  Tbody,
  TableColumn,
  TabPane,
  TimelineItem,
  TypographyParagraph,
  TypographyTitle,
  TypographyText,
  install,
  addI18nMessages,
  useLocale,
  getLocale,
  useFormItem
});
export {
  Affix,
  Alert,
  Anchor,
  AnchorLink,
  AutoComplete,
  Avatar,
  AvatarGroup,
  BackTop,
  Badge,
  Breadcrumb,
  BreadcrumbItem,
  Button,
  ButtonGroup,
  Card,
  CardGrid,
  CardMeta,
  Carousel,
  CarouselItem,
  Cascader,
  CascaderPanel,
  Checkbox,
  CheckboxGroup,
  Col,
  Collapse,
  CollapseItem,
  Comment2 as Comment,
  ConfigProvider,
  Countdown,
  DatePicker,
  Descriptions,
  DescriptionsItem,
  Dgroup,
  Divider,
  Doption,
  Drawer,
  Dropdown,
  DropdownButton,
  Dsubmenu,
  Empty2 as Empty,
  Form,
  FormItem,
  Grid,
  GridItem,
  Icon,
  Image,
  ImagePreview,
  _ImagePreviewAction as ImagePreviewAction,
  ImagePreviewGroup,
  Input,
  InputGroup,
  InputNumber,
  InputPassword,
  InputSearch,
  InputTag,
  Layout,
  LayoutContent,
  LayoutFooter,
  LayoutHeader,
  LayoutSider,
  Link,
  List,
  ListItem,
  ListItemMeta,
  Mention,
  Menu,
  MenuItem,
  MenuItemGroup,
  Message2 as Message,
  Modal,
  MonthPicker,
  Notification2 as Notification,
  Optgroup,
  Option,
  OverflowList,
  PageHeader,
  Pagination,
  Popconfirm,
  Popover,
  Progress,
  QuarterPicker,
  Radio,
  RadioGroup,
  RangePicker,
  Rate,
  ResizeBox,
  Result,
  Row,
  Scrollbar,
  Select,
  Skeleton,
  SkeletonLine,
  SkeletonShape,
  Slider,
  Space,
  Spin,
  Split,
  Statistic,
  Step,
  Steps,
  SubMenu,
  Switch,
  TabPane,
  Table,
  TableColumn,
  Tabs,
  Tag,
  Tbody,
  Td,
  Textarea,
  Th,
  Thead,
  TimePicker,
  Timeline,
  TimelineItem,
  Tooltip,
  Tr,
  Transfer,
  Tree,
  TreeSelect,
  Trigger,
  Typography,
  TypographyParagraph,
  TypographyText,
  TypographyTitle,
  Upload,
  WeekPicker,
  YearPicker,
  addI18nMessages,
  ArcoVue as default,
  getLocale,
  useFormItem,
  useLocale
};
//# sourceMappingURL=@arco-design_web-vue.js.map
